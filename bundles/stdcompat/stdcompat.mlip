#if OCAML_VERSION < (4,02,0)
  type bytes = string
#else
  type bytes_ = bytes
  type bytes = bytes_
#endif
(** @before 4.02.0 alias to [string]. *)

#if OCAML_VERSION < (4,06,0)
  type floatarray = float array
#else
  type floatarray_ = floatarray
  type floatarray = floatarray_
#endif
(** @before 4.06.0 alias to [float array]. *)

module Pervasives : sig
  include module type of struct
    include Pervasives
  end

#if OCAML_VERSION < (4,00,0)
  val hypot : float -> float -> float

  val copysign : float -> float -> float
#endif

#if OCAML_VERSION < (4,01,0)
  val ( |> ) : 'a -> ('a -> 'b) -> 'b

  val ( @@ ) : ('a -> 'b) -> 'a -> 'b
#endif

#if OCAML_VERSION < (4,02,0)
  external raise_notrace : exn -> 'a = "%raise"
#endif
  (** @before 4.02.0 equivalent to [raise]. *)

  val print_bytes : bytes -> unit

  val prerr_bytes : bytes -> unit

  val output : out_channel -> bytes -> int -> int -> unit

  val output_substring : out_channel -> string -> int -> int -> unit

  val really_input_string : in_channel -> int -> string

#if OCAML_VERSION < (4,03,0)
  type ('a, 'b) result
#ifdef HAS_RESULT_PKG
    = ('a, 'b) Result.result
#endif
    = Ok of 'a | Error of 'b
#endif

  val bool_of_string_opt : string -> bool option

  val int_of_string_opt : string -> int option

  val float_of_string_opt : string -> float option

  val read_int_opt : unit -> int option

  val read_float_opt : unit -> float option
end

include module type of struct
  include Pervasives
end

module Arg : sig
  include module type of Arg

  val read_arg : string -> string array

  val read_arg0 : string -> string array

  val write_arg : string -> string array -> unit

  val write_arg0 : string -> string array -> unit
end

module Lazy : sig
  include module type of Lazy

  val from_fun : (unit -> 'a) -> 'a t

  val from_val : 'a -> 'a t
end

module Char : sig
  include module type of Char

  val lowercase_ascii : t -> t

  val uppercase_ascii : t -> t

  val equal : t -> t -> bool
end

module Seq : sig
#if OCAML_VERSION < (4,07,0)
#ifdef HAS_SEQ_PKG
  include module type of struct
    include Seq
  end
#else
  type 'a t = unit -> 'a node
  and +'a node =
    | Nil
    | Cons of 'a * 'a t

  val empty : 'a t

  val return : 'a -> 'a t

  val map : ('a -> 'b) -> 'a t -> 'b t

  val filter : ('a -> bool) -> 'a t -> 'a t

  val filter_map : ('a -> 'b option) -> 'a t -> 'b t

  val flat_map : ('a -> 'b t) -> 'a t -> 'b t

  val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a

  val iter : ('a -> unit) -> 'a t -> unit
#endif
#else
  include module type of struct
    include Seq
  end
#endif
end

module String : sig
  include module type of String

  val init : int -> (int -> char) -> string

  val mapi : (int -> char -> char) -> string -> string

  val iteri : (int -> char -> unit) -> string -> unit

  val map : (char -> char) -> string -> string

  val trim : string -> string

  val lowercase_ascii : string -> string

  val uppercase_ascii : string -> string

  val capitalize_ascii : string -> string

  val uncapitalize_ascii : string -> string

  val equal : t -> t -> bool

  val split_on_char : char -> string -> string list

  val index_opt : string -> char -> int option

  val rindex_opt : string -> char -> int option

  val index_from_opt : string -> int -> char -> int option

  val rindex_from_opt : string -> int -> char -> int option

  val of_seq : char Seq.t -> t

  val to_seq : t -> char Seq.t

  val to_seqi : t -> (int * char) Seq.t
end

module StringLabels : sig
  include module type of StringLabels

  val init : int -> f:(int -> char) -> string

  val mapi : f:(int -> char -> char) -> string -> string

  val iteri : f:(int -> char -> unit) -> string -> unit

  val map : f:(char -> char) -> string -> string

  val trim : string -> string

  val lowercase_ascii : string -> string

  val uppercase_ascii : string -> string

  val capitalize_ascii : string -> string

  val uncapitalize_ascii : string -> string

  val equal : t -> t -> bool

  val split_on_char : sep:char -> string -> string list

  val index_opt : string -> char -> int option

  val rindex_opt : string -> char -> int option

  val index_from_opt : string -> int -> char -> int option

  val rindex_from_opt : string -> int -> char -> int option

  val of_seq : char Seq.t -> t

  val to_seq : t -> char Seq.t

  val to_seqi : t -> (int * char) Seq.t
end

module Stack : sig
  include module type of struct
    include Stack
  end

  val fold : ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a

  val of_seq : 'a Seq.t -> 'a t

  val add_seq : 'a t -> 'a Seq.t -> unit

  val to_seq : 'a t -> 'a Seq.t
end

module Hashtbl : sig
  type ('a, 'b) t = ('a, 'b) Hashtbl.t

  val clear : ('a, 'b) t -> unit

  val copy : ('a, 'b) t -> ('a, 'b) t

  val add : ('a, 'b) t -> 'a -> 'b -> unit

  val find : ('a, 'b) t -> 'a -> 'b

  val find_all : ('a, 'b) t -> 'a -> 'b list

  val mem : ('a, 'b) t -> 'a -> bool

  val remove : ('a, 'b) t -> 'a -> unit

  val replace : ('a, 'b) t -> 'a -> 'b -> unit

  val iter : ('a -> 'b -> unit) -> ('a, 'b) t -> unit

  val fold : ('a -> 'b -> 'c -> 'c) -> ('a, 'b) t -> 'c -> 'c

  val length : ('a, 'b) t -> int

  module type HashedType = Hashtbl.HashedType

  val hash : 'a -> int

  val hash_param : int -> int -> 'a -> int

  val create : ?random:bool -> int -> ('a, 'b) t

  val reset : ('a, 'b) t -> unit
  (** @before 4.00.0 alias to [Hashtbl.clear]. *)

  val randomize : unit -> unit
  (** @before 4.00.0 ignored: does nothing. *)

  type statistics
#if OCAML_VERSION >= (4,00,0)
     = Hashtbl.statistics
#endif
     = {
      num_bindings : int;
      num_buckets : int;
      max_bucket_length : int;
      bucket_histogram : int array;
    }

  val stats : ('a, 'b) t -> statistics
  (** @before 4.00.0 returns void statistics (only the field [num_bindings] is
      initialized correctly. *)

  val is_randomized : unit -> bool
  (** @before 4.00.0 always false *)

  val filter_map_inplace : ('a -> 'b -> 'b option) -> ('a, 'b) t -> unit
  (** @before 4.03.0 clear and rebuild the hash table when several values
      have been associated to the same key and the updated values are not the
      ones that are currently associated with the key. *)

  val find_opt : ('a, 'b) t -> 'a -> 'b option

  val seeded_hash : int -> 'a -> int

  val seeded_hash_param : int -> int -> int -> 'a -> int

  val of_seq : ('a * 'b) Seq.t -> ('a, 'b) t

  val add_seq : ('a, 'b) t -> ('a * 'b) Seq.t -> unit

  val replace_seq : ('a, 'b) t -> ('a * 'b) Seq.t -> unit

  val to_seq : ('a, 'b) t -> ('a * 'b) Seq.t

  val to_seq_keys : ('a, 'b) t -> 'a Seq.t

  val to_seq_values : ('a, 'b) t -> 'b Seq.t

  module type S = sig
    type 'a t

    type key

    val clear : 'a t -> unit

    val copy : 'a t -> 'a t

    val add : 'a t -> key -> 'a -> unit

    val find : 'a t -> key -> 'a

    val find_all : 'a t -> key -> 'a list

    val mem : 'a t -> key -> bool

    val remove : 'a t -> key -> unit

    val replace : 'a t -> key -> 'a -> unit

    val iter : (key -> 'a -> unit) -> 'a t -> unit

    val fold : (key -> 'a -> 'c -> 'c) -> 'a t -> 'c -> 'c

    val length : 'a t -> int

    val create : int -> 'a t

    val reset : 'a t -> unit

    val filter_map_inplace : (key -> 'a -> 'a option) -> 'a t -> unit

    val find_opt : 'a t -> key -> 'a option

    val stats : 'a t -> statistics

    val of_seq : (key * 'a) Seq.t -> 'a t

    val add_seq : 'a t -> (key * 'a) Seq.t -> unit

    val replace_seq : 'a t -> (key * 'a) Seq.t -> unit

    val to_seq : 'a t -> (key * 'a) Seq.t

    val to_seq_keys : 'a t -> key Seq.t

    val to_seq_values : 'a t -> 'a Seq.t
  end

  module Make (H : HashedType) : sig
    include module type of struct
      include (Hashtbl.Make (H))
    end

    include S with type 'a t := 'a t and type key := key
  end

  module type SeededHashedType = sig
    type t

    val equal : t -> t -> bool

    val hash : int -> t -> int
  end

  module type SeededS = sig
    include S

    val create : ?random:bool -> int -> 'a t
  end

  module MakeSeeded (H : SeededHashedType) : sig
#if OCAML_VERSION < (4,00,0)
    include SeededS
#else
    include module type of struct
      include Hashtbl.MakeSeeded (H)
    end

    include SeededS with type 'a t := 'a t and type key := key
#endif
  end
  (** before 4.00.0 a non-seeded hash table is created instead: the seed is
      always 0. *)
end

module Set : sig
  module type OrderedType = Set.OrderedType

  module type S = sig
    include Set.S

    val find : elt -> t -> elt

    val of_list : elt list -> t

    val map : (elt -> elt) -> t -> t

    val min_elt_opt : t -> elt option

    val max_elt_opt : t -> elt option

    val choose_opt : t -> elt option

    val find_opt : elt -> t -> elt option

    val find_first : (elt -> bool) -> t -> elt
    (** @before 4.05.0 linear time complexity. *)

    val find_first_opt : (elt -> bool) -> t -> elt option
    (** @before 4.05.0 linear time complexity. *)

    val find_last : (elt -> bool) -> t -> elt
    (** @before 4.05.0 linear time complexity. *)

    val find_last_opt : (elt -> bool) -> t -> elt option
    (** @before 4.05.0 linear time complexity. *)

    val of_seq : elt Seq.t -> t

    val add_seq : elt Seq.t -> t -> t

    val to_seq : t -> elt Seq.t

    val to_seq_from : elt -> t -> elt Seq.t
  end

  module Make (Ord : OrderedType) : sig
    include module type of struct
      include Set.Make (Ord)
    end

    include S with type elt := elt and type t := t
  end
end

module Map : sig
  module type OrderedType = Map.OrderedType

  module type S = sig
    include Map.S

    val union : (key -> 'a -> 'a -> 'a option) -> 'a t -> 'a t -> 'a t

    val find_opt : key -> 'a t -> 'a option

    val min_binding_opt : 'a t -> (key * 'a) option

    val max_binding_opt : 'a t -> (key * 'a) option

    val choose_opt : 'a t -> (key * 'a) option

    val update : key -> ('a option -> 'a option) -> 'a t -> 'a t

    val of_seq : (key * 'a) Seq.t -> 'a t

    val add_seq : (key * 'a) Seq.t -> 'a t -> 'a t

    val to_seq : 'a t -> (key * 'a) Seq.t

    val to_seq_from : key -> 'a t -> (key * 'a) Seq.t
  end

  module Make (Ord : OrderedType) : sig
    include module type of struct
      include Map.Make (Ord)
    end

    include S with type 'a t := 'a t and type key := key
  end
end

module Weak : sig
  type 'a t = 'a Weak.t

  val create : int -> 'a t

  val length : 'a t -> int

  val set : 'a t -> int -> 'a option -> unit

  val get : 'a t -> int -> 'a option

  val get_copy : 'a t -> int -> 'a option

  val check : 'a t -> int -> bool

  val fill : 'a t -> int -> int -> 'a option -> unit

  val blit : 'a t -> int -> 'a t -> int -> int -> unit

  module type S = sig
    include Weak.S

    val find_opt: t -> data -> data option
  end

  module Make (H : Hashtbl.HashedType) : sig
    include module type of struct
      include Weak.Make (H)
    end

    include S with type t := t and type data := data
  end
end

module Sys : sig
  include module type of struct
    include Sys
  end

  val unix : bool

  val win32 : bool

  val cygwin : bool

  val sigbus : int

  val sigpoll : int

  val sigsys : int

  val sigtrap : int

  val sigurg : int

  val sigxcpu : int

  val sigxfsz : int

#if OCAML_VERSION < (4,04,0)
  type backend_type =
    | Native
    | Bytecode
    | Other of string
#endif

  val backend_type : backend_type

  val int_size : int

  val big_endian : bool

  val runtime_variant : unit -> string
  (** @before 4.03.0 returns always the empty string *)

  val runtime_parameters : unit -> string
  (** @before 4.03.0 returns always the empty string *)

  val enable_runtime_warnings : bool -> unit
  (** @before 4.03.0 does nothing *)

  val runtime_warnings_enabled : unit -> bool
  (** @before 4.03.0 returns always false *)

  val getenv_opt : string -> string option
end

module Uchar : sig
#if OCAML_VERSION < (4,03,0)
  type t
#else
  include module type of struct
    include Uchar
  end
#endif
  (** @before 4.03.0 the module [Uchar] is redefined from scratch. *)

  val min : t

  val max : t

  val succ : t -> t

  val pred : t -> t

  val is_valid : int -> bool

  val of_int : int -> t

  val unsafe_of_int : int -> t

  val to_int : t -> int

  val is_char : t -> bool

  val of_char : char -> t

  val to_char : t -> char

  val unsafe_to_char : t -> char

  val equal : t -> t -> bool

  val compare : t -> t -> int

  val hash : t -> int

  val bom : t

  val rep : t
end

module Bytes : sig
#if OCAML_VERSION < (4,02,0)
  include module type of struct
    include String
  end
#else
  include module type of struct
    include Bytes
  end
#endif
  (** @before 4.02.0 the module [Bytes] is defined on top of the module
      [String]. *)

  val empty : t

  val of_string : string -> t

  val to_string : t -> string

  val sub_string : t -> int -> int -> string

  val extend : t -> int -> int -> t

  val blit_string : string -> int -> t -> int -> int -> unit

  val cat : t -> t -> t

  val unsafe_of_string : string -> t

  val unsafe_to_string : t -> string

  val uppercase_ascii : t -> t

  val lowercase_ascii : t -> t

  val capitalize_ascii : t -> t

  val uncapitalize_ascii : t -> t

  val equal : t -> t -> bool

  val of_seq : char Seq.t -> t

  val to_seq : t -> char Seq.t

  val to_seqi : t -> (int * char) Seq.t
end

module BytesLabels : sig
#if OCAML_VERSION < (4,02,0)
  include module type of struct
    include StringLabels
  end
#else
  include module type of struct
    include BytesLabels
  end
#endif
  (** @before 4.02.0 the module [BytesLabels] is defined on top of the module
      [StringLabels]. *)

  val empty : t

  val of_string : string -> t

  val to_string : t -> string

  val sub_string : t -> pos:int -> len:int -> string

  val extend : t -> left:int -> right:int -> t

  val blit_string :
    src:string -> src_pos:int -> dst:t -> dst_pos:int -> len:int -> unit

  val cat : t -> t -> t

  val unsafe_of_string : string -> t

  val unsafe_to_string : t -> string

  val uppercase_ascii : t -> t

  val lowercase_ascii : t -> t

  val capitalize_ascii : t -> t

  val uncapitalize_ascii : t -> t

  val equal : t -> t -> bool

  val of_seq : char Seq.t -> t

  val to_seq : t -> char Seq.t

  val to_seqi : t -> (int * char) Seq.t
end

module Buffer : sig
  include module type of struct
    include Buffer
  end

  val to_bytes : t -> bytes

  val truncate : t -> int -> unit
  (** @before 4.05.0 duplicates the prefix kept. *)

  val add_bytes : t -> bytes -> unit

  val add_subbytes : t -> bytes -> int -> int -> unit

  val add_utf_8_uchar : t -> Uchar.t -> unit

  val add_utf_16be_uchar : t -> Uchar.t -> unit

  val add_utf_16le_uchar : t -> Uchar.t -> unit

  val of_seq : char Seq.t -> t

  val add_seq : t -> char Seq.t -> unit

  val to_seq : t -> char Seq.t

  val to_seqi : t -> (int * char) Seq.t
end

module Stream : sig
  include module type of struct
    include Stream
  end

  val of_bytes : bytes -> char t
end

module Digest : sig
  include module type of struct
    include Digest
  end

  val equal : t -> t -> bool
end

module Nativeint : sig
  include module type of struct
    include Nativeint
  end

  val equal : t -> t -> bool

  val of_string_opt : string -> t option
end

module Int32 : sig
  include module type of struct
    include Int32
  end

  val equal : t -> t -> bool

  val of_string_opt : string -> t option
end

module Int64 : sig
  include module type of struct
    include Int64
  end

  val equal : t -> t -> bool

  val of_string_opt : string -> t option
end

module List : sig
  include module type of struct
    include List
  end

  val iteri : (int -> 'a -> unit) -> 'a list -> unit

  val mapi : (int -> 'a -> 'b) -> 'a list -> 'b list

  val sort_uniq : ('a -> 'a -> int) -> 'a list -> 'a list

  val cons : 'a -> 'a list -> 'a list

  val compare_lengths : 'a list -> 'a list -> int

  val compare_length_with : 'a list -> int -> int

  val nth_opt : 'a list -> int -> 'a option

  val find_opt : ('a -> bool) -> 'a list -> 'a option

  val assoc_opt : 'a -> ('a * 'b) list -> 'b option

  val assq_opt : 'a -> ('a * 'b) list -> 'b option

  val to_seq : 'a list -> 'a Seq.t

  val of_seq : 'a Seq.t -> 'a list
end

module ListLabels : sig
  include module type of struct
    include ListLabels
  end

  val iteri : f:(int -> 'a -> unit) -> 'a list -> unit

  val mapi : f:(int -> 'a -> 'b) -> 'a list -> 'b list

  val sort_uniq : cmp:('a -> 'a -> int) -> 'a list -> 'a list

  val cons : 'a -> 'a list -> 'a list

  val compare_lengths : 'a list -> 'a list -> int

  val compare_length_with : 'a list -> len:int -> int

  val nth_opt : 'a list -> int -> 'a option

  val find_opt : f:('a -> bool) -> 'a list -> 'a option

  val assoc_opt : 'a -> ('a * 'b) list -> 'b option

  val assq_opt : 'a -> ('a * 'b) list -> 'b option

  val to_seq : 'a list -> 'a Seq.t

  val of_seq : 'a Seq.t -> 'a list
end

module Filename : sig
  include module type of struct
    include Filename
  end

  val extension : string -> string

  val remove_extension : string -> string

  val get_temp_dir_name : unit -> string

  val set_temp_dir_name : string -> unit

  val open_temp_file :
      ?mode : open_flag list -> ?perms : int -> ?temp_dir : string -> string
          -> string -> string * out_channel
end

module Array : sig
  include module type of struct
    include Array
  end

#if OCAML_VERSION < (4,06,0)
  module Floatarray : sig
    val create : int -> floatarray

    val length : floatarray -> int

    val get : floatarray -> int -> float

    val set : floatarray -> int -> float -> unit

    val unsafe_get : floatarray -> int -> float

    val unsafe_set : floatarray -> int -> float -> unit
  end
#endif

  val iter2 : ('a -> 'b -> unit) -> 'a array -> 'b array -> unit

  val map2 : ('a -> 'b -> 'c) -> 'a array -> 'b array -> 'c array

  val for_all : ('a -> bool) -> 'a array -> bool

  val exists : ('a -> bool) -> 'a array -> bool

  val mem : 'a -> 'a array -> bool

  val memq : 'a -> 'a array -> bool

  val create_float : int -> float array
  (** @before 4.03.0 alias for [Array.make_float]
      @before 4.02.0 implemented as [Array.make len 0]. *)

  val of_seq : 'a Seq.t -> 'a array

  val to_seq : 'a array -> 'a Seq.t

  val to_seqi : 'a array -> (int * 'a) Seq.t
end

module ArrayLabels : sig
  include module type of struct
    include ArrayLabels
  end

#if OCAML_VERSION < (4,06,0)
  module Floatarray : module type of Array.Floatarray
#endif

  val iter2 : f:('a -> 'b -> unit) -> 'a array -> 'b array -> unit

  val map2 : f:('a -> 'b -> 'c) -> 'a array -> 'b array -> 'c array

  val for_all : f:('a -> bool) -> 'a array -> bool

  val exists : f:('a -> bool) -> 'a array -> bool

  val mem : 'a -> set:'a array -> bool

  val memq : 'a -> set:'a array -> bool

  val create_float : int -> float array
  (** @before 4.03.0 alias for [Array.make_float]
      @before 4.02.0 implemented as [Array.make len 0]. *)

  val of_seq : 'a Seq.t -> 'a array

  val to_seq : 'a array -> 'a Seq.t

  val to_seqi : 'a array -> (int * 'a) Seq.t
end

#if OCAML_VERSION < (4,02,0)
#define UNBOXED
#define NOALLOC
#define _UNBOXED
#define _UNTAGGED
#else
#define UNBOXED [@@unboxed]
#define NOALLOC [@@noalloc]
#define _UNBOXED [@unboxed]
#define _UNTAGGED [@untagged]
#endif

module Float : sig
#if OCAML_VERSION < (4,07,0)
  external neg : float -> float = "%negfloat"

  external add : float -> float -> float = "%addfloat"

  external sub : float -> float -> float = "%subfloat"

  external mul : float -> float -> float = "%mulfloat"

  external div : float -> float -> float = "%divfloat"

  external rem : float -> float -> float = "caml_fmod_float" "fmod"
    UNBOXED NOALLOC

  external abs : float -> float = "%absfloat"

  val infinity : float

  val neg_infinity : float

  val nan : float

  val pi : float

  val max_float : float

  val min_float : float

  val epsilon : float

  external of_int : int -> float = "%floatofint"

  external to_int : float -> int = "%intoffloat"

  external of_string : string -> float = "caml_float_of_string"

  val of_string_opt: string -> float option

  val to_string : float -> string

  type fpclass = Pervasives.fpclass =
      FP_normal
    | FP_subnormal
    | FP_zero
    | FP_infinite
    | FP_nan

#if OCAML_VERSION < (4,03,0)
  external classify_float : float -> fpclass = "caml_classify_float"
#else
  external classify_float : (float _UNBOXED) -> fpclass =
    "caml_classify_float" "caml_classify_float_unboxed" NOALLOC
#endif

  external pow : float -> float -> float = "caml_power_float" "pow"
    UNBOXED NOALLOC

  external sqrt : float -> float = "caml_sqrt_float" "sqrt"
    UNBOXED NOALLOC

  external exp : float -> float = "caml_exp_float" "exp"
    UNBOXED NOALLOC

  external log : float -> float = "caml_log_float" "log"
    UNBOXED NOALLOC

  external log10 : float -> float = "caml_log10_float" "log10"
    UNBOXED NOALLOC

  external expm1 : float -> float = "caml_expm1_float" "caml_expm1"
    UNBOXED NOALLOC

  external log1p : float -> float = "caml_log1p_float" "caml_log1p"
    UNBOXED NOALLOC

  external cos : float -> float = "caml_cos_float" "cos"
    UNBOXED NOALLOC

  external sin : float -> float = "caml_sin_float" "sin"
    UNBOXED NOALLOC

  external tan : float -> float = "caml_tan_float" "tan"
    UNBOXED NOALLOC

  external acos : float -> float = "caml_acos_float" "acos"
    UNBOXED NOALLOC

  external asin : float -> float = "caml_asin_float" "asin"
    UNBOXED NOALLOC

  external atan : float -> float = "caml_atan_float" "atan"
    UNBOXED NOALLOC

  external atan2 : float -> float -> float = "caml_atan2_float" "atan2"
    UNBOXED NOALLOC

  external cosh : float -> float = "caml_cosh_float" "cosh"
    UNBOXED NOALLOC

  external sinh : float -> float = "caml_sinh_float" "sinh"
    UNBOXED NOALLOC

  external tanh : float -> float = "caml_tanh_float" "tanh"
    UNBOXED NOALLOC

  external ceil : float -> float = "caml_ceil_float" "ceil"
    UNBOXED NOALLOC

  external floor : float -> float = "caml_floor_float" "floor"
    UNBOXED NOALLOC

#if OCAML_VERSION < (4,00,0)
  val hypot : float -> float -> float

  val copysign : float -> float -> float
#else
  external hypot : float -> float -> float = "caml_hypot_float" "caml_hypot"
    UNBOXED NOALLOC

  external copysign : float -> float -> float
    = "caml_copysign_float" "caml_copysign"
    UNBOXED NOALLOC
#endif

  external frexp : float -> float * int = "caml_frexp_float"

#if OCAML_VERSION < (4,03,0)
  external ldexp : float -> int -> float = "caml_ldexp_float"
#else
  external ldexp :
    (float _UNBOXED) -> (int _UNTAGGED) -> (float _UNBOXED) =
    "caml_ldexp_float" "caml_ldexp_float_unboxed" NOALLOC
#endif

  external modf : float -> float * float = "caml_modf_float"

  type t = float

  val compare: t -> t -> int

  val equal: t -> t -> bool

  val hash: t -> int

  module Array : module type of struct
    include Array.Floatarray
  end
#else
  include module type of struct
    include Float
  end
#endif
end

module Queue : sig
  include module type of struct
    include Queue
  end

  val of_seq : 'a Seq.t -> 'a t

  val add_seq : 'a t -> 'a Seq.t -> unit

  val to_seq : 'a t -> 'a Seq.t
end