diff -Nru a/Documentation/filesystems/ntfs.txt b/Documentation/filesystems/ntfs.txt
--- a/Documentation/filesystems/ntfs.txt	Thu Jun 20 15:54:01 2002
+++ b/Documentation/filesystems/ntfs.txt	Thu Jun 20 15:54:01 2002
@@ -247,6 +247,16 @@
 
 Note, a technical ChangeLog aimed at kernel hackers is in fs/ntfs/ChangeLog.
 
+2.0.10:
+	- Microsoft says that the maximum number of inodes is 2^32 - 1. Update
+	  the driver accordingly to only use 32-bits to store inode numbers on
+	  32-bit architectures. This improves the speed of the driver a little.
+2.0.9:
+	- Change decompression engine to use a single buffer. This should not
+	  affect performance except perhaps on the most heavy i/o on SMP
+	  systems when accessing multiple compressed files from multiple
+	  devices simultaneously.
+	- Minor updates and cleanups.
 2.0.8:
 	- Remove now obsolete show_inodes and posix mount option(s).
 	- Restore show_sys_files mount option.
diff -Nru a/Documentation/networking/dl2k.txt b/Documentation/networking/dl2k.txt
--- a/Documentation/networking/dl2k.txt	Thu Jun 20 15:54:00 2002
+++ b/Documentation/networking/dl2k.txt	Thu Jun 20 15:54:00 2002
@@ -1,7 +1,7 @@
 
     D-Link DL2000-based Gigabit Ethernet Adapter Installation
     for Linux
-    Jan 29, 2002
+    May 23, 2002
 
 Contents
 ========
@@ -202,7 +202,7 @@
 				  1000mbps_fd and 1000mbps_hd types are only
 				  available for fiber adapter.
 
-vlan=[0|1]			- Specifies the VLAN ID. If vlan=0, the
+vlan=n				- Specifies the VLAN ID. If vlan=0, the
 				  Virtual Local Area Network (VLAN) function is
 				  disable.
 
@@ -211,24 +211,34 @@
 				  function is disabled.
 				  Jumbo frame usually improve the performance
 				  int gigabit.
+				  This feature need jumbo frame compatible 
+				  remote.
 				  
-rx_coalesce=n			- Rx frame count each interrupt.
-rx_timeout=n			- Rx DMA wait time for an interrupt. Proper 
-				  values of rx_coalesce and rx_timeout bring 
-				  a conspicuous performance in the fast machine.
-				  Ex. rx_coalesce=5 and rx_timeout=750 
-
-tx_coalesce=n			- Tx transmit count each TxComp interrupt.
-				  Setting value larger than 1 will improve 
-				  performance, but this is possible to lower 
-				  stability in slow UP machines. By default, 
-				  tx_coalesce=1. (dl2k)
+rx_coalesce=m			- Number of rx frame handled each interrupt.
+rx_timeout=n			- Rx DMA wait time for an interrupt. 
+				  If set rx_coalesce > 0, hardware only assert 
+				  an interrupt for m frames. Hardware won't 
+				  assert rx interrupt until m frames received or
+				  reach timeout of n * 640 nano seconds. 
+				  Set proper rx_coalesce and rx_timeout can 
+				  reduce congestion collapse and overload which
+				  has been a bottlenect for high speed network.
 				  
-tx_flow=[1|0]			- Specifies the Tx flow control. If tx_flow=1, 
-				  the Tx flow control enable.
+				  For example, rx_coalesce=10 rx_timeout=800.
+				  that is, hardware assert only 1 interrupt 
+				  for 10 frames received or timeout of 512 us. 
+
+tx_coalesce=n			- Number of tx frame handled each interrupt.
+				  Set n > 1 can reduce the interrupts 
+				  congestion usually lower performance of
+				  high speed network card. Default is 16.
 				  
-rx_flow=[1|0]			- Specifies the Rx flow control. If rx_flow=1, 
-				  the Rx flow control enable.
+tx_flow=[1|0]			- Specifies the Tx flow control. If tx_flow=0, 
+				  the Tx flow control disable else driver
+				  autodetect.
+rx_flow=[1|0]			- Specifies the Rx flow control. If rx_flow=0, 
+				  the Rx flow control enable else driver
+				  autodetect.
 
 
 Configuration Script Sample
diff -Nru a/Makefile b/Makefile
--- a/Makefile	Thu Jun 20 15:54:00 2002
+++ b/Makefile	Thu Jun 20 15:54:00 2002
@@ -1,6 +1,6 @@
 VERSION = 2
 PATCHLEVEL = 5
-SUBLEVEL = 23
+SUBLEVEL = 24
 EXTRAVERSION =
 
 # We are using a recursive build, so we need to do a little thinking
@@ -48,11 +48,35 @@
   KBUILD_VERBOSE = 1
 endif
 
-# 	Decide whether to build built-in, modular, or both
+# 	Decide whether to build built-in, modular, or both.
+#	Normally, just do built-in.
 
-KBUILD_MODULES := 1
+KBUILD_MODULES :=
 KBUILD_BUILTIN := 1
 
+#	If we have only "make modules", don't compile built-in objects.
+
+ifeq ($(MAKECMDGOALS),modules)
+  KBUILD_BUILTIN :=
+endif
+
+#	If we have "make <whatever> modules", compile modules
+#	in addition to whatever we do anyway.
+
+ifneq ($(filter modules,$(MAKECMDGOALS)),)
+  KBUILD_MODULES := 1
+endif
+
+#	Just "make" or "make all" shall build modules as well
+
+ifeq ($(MAKECMDGOALS),)
+  KBUILD_MODULES := 1
+endif
+
+ifneq ($(filter all,$(MAKECMDGOALS)),)
+  KBUILD_MODULES := 1
+endif
+
 export KBUILD_MODULES KBUILD_BUILTIN
 
 # Beautify output
@@ -120,6 +144,8 @@
 export CFLAGS CFLAGS_KERNEL CFLAGS_MODULE 
 export AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
 
+SUBDIRS		:= init kernel mm fs ipc lib drivers sound net
+
 noconfig_targets := xconfig menuconfig config oldconfig randconfig \
 		    defconfig allyesconfig allnoconfig allmodconfig \
 		    clean mrproper distclean \
@@ -182,7 +208,7 @@
 
 # Link components for vmlinux
 # ---------------------------------------------------------------------------
-SUBDIRS		:= init kernel mm fs ipc lib drivers sound net
+
 INIT		:= init/init.o
 CORE_FILES	:= kernel/kernel.o mm/mm.o fs/fs.o ipc/ipc.o
 LIBS		:= lib/lib.a
@@ -254,6 +280,7 @@
 
 .PHONY: prepare
 prepare: include/linux/version.h include/asm include/config/MARKER
+	@echo '  Starting the build. KBUILD_BUILTIN=$(KBUILD_BUILTIN) KBUILD_MODULES=$(KBUILD_MODULES)'
 
 # Single targets
 # ---------------------------------------------------------------------------
@@ -354,7 +381,7 @@
 	@( echo "#ifndef _LINUX_MODVERSIONS_H";\
 	   echo "#define _LINUX_MODVERSIONS_H"; \
 	   echo "#include <linux/modsetver.h>"; \
-	   for f in `cd .tmp_export-objs; find modules -name \*.ver -print | sort`; do \
+	   for f in `cd .tmp_export-objs; find modules -name SCCS -prune -o -name BitKeeper -prune -o -name \*.ver -print | sort`; do \
 	     echo "#include <linux/$${f}>"; \
 	   done; \
 	   echo "#endif"; \
@@ -384,8 +411,7 @@
 endif
 
 .PHONY: modules
-modules:
-	@$(MAKE) KBUILD_BUILTIN= $(SUBDIRS)
+modules: $(SUBDIRS)
 
 #	Install modules
 
@@ -466,7 +492,9 @@
 #	   will become invalid
 
 rpm:	clean spec
-	find . \( -size 0 -o -name .depend -o -name .hdepend \) -type f -print | xargs rm -f
+	find . -name SCCS -prune -o -name BitKeeper -prune -o \
+		\( -size 0 -o -name .depend -o -name .hdepend \) \
+		-type f -print | xargs rm -f
 	set -e; \
 	cd $(TOPDIR)/.. ; \
 	ln -sf $(TOPDIR) $(KERNELPATH) ; \
@@ -549,6 +577,7 @@
 	drivers/char/consolemap_deftbl.c drivers/video/promcon_tbl.c \
 	drivers/char/conmakehash \
 	drivers/char/drm/*-mod.c \
+	drivers/char/defkeymap.c drivers/char/qtronixmap.c \
 	drivers/pci/devlist.h drivers/pci/classlist.h drivers/pci/gen-devlist \
 	drivers/zorro/devlist.h drivers/zorro/gen-devlist \
 	sound/oss/bin2hex sound/oss/hex2hex \
@@ -559,9 +588,12 @@
 	drivers/scsi/aic7xxx/aicasm/aicasm_scan.c \
 	drivers/scsi/aic7xxx/aicasm/y.tab.h \
 	drivers/scsi/aic7xxx/aicasm/aicasm \
-	drivers/scsi/53c700_d.h \
-	net/khttpd/make_times_h \
-	net/khttpd/times.h \
+	drivers/scsi/53c700_d.h drivers/scsi/sim710_d.h \
+	drivers/scsi/53c7xx_d.h drivers/scsi/53c7xx_u.h \
+	drivers/scsi/53c8xx_d.h drivers/scsi/53c8xx_u.h \
+	net/802/cl2llc.c net/802/transit/pdutr.h net/802/transit/timertr.h \
+	net/802/pseudo/pseudocode.h \
+	net/khttpd/make_times_h net/khttpd/times.h \
 	submenu*
 
 # 	files removed with 'make mrproper'
@@ -599,23 +631,26 @@
 
 clean:	archclean
 	@echo 'Cleaning up'
-	@find . \( -name \*.[oas] -o -name core -o -name .\*.cmd -o \
-		   -name .\*.tmp -o -name .\*.d \) -type f -print \
+	@find . -name SCCS -prune -o -name BitKeeper -prune -o \
+		\( -name \*.[oas] -o -name core -o -name .\*.cmd -o \
+		-name .\*.tmp -o -name .\*.d \) -type f -print \
 		| grep -v lxdialog/ | xargs rm -f
 	@rm -f $(CLEAN_FILES)
 	@$(MAKE) -C Documentation/DocBook clean
 
 mrproper: clean archmrproper
 	@echo 'Making mrproper'
-	@find . \( -size 0 -o -name .depend -o -name .\*.cmd \) \
-		   -type f -print | xargs rm -f
+	@find . -name SCCS -prune -o -name BitKeeper -prune -o \
+		\( -name .depend -o -name .\*.cmd \) \
+		-type f -print | xargs rm -f
 	@rm -f $(MRPROPER_FILES)
 	@rm -rf $(MRPROPER_DIRS)
 	@$(MAKE) -C Documentation/DocBook mrproper
 
 distclean: mrproper
 	@echo 'Making distclean'
-	@find . \( -not -type d \) -and \
+	@find . -name SCCS -prune -o -name BitKeeper -prune -o \
+		\( -not -type d \) -and \
 	 	\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
 		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
 	 	-o -name '.*.rej' -o -name '.SUMS' -o -size 0 \) -type f \
@@ -625,16 +660,24 @@
 # ---------------------------------------------------------------------------
 
 TAGS: FORCE
-	{ find include/asm-${ARCH} -name '*.h' -print ; \
-	find include -type d \( -name "asm-*" -o -name config \) -prune -o -name '*.h' -print ; \
-	find $(SUBDIRS) init arch/${ARCH} -name '*.[chS]' ; } | grep -v SCCS | etags -
+	{ find include/asm-${ARCH} -name SCCS -prune -o -name BitKeeper -prune \
+		-o -name '*.h' -print ; \
+	find include -name SCCS -prune -o -name BitKeeper -prune -o \
+		-type d \( -name "asm-*" -o -name config \) -prune -o \
+		-name '*.h' -print ; \
+	find $(SUBDIRS) init arch/${ARCH} \
+		-name SCCS -prune -o -name BitKeeper -prune -o \
+		-name '*.[chS]' -print ; } | grep -v SCCS | etags -
 
 # 	Exuberant ctags works better with -I
 tags: FORCE
 	CTAGSF=`ctags --version | grep -i exuberant >/dev/null && echo "-I __initdata,__exitdata,EXPORT_SYMBOL,EXPORT_SYMBOL_NOVERS"`; \
-	ctags $$CTAGSF `find include/asm-$(ARCH) -name '*.h'` && \
-	find include -type d \( -name "asm-*" -o -name config \) -prune -o -name '*.h' -print | xargs ctags $$CTAGSF -a && \
-	find $(SUBDIRS) init -name '*.[ch]' | xargs ctags $$CTAGSF -a
+	ctags $$CTAGSF `find include/asm-$(ARCH) -name SCCS -prune -o -name BitKeeper -prune -o -name '*.h' -print` && \
+	find include -name SCCS -prune -o -name BitKeeper -prune -o \
+		-type d \( -name "asm-*" -o -name config \) -prune -o \
+		-name '*.h' -print | xargs ctags $$CTAGSF -a && \
+	find $(SUBDIRS) init -name SCCS -prune -o -name BitKeeper -prune -o \
+		-name '*.[ch]' -print | xargs ctags $$CTAGSF -a
 
 # Documentation targets
 # ---------------------------------------------------------------------------
@@ -647,13 +690,19 @@
 # ---------------------------------------------------------------------------
 
 checkconfig:
-	find * -name '*.[hcS]' -type f -print | sort | xargs $(PERL) -w scripts/checkconfig.pl
+	find * -name SCCS -prune -o -name BitKeeper -prune -o \
+		-name '*.[hcS]' -type f -print | sort \
+		| xargs $(PERL) -w scripts/checkconfig.pl
 
 checkhelp:
-	find * -name [cC]onfig.in -print | sort | xargs $(PERL) -w scripts/checkhelp.pl
+	find * -name SCCS -prune -o -name BitKeeper -prune -o \
+		-name [cC]onfig.in -print | sort \
+		| xargs $(PERL) -w scripts/checkhelp.pl
 
 checkincludes:
-	find * -name '*.[hcS]' -type f -print | sort | xargs $(PERL) -w scripts/checkincludes.pl
+	find * -name SCCS -prune -o -name BitKeeper -prune -o \
+		-name '*.[hcS]' -type f -print | sort \
+		| xargs $(PERL) -w scripts/checkincludes.pl
 
 else # ifneq ($(filter-out $(noconfig_targets),$(MAKECMDGOALS)),)
 
diff -Nru a/Rules.make b/Rules.make
--- a/Rules.make	Thu Jun 20 15:54:00 2002
+++ b/Rules.make	Thu Jun 20 15:54:00 2002
@@ -22,6 +22,30 @@
   TOPDIR_REL := $(subst $(space),,$(foreach d,$(subst /, ,$(RELDIR)),../))
 endif
 
+# Some paths for the Makefiles to use
+# ---------------------------------------------------------------------------
+
+# Usage:
+#
+# $(obj)/target.o                     : target.o in the build dir
+# $(src)/target.c                     : target.c in the source dir
+# $(objtree)/include/linux/version.h  : Some file relative to the build
+#					dir root
+# $(srctree)/include/linux/module.h   : Some file relative to the source
+#				        dir root
+#
+# Those can only be used in the section after
+# include $(TOPDIR)/Rules.make, i.e for generated files and the like.
+# Intentionally.
+#
+# We don't support separate source / object yet, so these are just
+# placeholders for now
+
+obj := .
+src := .
+objtree := $(TOPDIR)
+srctree := $(TOPDIR)
+
 # Figure out what we need to build from the various variables
 # ===========================================================================
 
@@ -381,6 +405,13 @@
 
 endif # ! modules_install
 endif # ! fastdep
+
+# Shipped files
+# ===========================================================================
+
+%:: %_shipped
+	@echo '  CP     $(RELDIR)/$@'
+	@cp $< $@
 
 # ===========================================================================
 # Generic stuff
diff -Nru a/arch/alpha/config.in b/arch/alpha/config.in
--- a/arch/alpha/config.in	Thu Jun 20 15:54:00 2002
+++ b/arch/alpha/config.in	Thu Jun 20 15:54:00 2002
@@ -329,7 +329,7 @@
 mainmenu_option next_comment
 comment 'Old CD-ROM drivers (not SCSI, not IDE)'
 
-bool 'Support non-SCSI/IDE/ATAPI drives' CONFIG_CD_NO_IDESCSI
+bool 'Support non-SCSI/IDE/ATAPI CDROM drives' CONFIG_CD_NO_IDESCSI
 if [ "$CONFIG_CD_NO_IDESCSI" != "n" ]; then
   source drivers/cdrom/Config.in
 fi
diff -Nru a/arch/alpha/kernel/traps.c b/arch/alpha/kernel/traps.c
--- a/arch/alpha/kernel/traps.c	Thu Jun 20 15:54:00 2002
+++ b/arch/alpha/kernel/traps.c	Thu Jun 20 15:54:00 2002
@@ -141,7 +141,7 @@
 	}
 }
 
-int kstack_depth_to_print = 24;
+static int kstack_depth_to_print = 24;
 
 void show_stack(unsigned long *sp)
 {
diff -Nru a/arch/arm/config.in b/arch/arm/config.in
--- a/arch/arm/config.in	Thu Jun 20 15:54:00 2002
+++ b/arch/arm/config.in	Thu Jun 20 15:54:00 2002
@@ -66,7 +66,7 @@
    choice 'Cerf Flash available'  \
         "8MB    CONFIG_SA1100_CERF_FLASH_8MB \
          16MB   CONFIG_SA1100_CERF_FLASH_16MB \
-         32MB   CONFIG_SA1100_CERF_FLASH_32MB" CerfFlash
+         32MB   CONFIG_SA1100_CERF_FLASH_32MB" 8MB
    bool 'Cerf w/CPLD support (CerfPDA)' CONFIG_SA1100_CERF_CPLD
 fi
 dep_bool '  Compaq iPAQ H3100' CONFIG_SA1100_H3100 $CONFIG_ARCH_SA1100
@@ -341,7 +341,7 @@
 if [ "$CONFIG_CPU_ARM720T" = "y" -o "$CONFIG_CPU_ARM920T" = "y" -o \
      "$CONFIG_CPU_ARM922T" = "y" -o "$CONFIG_CPU_ARM926T" = "y" -o \
      "$CONFIG_CPU_ARM1020" = "y" -o "$CONFIG_CPU_XSCALE" = "y" ]; then
-   dep_bool 'Support Thumb instructions (experimental)' CONFIG_ARM_THUMB $CONFIG_EXPERIMENTAL
+   dep_bool 'Support Thumb instructions (EXPERIMENTAL)' CONFIG_ARM_THUMB $CONFIG_EXPERIMENTAL
 fi
 if [ "$CONFIG_CPU_ARM920T" = "y" -o "$CONFIG_CPU_ARM922T" = "y" -o \
      "$CONFIG_CPU_ARM926T" = "y" -o "$CONFIG_CPU_ARM1020" = "y" ]; then
@@ -440,7 +440,7 @@
 fi
 
 source drivers/pci/Config.in
-bool 'Support hot-pluggable devices' CONFIG_HOTPLUG
+bool 'Support for hot-pluggable devices' CONFIG_HOTPLUG
 if [ "$CONFIG_HOTPLUG" = "y" ]; then
    source drivers/pcmcia/Config.in
 else
@@ -449,7 +449,7 @@
 comment 'At least one math emulation must be selected'
 tristate 'NWFPE math emulation' CONFIG_FPE_NWFPE
 if [ "$CONFIG_CPU_26" = "n" -a "$CONFIG_CPU_32v3" = "n" ]; then
-   dep_tristate 'FastFPE math emulation (experimental)' CONFIG_FPE_FASTFPE $CONFIG_EXPERIMENTAL
+   dep_tristate 'FastFPE math emulation (EXPERIMENTAL)' CONFIG_FPE_FASTFPE $CONFIG_EXPERIMENTAL
 fi
 choice 'Kernel core (/proc/kcore) format' \
 	"ELF		CONFIG_KCORE_ELF	\
@@ -458,7 +458,7 @@
 tristate 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'Power Management support' CONFIG_PM
-dep_bool 'Preemptible Kernel (experimental)' CONFIG_PREEMPT $CONFIG_CPU_32 $CONFIG_EXPERIMENTAL
+dep_bool 'Preemptible Kernel (EXPERIMENTAL)' CONFIG_PREEMPT $CONFIG_CPU_32 $CONFIG_EXPERIMENTAL
 dep_tristate 'Advanced Power Management Emulation' CONFIG_APM $CONFIG_PM
 dep_tristate 'RISC OS personality' CONFIG_ARTHUR $CONFIG_CPU_32
 string 'Default kernel command string' CONFIG_CMDLINE ""
@@ -520,7 +520,7 @@
    mainmenu_option next_comment
    comment 'Network device support'
 
-   bool 'Network device support?' CONFIG_NETDEVICES
+   bool 'Network device support' CONFIG_NETDEVICES
    if [ "$CONFIG_NETDEVICES" = "y" ]; then
       source drivers/net/Config.in
    fi
@@ -546,7 +546,7 @@
 mainmenu_option next_comment
 comment 'SCSI support'
 
-tristate 'SCSI support?' CONFIG_SCSI
+tristate 'SCSI support' CONFIG_SCSI
 
 if [ "$CONFIG_SCSI" != "n" ]; then
    source drivers/scsi/Config.in
@@ -626,7 +626,7 @@
    mainmenu_option next_comment
    comment 'Sound'
 
-   tristate 'Sound support' CONFIG_SOUND
+   tristate 'Sound card support' CONFIG_SOUND
    if [ "$CONFIG_SOUND" != "n" ]; then
       source sound/Config.in
    fi
diff -Nru a/arch/arm/kernel/sys_arm.c b/arch/arm/kernel/sys_arm.c
--- a/arch/arm/kernel/sys_arm.c	Thu Jun 20 15:54:00 2002
+++ b/arch/arm/kernel/sys_arm.c	Thu Jun 20 15:54:00 2002
@@ -279,10 +279,3 @@
 out:
 	return error;
 }
-
-asmlinkage int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
diff -Nru a/arch/cris/kernel/sys_cris.c b/arch/cris/kernel/sys_cris.c
--- a/arch/cris/kernel/sys_cris.c	Thu Jun 20 15:54:00 2002
+++ b/arch/cris/kernel/sys_cris.c	Thu Jun 20 15:54:00 2002
@@ -167,12 +167,3 @@
 		return -EINVAL;
 	}
 }
-
-/* apparently this is legacy - if we don't need this in Linux/CRIS we can remove it. */
-
-asmlinkage int sys_pause(void)
-{
-        current->state = TASK_INTERRUPTIBLE;
-        schedule();
-        return -ERESTARTNOHAND;
-}
diff -Nru a/arch/cris/kernel/traps.c b/arch/cris/kernel/traps.c
--- a/arch/cris/kernel/traps.c	Thu Jun 20 15:54:01 2002
+++ b/arch/cris/kernel/traps.c	Thu Jun 20 15:54:01 2002
@@ -28,7 +28,7 @@
 #include <asm/io.h>
 #include <asm/pgtable.h>
 
-int kstack_depth_to_print = 24;
+static int kstack_depth_to_print = 24;
 
 void show_trace(unsigned long * stack)
 {
diff -Nru a/arch/i386/Makefile b/arch/i386/Makefile
--- a/arch/i386/Makefile	Thu Jun 20 15:54:00 2002
+++ b/arch/i386/Makefile	Thu Jun 20 15:54:00 2002
@@ -110,6 +110,8 @@
 .PHONY: zImage bzImage compressed zlilo bzlilo zdisk bzdisk install \
 		clean archclean archmrproper
 
+all: bzImage
+
 zImage: vmlinux
 	@$(MAKEBOOT) zImage
 
diff -Nru a/arch/i386/boot/compressed/misc.c b/arch/i386/boot/compressed/misc.c
--- a/arch/i386/boot/compressed/misc.c	Thu Jun 20 15:54:01 2002
+++ b/arch/i386/boot/compressed/misc.c	Thu Jun 20 15:54:01 2002
@@ -125,7 +125,7 @@
 static int lines, cols;
 
 #ifdef CONFIG_MULTIQUAD
-static void *xquad_portio = NULL;
+static void * const xquad_portio = NULL;
 #endif
 
 #include "../../../../lib/inflate.c"
diff -Nru a/arch/i386/kernel/apm.c b/arch/i386/kernel/apm.c
--- a/arch/i386/kernel/apm.c	Thu Jun 20 15:54:00 2002
+++ b/arch/i386/kernel/apm.c	Thu Jun 20 15:54:00 2002
@@ -922,12 +922,13 @@
  * callback we use.
  */
 
-void handle_poweroff (int key, struct pt_regs *pt_regs,
-		struct kbd_struct *kbd, struct tty_struct *tty) {
+static void handle_poweroff (int key, struct pt_regs *pt_regs,
+		struct kbd_struct *kbd, struct tty_struct *tty)
+{
         apm_power_off();
 }
 
-struct sysrq_key_op	sysrq_poweroff_op = {
+static struct sysrq_key_op	sysrq_poweroff_op = {
 	handler:        handle_poweroff,
 	help_msg:       "Off",
 	action_msg:     "Power Off\n"
diff -Nru a/arch/i386/kernel/i386_ksyms.c b/arch/i386/kernel/i386_ksyms.c
--- a/arch/i386/kernel/i386_ksyms.c	Thu Jun 20 15:54:01 2002
+++ b/arch/i386/kernel/i386_ksyms.c	Thu Jun 20 15:54:01 2002
@@ -63,6 +63,7 @@
 EXPORT_SYMBOL(dump_fpu);
 EXPORT_SYMBOL(dump_extended_fpu);
 EXPORT_SYMBOL(__ioremap);
+EXPORT_SYMBOL(ioremap_nocache);
 EXPORT_SYMBOL(iounmap);
 EXPORT_SYMBOL(enable_irq);
 EXPORT_SYMBOL(disable_irq);
@@ -175,3 +176,7 @@
 EXPORT_SYMBOL(is_sony_vaio_laptop);
 
 EXPORT_SYMBOL(__PAGE_KERNEL);
+
+#ifdef CONFIG_MULTIQUAD
+EXPORT_SYMBOL(xquad_portio);
+#endif
diff -Nru a/arch/i386/kernel/mpparse.c b/arch/i386/kernel/mpparse.c
--- a/arch/i386/kernel/mpparse.c	Thu Jun 20 15:54:00 2002
+++ b/arch/i386/kernel/mpparse.c	Thu Jun 20 15:54:00 2002
@@ -64,7 +64,7 @@
 unsigned int boot_cpu_physical_apicid = -1U;
 unsigned int boot_cpu_logical_apicid = -1U;
 /* Internal processor count */
-static unsigned int num_processors;
+static unsigned int __initdata num_processors;
 
 /* Bitmask of physically existing CPUs */
 unsigned long phys_cpu_present_map;
diff -Nru a/arch/i386/kernel/smpboot.c b/arch/i386/kernel/smpboot.c
--- a/arch/i386/kernel/smpboot.c	Thu Jun 20 15:54:01 2002
+++ b/arch/i386/kernel/smpboot.c	Thu Jun 20 15:54:01 2002
@@ -50,11 +50,11 @@
 #include <asm/tlbflush.h>
 #include <asm/smpboot.h>
 
-/* Set if we find a B stepping CPU			*/
-static int smp_b_stepping;
+/* Set if we find a B stepping CPU */
+static int __initdata smp_b_stepping;
 
 /* Setup configured maximum number of CPUs to activate */
-static int max_cpus = -1;
+static int __initdata max_cpus = NR_CPUS;
 
 /* Number of siblings per CPU package */
 int smp_num_siblings = 1;
@@ -1011,7 +1011,7 @@
 
 static int boot_cpu_logical_apicid;
 /* Where the IO area was mapped on multiquad, always 0 otherwise */
-void *xquad_portio = NULL;
+void *xquad_portio;
 
 int cpu_sibling_map[NR_CPUS] __cacheline_aligned;
 
@@ -1146,7 +1146,7 @@
 
 		if (!(phys_cpu_present_map & (1 << bit)))
 			continue;
-		if ((max_cpus >= 0) && (max_cpus <= cpucount+1))
+		if (max_cpus <= cpucount+1)
 			continue;
 
 		do_boot_cpu(apicid);
diff -Nru a/arch/i386/kernel/sys_i386.c b/arch/i386/kernel/sys_i386.c
--- a/arch/i386/kernel/sys_i386.c	Thu Jun 20 15:54:01 2002
+++ b/arch/i386/kernel/sys_i386.c	Thu Jun 20 15:54:01 2002
@@ -246,11 +246,3 @@
 
 	return error;
 }
-
-asmlinkage int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
diff -Nru a/arch/i386/kernel/traps.c b/arch/i386/kernel/traps.c
--- a/arch/i386/kernel/traps.c	Thu Jun 20 15:54:00 2002
+++ b/arch/i386/kernel/traps.c	Thu Jun 20 15:54:00 2002
@@ -89,7 +89,7 @@
 asmlinkage void spurious_interrupt_bug(void);
 asmlinkage void machine_check(void);
 
-int kstack_depth_to_print = 24;
+static int kstack_depth_to_print = 24;
 
 
 /*
diff -Nru a/arch/ia64/config.in b/arch/ia64/config.in
--- a/arch/ia64/config.in	Thu Jun 20 15:54:01 2002
+++ b/arch/ia64/config.in	Thu Jun 20 15:54:01 2002
@@ -64,12 +64,12 @@
 	fi
 fi
 
-if [ "$CONFIG_IA64_GENERIC" = "y" ] || [ "$CONFIG_IA64_DIG" = "y" ] || [ "$CONFIG_IA64_HP_ZX1" = "y" ]; then
+if [ "$CONFIG_IA64_GENERIC" = "y" -o  "$CONFIG_IA64_DIG" = "y" -o "$CONFIG_IA64_HP_ZX1" = "y" ]; then
 	bool '  Enable IA-64 Machine Check Abort' CONFIG_IA64_MCA
 	define_bool CONFIG_PM y
 fi
 
-if [ "$CONFIG_IA64_SGI_SN1" = "y" ] || [ "$CONFIG_IA64_SGI_SN2" = "y" ]; then
+if [ "$CONFIG_IA64_SGI_SN1" = "y" -o  "$CONFIG_IA64_SGI_SN2" = "y" ]; then
 	define_bool CONFIG_IA64_SGI_SN y
 	bool '  Enable extra debugging code' CONFIG_IA64_SGI_SN_DEBUG n
 	bool '  Enable SGI Medusa Simulator Support' CONFIG_IA64_SGI_SN_SIM
@@ -187,7 +187,7 @@
 mainmenu_option next_comment
 comment 'CD-ROM drivers (not for SCSI or IDE/ATAPI drives)'
 
-bool 'Support non-SCSI/IDE/ATAPI drives' CONFIG_CD_NO_IDESCSI
+bool 'Support non-SCSI/IDE/ATAPI CDROM drives' CONFIG_CD_NO_IDESCSI
 if [ "$CONFIG_CD_NO_IDESCSI" != "n" ]; then
   source drivers/cdrom/Config.in
 fi
diff -Nru a/arch/m68k/config.in b/arch/m68k/config.in
--- a/arch/m68k/config.in	Thu Jun 20 15:54:01 2002
+++ b/arch/m68k/config.in	Thu Jun 20 15:54:01 2002
@@ -125,7 +125,7 @@
    fi
    dep_tristate '  Parallel printer support' CONFIG_PRINTER $CONFIG_PARPORT
    if [ "$CONFIG_PRINTER" != "n" ]; then
-      bool '    Support IEEE1284 status readback' CONFIG_PARPORT_1284
+      bool '    IEEE 1284 transfer modes' CONFIG_PARPORT_1284
    fi
 fi
 
@@ -188,7 +188,7 @@
    if [ "$CONFIG_CHR_DEV_ST" != "n" ]; then
       int  'Maximum number of SCSI tapes that can be loaded as modules' CONFIG_ST_EXTRA_DEVS 2
    fi
-   dep_tristate '  SCSI CD-ROM support' CONFIG_BLK_DEV_SR $CONFIG_SCSI
+   dep_tristate '  SCSI CDROM support' CONFIG_BLK_DEV_SR $CONFIG_SCSI
    if [ "$CONFIG_BLK_DEV_SR" != "n" ]; then
       bool '    Enable vendor-specific extensions (for SCSI CDROM)' CONFIG_BLK_DEV_SR_VENDOR
       int  'Maximum number of CDROM devices that can be loaded as modules' CONFIG_SR_EXTRA_DEVS 2
@@ -501,7 +501,7 @@
 bool 'Watchdog Timer Support'	CONFIG_WATCHDOG
 if [ "$CONFIG_WATCHDOG" != "n" ]; then
    bool '  Disable watchdog shutdown on close' CONFIG_WATCHDOG_NOWAYOUT
-   bool '  Software Watchdog' CONFIG_SOFT_WATCHDOG
+   bool '  Software watchdog' CONFIG_SOFT_WATCHDOG
 fi
 if [ "$CONFIG_ATARI" = "y" ]; then
    bool 'Enhanced Real Time Clock Support' CONFIG_RTC
diff -Nru a/arch/m68k/kernel/sys_m68k.c b/arch/m68k/kernel/sys_m68k.c
--- a/arch/m68k/kernel/sys_m68k.c	Thu Jun 20 15:54:00 2002
+++ b/arch/m68k/kernel/sys_m68k.c	Thu Jun 20 15:54:00 2002
@@ -676,13 +676,3 @@
 {
 	return PAGE_SIZE;
 }
-
-/*
- * Old cruft
- */
-asmlinkage int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
diff -Nru a/arch/m68k/kernel/traps.c b/arch/m68k/kernel/traps.c
--- a/arch/m68k/kernel/traps.c	Thu Jun 20 15:54:01 2002
+++ b/arch/m68k/kernel/traps.c	Thu Jun 20 15:54:01 2002
@@ -815,7 +815,7 @@
 }
 
 
-int kstack_depth_to_print = 48;
+static int kstack_depth_to_print = 48;
 extern struct module kernel_module;
 
 static inline int kernel_text_address(unsigned long addr)
diff -Nru a/arch/mips/config.in b/arch/mips/config.in
--- a/arch/mips/config.in	Thu Jun 20 15:54:01 2002
+++ b/arch/mips/config.in	Thu Jun 20 15:54:01 2002
@@ -50,7 +50,7 @@
        if [ "$CONFIG_QTRONIX_KEYBOARD" = "y" ]; then
 	   define_bool CONFIG_IT8172_CIR y
        else
-           bool '    Enable PS2 Keyboard Support ' CONFIG_PC_KEYB
+           bool '    Enable PS2 Keyboard Support' CONFIG_PC_KEYB
        fi
        bool '    Enable Smart Card Reader 0 Support ' CONFIG_IT8172_SCR0
        bool '    Enable Smart Card Reader 1 Support ' CONFIG_IT8172_SCR1
@@ -444,7 +444,7 @@
 	 define_bool CONFIG_FONT_8x16 y
       fi
    fi
-   bool 'PS/2 mouse support' CONFIG_PSMOUSE
+   bool 'PS/2 mouse support (aka "auxiliary device")' CONFIG_PSMOUSE
    if [ "$CONFIG_PSMOUSE" != "n" ]; then
       define_bool CONFIG_MOUSE y
    fi
diff -Nru a/arch/mips/kernel/sysmips.c b/arch/mips/kernel/sysmips.c
--- a/arch/mips/kernel/sysmips.c	Thu Jun 20 15:54:00 2002
+++ b/arch/mips/kernel/sysmips.c	Thu Jun 20 15:54:00 2002
@@ -156,10 +156,3 @@
 {
 	return -ENOSYS;
 }
-
-asmlinkage int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
diff -Nru a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
--- a/arch/mips/kernel/traps.c	Thu Jun 20 15:54:01 2002
+++ b/arch/mips/kernel/traps.c	Thu Jun 20 15:54:01 2002
@@ -69,8 +69,6 @@
 void (*ibe_board_handler)(struct pt_regs *regs);
 void (*dbe_board_handler)(struct pt_regs *regs);
 
-int kstack_depth_to_print = 24;
-
 /*
  * These constant is for searching for possible module text segments.
  * MODULE_RANGE is a guess of how much space is likely to be vmalloced.
diff -Nru a/arch/mips64/config.in b/arch/mips64/config.in
--- a/arch/mips64/config.in	Thu Jun 20 15:54:00 2002
+++ b/arch/mips64/config.in	Thu Jun 20 15:54:00 2002
@@ -10,12 +10,12 @@
 comment 'Machine selection'
 choice 'Machine type'						\
 	"SGI-IP22,Indy/Indigo2 CONFIG_SGI_IP22			\
-	 SGI-IP27,Origin200/2000 CONFIG_SGI_IP27 SGI-IP27,Origin200/2000"
+	 SGI-IP27,Origin200/2000 CONFIG_SGI_IP27" SGI-IP27,Origin200/2000
 
 if [ "$CONFIG_SGI_IP27" = "y" ]; then
    bool '  IP27 N-Mode' CONFIG_SGI_SN0_N_MODE
    bool '  Discontiguous Memory Support' CONFIG_DISCONTIGMEM
-   bool '  NUMA support' CONFIG_NUMA
+   bool '  NUMA Support' CONFIG_NUMA
    bool '  Mapped kernel support' CONFIG_MAPPED_KERNEL
    bool '  Kernel text replication support' CONFIG_REPLICATE_KTEXT
    bool '  Exception handler replication support' CONFIG_REPLICATE_EXHANDLERS
@@ -122,8 +122,6 @@
 endmenu
 
 source drivers/pci/Config.in
-
-endmenu
 
 source drivers/mtd/Config.in
 
diff -Nru a/arch/mips64/kernel/syscall.c b/arch/mips64/kernel/syscall.c
--- a/arch/mips64/kernel/syscall.c	Thu Jun 20 15:54:01 2002
+++ b/arch/mips64/kernel/syscall.c	Thu Jun 20 15:54:01 2002
@@ -275,10 +275,3 @@
 {
 	do_exit(SIGSEGV);
 }
-
-asmlinkage int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
diff -Nru a/arch/mips64/kernel/traps.c b/arch/mips64/kernel/traps.c
--- a/arch/mips64/kernel/traps.c	Thu Jun 20 15:54:01 2002
+++ b/arch/mips64/kernel/traps.c	Thu Jun 20 15:54:01 2002
@@ -51,8 +51,6 @@
 char vce_available = 0;
 char mips4_available = 0;
 
-int kstack_depth_to_print = 24;
-
 /*
  * These constant is for searching for possible module text segments.
  * MODULE_RANGE is a guess of how much space is likely to be vmalloced.
diff -Nru a/arch/parisc/config.in b/arch/parisc/config.in
--- a/arch/parisc/config.in	Thu Jun 20 15:54:01 2002
+++ b/arch/parisc/config.in	Thu Jun 20 15:54:01 2002
@@ -27,7 +27,7 @@
 bool 'U2/Uturn I/O MMU' CONFIG_IOMMU_CCIO y
 bool 'LASI I/O support' CONFIG_GSC_LASI y
 
-bool 'PCI bus support' CONFIG_PCI y
+bool 'PCI support' CONFIG_PCI y
 
 if [ "$CONFIG_PCI" = "y" ]; then
 	bool 'GSCtoPCI/DINO PCI support' CONFIG_GSC_DINO y
@@ -49,7 +49,7 @@
 comment 'Loadable module support'
 bool 'Enable loadable module support' CONFIG_MODULES
 if [ "$CONFIG_MODULES" = "y" ]; then
-  bool 'Set version information on all symbols for modules' CONFIG_MODVERSIONS
+  bool 'Set version information on all module symbols' CONFIG_MODVERSIONS
   bool 'Kernel module loader' CONFIG_KMOD
 fi
 endmenu
diff -Nru a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c
--- a/arch/parisc/kernel/sys_parisc.c	Thu Jun 20 15:54:01 2002
+++ b/arch/parisc/kernel/sys_parisc.c	Thu Jun 20 15:54:01 2002
@@ -37,13 +37,6 @@
 	return error;
 }
 
-int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
 int sys_mmap(unsigned long addr, unsigned long len,
 		unsigned long prot, unsigned long flags, unsigned long fd,
 		unsigned long offset)
diff -Nru a/arch/parisc/kernel/traps.c b/arch/parisc/kernel/traps.c
--- a/arch/parisc/kernel/traps.c	Thu Jun 20 15:54:01 2002
+++ b/arch/parisc/kernel/traps.c	Thu Jun 20 15:54:01 2002
@@ -58,8 +58,6 @@
 #define VMALLOC_OFFSET (8*1024*1024)
 #define MODULE_RANGE (8*1024*1024)
 
-int kstack_depth_to_print = 24;
-
 static void printbinary(unsigned long x, int nbits)
 {
 	unsigned long mask = 1UL << (nbits - 1);
diff -Nru a/arch/ppc/8260_io/Config.in b/arch/ppc/8260_io/Config.in
--- a/arch/ppc/8260_io/Config.in	Thu Jun 20 15:54:00 2002
+++ b/arch/ppc/8260_io/Config.in	Thu Jun 20 15:54:00 2002
@@ -5,8 +5,6 @@
 comment 'MPC8260 Communication Options'
 bool 'Enable SCC Console' CONFIG_SCC_CONSOLE
 if [ "$CONFIG_NET_ETHERNET" = "y" ]; then
-  mainmenu_option next_comment
-  comment 'MPC8260 Communication Options'
   bool 'CPM SCC Ethernet' CONFIG_SCC_ENET
   if [ "$CONFIG_SCC_ENET" = "y" ]; then
   bool 'Ethernet on SCC1' CONFIG_SCC1_ENET
diff -Nru a/arch/ppc/config.in b/arch/ppc/config.in
--- a/arch/ppc/config.in	Thu Jun 20 15:53:59 2002
+++ b/arch/ppc/config.in	Thu Jun 20 15:53:59 2002
@@ -244,7 +244,7 @@
    fi
 
    bool 'Blue Logic DMA' CONFIG_405_DMA
-   dep_bool 'Power Management support (experimental)' CONFIG_PM $CONFIG_EXPERIMENTAL
+   dep_bool 'Power Management support (EXPERIMENTAL)' CONFIG_PM $CONFIG_EXPERIMENTAL
 
    choice 'TTYS0 device and default console'	\
 	"UART0  CONFIG_UART0_TTYS0		\
@@ -311,7 +311,7 @@
 define_bool CONFIG_MCA n
 
 if [ "$CONFIG_4xx" = "y" -o "$CONFIG_8260" = "y" ]; then
-   bool "Enable PCI" CONFIG_PCI
+   bool "PCI support" CONFIG_PCI
    bool 'PC PS/2 style Keyboard' CONFIG_PC_KEYBOARD
 else
    if [ "$CONFIG_8xx" = "y" ]; then
diff -Nru a/arch/ppc/kernel/syscalls.c b/arch/ppc/kernel/syscalls.c
--- a/arch/ppc/kernel/syscalls.c	Thu Jun 20 15:54:01 2002
+++ b/arch/ppc/kernel/syscalls.c	Thu Jun 20 15:54:01 2002
@@ -257,13 +257,6 @@
 	return sys_select(n, inp, outp, exp, tvp);
 }
 
-int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
 int sys_uname(struct old_utsname * name)
 {
 	int err = -EFAULT;
diff -Nru a/arch/ppc64/config.in b/arch/ppc64/config.in
--- a/arch/ppc64/config.in	Thu Jun 20 15:54:00 2002
+++ b/arch/ppc64/config.in	Thu Jun 20 15:54:00 2002
@@ -47,9 +47,9 @@
    define_bool CONFIG_KCORE_ELF y
 fi
 
-bool 'Kernel Support for 64 bit ELF binaries' CONFIG_BINFMT_ELF
+bool 'Kernel support for 64-bit ELF binaries' CONFIG_BINFMT_ELF
 
-tristate 'Kernel support for 32 bit binaries' CONFIG_BINFMT_ELF32
+tristate 'Kernel support for 32-bit ELF binaries' CONFIG_BINFMT_ELF32
 
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 
diff -Nru a/arch/ppc64/kernel/syscalls.c b/arch/ppc64/kernel/syscalls.c
--- a/arch/ppc64/kernel/syscalls.c	Thu Jun 20 15:54:00 2002
+++ b/arch/ppc64/kernel/syscalls.c	Thu Jun 20 15:54:00 2002
@@ -227,17 +227,6 @@
 	return ret;
 }
 
-asmlinkage int sys_pause(void)
-{
-	
-	PPCDBG(PPCDBG_SYS64X, "sys_pause - entered - pid=%ld current=%lx comm=%s \n", current->pid, current, current->comm);
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	
-	PPCDBG(PPCDBG_SYS64X, "sys_pause - exited - pid=%ld current=%lx comm=%s \n", current->pid, current, current->comm);
-	return -ERESTARTNOHAND;
-}
-
 static int __init set_fakeppc(char *str)
 {
 	if (*str)
diff -Nru a/arch/s390/kernel/sys_s390.c b/arch/s390/kernel/sys_s390.c
--- a/arch/s390/kernel/sys_s390.c	Thu Jun 20 15:54:00 2002
+++ b/arch/s390/kernel/sys_s390.c	Thu Jun 20 15:54:00 2002
@@ -241,13 +241,6 @@
 	return error;
 }
 
-asmlinkage int sys_pause(void)
-{
-	set_current_state(TASK_INTERRUPTIBLE);
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
 asmlinkage int sys_ioperm(unsigned long from, unsigned long num, int on)
 {
   return -ENOSYS;
diff -Nru a/arch/s390/kernel/traps.c b/arch/s390/kernel/traps.c
--- a/arch/s390/kernel/traps.c	Thu Jun 20 15:54:00 2002
+++ b/arch/s390/kernel/traps.c	Thu Jun 20 15:54:00 2002
@@ -61,7 +61,7 @@
 static ext_int_info_t ext_int_pfault;
 #endif
 
-int kstack_depth_to_print = 12;
+static int kstack_depth_to_print = 12;
 
 /*
  * If the address is either in the .text section of the
diff -Nru a/arch/s390x/kernel/sys_s390.c b/arch/s390x/kernel/sys_s390.c
--- a/arch/s390x/kernel/sys_s390.c	Thu Jun 20 15:54:01 2002
+++ b/arch/s390x/kernel/sys_s390.c	Thu Jun 20 15:54:01 2002
@@ -197,13 +197,6 @@
 	return err?-EFAULT:0;
 }
 
-asmlinkage int sys_pause(void)
-{
-	set_current_state(TASK_INTERRUPTIBLE);
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
 extern asmlinkage int sys_newuname(struct new_utsname * name);
 
 asmlinkage int s390x_newuname(struct new_utsname * name)
diff -Nru a/arch/s390x/kernel/traps.c b/arch/s390x/kernel/traps.c
--- a/arch/s390x/kernel/traps.c	Thu Jun 20 15:54:01 2002
+++ b/arch/s390x/kernel/traps.c	Thu Jun 20 15:54:01 2002
@@ -63,7 +63,7 @@
 static ext_int_info_t ext_int_pfault;
 #endif
 
-int kstack_depth_to_print = 20;
+static int kstack_depth_to_print = 20;
 
 /*
  * If the address is either in the .text section of the
diff -Nru a/arch/sh/kernel/sys_sh.c b/arch/sh/kernel/sys_sh.c
--- a/arch/sh/kernel/sys_sh.c	Thu Jun 20 15:54:01 2002
+++ b/arch/sh/kernel/sys_sh.c	Thu Jun 20 15:54:01 2002
@@ -231,10 +231,3 @@
 	up_read(&uts_sem);
 	return err?-EFAULT:0;
 }
-
-asmlinkage int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
diff -Nru a/arch/sparc/config.in b/arch/sparc/config.in
--- a/arch/sparc/config.in	Thu Jun 20 15:54:00 2002
+++ b/arch/sparc/config.in	Thu Jun 20 15:54:00 2002
@@ -180,7 +180,7 @@
           tristate '  Ethertap network tap (OBSOLETE)' CONFIG_ETHERTAP
         fi
       fi
-      tristate '  PPP (point-to-point) support' CONFIG_PPP
+      tristate '  PPP (point-to-point protocol) support' CONFIG_PPP
       if [ ! "$CONFIG_PPP" = "n" ]; then
         dep_tristate '  PPP support for async serial ports' CONFIG_PPP_ASYNC $CONFIG_PPP
         dep_tristate '  PPP support for sync tty ports' CONFIG_PPP_SYNC_TTY $CONFIG_PPP
diff -Nru a/arch/sparc/kernel/sys_sparc.c b/arch/sparc/kernel/sys_sparc.c
--- a/arch/sparc/kernel/sys_sparc.c	Thu Jun 20 15:54:00 2002
+++ b/arch/sparc/kernel/sys_sparc.c	Thu Jun 20 15:54:00 2002
@@ -442,14 +442,6 @@
 	return ret;
 }
 
-/* Just in case some old old binary calls this. */
-asmlinkage int sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
 asmlinkage int sys_getdomainname(char *name, int len)
 {
  	int nlen;
diff -Nru a/arch/sparc64/config.in b/arch/sparc64/config.in
--- a/arch/sparc64/config.in	Thu Jun 20 15:54:00 2002
+++ b/arch/sparc64/config.in	Thu Jun 20 15:54:00 2002
@@ -15,7 +15,7 @@
 define_bool CONFIG_VT_CONSOLE y
 
 bool 'Symmetric multi-processing support' CONFIG_SMP
-bool 'Preemptible kernel' CONFIG_PREEMPT
+bool 'Preemptible Kernel' CONFIG_PREEMPT
 
 # Identify this as a Sparc64 build
 define_bool CONFIG_SPARC64 y
diff -Nru a/arch/sparc64/kernel/cpu.c b/arch/sparc64/kernel/cpu.c
--- a/arch/sparc64/kernel/cpu.c	Thu Jun 20 15:54:01 2002
+++ b/arch/sparc64/kernel/cpu.c	Thu Jun 20 15:54:01 2002
@@ -26,9 +26,6 @@
   char* fp_name;
 };
 
-/* In order to get the fpu type correct, you need to take the IDPROM's
- * machine type value into consideration too.  I will fix this.
- */
 struct cpu_fp_info linux_sparc_fpu[] = {
   { 0x17, 0x10, 0, "UltraSparc I integrated FPU"},
   { 0x22, 0x10, 0, "UltraSparc II integrated FPU"},
@@ -51,13 +48,8 @@
 
 #define NSPARCCHIPS  (sizeof(linux_sparc_chips)/sizeof(struct cpu_iu_info))
 
-#ifdef CONFIG_SMP
-char *sparc_cpu_type[64] = { "cpu-oops", "cpu-oops1", "cpu-oops2", "cpu-oops3" };
-char *sparc_fpu_type[64] = { "fpu-oops", "fpu-oops1", "fpu-oops2", "fpu-oops3" };
-#else
-char *sparc_cpu_type[64] = { "cpu-oops", };
-char *sparc_fpu_type[64] = { "fpu-oops", };
-#endif
+char *sparc_cpu_type[NR_CPUS] = { "cpu-oops", };
+char *sparc_fpu_type[NR_CPUS] = { "fpu-oops", };
 
 unsigned int fsr_storage;
 
@@ -72,39 +64,47 @@
 
 	fprs = fprs_read ();
 	fprs_write (FPRS_FEF);
-	__asm__ __volatile__ ("rdpr %%ver, %0; stx %%fsr, [%1]" : "=&r" (ver) : "r" (&fpu_vers));
+	__asm__ __volatile__ ("rdpr %%ver, %0; stx %%fsr, [%1]"
+			      : "=&r" (ver)
+			      : "r" (&fpu_vers));
 	fprs_write (fprs);
 	
-	manuf = ((ver >> 48)&0xffff);
-	impl = ((ver >> 32)&0xffff);
+	manuf = ((ver >> 48) & 0xffff);
+	impl = ((ver >> 32) & 0xffff);
 
-	fpu_vers = ((fpu_vers>>17)&0x7);
+	fpu_vers = ((fpu_vers >> 17) & 0x7);
 
-	for(i = 0; i<NSPARCCHIPS; i++) {
-		if(linux_sparc_chips[i].manuf == manuf)
-			if(linux_sparc_chips[i].impl == impl) {
-				sparc_cpu_type[cpuid] = linux_sparc_chips[i].cpu_name;
+	for (i = 0; i < NSPARCCHIPS; i++) {
+		if (linux_sparc_chips[i].manuf == manuf) {
+			if (linux_sparc_chips[i].impl == impl) {
+				sparc_cpu_type[cpuid] =
+					linux_sparc_chips[i].cpu_name;
 				break;
 			}
+		}
 	}
 
-	if(i==NSPARCCHIPS) {
-		printk("DEBUG: manuf = 0x%x   impl = 0x%x\n", manuf, 
-			    impl);
+	if (i == NSPARCCHIPS) {
+		printk("DEBUG: manuf = 0x%x   impl = 0x%x\n",
+		       manuf, impl);
 		sparc_cpu_type[cpuid] = "Unknown CPU";
 	}
 
-	for(i = 0; i<NSPARCFPU; i++) {
-		if(linux_sparc_fpu[i].manuf == manuf && linux_sparc_fpu[i].impl == impl)
-			if(linux_sparc_fpu[i].fpu_vers == fpu_vers) {
-				sparc_fpu_type[cpuid] = linux_sparc_fpu[i].fp_name;
+	for (i = 0; i < NSPARCFPU; i++) {
+		if (linux_sparc_fpu[i].manuf == manuf &&
+		    linux_sparc_fpu[i].impl == impl) {
+			if (linux_sparc_fpu[i].fpu_vers == fpu_vers) {
+				sparc_fpu_type[cpuid] =
+					linux_sparc_fpu[i].fp_name;
 				break;
 			}
+		}
 	}
 
-	if(i == NSPARCFPU) {
-		printk("DEBUG: manuf = 0x%x  impl = 0x%x fsr.vers = 0x%x\n", manuf, impl,
-			    (unsigned)fpu_vers);
+	if (i == NSPARCFPU) {
+		printk("DEBUG: manuf = 0x%x  impl = 0x%x fsr.vers = 0x%x\n",
+		       manuf, impl,
+		       (unsigned int) fpu_vers);
 		sparc_fpu_type[cpuid] = "Unknown FPU";
 	}
 }
diff -Nru a/arch/sparc64/kernel/devices.c b/arch/sparc64/kernel/devices.c
--- a/arch/sparc64/kernel/devices.c	Thu Jun 20 15:54:00 2002
+++ b/arch/sparc64/kernel/devices.c	Thu Jun 20 15:54:00 2002
@@ -17,8 +17,8 @@
 #include <asm/smp.h>
 #include <asm/spitfire.h>
 
-struct prom_cpuinfo linux_cpus[64] __initdata = { { 0 } };
-unsigned prom_cpu_nodes[64];
+struct prom_cpuinfo linux_cpus[NR_CPUS] __initdata = { { 0 } };
+unsigned prom_cpu_nodes[NR_CPUS];
 int linux_num_cpus = 0;
 
 extern void cpu_probe(void);
diff -Nru a/arch/sparc64/kernel/irq.c b/arch/sparc64/kernel/irq.c
--- a/arch/sparc64/kernel/irq.c	Thu Jun 20 15:54:00 2002
+++ b/arch/sparc64/kernel/irq.c	Thu Jun 20 15:54:00 2002
@@ -122,9 +122,12 @@
 #ifndef CONFIG_SMP
 		seq_printf(p, "%10u ", kstat_irqs(i));
 #else
-		for (j = 0; j < smp_num_cpus; j++)
+		for (j = 0; j < NR_CPUS; j++) {
+			if (!cpu_online(j))
+				continue;
 			seq_printf(p, "%10u ",
-				   kstat.irqs[cpu_logical_map(j)][i]);
+				   kstat.irqs[j][i]);
+		}
 #endif
 		seq_printf(p, " %s:%lx", action->name,
 			   get_ino_in_irqaction(action));
@@ -574,12 +577,18 @@
 
 	printk("\n%s, CPU %d:\n", str, cpu);
 	printk("irq:  %d [ ", irqs_running());
-	for (i = 0; i < smp_num_cpus; i++)
+	for (i = 0; i < NR_CPUS; i++) {
+		if (!cpu_online(i))
+			continue;
 		printk("%u ", __brlock_array[i][BR_GLOBALIRQ_LOCK]);
+	}
 	printk("]\nbh:   %d [ ",
 	       (spin_is_locked(&global_bh_lock) ? 1 : 0));
-	for (i = 0; i < smp_num_cpus; i++)
+	for (i = 0; i < NR_CPUS; i++) {
+		if (!cpu_online(i))
+			continue;
 		printk("%u ", local_bh_count(i));
+	}
 	printk("]\n");
 }
 
@@ -743,8 +752,9 @@
 	unsigned long cpu_mask = get_smpaff_in_irqaction(ap);
 	unsigned int buddy, ticks;
 
+	cpu_mask &= cpu_online_map;
 	if (cpu_mask == 0)
-		cpu_mask = ~0UL;
+		cpu_mask = cpu_online_map;
 
 	if (this_is_starfire != 0 ||
 	    bp->pil >= 10 || current->pid == 0)
@@ -753,28 +763,23 @@
 	/* 'cpu' is the MID (ie. UPAID), calculate the MID
 	 * of our buddy.
 	 */
-	buddy = cpu_number_map(cpu) + 1;
-	if (buddy >= NR_CPUS ||
-	    cpu_logical_map(buddy) == -1)
+	buddy = cpu + 1;
+	if (buddy >= NR_CPUS)
 		buddy = 0;
 
 	ticks = 0;
 	while ((cpu_mask & (1UL << buddy)) == 0) {
-		buddy++;
-		if (buddy >= NR_CPUS ||
-		    cpu_logical_map(buddy) == -1)
-			buddy = cpu_logical_map(0);
+		if (++buddy >= NR_CPUS)
+			buddy = 0;
 		if (++ticks > NR_CPUS) {
 			put_smpaff_in_irqaction(ap, 0);
 			goto out;
 		}
 	}
 
-	if (buddy == cpu_number_map(cpu))
+	if (buddy == cpu)
 		goto out;
 
-	buddy = cpu_logical_map(buddy);
-
 	/* Voo-doo programming. */
 	if (cpu_data[buddy].idle_volume < FORWARD_VOLUME)
 		goto out;
@@ -1140,22 +1145,28 @@
 	unsigned long imap = bucket->imap;
 	unsigned int tid;
 
+	while (!cpu_online(goal_cpu)) {
+		if (++goal_cpu >= NR_CPUS)
+			goal_cpu = 0;
+	}
+
 	if (tlb_type == cheetah) {
-		tid = __cpu_logical_map[goal_cpu] << 26;
+		tid = goal_cpu << 26;
 		tid &= IMAP_AID_SAFARI;
 	} else if (this_is_starfire == 0) {
-		tid = __cpu_logical_map[goal_cpu] << 26;
+		tid = goal_cpu << 26;
 		tid &= IMAP_TID_UPA;
 	} else {
-		tid = (starfire_translate(imap, __cpu_logical_map[goal_cpu]) << 26);
+		tid = (starfire_translate(imap, goal_cpu) << 26);
 		tid &= IMAP_TID_UPA;
 	}
 	upa_writel(tid | IMAP_VALID, imap);
 
-	goal_cpu++;
-	if(goal_cpu >= NR_CPUS ||
-	   __cpu_logical_map[goal_cpu] == -1)
-		goal_cpu = 0;
+	while (!cpu_online(goal_cpu)) {
+		if (++goal_cpu >= NR_CPUS)
+			goal_cpu = 0;
+	}
+
 	return goal_cpu;
 }
 
@@ -1326,38 +1337,6 @@
 	return 0;
 }
 
-static unsigned long hw_to_logical(unsigned long mask)
-{
-	unsigned long new_mask = 0UL;
-	int i;
-
-	for (i = 0; i < NR_CPUS; i++) {
-		if (mask & (1UL << i)) {
-			int logical = cpu_number_map(i);
-
-			new_mask |= (1UL << logical);
-		}
-	}
-
-	return new_mask;
-}
-
-static unsigned long logical_to_hw(unsigned long mask)
-{
-	unsigned long new_mask = 0UL;
-	int i;
-
-	for (i = 0; i < NR_CPUS; i++) {
-		if (mask & (1UL << i)) {
-			int hw = cpu_logical_map(i);
-
-			new_mask |= (1UL << hw);
-		}
-	}
-
-	return new_mask;
-}
-
 static int irq_affinity_read_proc (char *page, char **start, off_t off,
 			int count, int *eof, void *data)
 {
@@ -1365,8 +1344,6 @@
 	struct irqaction *ap = bp->irq_info;
 	unsigned long mask = get_smpaff_in_irqaction(ap);
 
-	mask = logical_to_hw(mask);
-
 	if (count < HEX_DIGITS+1)
 		return -EINVAL;
 	return sprintf (page, "%016lx\n", mask == 0 ? ~0UL : mask);
@@ -1375,14 +1352,11 @@
 static inline void set_intr_affinity(int irq, unsigned long hw_aff)
 {
 	struct ino_bucket *bp = ivector_table + irq;
-	unsigned long aff = hw_to_logical(hw_aff);
 
-	/*
-	 * Users specify affinity in terms of cpu ids, which is what
-	 * is displayed via /proc/cpuinfo. As soon as we do this, 
-	 * handler_irq() might see and take action.
+	/* Users specify affinity in terms of hw cpu ids.
+	 * As soon as we do this, handler_irq() might see and take action.
 	 */
-	put_smpaff_in_irqaction((struct irqaction *)bp->irq_info, aff);
+	put_smpaff_in_irqaction((struct irqaction *)bp->irq_info, hw_aff);
 
 	/* Migration is simply done by the next cpu to service this
 	 * interrupt.
@@ -1393,7 +1367,7 @@
 					unsigned long count, void *data)
 {
 	int irq = (long) data, full_count = count, err;
-	unsigned long new_value;
+	unsigned long new_value, i;
 
 	err = parse_hex_value(buffer, count, &new_value);
 
@@ -1402,7 +1376,12 @@
 	 * way to make the system unusable accidentally :-) At least
 	 * one online CPU still has to be targeted.
 	 */
-	new_value &= cpu_online_map;
+	for (i = 0; i < NR_CPUS; i++) {
+		if ((new_value & (1UL << i)) != 0 &&
+		    !cpu_online(i))
+			new_value &= ~(1UL << i);
+	}
+
 	if (!new_value)
 		return -EINVAL;
 
diff -Nru a/arch/sparc64/kernel/setup.c b/arch/sparc64/kernel/setup.c
--- a/arch/sparc64/kernel/setup.c	Thu Jun 20 15:54:00 2002
+++ b/arch/sparc64/kernel/setup.c	Thu Jun 20 15:54:00 2002
@@ -649,7 +649,7 @@
 		   (prom_prev >> 8) & 0xff,
 		   prom_prev & 0xff,
 		   linux_num_cpus,
-		   smp_num_cpus
+		   num_online_cpus()
 #ifndef CONFIG_SMP
 		   , loops_per_jiffy/(500000/HZ),
 		   (loops_per_jiffy/(5000/HZ)) % 100,
diff -Nru a/arch/sparc64/kernel/smp.c b/arch/sparc64/kernel/smp.c
--- a/arch/sparc64/kernel/smp.c	Thu Jun 20 15:53:59 2002
+++ b/arch/sparc64/kernel/smp.c	Thu Jun 20 15:53:59 2002
@@ -40,13 +40,9 @@
 
 extern int linux_num_cpus;
 extern void calibrate_delay(void);
-extern unsigned prom_cpu_nodes[];
 
 cpuinfo_sparc cpu_data[NR_CPUS];
 
-volatile int __cpu_number_map[NR_CPUS]  __attribute__ ((aligned (SMP_CACHE_BYTES)));
-volatile int __cpu_logical_map[NR_CPUS] __attribute__ ((aligned (SMP_CACHE_BYTES)));
-
 /* Please don't make this stuff initdata!!!  --DaveM */
 static unsigned char boot_cpu_id;
 static int smp_activated;
@@ -55,8 +51,8 @@
 spinlock_t kernel_flag __cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
 
 volatile int smp_processors_ready = 0;
-unsigned long cpu_present_map = 0;
-int smp_num_cpus = 1;
+atomic_t sparc64_num_cpus_online = ATOMIC_INIT(0);
+unsigned long cpu_online_map = 0;
 int smp_threads_ready = 0;
 
 void __init smp_setup(char *str, int *ints)
@@ -79,7 +75,7 @@
 	
 	seq_printf(m, "State:\n");
 	for (i = 0; i < NR_CPUS; i++) {
-		if (cpu_present_map & (1UL << i))
+		if (cpu_online(i))
 			seq_printf(m,
 				   "CPU%d:\t\tonline\n", i);
 	}
@@ -90,7 +86,7 @@
 	int i;
 	
 	for (i = 0; i < NR_CPUS; i++)
-		if (cpu_present_map & (1UL << i))
+		if (cpu_online(i))
 			seq_printf(m,
 				   "Cpu%dBogo\t: %lu.%02lu\n"
 				   "Cpu%dClkTck\t: %016lx\n",
@@ -230,7 +226,7 @@
 	panic("SMP bolixed\n");
 }
 
-extern struct prom_cpuinfo linux_cpus[64];
+extern struct prom_cpuinfo linux_cpus[NR_CPUS];
 
 extern unsigned long sparc64_cpu_startup;
 
@@ -261,9 +257,11 @@
 
 		if ((cpucount + 1) == max_cpus)
 			goto ignorecpu;
-		if (cpu_present_map & (1UL << i)) {
-			unsigned long entry = (unsigned long)(&sparc64_cpu_startup);
-			unsigned long cookie = (unsigned long)(&cpu_new_thread);
+		if (cpu_online(i)) {
+			unsigned long entry =
+				(unsigned long)(&sparc64_cpu_startup);
+			unsigned long cookie =
+				(unsigned long)(&cpu_new_thread);
 			struct task_struct *p;
 			int timeout;
 			int no;
@@ -291,8 +289,7 @@
 				udelay(100);
 			}
 			if (callin_flag) {
-				__cpu_number_map[i] = cpucount;
-				__cpu_logical_map[cpucount] = i;
+				atomic_inc(&sparc64_num_cpus_online);
 				prom_cpu_nodes[i] = linux_cpus[no].prom_node;
 				prom_printf("OK\n");
 			} else {
@@ -300,31 +297,33 @@
 				printk("Processor %d is stuck.\n", i);
 				prom_printf("FAILED\n");
 			}
-		}
-		if (!callin_flag) {
+			if (!callin_flag) {
 ignorecpu:
-			cpu_present_map &= ~(1UL << i);
-			__cpu_number_map[i] = -1;
+				clear_bit(i, &cpu_online_map);
+			}
+
 		}
 	}
 	cpu_new_thread = NULL;
 	if (cpucount == 0) {
 		if (max_cpus != 1)
 			printk("Error: only one processor found.\n");
-		cpu_present_map = (1UL << smp_processor_id());
+		memset(&cpu_online_map, 0, sizeof(cpu_online_map));
+		set_bit(smp_processor_id(), &cpu_online_map);
+		atomic_set(&sparc64_num_cpus_online, 1);
 	} else {
 		unsigned long bogosum = 0;
 
 		for (i = 0; i < NR_CPUS; i++) {
-			if (cpu_present_map & (1UL << i))
+			if (cpu_online(i))
 				bogosum += cpu_data[i].udelay_val;
 		}
-		printk("Total of %d processors activated (%lu.%02lu BogoMIPS).\n",
+		printk("Total of %d processors activated "
+		       "(%lu.%02lu BogoMIPS).\n",
 		       cpucount + 1,
 		       bogosum/(500000/HZ),
 		       (bogosum/(5000/HZ))%100);
 		smp_activated = 1;
-		smp_num_cpus = cpucount + 1;
 	}
 
 	/* We want to run this with all the other cpus spinning
@@ -372,8 +371,9 @@
 	membar	#Sync"
 	: "=r" (tmp)
 	: "r" (pstate), "i" (PSTATE_IE), "i" (ASI_INTR_W),
-	  "r" (data0), "r" (data1), "r" (data2), "r" (target), "r" (0x10), "0" (tmp)
-       : "g1");
+	  "r" (data0), "r" (data1), "r" (data2), "r" (target),
+	  "r" (0x10), "0" (tmp)
+        : "g1");
 
 	/* NOTE: PSTATE_IE is still clear. */
 	stuck = 100000;
@@ -403,15 +403,16 @@
 
 static __inline__ void spitfire_xcall_deliver(u64 data0, u64 data1, u64 data2, unsigned long mask)
 {
-	int ncpus = smp_num_cpus - 1;
-	int i;
 	u64 pstate;
+	int i;
 
 	__asm__ __volatile__("rdpr %%pstate, %0" : "=r" (pstate));
-	for (i = 0; (i < NR_CPUS) && ncpus; i++) {
+	for (i = 0; i < NR_CPUS; i++) {
 		if (mask & (1UL << i)) {
 			spitfire_xcall_helper(data0, data1, data2, pstate, i);
-			ncpus--;
+			mask &= ~(1UL << i);
+			if (!mask)
+				break;
 		}
 	}
 }
@@ -449,18 +450,22 @@
 
 	nack_busy_id = 0;
 	{
-		int i, ncpus = smp_num_cpus - 1;
+		unsigned long work_mask = mask;
+		int i;
 
-		for (i = 0; (i < NR_CPUS) && ncpus; i++) {
-			if (mask & (1UL << i)) {
+		for (i = 0; i < NR_CPUS; i++) {
+			if (work_mask & (1UL << i)) {
 				u64 target = (i << 14) | 0x70;
 
 				target |= (nack_busy_id++ << 24);
-				__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
-						     "membar	#Sync\n\t"
-						     : /* no outputs */
-						     : "r" (target), "i" (ASI_INTR_W));
-				ncpus--;
+				__asm__ __volatile__(
+					"stxa	%%g0, [%0] %1\n\t"
+					"membar	#Sync\n\t"
+					: /* no outputs */
+					: "r" (target), "i" (ASI_INTR_W));
+				work_mask &= ~(1UL << i);
+				if (!work_mask)
+					break;
 			}
 		}
 	}
@@ -494,6 +499,7 @@
 			printk("CPU[%d]: mondo stuckage result[%016lx]\n",
 			       smp_processor_id(), dispatch_stat);
 		} else {
+			unsigned long work_mask = mask;
 			int i, this_busy_nack = 0;
 
 			/* Delay some random time with interrupts enabled
@@ -505,10 +511,14 @@
 			 * NACK us.
 			 */
 			for (i = 0; i < NR_CPUS; i++) {
-				if (mask & (1UL << i)) {
-					if ((dispatch_stat & (0x2 << this_busy_nack)) == 0)
+				if (work_mask & (1UL << i)) {
+					if ((dispatch_stat &
+					     (0x2 << this_busy_nack)) == 0)
 						mask &= ~(1UL << i);
 					this_busy_nack += 2;
+					work_mask &= ~(1UL << i);
+					if (!work_mask)
+						break;
 				}
 			}
 
@@ -525,6 +535,7 @@
 	if (smp_processors_ready) {
 		u64 data0 = (((u64)ctx)<<32 | (((u64)func) & 0xffffffff));
 
+		mask &= cpu_online_map;
 		mask &= ~(1UL<<smp_processor_id());
 
 		if (tlb_type == spitfire)
@@ -538,7 +549,7 @@
 
 /* Send cross call to all processors except self. */
 #define smp_cross_call(func, ctx, data1, data2) \
-	smp_cross_call_masked(func, ctx, data1, data2, cpu_present_map)
+	smp_cross_call_masked(func, ctx, data1, data2, cpu_online_map)
 
 struct call_data_struct {
 	void (*func) (void *info);
@@ -560,7 +571,7 @@
 		      int nonatomic, int wait)
 {
 	struct call_data_struct data;
-	int cpus = smp_num_cpus - 1;
+	int cpus = num_online_cpus() - 1;
 	long timeout;
 
 	if (!cpus)
@@ -596,7 +607,7 @@
 out_timeout:
 	spin_unlock(&call_lock);
 	printk("XCALL: Remote cpus not responding, ncpus=%d finished=%d\n",
-	       smp_num_cpus - 1, atomic_read(&data.finished));
+	       num_online_cpus() - 1, atomic_read(&data.finished));
 	return 0;
 }
 
@@ -657,11 +668,12 @@
 #endif
 		if (cpu == smp_processor_id()) {
 			__local_flush_dcache_page(page);
-		} else if ((cpu_present_map & mask) != 0) {
+		} else if ((cpu_online_map & mask) != 0) {
 			u64 data0;
 
 			if (tlb_type == spitfire) {
-				data0 = ((u64)&xcall_flush_dcache_page_spitfire);
+				data0 =
+				  ((u64)&xcall_flush_dcache_page_spitfire);
 				if (page->mapping != NULL)
 					data0 |= ((u64)1 << 32);
 				spitfire_xcall_deliver(data0,
@@ -669,7 +681,8 @@
 						       (u64) page->virtual,
 						       mask);
 			} else {
-				data0 = ((u64)&xcall_flush_dcache_page_cheetah);
+				data0 =
+				  ((u64)&xcall_flush_dcache_page_cheetah);
 				cheetah_xcall_deliver(data0,
 						      __pa(page->virtual),
 						      0, mask);
@@ -684,7 +697,8 @@
 void flush_dcache_page_all(struct mm_struct *mm, struct page *page)
 {
 	if (smp_processors_ready) {
-		unsigned long mask = cpu_present_map & ~(1UL << smp_processor_id());
+		unsigned long mask =
+			cpu_online_map & ~(1UL << smp_processor_id());
 		u64 data0;
 
 #ifdef CONFIG_DEBUG_DCFLUSH
@@ -719,8 +733,9 @@
 	if (smp_processors_ready) {
 		unsigned long mask = 1UL << cpu;
 
-		if ((cpu_present_map & mask) != 0) {
-			u64 data0 = (((u64)&xcall_receive_signal) & 0xffffffff);
+		if ((cpu_online_map & mask) != 0) {
+			u64 data0 =
+			  (((u64)&xcall_receive_signal) & 0xffffffff);
 
 			if (tlb_type == spitfire)
 				spitfire_xcall_deliver(data0, 0, 0, mask);
@@ -848,7 +863,8 @@
 			      mm->cpu_vm_mask);
 
  local_flush_and_out:
-	__flush_tlb_range(ctx, start, SECONDARY_CONTEXT, end, PAGE_SIZE, (end-start));
+	__flush_tlb_range(ctx, start, SECONDARY_CONTEXT,
+			  end, PAGE_SIZE, (end-start));
 }
 
 void smp_flush_tlb_kernel_range(unsigned long start, unsigned long end)
@@ -870,31 +886,32 @@
 		int cpu = smp_processor_id();
 
 		page &= PAGE_MASK;
-		if (mm == current->active_mm && atomic_read(&mm->mm_users) == 1) {
+		if (mm == current->active_mm &&
+		    atomic_read(&mm->mm_users) == 1) {
 			/* By virtue of being the current address space, and
-			 * having the only reference to it, the following operation
-			 * is safe.
+			 * having the only reference to it, the following
+			 * operation is safe.
 			 *
-			 * It would not be a win to perform the xcall tlb flush in
-			 * this case, because even if we switch back to one of the
-			 * other processors in cpu_vm_mask it is almost certain that
-			 * all TLB entries for this context will be replaced by the
-			 * time that happens.
+			 * It would not be a win to perform the xcall tlb
+			 * flush in this case, because even if we switch back
+			 * to one of the other processors in cpu_vm_mask it
+			 * is almost certain that all TLB entries for this
+			 * context will be replaced by the time that happens.
 			 */
 			mm->cpu_vm_mask = (1UL << cpu);
 			goto local_flush_and_out;
 		} else {
 			/* By virtue of running under the mm->page_table_lock,
-			 * and mmu_context.h:switch_mm doing the same, the following
-			 * operation is safe.
+			 * and mmu_context.h:switch_mm doing the same, the
+			 * following operation is safe.
 			 */
 			if (mm->cpu_vm_mask == (1UL << cpu))
 				goto local_flush_and_out;
 		}
 
-		/* OK, we have to actually perform the cross call.  Most likely
-		 * this is a cloned mm or kswapd is kicking out pages for a task
-		 * which has run recently on another cpu.
+		/* OK, we have to actually perform the cross call.  Most
+		 * likely this is a cloned mm or kswapd is kicking out pages
+		 * for a task which has run recently on another cpu.
 		 */
 		smp_cross_call_masked(&xcall_flush_tlb_page,
 				      ctx, page, 0,
@@ -922,7 +939,7 @@
 
 		membar("#StoreStore | #LoadStore");
 		if (result == 1) {
-			int ncpus = smp_num_cpus;
+			int ncpus = num_online_cpus();
 
 #ifdef CAPTURE_DEBUG
 			printk("CPU[%d]: Sending penguins to jail...",
@@ -946,7 +963,8 @@
 	if (smp_processors_ready) {
 		if (atomic_dec_and_test(&smp_capture_depth)) {
 #ifdef CAPTURE_DEBUG
-			printk("CPU[%d]: Giving pardon to imprisoned penguins\n",
+			printk("CPU[%d]: Giving pardon to "
+			       "imprisoned penguins\n",
 			       smp_processor_id());
 #endif
 			penguins_are_doing_time = 0;
@@ -1027,7 +1045,8 @@
 
 	do {
 		if (!user)
-			sparc64_do_profile(regs->tpc, regs->u_regs[UREG_RETPC]);
+			sparc64_do_profile(regs->tpc,
+					   regs->u_regs[UREG_RETPC]);
 		if (!--prof_counter(cpu)) {
 			if (cpu == boot_cpu_id) {
 				irq_enter(cpu, 0);
@@ -1151,16 +1170,20 @@
 	
 	boot_cpu_id = hard_smp_processor_id();
 	current_tick_offset = timer_tick_offset;
-	cpu_present_map = 0;
-	for (i = 0; i < linux_num_cpus; i++)
-		cpu_present_map |= (1UL << linux_cpus[i].mid);
-	for (i = 0; i < NR_CPUS; i++) {
-		__cpu_number_map[i] = -1;
-		__cpu_logical_map[i] = -1;
+
+	if (boot_cpu_id >= NR_CPUS) {
+		prom_printf("Serious problem, boot cpu id >= NR_CPUS\n");
+		prom_halt();
+	}
+
+	atomic_set(&sparc64_num_cpus_online, 1);
+	memset(&cpu_online_map, 0, sizeof(cpu_online_map));
+	for (i = 0; i < linux_num_cpus; i++) {
+		if (linux_cpus[i].mid < NR_CPUS)
+			set_bit(linux_cpus[i].mid, &cpu_online_map);
 	}
-	__cpu_number_map[boot_cpu_id] = 0;
+
 	prom_cpu_nodes[boot_cpu_id] = linux_cpus[0].prom_node;
-	__cpu_logical_map[0] = boot_cpu_id;
 	prof_counter(boot_cpu_id) = prof_multiplier(boot_cpu_id) = 1;
 }
 
@@ -1223,8 +1246,10 @@
 				     "bne,pt	%%xcc, 1b\n\t"
 				     " nop\n\t"
 				     "rd	%%tick, %1\n\t"
-				     : "=&r" (tick1), "=&r" (tick2), "=&r" (flush_base)
-				     : "2" (flush_base), "r" (flush_base + ecache_size)
+				     : "=&r" (tick1), "=&r" (tick2),
+				       "=&r" (flush_base)
+				     : "2" (flush_base),
+				       "r" (flush_base + ecache_size)
 				     : "g1", "g2", "g3", "g5");
 		} else {
 		__asm__ __volatile__("b,pt	%%xcc, 1f\n\t"
@@ -1239,8 +1264,10 @@
 				     "bne,pt	%%xcc, 1b\n\t"
 				     " nop\n\t"
 				     "rd	%%asr24, %1\n\t"
-				     : "=&r" (tick1), "=&r" (tick2), "=&r" (flush_base)
-				     : "2" (flush_base), "r" (flush_base + ecache_size)
+				     : "=&r" (tick1), "=&r" (tick2),
+				       "=&r" (flush_base)
+				     : "2" (flush_base),
+				       "r" (flush_base + ecache_size)
 				     : "g1", "g2", "g3", "g5");
 		}
 
@@ -1276,10 +1303,8 @@
 		return -EINVAL;
 
 	save_and_cli(flags);
-	for (i = 0; i < NR_CPUS; i++) {
-		if (cpu_present_map & (1UL << i))
-			prof_multiplier(i) = multiplier;
-	}
+	for (i = 0; i < NR_CPUS; i++)
+		prof_multiplier(i) = multiplier;
 	current_tick_offset = (timer_tick_offset / multiplier);
 	restore_flags(flags);
 
diff -Nru a/arch/sparc64/kernel/sparc64_ksyms.c b/arch/sparc64/kernel/sparc64_ksyms.c
--- a/arch/sparc64/kernel/sparc64_ksyms.c	Thu Jun 20 15:54:00 2002
+++ b/arch/sparc64/kernel/sparc64_ksyms.c	Thu Jun 20 15:54:00 2002
@@ -59,7 +59,6 @@
 	short revents;
 };
 
-extern unsigned prom_cpu_nodes[64];
 extern void die_if_kernel(char *str, struct pt_regs *regs);
 extern pid_t kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
 void _sigpause_common (unsigned int set, struct pt_regs *);
@@ -103,7 +102,6 @@
 
 #ifdef CONFIG_SMP
 extern spinlock_t kernel_flag;
-extern int smp_num_cpus;
 #ifdef CONFIG_DEBUG_SPINLOCK
 extern void _do_spin_lock (spinlock_t *lock, char *str);
 extern void _do_spin_unlock (spinlock_t *lock);
@@ -149,12 +147,9 @@
 /* Per-CPU information table */
 EXPORT_SYMBOL(cpu_data);
 
-/* Misc SMP information */
-#ifdef CONFIG_SMP
-EXPORT_SYMBOL(smp_num_cpus);
-#endif
-EXPORT_SYMBOL(__cpu_number_map);
-EXPORT_SYMBOL(__cpu_logical_map);
+/* CPU online map and active count.  */
+EXPORT_SYMBOL(cpu_online_map);
+EXPORT_SYMBOL(sparc64_num_cpus_online);
 
 /* Spinlock debugging library, optional. */
 #ifdef CONFIG_DEBUG_SPINLOCK
diff -Nru a/arch/sparc64/kernel/starfire.c b/arch/sparc64/kernel/starfire.c
--- a/arch/sparc64/kernel/starfire.c	Thu Jun 20 15:54:01 2002
+++ b/arch/sparc64/kernel/starfire.c	Thu Jun 20 15:54:01 2002
@@ -24,37 +24,13 @@
 void check_if_starfire(void)
 {
 	int ssnode = prom_finddevice("/ssp-serial");
-	if(ssnode != 0 && ssnode != -1)
+	if (ssnode != 0 && ssnode != -1)
 		this_is_starfire = 1;
 }
 
 void starfire_cpu_setup(void)
 {
-	if (this_is_starfire) {
-/*
- * We do this in starfire_translate and xcall_deliver. When we fix our cpu
- * arrays to support > 64 processors we can use the real upaid instead
- * of the logical cpuid in __cpu_number_map etc, then we can get rid of
- * the translations everywhere. - Anton
- */
-#if 0
-		int i;
-
-		/*
-		 * Now must fixup cpu MIDs.  OBP gave us a logical
-		 * linear cpuid number, not the real upaid.
-		 */
-		for(i = 0; i < linux_num_cpus; i++) {
-			unsigned int mid = linux_cpus[i].mid;
-
-			mid = (((mid & 0x3c) << 1) |
-			       ((mid & 0x40) >> 4) |
-			       (mid & 0x3));
-
-			linux_cpus[i].mid = mid;
-		}
-#endif
-	}
+	/* Currently, nothing to do.  */
 }
 
 int starfire_hard_smp_processor_id(void)
@@ -84,7 +60,7 @@
 	unsigned long treg_base, hwmid, i;
 
 	p = kmalloc(sizeof(*p), GFP_KERNEL);
-	if(!p) {
+	if (!p) {
 		prom_printf("starfire_hookup: No memory, this is insane.\n");
 		prom_halt();
 	}
@@ -95,7 +71,7 @@
 	p->hwmid = hwmid;
 	treg_base += (hwmid << 33UL);
 	treg_base += 0x200UL;
-	for(i = 0; i < 32; i++) {
+	for (i = 0; i < 32; i++) {
 		p->imap_slots[i] = 0UL;
 		p->tregs[i] = treg_base + (i * 0x10UL);
 		/* Lets play it safe and not overwrite existing mappings */
@@ -117,20 +93,20 @@
 	unsigned int i;
 
 	bus_hwmid = (((unsigned long)imap) >> 33) & 0x7f;
-	for(p = sflist; p != NULL; p = p->next)
-		if(p->hwmid == bus_hwmid)
+	for (p = sflist; p != NULL; p = p->next)
+		if (p->hwmid == bus_hwmid)
 			break;
-	if(p == NULL) {
+	if (p == NULL) {
 		prom_printf("XFIRE: Cannot find irqinfo for imap %016lx\n",
 			    ((unsigned long)imap));
 		prom_halt();
 	}
-	for(i = 0; i < 32; i++) {
-		if(p->imap_slots[i] == imap ||
-		   p->imap_slots[i] == 0UL)
+	for (i = 0; i < 32; i++) {
+		if (p->imap_slots[i] == imap ||
+		    p->imap_slots[i] == 0UL)
 			break;
 	}
-	if(i == 32) {
+	if (i == 32) {
 		printk("starfire_translate: Are you kidding me?\n");
 		panic("Lucy in the sky....");
 	}
@@ -138,8 +114,8 @@
 
 	/* map to real upaid */
 	upaid = (((upaid & 0x3c) << 1) |
-	       ((upaid & 0x40) >> 4) |
-	       (upaid & 0x3));
+		 ((upaid & 0x40) >> 4) |
+		 (upaid & 0x3));
 
 	upa_writel(upaid, p->tregs[i]);
 
diff -Nru a/arch/sparc64/kernel/traps.c b/arch/sparc64/kernel/traps.c
--- a/arch/sparc64/kernel/traps.c	Thu Jun 20 15:54:01 2002
+++ b/arch/sparc64/kernel/traps.c	Thu Jun 20 15:54:01 2002
@@ -402,7 +402,7 @@
 {
 	unsigned long largest_size, smallest_linesize, order;
 	char type[16];
-	int node, highest_cpu, i;
+	int node, i;
 
 	/* Scan all cpu device tree nodes, note two values:
 	 * 1) largest E-cache size
@@ -458,15 +458,7 @@
 	}
 
 	/* Now allocate error trap reporting scoreboard. */
-	highest_cpu = 0;
-#ifdef CONFIG_SMP
-	for (i = 0; i < NR_CPUS; i++) {
-		if ((1UL << i) & cpu_present_map)
-			highest_cpu = i;
-	}
-#endif
-	highest_cpu++;
-	node = highest_cpu * (2 * sizeof(struct cheetah_err_info));
+	node = NR_CPUS * (2 * sizeof(struct cheetah_err_info));
 	for (order = 0; order < MAX_ORDER; order++) {
 		if ((PAGE_SIZE << order) >= node)
 			break;
@@ -483,7 +475,7 @@
 	/* Mark all AFSRs as invalid so that the trap handler will
 	 * log new new information there.
 	 */
-	for (i = 0; i < 2 * highest_cpu; i++)
+	for (i = 0; i < 2 * NR_CPUS; i++)
 		cheetah_error_log[i].afsr = CHAFSR_INVALID;
 
 	/* Now patch trap tables. */
diff -Nru a/arch/sparc64/solaris/misc.c b/arch/sparc64/solaris/misc.c
--- a/arch/sparc64/solaris/misc.c	Thu Jun 20 15:54:01 2002
+++ b/arch/sparc64/solaris/misc.c	Thu Jun 20 15:54:01 2002
@@ -21,6 +21,7 @@
 #include <asm/string.h>
 #include <asm/oplib.h>
 #include <asm/idprom.h>
+#include <asm/smp.h>
 
 #include "conv.h"
 
@@ -336,8 +337,6 @@
 #define	SOLARIS_CONFIG_PHYS_PAGES		26
 #define	SOLARIS_CONFIG_AVPHYS_PAGES		27
 
-extern unsigned prom_cpu_nodes[NR_CPUS];
-
 asmlinkage int solaris_sysconf(int id)
 {
 	switch (id) {
@@ -353,7 +352,7 @@
 					  "clock-frequency", 167000000);
 #ifdef CONFIG_SMP	
 	case SOLARIS_CONFIG_NPROC_CONF:	return NR_CPUS;
-	case SOLARIS_CONFIG_NPROC_ONLN:	return smp_num_cpus;
+	case SOLARIS_CONFIG_NPROC_ONLN:	return num_online_cpus();
 #else
 	case SOLARIS_CONFIG_NPROC_CONF:	return 1;
 	case SOLARIS_CONFIG_NPROC_ONLN:	return 1;
diff -Nru a/arch/x86_64/kernel/sys_x86_64.c b/arch/x86_64/kernel/sys_x86_64.c
--- a/arch/x86_64/kernel/sys_x86_64.c	Thu Jun 20 15:54:01 2002
+++ b/arch/x86_64/kernel/sys_x86_64.c	Thu Jun 20 15:54:01 2002
@@ -105,13 +105,6 @@
 	return err ? -EFAULT : 0;
 }
 
-asmlinkage long sys_pause(void)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
 asmlinkage long wrap_sys_shmat(int shmid, char *shmaddr, int shmflg)
 {
 	unsigned long raddr;
diff -Nru a/arch/x86_64/kernel/traps.c b/arch/x86_64/kernel/traps.c
--- a/arch/x86_64/kernel/traps.c	Thu Jun 20 15:54:00 2002
+++ b/arch/x86_64/kernel/traps.c	Thu Jun 20 15:54:00 2002
@@ -81,7 +81,7 @@
 
 struct notifier_block *die_chain;
 
-int kstack_depth_to_print = 10;
+static int kstack_depth_to_print = 10;
 
 #ifdef CONFIG_KALLSYMS
 #include <linux/kallsyms.h> 
diff -Nru a/drivers/Makefile b/drivers/Makefile
--- a/drivers/Makefile	Thu Jun 20 15:54:01 2002
+++ b/drivers/Makefile	Thu Jun 20 15:54:01 2002
@@ -39,6 +39,6 @@
 obj-$(CONFIG_MD)		+= md/
 obj-$(CONFIG_BLUEZ)		+= bluetooth/
 obj-$(CONFIG_HOTPLUG_PCI)	+= hotplug/
-obj-$(CONFIG_ISDN)		+= isdn/
+obj-$(CONFIG_ISDN_BOOL)		+= isdn/
 
 include $(TOPDIR)/Rules.make
diff -Nru a/drivers/acorn/char/Makefile b/drivers/acorn/char/Makefile
--- a/drivers/acorn/char/Makefile	Thu Jun 20 15:54:00 2002
+++ b/drivers/acorn/char/Makefile	Thu Jun 20 15:54:00 2002
@@ -20,5 +20,5 @@
 
 include $(TOPDIR)/Rules.make
 
-%.c: %.map
+$(obj)/%.c: $(src)/%.map
 	loadkeys --mktable $< > $@
diff -Nru a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
--- a/drivers/acpi/pci_irq.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/acpi/pci_irq.c	Thu Jun 20 15:54:01 2002
@@ -33,6 +33,7 @@
 #include <linux/pm.h>
 #include <linux/pci.h>
 #include <linux/acpi.h>
+#include <asm/mpspec.h>
 #include "acpi_bus.h"
 #include "acpi_drivers.h"
 
diff -Nru a/drivers/atm/Makefile b/drivers/atm/Makefile
--- a/drivers/atm/Makefile	Thu Jun 20 15:54:00 2002
+++ b/drivers/atm/Makefile	Thu Jun 20 15:54:00 2002
@@ -52,52 +52,26 @@
 
 obj-$(CONFIG_ATM_FORE200E) += fore_200e.o
 
-EXTRA_CFLAGS=-g
-
 fore_200e-objs	:= fore200e.o $(FORE200E_FW_OBJS)
 
 host-progs := fore200e_mkfirm
 
-include $(TOPDIR)/Rules.make
+EXTRA_CFLAGS := -g
 
+include $(TOPDIR)/Rules.make
 
 # FORE Systems 200E-series firmware magic
-fore200e_pca_fw.c: $(patsubst "%", %, $(CONFIG_ATM_FORE200E_PCA_FW)) \
-	  fore200e_mkfirm
-	./fore200e_mkfirm -k -b _fore200e_pca_fw \
+$(obj)/fore200e_pca_fw.c: $(patsubst "%", %, $(CONFIG_ATM_FORE200E_PCA_FW)) \
+			  $(obj)/fore200e_mkfirm
+	$(obj)/fore200e_mkfirm -k -b _fore200e_pca_fw \
 	  -i $(CONFIG_ATM_FORE200E_PCA_FW) -o $@
-	@ ( \
-	  echo 'ifeq ($(strip $(CONFIG_ATM_FORE200E_PCA_FW)), $$(CONFIG_ATM_FORE200E_PCA_FW))'; \
-	  echo 'FORE200E_FW_UP_TO_DATE += $@'; \
-	  echo 'endif' \
-	) >.$@.fw
-
-fore200e_sba_fw.c: $(patsubst "%", %, $(CONFIG_ATM_FORE200E_SBA_FW)) \
-	  fore200e_mkfirm
-	./fore200e_mkfirm -k -b _fore200e_sba_fw \
+
+$(obj)/fore200e_sba_fw.c: $(patsubst "%", %, $(CONFIG_ATM_FORE200E_SBA_FW)) \
+			  $(obj)/fore200e_mkfirm
+	$(obj)/fore200e_mkfirm -k -b _fore200e_sba_fw \
 	  -i $(CONFIG_ATM_FORE200E_SBA_FW) -o $@
-	@ ( \
-	  echo 'ifeq ($(strip $(CONFIG_ATM_FORE200E_SBA_FW)), $$(CONFIG_ATM_FORE200E_SBA_FW))'; \
-	  echo 'FORE200E_FW_UP_TO_DATE += $@'; \
-	  echo 'endif' \
-	) >.$@.fw
 
 # deal with the various suffixes of the binary firmware images
-%.bin %.bin1 %.bin2: %.data
+$(obj)/%.bin $(obj)/%.bin1 $(obj)/%.bin2: $(obj)/%.data
 	objcopy -Iihex $< -Obinary $@.gz
 	gzip -df $@.gz
-
-# firmware dependency stuff taken from drivers/sound/Makefile
-FORE200E_FW_UP_TO_DATE :=
-
-FORE200E_FW_FILES := $(wildcard .fore200e_*.fw)
-ifneq ($(FORE200E_FW_FILES),)
-include $(FORE200E_FW_FILES)
-endif
-
-FORE200E_FW_CHANGED := $(filter-out $(FORE200E_FW_UP_TO_DATE), \
-                       fore200e_pca_fw.c fore200e_sba_fw.c)
-
-ifneq ($(FORE200E_FW_CHANGED),)
-$(FORE200E_FW_CHANGED): FORCE
-endif
diff -Nru a/drivers/atm/idt77252.h b/drivers/atm/idt77252.h
--- a/drivers/atm/idt77252.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/atm/idt77252.h	Thu Jun 20 15:54:00 2002
@@ -36,6 +36,7 @@
 
 #include <linux/ptrace.h>
 #include <linux/skbuff.h>
+#include <linux/tqueue.h>
 
 
 /*****************************************************************************/
diff -Nru a/drivers/block/Config.in b/drivers/block/Config.in
--- a/drivers/block/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/block/Config.in	Thu Jun 20 15:54:00 2002
@@ -37,7 +37,7 @@
 dep_tristate 'Compaq Smart Array 5xxx support' CONFIG_BLK_CPQ_CISS_DA $CONFIG_PCI 
 dep_mbool '       SCSI tape drive support for Smart Array 5xxx' CONFIG_CISS_SCSI_TAPE $CONFIG_BLK_CPQ_CISS_DA $CONFIG_SCSI
 dep_tristate 'Mylex DAC960/DAC1100 PCI RAID Controller support' CONFIG_BLK_DEV_DAC960 $CONFIG_PCI
-dep_tristate 'Micro Memory MM5415 Battery Backed RAM support' CONFIG_BLK_DEV_UMEM $CONFIG_PCI $CONFIG_EXPERIMENTAL
+dep_tristate 'Micro Memory MM5415 Battery Backed RAM support (EXPERIMENTAL)' CONFIG_BLK_DEV_UMEM $CONFIG_PCI $CONFIG_EXPERIMENTAL
 
 tristate 'Loopback device support' CONFIG_BLK_DEV_LOOP
 dep_tristate 'Network block device support' CONFIG_BLK_DEV_NBD $CONFIG_NET
diff -Nru a/drivers/block/elevator.c b/drivers/block/elevator.c
--- a/drivers/block/elevator.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/block/elevator.c	Thu Jun 20 15:54:01 2002
@@ -388,11 +388,43 @@
 	q->elevator.elevator_add_req_fn(q, rq, insert_here);
 }
 
-struct request *__elv_next_request(request_queue_t *q)
+static inline struct request *__elv_next_request(request_queue_t *q)
 {
 	return q->elevator.elevator_next_req_fn(q);
 }
 
+struct request *elv_next_request(request_queue_t *q)
+{
+	struct request *rq;
+
+	while ((rq = __elv_next_request(q))) {
+		rq->flags |= REQ_STARTED;
+
+		if (&rq->queuelist == q->last_merge)
+			q->last_merge = NULL;
+
+		if ((rq->flags & REQ_DONTPREP) || !q->prep_rq_fn)
+			break;
+
+		/*
+		 * all ok, break and return it
+		 */
+		if (!q->prep_rq_fn(q, rq))
+			break;
+
+		/*
+		 * prep said no-go, kill it
+		 */
+		blkdev_dequeue_request(rq);
+		if (end_that_request_first(rq, 0, rq->nr_sectors))
+			BUG();
+
+		end_that_request_last(rq);
+	}
+
+	return rq;
+}
+
 void elv_remove_request(request_queue_t *q, struct request *rq)
 {
 	elevator_t *e = &q->elevator;
@@ -423,7 +455,7 @@
 EXPORT_SYMBOL(elevator_noop);
 
 EXPORT_SYMBOL(__elv_add_request);
-EXPORT_SYMBOL(__elv_next_request);
+EXPORT_SYMBOL(elv_next_request);
 EXPORT_SYMBOL(elv_remove_request);
 EXPORT_SYMBOL(elevator_exit);
 EXPORT_SYMBOL(elevator_init);
diff -Nru a/drivers/block/genhd.c b/drivers/block/genhd.c
--- a/drivers/block/genhd.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/block/genhd.c	Thu Jun 20 15:54:01 2002
@@ -200,10 +200,6 @@
 
 
 extern int blk_dev_init(void);
-#ifdef CONFIG_FUSION
-extern int fusion_init(void);
-#endif
-extern int net_dev_init(void);
 extern int soc_probe(void);
 extern int atmdev_init(void);
 extern int i2o_init(void);
@@ -217,18 +213,12 @@
 #ifdef CONFIG_I2O
 	i2o_init();
 #endif
-#ifdef CONFIG_FUSION
-	fusion_init();
-#endif
 #ifdef CONFIG_FC4_SOC
 	/* This has to be done before scsi_dev_init */
 	soc_probe();
 #endif
 #ifdef CONFIG_BLK_CPQ_DA
 	cpqarray_init();
-#endif
-#ifdef CONFIG_NET
-	net_dev_init();
 #endif
 #ifdef CONFIG_ATM
 	(void) atmdev_init();
diff -Nru a/drivers/block/nbd.c b/drivers/block/nbd.c
--- a/drivers/block/nbd.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/block/nbd.c	Thu Jun 20 15:54:00 2002
@@ -288,6 +288,7 @@
 
 	}
  out:
+	return;
 }
 
 void nbd_clear_que(struct nbd_device *lo)
diff -Nru a/drivers/cdrom/cm206.c b/drivers/cdrom/cm206.c
--- a/drivers/cdrom/cm206.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/cdrom/cm206.c	Thu Jun 20 15:54:00 2002
@@ -345,6 +345,8 @@
 	}
 }
 
+static struct tasklet_struct cm206_tasklet;
+
 /* The interrupt handler. When the cm260 generates an interrupt, very
    much care has to be taken in reading out the registers in the right
    order; in case of a receive_buffer_full interrupt, first the
@@ -432,7 +434,7 @@
 	if (cd->background
 	    && (cd->adapter_last - cd->adapter_first == cd->max_sectors
 		|| cd->fifo_overflowed))
-		mark_bh(CM206_BH);	/* issue a stop read command */
+		tasklet_schedule(&cm206_tasklet);	/* issue a stop read command */
 	stats(interrupt);
 }
 
@@ -701,7 +703,7 @@
    4 c_stop waits for receive_buffer_full: 0xff
 */
 
-void cm206_bh(void)
+static void cm206_tasklet_func(unsigned long ignore)
 {
 	debug(("bh: %d\n", cd->background));
 	switch (cd->background) {
@@ -745,6 +747,8 @@
 	}
 }
 
+static DECLARE_TASKLET(cm206_tasklet, cm206_tasklet_func, 0);
+
 /* This command clears the dsb_possible_media_change flag, so we must 
  * retain it.
  */
@@ -1503,7 +1507,6 @@
 	blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), do_cm206_request,
 		       &cm206_lock);
 	blk_queue_hardsect_size(BLK_DEFAULT_QUEUE(MAJOR_NR), 2048);
-	init_bh(CM206_BH, cm206_bh);
 
 	memset(cd, 0, sizeof(*cd));	/* give'm some reasonable value */
 	cd->sector_last = -1;	/* flag no data buffered */
diff -Nru a/drivers/char/Config.in b/drivers/char/Config.in
--- a/drivers/char/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/char/Config.in	Thu Jun 20 15:54:00 2002
@@ -148,7 +148,7 @@
 bool 'Watchdog Timer Support'	CONFIG_WATCHDOG
 if [ "$CONFIG_WATCHDOG" != "n" ]; then
    bool '  Disable watchdog shutdown on close' CONFIG_WATCHDOG_NOWAYOUT
-   tristate '  Software Watchdog' CONFIG_SOFT_WATCHDOG
+   tristate '  Software watchdog' CONFIG_SOFT_WATCHDOG
    tristate '  WDT Watchdog timer' CONFIG_WDT
    tristate '  WDT PCI Watchdog timer' CONFIG_WDTPCI
    if [ "$CONFIG_WDT" != "n" ]; then
@@ -192,14 +192,14 @@
    bool 'EFI Real Time Clock Services' CONFIG_EFI_RTC
 fi
 if [ "$CONFIG_OBSOLETE" = "y" -a "$CONFIG_ALPHA_BOOK1" = "y" ]; then
-   bool 'Tadpole ANA H8 Support'  CONFIG_H8
+   bool 'Tadpole ANA H8 Support (OBSOLETE)'  CONFIG_H8
 fi
 
 tristate 'Double Talk PC internal speech card support' CONFIG_DTLK
 tristate 'Siemens R3964 line discipline' CONFIG_R3964
 tristate 'Applicom intelligent fieldbus card support' CONFIG_APPLICOM
 if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_X86" = "y" ]; then
-   dep_tristate 'Sony Vaio Programmable I/O Control Device support' CONFIG_SONYPI $CONFIG_PCI
+   dep_tristate 'Sony Vaio Programmable I/O Control Device support (EXPERIMENTAL)' CONFIG_SONYPI $CONFIG_PCI
 fi
 
 mainmenu_option next_comment
diff -Nru a/drivers/char/Makefile b/drivers/char/Makefile
--- a/drivers/char/Makefile	Thu Jun 20 15:54:01 2002
+++ b/drivers/char/Makefile	Thu Jun 20 15:54:01 2002
@@ -216,13 +216,11 @@
 
 include $(TOPDIR)/Rules.make
 
-consolemap_deftbl.c: $(FONTMAPFILE) conmakehash
-	./conmakehash $< > $@
+$(obj)/consolemap_deftbl.c: $(src)/$(FONTMAPFILE) $(obj)/conmakehash
+	$(obj)/conmakehash $< > $@
 
-.DELETE_ON_ERROR:
-
-defkeymap.c: defkeymap.map
+$(obj)/defkeymap.c: $(src)/defkeymap.map
 	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
 
-qtronixmap.c: qtronixmap.map
+$(obj)/qtronixmap.c: $(src)/qtronixmap.map
 	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
diff -Nru a/drivers/char/defkeymap.c b/drivers/char/defkeymap.c
--- a/drivers/char/defkeymap.c	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,262 +0,0 @@
-/* Do not edit this file! It was automatically generated by   */
-/*    loadkeys --mktable defkeymap.map > defkeymap.c          */
-
-#include <linux/types.h>
-#include <linux/keyboard.h>
-#include <linux/kd.h>
-
-u_short plain_map[NR_KEYS] = {
-	0xf200,	0xf01b,	0xf031,	0xf032,	0xf033,	0xf034,	0xf035,	0xf036,
-	0xf037,	0xf038,	0xf039,	0xf030,	0xf02d,	0xf03d,	0xf07f,	0xf009,
-	0xfb71,	0xfb77,	0xfb65,	0xfb72,	0xfb74,	0xfb79,	0xfb75,	0xfb69,
-	0xfb6f,	0xfb70,	0xf05b,	0xf05d,	0xf201,	0xf702,	0xfb61,	0xfb73,
-	0xfb64,	0xfb66,	0xfb67,	0xfb68,	0xfb6a,	0xfb6b,	0xfb6c,	0xf03b,
-	0xf027,	0xf060,	0xf700,	0xf05c,	0xfb7a,	0xfb78,	0xfb63,	0xfb76,
-	0xfb62,	0xfb6e,	0xfb6d,	0xf02c,	0xf02e,	0xf02f,	0xf700,	0xf30c,
-	0xf703,	0xf020,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
-	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf209,	0xf307,
-	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
-	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03c,	0xf10a,
-	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
-	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
-	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-};
-
-u_short shift_map[NR_KEYS] = {
-	0xf200,	0xf01b,	0xf021,	0xf040,	0xf023,	0xf024,	0xf025,	0xf05e,
-	0xf026,	0xf02a,	0xf028,	0xf029,	0xf05f,	0xf02b,	0xf07f,	0xf009,
-	0xfb51,	0xfb57,	0xfb45,	0xfb52,	0xfb54,	0xfb59,	0xfb55,	0xfb49,
-	0xfb4f,	0xfb50,	0xf07b,	0xf07d,	0xf201,	0xf702,	0xfb41,	0xfb53,
-	0xfb44,	0xfb46,	0xfb47,	0xfb48,	0xfb4a,	0xfb4b,	0xfb4c,	0xf03a,
-	0xf022,	0xf07e,	0xf700,	0xf07c,	0xfb5a,	0xfb58,	0xfb43,	0xfb56,
-	0xfb42,	0xfb4e,	0xfb4d,	0xf03c,	0xf03e,	0xf03f,	0xf700,	0xf30c,
-	0xf703,	0xf020,	0xf207,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf10e,
-	0xf10f,	0xf110,	0xf111,	0xf112,	0xf113,	0xf213,	0xf203,	0xf307,
-	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
-	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03e,	0xf10a,
-	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
-	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
-	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-};
-
-u_short altgr_map[NR_KEYS] = {
-	0xf200,	0xf200,	0xf200,	0xf040,	0xf200,	0xf024,	0xf200,	0xf200,
-	0xf07b,	0xf05b,	0xf05d,	0xf07d,	0xf05c,	0xf200,	0xf200,	0xf200,
-	0xfb71,	0xfb77,	0xf918,	0xfb72,	0xfb74,	0xfb79,	0xfb75,	0xfb69,
-	0xfb6f,	0xfb70,	0xf200,	0xf07e,	0xf201,	0xf702,	0xf914,	0xfb73,
-	0xf917,	0xf919,	0xfb67,	0xfb68,	0xfb6a,	0xfb6b,	0xfb6c,	0xf200,
-	0xf200,	0xf200,	0xf700,	0xf200,	0xfb7a,	0xfb78,	0xf916,	0xfb76,
-	0xf915,	0xfb6e,	0xfb6d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
-	0xf703,	0xf200,	0xf207,	0xf50c,	0xf50d,	0xf50e,	0xf50f,	0xf510,
-	0xf511,	0xf512,	0xf513,	0xf514,	0xf515,	0xf208,	0xf202,	0xf911,
-	0xf912,	0xf913,	0xf30b,	0xf90e,	0xf90f,	0xf910,	0xf30a,	0xf90b,
-	0xf90c,	0xf90d,	0xf90a,	0xf310,	0xf206,	0xf200,	0xf07c,	0xf516,
-	0xf517,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
-	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
-	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-};
-
-u_short ctrl_map[NR_KEYS] = {
-	0xf200,	0xf200,	0xf200,	0xf000,	0xf01b,	0xf01c,	0xf01d,	0xf01e,
-	0xf01f,	0xf07f,	0xf200,	0xf200,	0xf01f,	0xf200,	0xf008,	0xf200,
-	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,	0xf019,	0xf015,	0xf009,
-	0xf00f,	0xf010,	0xf01b,	0xf01d,	0xf201,	0xf702,	0xf001,	0xf013,
-	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
-	0xf007,	0xf000,	0xf700,	0xf01c,	0xf01a,	0xf018,	0xf003,	0xf016,
-	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf20e,	0xf07f,	0xf700,	0xf30c,
-	0xf703,	0xf000,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
-	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf204,	0xf307,
-	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
-	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf10a,
-	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
-	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
-	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-};
-
-u_short shift_ctrl_map[NR_KEYS] = {
-	0xf200,	0xf200,	0xf200,	0xf000,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf01f,	0xf200,	0xf200,	0xf200,
-	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,	0xf019,	0xf015,	0xf009,
-	0xf00f,	0xf010,	0xf200,	0xf200,	0xf201,	0xf702,	0xf001,	0xf013,
-	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
-	0xf200,	0xf200,	0xf700,	0xf200,	0xf01a,	0xf018,	0xf003,	0xf016,
-	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
-	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
-	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
-	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
-	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
-	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-};
-
-u_short alt_map[NR_KEYS] = {
-	0xf200,	0xf81b,	0xf831,	0xf832,	0xf833,	0xf834,	0xf835,	0xf836,
-	0xf837,	0xf838,	0xf839,	0xf830,	0xf82d,	0xf83d,	0xf87f,	0xf809,
-	0xf871,	0xf877,	0xf865,	0xf872,	0xf874,	0xf879,	0xf875,	0xf869,
-	0xf86f,	0xf870,	0xf85b,	0xf85d,	0xf80d,	0xf702,	0xf861,	0xf873,
-	0xf864,	0xf866,	0xf867,	0xf868,	0xf86a,	0xf86b,	0xf86c,	0xf83b,
-	0xf827,	0xf860,	0xf700,	0xf85c,	0xf87a,	0xf878,	0xf863,	0xf876,
-	0xf862,	0xf86e,	0xf86d,	0xf82c,	0xf82e,	0xf82f,	0xf700,	0xf30c,
-	0xf703,	0xf820,	0xf207,	0xf500,	0xf501,	0xf502,	0xf503,	0xf504,
-	0xf505,	0xf506,	0xf507,	0xf508,	0xf509,	0xf208,	0xf209,	0xf907,
-	0xf908,	0xf909,	0xf30b,	0xf904,	0xf905,	0xf906,	0xf30a,	0xf901,
-	0xf902,	0xf903,	0xf900,	0xf310,	0xf206,	0xf200,	0xf83c,	0xf50a,
-	0xf50b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
-	0xf118,	0xf210,	0xf211,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
-	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-};
-
-u_short ctrl_alt_map[NR_KEYS] = {
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf811,	0xf817,	0xf805,	0xf812,	0xf814,	0xf819,	0xf815,	0xf809,
-	0xf80f,	0xf810,	0xf200,	0xf200,	0xf201,	0xf702,	0xf801,	0xf813,
-	0xf804,	0xf806,	0xf807,	0xf808,	0xf80a,	0xf80b,	0xf80c,	0xf200,
-	0xf200,	0xf200,	0xf700,	0xf200,	0xf81a,	0xf818,	0xf803,	0xf816,
-	0xf802,	0xf80e,	0xf80d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
-	0xf703,	0xf200,	0xf207,	0xf500,	0xf501,	0xf502,	0xf503,	0xf504,
-	0xf505,	0xf506,	0xf507,	0xf508,	0xf509,	0xf208,	0xf200,	0xf307,
-	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
-	0xf302,	0xf303,	0xf300,	0xf20c,	0xf206,	0xf200,	0xf200,	0xf50a,
-	0xf50b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
-	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
-	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-};
-
-ushort *key_maps[MAX_NR_KEYMAPS] = {
-	plain_map, shift_map, altgr_map, 0,
-	ctrl_map, shift_ctrl_map, 0, 0,
-	alt_map, 0, 0, 0,
-	ctrl_alt_map,	0
-};
-
-unsigned int keymap_count = 7;
-
-/*
- * Philosophy: most people do not define more strings, but they who do
- * often want quite a lot of string space. So, we statically allocate
- * the default and allocate dynamically in chunks of 512 bytes.
- */
-
-char func_buf[] = {
-	'\033', '[', '[', 'A', 0, 
-	'\033', '[', '[', 'B', 0, 
-	'\033', '[', '[', 'C', 0, 
-	'\033', '[', '[', 'D', 0, 
-	'\033', '[', '[', 'E', 0, 
-	'\033', '[', '1', '7', '~', 0, 
-	'\033', '[', '1', '8', '~', 0, 
-	'\033', '[', '1', '9', '~', 0, 
-	'\033', '[', '2', '0', '~', 0, 
-	'\033', '[', '2', '1', '~', 0, 
-	'\033', '[', '2', '3', '~', 0, 
-	'\033', '[', '2', '4', '~', 0, 
-	'\033', '[', '2', '5', '~', 0, 
-	'\033', '[', '2', '6', '~', 0, 
-	'\033', '[', '2', '8', '~', 0, 
-	'\033', '[', '2', '9', '~', 0, 
-	'\033', '[', '3', '1', '~', 0, 
-	'\033', '[', '3', '2', '~', 0, 
-	'\033', '[', '3', '3', '~', 0, 
-	'\033', '[', '3', '4', '~', 0, 
-	'\033', '[', '1', '~', 0, 
-	'\033', '[', '2', '~', 0, 
-	'\033', '[', '3', '~', 0, 
-	'\033', '[', '4', '~', 0, 
-	'\033', '[', '5', '~', 0, 
-	'\033', '[', '6', '~', 0, 
-	'\033', '[', 'M', 0, 
-	'\033', '[', 'P', 0, 
-};
-
-char *funcbufptr = func_buf;
-int funcbufsize = sizeof(func_buf);
-int funcbufleft = 0;          /* space left */
-
-char *func_table[MAX_NR_FUNC] = {
-	func_buf + 0,
-	func_buf + 5,
-	func_buf + 10,
-	func_buf + 15,
-	func_buf + 20,
-	func_buf + 25,
-	func_buf + 31,
-	func_buf + 37,
-	func_buf + 43,
-	func_buf + 49,
-	func_buf + 55,
-	func_buf + 61,
-	func_buf + 67,
-	func_buf + 73,
-	func_buf + 79,
-	func_buf + 85,
-	func_buf + 91,
-	func_buf + 97,
-	func_buf + 103,
-	func_buf + 109,
-	func_buf + 115,
-	func_buf + 120,
-	func_buf + 125,
-	func_buf + 130,
-	func_buf + 135,
-	func_buf + 140,
-	func_buf + 145,
-	0,
-	0,
-	func_buf + 149,
-	0,
-};
-
-struct kbdiacr accent_table[MAX_DIACR] = {
-	{'`', 'A', '\300'},	{'`', 'a', '\340'},
-	{'\'', 'A', '\301'},	{'\'', 'a', '\341'},
-	{'^', 'A', '\302'},	{'^', 'a', '\342'},
-	{'~', 'A', '\303'},	{'~', 'a', '\343'},
-	{'"', 'A', '\304'},	{'"', 'a', '\344'},
-	{'O', 'A', '\305'},	{'o', 'a', '\345'},
-	{'0', 'A', '\305'},	{'0', 'a', '\345'},
-	{'A', 'A', '\305'},	{'a', 'a', '\345'},
-	{'A', 'E', '\306'},	{'a', 'e', '\346'},
-	{',', 'C', '\307'},	{',', 'c', '\347'},
-	{'`', 'E', '\310'},	{'`', 'e', '\350'},
-	{'\'', 'E', '\311'},	{'\'', 'e', '\351'},
-	{'^', 'E', '\312'},	{'^', 'e', '\352'},
-	{'"', 'E', '\313'},	{'"', 'e', '\353'},
-	{'`', 'I', '\314'},	{'`', 'i', '\354'},
-	{'\'', 'I', '\315'},	{'\'', 'i', '\355'},
-	{'^', 'I', '\316'},	{'^', 'i', '\356'},
-	{'"', 'I', '\317'},	{'"', 'i', '\357'},
-	{'-', 'D', '\320'},	{'-', 'd', '\360'},
-	{'~', 'N', '\321'},	{'~', 'n', '\361'},
-	{'`', 'O', '\322'},	{'`', 'o', '\362'},
-	{'\'', 'O', '\323'},	{'\'', 'o', '\363'},
-	{'^', 'O', '\324'},	{'^', 'o', '\364'},
-	{'~', 'O', '\325'},	{'~', 'o', '\365'},
-	{'"', 'O', '\326'},	{'"', 'o', '\366'},
-	{'/', 'O', '\330'},	{'/', 'o', '\370'},
-	{'`', 'U', '\331'},	{'`', 'u', '\371'},
-	{'\'', 'U', '\332'},	{'\'', 'u', '\372'},
-	{'^', 'U', '\333'},	{'^', 'u', '\373'},
-	{'"', 'U', '\334'},	{'"', 'u', '\374'},
-	{'\'', 'Y', '\335'},	{'\'', 'y', '\375'},
-	{'T', 'H', '\336'},	{'t', 'h', '\376'},
-	{'s', 's', '\337'},	{'"', 'y', '\377'},
-	{'s', 'z', '\337'},	{'i', 'j', '\377'},
-};
-
-unsigned int accent_table_size = 68;
diff -Nru a/drivers/hotplug/cpqphp_core.c b/drivers/hotplug/cpqphp_core.c
--- a/drivers/hotplug/cpqphp_core.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/hotplug/cpqphp_core.c	Thu Jun 20 15:53:59 2002
@@ -33,6 +33,7 @@
 #include <linux/proc_fs.h>
 #include <linux/miscdevice.h>
 #include <linux/slab.h>
+#include <linux/tqueue.h>
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <asm/uaccess.h>
diff -Nru a/drivers/hotplug/cpqphp_ctrl.c b/drivers/hotplug/cpqphp_ctrl.c
--- a/drivers/hotplug/cpqphp_ctrl.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/hotplug/cpqphp_ctrl.c	Thu Jun 20 15:54:00 2002
@@ -31,6 +31,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/slab.h>
+#include <linux/tqueue.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/wait.h>
diff -Nru a/drivers/hotplug/cpqphp_nvram.c b/drivers/hotplug/cpqphp_nvram.c
--- a/drivers/hotplug/cpqphp_nvram.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/hotplug/cpqphp_nvram.c	Thu Jun 20 15:54:01 2002
@@ -33,6 +33,7 @@
 #include <linux/proc_fs.h>
 #include <linux/miscdevice.h>
 #include <linux/slab.h>
+#include <linux/tqueue.h>
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <asm/uaccess.h>
diff -Nru a/drivers/hotplug/cpqphp_pci.c b/drivers/hotplug/cpqphp_pci.c
--- a/drivers/hotplug/cpqphp_pci.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/hotplug/cpqphp_pci.c	Thu Jun 20 15:54:01 2002
@@ -31,6 +31,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/slab.h>
+#include <linux/tqueue.h>
 #include <linux/proc_fs.h>
 #include <linux/pci.h>
 #include "cpqphp.h"
diff -Nru a/drivers/hotplug/cpqphp_proc.c b/drivers/hotplug/cpqphp_proc.c
--- a/drivers/hotplug/cpqphp_proc.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/hotplug/cpqphp_proc.c	Thu Jun 20 15:54:01 2002
@@ -31,6 +31,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/proc_fs.h>
+#include <linux/tqueue.h>
 #include <linux/pci.h>
 #include "cpqphp.h"
 
diff -Nru a/drivers/i2c/Config.in b/drivers/i2c/Config.in
--- a/drivers/i2c/Config.in	Thu Jun 20 15:54:01 2002
+++ b/drivers/i2c/Config.in	Thu Jun 20 15:54:01 2002
@@ -43,7 +43,7 @@
 # This is needed for automatic patch generation: sensors code ends here
 
    dep_tristate 'I2C device interface' CONFIG_I2C_CHARDEV $CONFIG_I2C
-   dep_tristate 'I2C /proc interface (required for hardware sensors)' CONFIG_I2C_PROC $CONFIG_I2C
+   dep_tristate 'I2C /proc interface (required for hardware sensors)' CONFIG_I2C_PROC $CONFIG_I2C $CONFIG_SYSCTL
 
 fi
 endmenu
diff -Nru a/drivers/i2c/i2c-algo-bit.c b/drivers/i2c/i2c-algo-bit.c
--- a/drivers/i2c/i2c-algo-bit.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/i2c/i2c-algo-bit.c	Thu Jun 20 15:53:59 2002
@@ -21,7 +21,7 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
    Frodo Looijaard <frodol@dds.nl> */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -32,7 +32,6 @@
 #include <asm/uaccess.h>
 #include <linux/ioport.h>
 #include <linux/errno.h>
-#include <linux/sched.h>
 
 #include <linux/i2c.h>
 #include <linux/i2c-algo-bit.h>
@@ -122,7 +121,7 @@
 		}
 		cond_resched();
 	}
-	DEBSTAT(printk("needed %ld jiffies\n", jiffies-start));
+	DEBSTAT(printk(KERN_DEBUG "needed %ld jiffies\n", jiffies-start));
 #ifdef SLO_IO
 	SLO_IO
 #endif
@@ -178,12 +177,12 @@
 	struct i2c_algo_bit_data *adap = i2c_adap->algo_data;
 
 	/* assert: scl is low */
-	DEB2(printk(" i2c_outb:%2.2X\n",c&0xff));
+	DEB2(printk(KERN_DEBUG " i2c_outb:%2.2X\n",c&0xff));
 	for ( i=7 ; i>=0 ; i-- ) {
 		sb = c & ( 1 << i );
 		setsda(adap,sb);
 		udelay(adap->udelay);
-		DEBPROTO(printk("%d",sb!=0));
+		DEBPROTO(printk(KERN_DEBUG "%d",sb!=0));
 		if (sclhi(adap)<0) { /* timed out */
 			sdahi(adap); /* we don't want to block the net */
 			return -ETIMEDOUT;
@@ -200,10 +199,10 @@
 	};
 	/* read ack: SDA should be pulled down by slave */
 	ack=getsda(adap);	/* ack: sda is pulled low ->success.	 */
-	DEB2(printk(" i2c_outb: getsda() =  0x%2.2x\n", ~ack ));
+	DEB2(printk(KERN_DEBUG " i2c_outb: getsda() =  0x%2.2x\n", ~ack ));
 
-	DEBPROTO( printk("[%2.2x]",c&0xff) );
-	DEBPROTO(if (0==ack){ printk(" A ");} else printk(" NA ") );
+	DEBPROTO( printk(KERN_DEBUG "[%2.2x]",c&0xff) );
+	DEBPROTO(if (0==ack){ printk(KERN_DEBUG " A ");} else printk(KERN_DEBUG " NA ") );
 	scllo(adap);
 	return 0==ack;		/* return 1 if device acked	 */
 	/* assert: scl is low (sda undef) */
@@ -219,7 +218,7 @@
 	struct i2c_algo_bit_data *adap = i2c_adap->algo_data;
 
 	/* assert: scl is low */
-	DEB2(printk("i2c_inb.\n"));
+	DEB2(printk(KERN_DEBUG "i2c_inb.\n"));
 
 	sdahi(adap);
 	for (i=0;i<8;i++) {
@@ -232,7 +231,7 @@
 		scllo(adap);
 	}
 	/* assert: scl is low */
-	DEBPROTO(printk(" %2.2x", indata & 0xff));
+	DEBPROTO(printk(KERN_DEBUG " %2.2x", indata & 0xff));
 	return (int) (indata & 0xff);
 }
 
@@ -244,69 +243,69 @@
 	int scl,sda;
 	sda=getsda(adap);
 	if (adap->getscl==NULL) {
-		printk("i2c-algo-bit.o: Warning: Adapter can't read from clock line - skipping test.\n");
+		printk(KERN_WARNING "i2c-algo-bit.o: Warning: Adapter can't read from clock line - skipping test.\n");
 		return 0;		
 	}
 	scl=getscl(adap);
-	printk("i2c-algo-bit.o: Adapter: %s scl: %d  sda: %d -- testing...\n",
+	printk(KERN_INFO "i2c-algo-bit.o: Adapter: %s scl: %d  sda: %d -- testing...\n",
 	       name,getscl(adap),getsda(adap));
 	if (!scl || !sda ) {
-		printk("i2c-algo-bit.o: %s seems to be busy.\n",name);
+		printk(KERN_INFO " i2c-algo-bit.o: %s seems to be busy.\n",name);
 		goto bailout;
 	}
 	sdalo(adap);
-	printk("i2c-algo-bit.o:1 scl: %d  sda: %d \n",getscl(adap),
+	printk(KERN_DEBUG "i2c-algo-bit.o:1 scl: %d  sda: %d \n",getscl(adap),
 	       getsda(adap));
 	if ( 0 != getsda(adap) ) {
-		printk("i2c-algo-bit.o: %s SDA stuck high!\n",name);
+		printk(KERN_WARNING "i2c-algo-bit.o: %s SDA stuck high!\n",name);
 		sdahi(adap);
 		goto bailout;
 	}
 	if ( 0 == getscl(adap) ) {
-		printk("i2c-algo-bit.o: %s SCL unexpected low while pulling SDA low!\n",
+		printk(KERN_WARNING "i2c-algo-bit.o: %s SCL unexpected low while pulling SDA low!\n",
 			name);
 		goto bailout;
 	}		
 	sdahi(adap);
-	printk("i2c-algo-bit.o:2 scl: %d  sda: %d \n",getscl(adap),
+	printk(KERN_DEBUG "i2c-algo-bit.o:2 scl: %d  sda: %d \n",getscl(adap),
 	       getsda(adap));
 	if ( 0 == getsda(adap) ) {
-		printk("i2c-algo-bit.o: %s SDA stuck low!\n",name);
+		printk(KERN_WARNING "i2c-algo-bit.o: %s SDA stuck low!\n",name);
 		sdahi(adap);
 		goto bailout;
 	}
 	if ( 0 == getscl(adap) ) {
-		printk("i2c-algo-bit.o: %s SCL unexpected low while SDA high!\n",
+		printk(KERN_WARNING "i2c-algo-bit.o: %s SCL unexpected low while SDA high!\n",
 		       name);
 	goto bailout;
 	}
 	scllo(adap);
-	printk("i2c-algo-bit.o:3 scl: %d  sda: %d \n",getscl(adap),
+	printk(KERN_DEBUG "i2c-algo-bit.o:3 scl: %d  sda: %d \n",getscl(adap),
 	       getsda(adap));
 	if ( 0 != getscl(adap) ) {
-		printk("i2c-algo-bit.o: %s SCL stuck high!\n",name);
+		printk(KERN_WARNING "i2c-algo-bit.o: %s SCL stuck high!\n",name);
 		sclhi(adap);
 		goto bailout;
 	}
 	if ( 0 == getsda(adap) ) {
-		printk("i2c-algo-bit.o: %s SDA unexpected low while pulling SCL low!\n",
+		printk(KERN_WARNING "i2c-algo-bit.o: %s SDA unexpected low while pulling SCL low!\n",
 			name);
 		goto bailout;
 	}
 	sclhi(adap);
-	printk("i2c-algo-bit.o:4 scl: %d  sda: %d \n",getscl(adap),
+	printk(KERN_DEBUG "i2c-algo-bit.o:4 scl: %d  sda: %d \n",getscl(adap),
 	       getsda(adap));
 	if ( 0 == getscl(adap) ) {
-		printk("i2c-algo-bit.o: %s SCL stuck low!\n",name);
+		printk(KERN_WARNING "i2c-algo-bit.o: %s SCL stuck low!\n",name);
 		sclhi(adap);
 		goto bailout;
 	}
 	if ( 0 == getsda(adap) ) {
-		printk("i2c-algo-bit.o: %s SDA unexpected low while SCL high!\n",
+		printk(KERN_WARNING "i2c-algo-bit.o: %s SDA unexpected low while SCL high!\n",
 			name);
 		goto bailout;
 	}
-	printk("i2c-algo-bit.o: %s passed test.\n",name);
+	printk(KERN_INFO "i2c-algo-bit.o: %s passed test.\n",name);
 	return 0;
 bailout:
 	sdahi(adap);
@@ -340,7 +339,7 @@
 		i2c_start(adap);
 		udelay(adap->udelay);
 	}
-	DEB2(if (i) printk("i2c-algo-bit.o: needed %d retries for %d\n",
+	DEB2(if (i) printk(KERN_DEBUG "i2c-algo-bit.o: needed %d retries for %d\n",
 	                   i,addr));
 	return ret;
 }
@@ -355,7 +354,7 @@
 
 	while (count > 0) {
 		c = *temp;
-		DEB2(printk("i2c-algo-bit.o: %s i2c_write: writing %2.2X\n",
+		DEB2(printk(KERN_DEBUG "i2c-algo-bit.o: %s i2c_write: writing %2.2X\n",
 			    i2c_adap->name, c&0xff));
 		retval = i2c_outb(i2c_adap,c);
 		if (retval>0) {
@@ -363,7 +362,7 @@
 			temp++;
 			wrcount++;
 		} else { /* arbitration or no acknowledge */
-			printk("i2c-algo-bit.o: %s i2c_write: error - bailout.\n",
+			printk(KERN_ERR "i2c-algo-bit.o: %s i2c_write: error - bailout.\n",
 			       i2c_adap->name);
 			i2c_stop(adap);
 			return (retval<0)? retval : -EFAULT;
@@ -391,7 +390,7 @@
 			*temp = inval;
 			rdcount++;
 		} else {   /* read timed out */
-			printk("i2c-algo-bit.o: i2c_read: i2c_inb timed out.\n");
+			printk(KERN_ERR "i2c-algo-bit.o: i2c_read: i2c_inb timed out.\n");
 			break;
 		}
 
@@ -404,7 +403,7 @@
 		}
 		if (sclhi(adap)<0) {	/* timeout */
 			sdahi(adap);
-			printk("i2c-algo-bit.o: i2c_read: Timeout at ack\n");
+			printk(KERN_ERR "i2c-algo-bit.o: i2c_read: Timeout at ack\n");
 			return -ETIMEDOUT;
 		};
 		scllo(adap);
@@ -434,18 +433,18 @@
 	if ( (flags & I2C_M_TEN)  ) { 
 		/* a ten bit address */
 		addr = 0xf0 | (( msg->addr >> 7) & 0x03);
-		DEB2(printk("addr0: %d\n",addr));
+		DEB2(printk(KERN_DEBUG "addr0: %d\n",addr));
 		/* try extended address code...*/
 		ret = try_address(i2c_adap, addr, retries);
 		if (ret!=1) {
-			printk("died at extended address code.\n");
+			printk(KERN_ERR "died at extended address code.\n");
 			return -EREMOTEIO;
 		}
 		/* the remaining 8 bit address */
 		ret = i2c_outb(i2c_adap,msg->addr & 0x7f);
 		if (ret != 1) {
 			/* the chip did not ack / xmission error occurred */
-			printk("died at 2nd address code.\n");
+			printk(KERN_ERR "died at 2nd address code.\n");
 			return -EREMOTEIO;
 		}
 		if ( flags & I2C_M_RD ) {
@@ -454,7 +453,7 @@
 			addr |= 0x01;
 			ret = try_address(i2c_adap, addr, retries);
 			if (ret!=1) {
-				printk("died at extended address code.\n");
+				printk(KERN_ERR "died at extended address code.\n");
 				return -EREMOTEIO;
 			}
 		}
@@ -489,7 +488,7 @@
 			}
 			ret = bit_doAddress(i2c_adap,pmsg,i2c_adap->retries);
 			if (ret != 0) {
-				DEB2(printk("i2c-algo-bit.o: NAK from device adr %#2x msg #%d\n"
+				DEB2(printk(KERN_DEBUG "i2c-algo-bit.o: NAK from device adr %#2x msg #%d\n"
 				       ,msgs[i].addr,i));
 				return (ret<0) ? ret : -EREMOTEIO;
 			}
@@ -497,14 +496,14 @@
 		if (pmsg->flags & I2C_M_RD ) {
 			/* read bytes into buffer*/
 			ret = readbytes(i2c_adap,pmsg->buf,pmsg->len);
-			DEB2(printk("i2c-algo-bit.o: read %d bytes.\n",ret));
+			DEB2(printk(KERN_DEBUG "i2c-algo-bit.o: read %d bytes.\n",ret));
 			if (ret < pmsg->len ) {
 				return (ret<0)? ret : -EREMOTEIO;
 			}
 		} else {
 			/* write bytes from buffer */
 			ret = sendbytes(i2c_adap,pmsg->buf,pmsg->len);
-			DEB2(printk("i2c-algo-bit.o: wrote %d bytes.\n",ret));
+			DEB2(printk(KERN_DEBUG "i2c-algo-bit.o: wrote %d bytes.\n",ret));
 			if (ret < pmsg->len ) {
 				return (ret<0) ? ret : -EREMOTEIO;
 			}
@@ -554,7 +553,7 @@
 			return -ENODEV;
 	}
 
-	DEB2(printk("i2c-algo-bit.o: hw routines for %s registered.\n",
+	DEB2(printk(KERN_DEBUG "i2c-algo-bit.o: hw routines for %s registered.\n",
 	            adap->name));
 
 	/* register new adapter to i2c module... */
@@ -598,7 +597,7 @@
 	if ((res = i2c_del_adapter(adap)) < 0)
 		return res;
 
-	DEB2(printk("i2c-algo-bit.o: adapter unregistered: %s\n",adap->name));
+	DEB2(printk(KERN_DEBUG "i2c-algo-bit.o: adapter unregistered: %s\n",adap->name));
 
 #ifdef MODULE
 	MOD_DEC_USE_COUNT;
@@ -608,7 +607,7 @@
 
 int __init i2c_algo_bit_init (void)
 {
-	printk("i2c-algo-bit.o: i2c bit algorithm module\n");
+	printk(KERN_INFO "i2c-algo-bit.o: i2c bit algorithm module version %s (%s)\n", I2C_VERSION, I2C_DATE);
 	return 0;
 }
 
diff -Nru a/drivers/i2c/i2c-algo-pcf.c b/drivers/i2c/i2c-algo-pcf.c
--- a/drivers/i2c/i2c-algo-pcf.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/i2c/i2c-algo-pcf.c	Thu Jun 20 15:54:01 2002
@@ -36,7 +36,6 @@
 #include <asm/uaccess.h>
 #include <linux/ioport.h>
 #include <linux/errno.h>
-#include <linux/sched.h>
 
 #include <linux/i2c.h>
 #include <linux/i2c-algo-pcf.h>
@@ -99,7 +98,7 @@
 	}
 #endif
 	if (timeout <= 0) {
-		printk("Timeout waiting for Bus Busy\n");
+		printk(KERN_ERR "Timeout waiting for Bus Busy\n");
 	}
 	
 	return (timeout<=0);
@@ -144,15 +143,14 @@
 {
 	unsigned char temp;
 
-	DEB3(printk("i2c-algo-pcf.o: PCF state 0x%02x\n", get_pcf(adap, 1)));
+	DEB3(printk(KERN_DEBUG "i2c-algo-pcf.o: PCF state 0x%02x\n", get_pcf(adap, 1)));
 
 	/* S1=0x80: S0 selected, serial interface off */
 	set_pcf(adap, 1, I2C_PCF_PIN);
 	/* check to see S1 now used as R/W ctrl -
 	   PCF8584 does that when ESO is zero */
-	/* PCF also resets PIN bit */
-	if ((temp = get_pcf(adap, 1)) != (0)) {
-		DEB2(printk("i2c-algo-pcf.o: PCF detection failed -- can't select S0 (0x%02x).\n", temp));
+	if (((temp = get_pcf(adap, 1)) & 0x7f) != (0)) {
+		DEB2(printk(KERN_ERR "i2c-algo-pcf.o: PCF detection failed -- can't select S0 (0x%02x).\n", temp));
 		return -ENXIO; /* definetly not PCF8584 */
 	}
 
@@ -160,15 +158,15 @@
 	i2c_outb(adap, get_own(adap));
 	/* check it's realy writen */
 	if ((temp = i2c_inb(adap)) != get_own(adap)) {
-		DEB2(printk("i2c-algo-pcf.o: PCF detection failed -- can't set S0 (0x%02x).\n", temp));
+		DEB2(printk(KERN_ERR "i2c-algo-pcf.o: PCF detection failed -- can't set S0 (0x%02x).\n", temp));
 		return -ENXIO;
 	}
 
 	/* S1=0xA0, next byte in S2					*/
 	set_pcf(adap, 1, I2C_PCF_PIN | I2C_PCF_ES1);
 	/* check to see S2 now selected */
-	if ((temp = get_pcf(adap, 1)) != I2C_PCF_ES1) {
-		DEB2(printk("i2c-algo-pcf.o: PCF detection failed -- can't select S2 (0x%02x).\n", temp));
+	if (((temp = get_pcf(adap, 1)) & 0x7f) != I2C_PCF_ES1) {
+		DEB2(printk(KERN_ERR "i2c-algo-pcf.o: PCF detection failed -- can't select S2 (0x%02x).\n", temp));
 		return -ENXIO;
 	}
 
@@ -176,7 +174,7 @@
 	i2c_outb(adap, get_clock(adap));
 	/* check it's realy writen, the only 5 lowest bits does matter */
 	if (((temp = i2c_inb(adap)) & 0x1f) != get_clock(adap)) {
-		DEB2(printk("i2c-algo-pcf.o: PCF detection failed -- can't set S2 (0x%02x).\n", temp));
+		DEB2(printk(KERN_ERR "i2c-algo-pcf.o: PCF detection failed -- can't set S2 (0x%02x).\n", temp));
 		return -ENXIO;
 	}
 
@@ -185,11 +183,11 @@
 
 	/* check to see PCF is realy idled and we can access status register */
 	if ((temp = get_pcf(adap, 1)) != (I2C_PCF_PIN | I2C_PCF_BB)) {
-		DEB2(printk("i2c-algo-pcf.o: PCF detection failed -- can't select S1` (0x%02x).\n", temp));
+		DEB2(printk(KERN_ERR "i2c-algo-pcf.o: PCF detection failed -- can't select S1` (0x%02x).\n", temp));
 		return -ENXIO;
 	}
 	
-	printk("i2c-algo-pcf.o: deteted and initialized PCF8584.\n");
+	printk(KERN_DEBUG "i2c-algo-pcf.o: deteted and initialized PCF8584.\n");
 
 	return 0;
 }
@@ -215,7 +213,7 @@
 		i2c_stop(adap);
 		udelay(adap->udelay);
 	}
-	DEB2(if (i) printk("i2c-algo-pcf.o: needed %d retries for %d\n",i,
+	DEB2(if (i) printk(KERN_DEBUG "i2c-algo-pcf.o: needed %d retries for %d\n",i,
 	                   addr));
 	return ret;
 }
@@ -228,20 +226,20 @@
 	int wrcount, status, timeout;
     
 	for (wrcount=0; wrcount<count; ++wrcount) {
-		DEB2(printk("i2c-algo-pcf.o: %s i2c_write: writing %2.2X\n",
+		DEB2(printk(KERN_DEBUG "i2c-algo-pcf.o: %s i2c_write: writing %2.2X\n",
 		      i2c_adap->name, buf[wrcount]&0xff));
 		i2c_outb(adap, buf[wrcount]);
 		timeout = wait_for_pin(adap, &status);
 		if (timeout) {
 			i2c_stop(adap);
-			printk("i2c-algo-pcf.o: %s i2c_write: "
+			printk(KERN_ERR "i2c-algo-pcf.o: %s i2c_write: "
 			       "error - timeout.\n", i2c_adap->name);
 			return -EREMOTEIO; /* got a better one ?? */
 		}
 #ifndef STUB_I2C
 		if (status & I2C_PCF_LRB) {
 			i2c_stop(adap);
-			printk("i2c-algo-pcf.o: %s i2c_write: "
+			printk(KERN_ERR "i2c-algo-pcf.o: %s i2c_write: "
 			       "error - no ack.\n", i2c_adap->name);
 			return -EREMOTEIO; /* got a better one ?? */
 		}
@@ -269,14 +267,14 @@
 
 		if (wait_for_pin(adap, &status)) {
 			i2c_stop(adap);
-			printk("i2c-algo-pcf.o: pcf_readbytes timed out.\n");
+			printk(KERN_ERR "i2c-algo-pcf.o: pcf_readbytes timed out.\n");
 			return (-1);
 		}
 
 #ifndef STUB_I2C
 		if ((status & I2C_PCF_LRB) && (i != count)) {
 			i2c_stop(adap);
-			printk("i2c-algo-pcf.o: i2c_read: i2c_inb, No ack.\n");
+			printk(KERN_ERR "i2c-algo-pcf.o: i2c_read: i2c_inb, No ack.\n");
 			return (-1);
 		}
 #endif
@@ -312,18 +310,18 @@
 	if ( (flags & I2C_M_TEN)  ) { 
 		/* a ten bit address */
 		addr = 0xf0 | (( msg->addr >> 7) & 0x03);
-		DEB2(printk("addr0: %d\n",addr));
+		DEB2(printk(KERN_DEBUG "addr0: %d\n",addr));
 		/* try extended address code...*/
 		ret = try_address(adap, addr, retries);
 		if (ret!=1) {
-			printk("died at extended address code.\n");
+			printk(KERN_ERR "died at extended address code.\n");
 			return -EREMOTEIO;
 		}
 		/* the remaining 8 bit address */
 		i2c_outb(adap,msg->addr & 0x7f);
 /* Status check comes here */
 		if (ret != 1) {
-			printk("died at 2nd address code.\n");
+			printk(KERN_ERR "died at 2nd address code.\n");
 			return -EREMOTEIO;
 		}
 		if ( flags & I2C_M_RD ) {
@@ -332,7 +330,7 @@
 			addr |= 0x01;
 			ret = try_address(adap, addr, retries);
 			if (ret!=1) {
-				printk("died at extended address code.\n");
+				printk(KERN_ERR "died at extended address code.\n");
 				return -EREMOTEIO;
 			}
 		}
@@ -360,7 +358,7 @@
 	/* Check for bus busy */
 	timeout = wait_for_bb(adap);
 	if (timeout) {
-		DEB2(printk("i2c-algo-pcf.o: "
+		DEB2(printk(KERN_ERR "i2c-algo-pcf.o: "
 		            "Timeout waiting for BB in pcf_xfer\n");)
 		return -EIO;
 	}
@@ -368,7 +366,7 @@
 	for (i = 0;ret >= 0 && i < num; i++) {
 		pmsg = &msgs[i];
 
-		DEB2(printk("i2c-algo-pcf.o: Doing %s %d bytes to 0x%02x - %d of %d messages\n",
+		DEB2(printk(KERN_DEBUG "i2c-algo-pcf.o: Doing %s %d bytes to 0x%02x - %d of %d messages\n",
 		     pmsg->flags & I2C_M_RD ? "read" : "write",
                      pmsg->len, pmsg->addr, i + 1, num);)
     
@@ -383,7 +381,7 @@
 		timeout = wait_for_pin(adap, &status);
 		if (timeout) {
 			i2c_stop(adap);
-			DEB2(printk("i2c-algo-pcf.o: Timeout waiting "
+			DEB2(printk(KERN_ERR "i2c-algo-pcf.o: Timeout waiting "
 				    "for PIN(1) in pcf_xfer\n");)
 			return (-EREMOTEIO);
 		}
@@ -392,12 +390,12 @@
 		/* Check LRB (last rcvd bit - slave ack) */
 		if (status & I2C_PCF_LRB) {
 			i2c_stop(adap);
-			DEB2(printk("i2c-algo-pcf.o: No LRB(1) in pcf_xfer\n");)
+			DEB2(printk(KERN_ERR "i2c-algo-pcf.o: No LRB(1) in pcf_xfer\n");)
 			return (-EREMOTEIO);
 		}
 #endif
     
-		DEB3(printk("i2c-algo-pcf.o: Msg %d, addr=0x%x, flags=0x%x, len=%d\n",
+		DEB3(printk(KERN_DEBUG "i2c-algo-pcf.o: Msg %d, addr=0x%x, flags=0x%x, len=%d\n",
 			    i, msgs[i].addr, msgs[i].flags, msgs[i].len);)
     
 		/* Read */
@@ -407,20 +405,20 @@
                                             (i + 1 == num));
         
 			if (ret != pmsg->len) {
-				DEB2(printk("i2c-algo-pcf.o: fail: "
+				DEB2(printk(KERN_DEBUG "i2c-algo-pcf.o: fail: "
 					    "only read %d bytes.\n",ret));
 			} else {
-				DEB2(printk("i2c-algo-pcf.o: read %d bytes.\n",ret));
+				DEB2(printk(KERN_DEBUG "i2c-algo-pcf.o: read %d bytes.\n",ret));
 			}
 		} else { /* Write */
 			ret = pcf_sendbytes(i2c_adap, pmsg->buf, pmsg->len,
                                             (i + 1 == num));
         
 			if (ret != pmsg->len) {
-				DEB2(printk("i2c-algo-pcf.o: fail: "
+				DEB2(printk(KERN_DEBUG "i2c-algo-pcf.o: fail: "
 					    "only wrote %d bytes.\n",ret));
 			} else {
-				DEB2(printk("i2c-algo-pcf.o: wrote %d bytes.\n",ret));
+				DEB2(printk(KERN_DEBUG "i2c-algo-pcf.o: wrote %d bytes.\n",ret));
 			}
 		}
 	}
@@ -461,7 +459,7 @@
 	int i, status;
 	struct i2c_algo_pcf_data *pcf_adap = adap->algo_data;
 
-	DEB2(printk("i2c-algo-pcf.o: hw routines for %s registered.\n",
+	DEB2(printk(KERN_DEBUG "i2c-algo-pcf.o: hw routines for %s registered.\n",
 	            adap->name));
 
 	/* register new adapter to i2c module... */
@@ -514,7 +512,7 @@
 	int res;
 	if ((res = i2c_del_adapter(adap)) < 0)
 		return res;
-	DEB2(printk("i2c-algo-pcf.o: adapter unregistered: %s\n",adap->name));
+	DEB2(printk(KERN_DEBUG "i2c-algo-pcf.o: adapter unregistered: %s\n",adap->name));
 
 #ifdef MODULE
 	MOD_DEC_USE_COUNT;
@@ -524,7 +522,7 @@
 
 int __init i2c_algo_pcf_init (void)
 {
-	printk("i2c-algo-pcf.o: i2c pcf8584 algorithm module\n");
+	printk(KERN_INFO "i2c-algo-pcf.o: i2c pcf8584 algorithm module version %s (%s)\n", I2C_VERSION, I2C_DATE);
 	return 0;
 }
 
diff -Nru a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
--- a/drivers/i2c/i2c-core.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/i2c/i2c-core.c	Thu Jun 20 15:54:00 2002
@@ -20,7 +20,7 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi>.
    All SMBus-related things are written by Frodo Looijaard <frodol@dds.nl> */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -28,7 +28,6 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/config.h>
-
 #include <linux/i2c.h>
 
 /* ----- compatibility stuff ----------------------------------------------- */
@@ -158,7 +157,7 @@
 
 		proc_entry = create_proc_entry(name,0,proc_bus);
 		if (! proc_entry) {
-			printk("i2c-core.o: Could not create /proc/bus/%s\n",
+			printk(KERN_ERR "i2c-core.o: Could not create /proc/bus/%s\n",
 			       name);
 			res = -ENOENT;
 			goto ERROR1;
@@ -188,7 +187,7 @@
 			drivers[j]->attach_adapter(adap);
 	DRV_UNLOCK();
 	
-	DEB(printk("i2c-core.o: adapter %s registered as adapter %d.\n",
+	DEB(printk(KERN_DEBUG "i2c-core.o: adapter %s registered as adapter %d.\n",
 	           adap->name,i));
 
 	return 0;	
@@ -214,7 +213,7 @@
 		if (adap == adapters[i])
 			break;
 	if (I2C_ADAP_MAX == i) {
-		printk( "i2c-core.o: unregister_adapter adap [%s] not found.\n",
+		printk( KERN_WARNING "i2c-core.o: unregister_adapter adap [%s] not found.\n",
 			adap->name);
 		res = -ENODEV;
 		goto ERROR0;
@@ -229,7 +228,7 @@
 	for (j = 0; j < I2C_DRIVER_MAX; j++) 
 		if (drivers[j] && (drivers[j]->flags & I2C_DF_DUMMY))
 			if ((res = drivers[j]->attach_adapter(adap))) {
-				printk("i2c-core.o: can't detach adapter %s "
+				printk(KERN_WARNING "i2c-core.o: can't detach adapter %s "
 				       "while detaching driver %s: driver not "
 				       "detached!",adap->name,drivers[j]->name);
 				goto ERROR1;	
@@ -247,7 +246,7 @@
 		     * must be deleted, as this would cause invalid states.
 		     */
 			if ((res=client->driver->detach_client(client))) {
-				printk("i2c-core.o: adapter %s not "
+				printk(KERN_ERR "i2c-core.o: adapter %s not "
 					"unregistered, because client at "
 					"address %02x can't be detached. ",
 					adap->name, client->addr);
@@ -266,7 +265,7 @@
 	adap_count--;
 	
 	ADAP_UNLOCK();	
-	DEB(printk("i2c-core.o: adapter unregistered: %s\n",adap->name));
+	DEB(printk(KERN_DEBUG "i2c-core.o: adapter unregistered: %s\n",adap->name));
 	return 0;
 
 ERROR0:
@@ -305,7 +304,7 @@
 	
 	DRV_UNLOCK();	/* driver was successfully added */
 	
-	DEB(printk("i2c-core.o: driver %s registered.\n",driver->name));
+	DEB(printk(KERN_DEBUG "i2c-core.o: driver %s registered.\n",driver->name));
 	
 	ADAP_LOCK();
 
@@ -340,7 +339,7 @@
 	 * attached. If so, detach them to be able to kill the driver 
 	 * afterwards.
 	 */
-	DEB2(printk("i2c-core.o: unregister_driver - looking for clients.\n"));
+	DEB2(printk(KERN_DEBUG "i2c-core.o: unregister_driver - looking for clients.\n"));
 	/* removing clients does not depend on the notify flag, else 
 	 * invalid operation might (will!) result, when using stale client
 	 * pointers.
@@ -350,7 +349,7 @@
 		struct i2c_adapter *adap = adapters[k];
 		if (adap == NULL) /* skip empty entries. */
 			continue;
-		DEB2(printk("i2c-core.o: examining adapter %s:\n",
+		DEB2(printk(KERN_DEBUG "i2c-core.o: examining adapter %s:\n",
 			    adap->name));
 		if (driver->flags & I2C_DF_DUMMY) {
 		/* DUMMY drivers do not register their clients, so we have to
@@ -359,7 +358,7 @@
 		 * this or hell will break loose...  
 		 */
 			if ((res = driver->attach_adapter(adap))) {
-				printk("i2c-core.o: while unregistering "
+				printk(KERN_WARNING "i2c-core.o: while unregistering "
 				       "dummy driver %s, adapter %s could "
 				       "not be detached properly; driver "
 				       "not unloaded!",driver->name,
@@ -378,7 +377,7 @@
 					if ((res = driver->
 							detach_client(client)))
 					{
-						printk("i2c-core.o: while "
+						printk(KERN_ERR "i2c-core.o: while "
 						       "unregistering driver "
 						       "`%s', the client at "
 						       "address %02x of "
@@ -400,7 +399,7 @@
 	driver_count--;
 	DRV_UNLOCK();
 	
-	DEB(printk("i2c-core.o: driver unregistered: %s\n",driver->name));
+	DEB(printk(KERN_DEBUG "i2c-core.o: driver unregistered: %s\n",driver->name));
 	return 0;
 }
 
@@ -436,10 +435,10 @@
 	
 	if (adapter->client_register) 
 		if (adapter->client_register(client)) 
-			printk("i2c-core.o: warning: client_register seems "
+			printk(KERN_DEBUG "i2c-core.o: warning: client_register seems "
 			       "to have failed for client %02x at adapter %s\n",
 			       client->addr,adapter->name);
-	DEB(printk("i2c-core.o: client [%s] registered to adapter [%s](pos. %d).\n",
+	DEB(printk(KERN_DEBUG "i2c-core.o: client [%s] registered to adapter [%s](pos. %d).\n",
 		client->name, adapter->name,i));
 
 	if(client->flags & I2C_CLIENT_ALLOW_USE)
@@ -470,7 +469,7 @@
 	
 	if (adapter->client_unregister != NULL) 
 		if ((res = adapter->client_unregister(client))) {
-			printk("i2c-core.o: client_unregister [%s] failed, "
+			printk(KERN_ERR "i2c-core.o: client_unregister [%s] failed, "
 			       "client not detached",client->name);
 			return res;
 		}
@@ -478,7 +477,7 @@
 	adapter->clients[i] = NULL;
 	adapter->client_count--;
 
-	DEB(printk("i2c-core.o: client [%s] unregistered.\n",client->name));
+	DEB(printk(KERN_DEBUG "i2c-core.o: client [%s] unregistered.\n",client->name));
 	return 0;
 }
 
@@ -659,12 +658,12 @@
 	int i,j,k,order_nr,len=0,len_total;
 	int order[I2C_CLIENT_MAX];
 
-	if (count > 4000)
+	if (count > 4096)
 		return -EINVAL; 
 	len_total = file->f_pos + count;
 	/* Too bad if this gets longer (unlikely) */
-	if (len_total > 4000)
-		len_total = 4000;
+	if (len_total > 4096)
+		len_total = 4096;
 	for (i = 0; i < I2C_ADAP_MAX; i++)
 		if (adapters[i]->inode == inode->i_ino) {
 		/* We need a bit of slack in the kernel buffer; this makes the
@@ -720,13 +719,13 @@
 	i2cproc_initialized = 0;
 
 	if (! proc_bus) {
-		printk("i2c-core.o: /proc/bus/ does not exist");
+		printk(KERN_ERR "i2c-core.o: /proc/bus/ does not exist");
 		i2cproc_cleanup();
 		return -ENOENT;
  	} 
 	proc_bus_i2c = create_proc_entry("i2c",0,proc_bus);
 	if (!proc_bus_i2c) {
-		printk("i2c-core.o: Could not create /proc/bus/i2c");
+		printk(KERN_ERR "i2c-core.o: Could not create /proc/bus/i2c");
 		i2cproc_cleanup();
 		return -ENOENT;
  	}
@@ -763,7 +762,7 @@
 	int ret;
 
 	if (adap->algo->master_xfer) {
- 	 	DEB2(printk("i2c-core.o: master_xfer: %s with %d msgs.\n",
+ 	 	DEB2(printk(KERN_DEBUG "i2c-core.o: master_xfer: %s with %d msgs.\n",
 		            adap->name,num));
 
 		I2C_LOCK(adap);
@@ -772,7 +771,7 @@
 
 		return ret;
 	} else {
-		printk("i2c-core.o: I2C adapter %04x: I2C level transfers not supported\n",
+		printk(KERN_ERR "i2c-core.o: I2C adapter %04x: I2C level transfers not supported\n",
 		       adap->id);
 		return -ENOSYS;
 	}
@@ -790,7 +789,7 @@
 		msg.len = count;
 		(const char *)msg.buf = buf;
 	
-		DEB2(printk("i2c-core.o: master_send: writing %d bytes on %s.\n",
+		DEB2(printk(KERN_DEBUG "i2c-core.o: master_send: writing %d bytes on %s.\n",
 			count,client->adapter->name));
 	
 		I2C_LOCK(adap);
@@ -802,7 +801,7 @@
 		 */
 		return (ret == 1 )? count : ret;
 	} else {
-		printk("i2c-core.o: I2C adapter %04x: I2C level transfers not supported\n",
+		printk(KERN_ERR "i2c-core.o: I2C adapter %04x: I2C level transfers not supported\n",
 		       client->adapter->id);
 		return -ENOSYS;
 	}
@@ -820,14 +819,14 @@
 		msg.len = count;
 		msg.buf = buf;
 
-		DEB2(printk("i2c-core.o: master_recv: reading %d bytes on %s.\n",
+		DEB2(printk(KERN_DEBUG "i2c-core.o: master_recv: reading %d bytes on %s.\n",
 			count,client->adapter->name));
 	
 		I2C_LOCK(adap);
 		ret = adap->algo->master_xfer(adap,&msg,1);
 		I2C_UNLOCK(adap);
 	
-		DEB2(printk("i2c-core.o: master_recv: return:%d (count:%d, addr:0x%02x)\n",
+		DEB2(printk(KERN_DEBUG "i2c-core.o: master_recv: return:%d (count:%d, addr:0x%02x)\n",
 			ret, count, client->addr));
 	
 		/* if everything went ok (i.e. 1 msg transmitted), return #bytes
@@ -835,7 +834,7 @@
 	 	*/
 		return (ret == 1 )? count : ret;
 	} else {
-		printk("i2c-core.o: I2C adapter %04x: I2C level transfers not supported\n",
+		printk(KERN_DEBUG "i2c-core.o: I2C adapter %04x: I2C level transfers not supported\n",
 		       client->adapter->id);
 		return -ENOSYS;
 	}
@@ -848,7 +847,7 @@
 	int ret = 0;
 	struct i2c_adapter *adap = client->adapter;
 
-	DEB2(printk("i2c-core.o: i2c ioctl, cmd: 0x%x, arg: %#lx\n", cmd, arg));
+	DEB2(printk(KERN_DEBUG "i2c-core.o: i2c ioctl, cmd: 0x%x, arg: %#lx\n", cmd, arg));
 	switch ( cmd ) {
 		case I2C_RETRIES:
 			adap->retries = arg;
@@ -893,7 +892,7 @@
 			if (((adap_id == address_data->force[i]) || 
 			     (address_data->force[i] == ANY_I2C_BUS)) &&
 			     (addr == address_data->force[i+1])) {
-				DEB2(printk("i2c-core.o: found force parameter for adapter %d, addr %04x\n",
+				DEB2(printk(KERN_DEBUG "i2c-core.o: found force parameter for adapter %d, addr %04x\n",
 				            adap_id,addr));
 				if ((err = found_proc(adapter,addr,0,0)))
 					return err;
@@ -911,7 +910,7 @@
 			if (((adap_id == address_data->ignore[i]) || 
 			    ((address_data->ignore[i] == ANY_I2C_BUS))) &&
 			    (addr == address_data->ignore[i+1])) {
-				DEB2(printk("i2c-core.o: found ignore parameter for adapter %d, "
+				DEB2(printk(KERN_DEBUG "i2c-core.o: found ignore parameter for adapter %d, "
 				     "addr %04x\n", adap_id ,addr));
 				found = 1;
 			}
@@ -923,7 +922,7 @@
 			    ((address_data->ignore_range[i]==ANY_I2C_BUS))) &&
 			    (addr >= address_data->ignore_range[i+1]) &&
 			    (addr <= address_data->ignore_range[i+2])) {
-				DEB2(printk("i2c-core.o: found ignore_range parameter for adapter %d, "
+				DEB2(printk(KERN_DEBUG "i2c-core.o: found ignore_range parameter for adapter %d, "
 				            "addr %04x\n", adap_id,addr));
 				found = 1;
 			}
@@ -938,7 +937,7 @@
 		     i += 1) {
 			if (addr == address_data->normal_i2c[i]) {
 				found = 1;
-				DEB2(printk("i2c-core.o: found normal i2c entry for adapter %d, "
+				DEB2(printk(KERN_DEBUG "i2c-core.o: found normal i2c entry for adapter %d, "
 				            "addr %02x", adap_id,addr));
 			}
 		}
@@ -949,7 +948,7 @@
 			if ((addr >= address_data->normal_i2c_range[i]) &&
 			    (addr <= address_data->normal_i2c_range[i+1])) {
 				found = 1;
-				DEB2(printk("i2c-core.o: found normal i2c_range entry for adapter %d, "
+				DEB2(printk(KERN_DEBUG "i2c-core.o: found normal i2c_range entry for adapter %d, "
 				            "addr %04x\n", adap_id,addr));
 			}
 		}
@@ -961,7 +960,7 @@
 			    ((address_data->probe[i] == ANY_I2C_BUS))) &&
 			    (addr == address_data->probe[i+1])) {
 				found = 1;
-				DEB2(printk("i2c-core.o: found probe parameter for adapter %d, "
+				DEB2(printk(KERN_DEBUG "i2c-core.o: found probe parameter for adapter %d, "
 				            "addr %04x\n", adap_id,addr));
 			}
 		}
@@ -973,7 +972,7 @@
 			   (addr >= address_data->probe_range[i+1]) &&
 			   (addr <= address_data->probe_range[i+2])) {
 				found = 1;
-				DEB2(printk("i2c-core.o: found probe_range parameter for adapter %d, "
+				DEB2(printk(KERN_DEBUG "i2c-core.o: found probe_range parameter for adapter %d, "
 				            "addr %04x\n", adap_id,addr));
 			}
 		}
@@ -1110,6 +1109,23 @@
 	                      I2C_SMBUS_BLOCK_DATA,&data);
 }
 
+/* Returns the number of read bytes */
+extern s32 i2c_smbus_read_i2c_block_data(struct i2c_client * client,
+                                         u8 command, u8 *values)
+{
+	union i2c_smbus_data data;
+	int i;
+	if (i2c_smbus_xfer(client->adapter,client->addr,client->flags,
+	                      I2C_SMBUS_READ,command,
+	                      I2C_SMBUS_I2C_BLOCK_DATA,&data))
+		return -1;
+	else {
+		for (i = 1; i <= data.block[0]; i++)
+			values[i-1] = data.block[i];
+		return data.block[0];
+	}
+}
+
 extern s32 i2c_smbus_write_i2c_block_data(struct i2c_client * client,
                                           u8 command, u8 length, u8 *values)
 {
@@ -1185,23 +1201,38 @@
 		break;
 	case I2C_SMBUS_BLOCK_DATA:
 		if (read_write == I2C_SMBUS_READ) {
-			printk("i2c-core.o: Block read not supported under "
+			printk(KERN_ERR "i2c-core.o: Block read not supported under "
 			       "I2C emulation!\n");
 		return -1;
 		} else {
 			msg[0].len = data->block[0] + 2;
 			if (msg[0].len > 34) {
-				printk("i2c-core.o: smbus_access called with "
+				printk(KERN_ERR "i2c-core.o: smbus_access called with "
 				       "invalid block write size (%d)\n",
-				       msg[0].len);
+				       data->block[0]);
 				return -1;
 			}
 			for (i = 1; i <= msg[0].len; i++)
 				msgbuf0[i] = data->block[i-1];
 		}
 		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		if (read_write == I2C_SMBUS_READ) {
+			msg[1].len = 32;
+		} else {
+			msg[0].len = data->block[0] + 2;
+			if (msg[0].len > 34) {
+				printk("i2c-core.o: i2c_smbus_xfer_emulated called with "
+				       "invalid block write size (%d)\n",
+				       data->block[0]);
+				return -1;
+			}
+			for (i = 0; i < data->block[0]; i++)
+				msgbuf0[i] = data->block[i+1];
+		}
+		break;
 	default:
-		printk("i2c-core.o: smbus_access called with invalid size (%d)\n",
+		printk(KERN_ERR "i2c-core.o: smbus_access called with invalid size (%d)\n",
 		       size);
 		return -1;
 	}
@@ -1221,6 +1252,12 @@
 			case I2C_SMBUS_PROC_CALL:
 				data->word = msgbuf1[0] | (msgbuf1[1] << 8);
 				break;
+			case I2C_SMBUS_I2C_BLOCK_DATA:
+				/* fixed at 32 for now */
+				data->block[0] = 32;
+				for (i = 0; i < 32; i++)
+					data->block[i+1] = msgbuf1[i];
+				break;
 		}
 	return 0;
 }
@@ -1263,7 +1300,7 @@
 
 static int __init i2c_init(void)
 {
-	printk("i2c-core.o: i2c core module\n");
+	printk(KERN_INFO "i2c-core.o: i2c core module version %s (%s)\n", I2C_VERSION, I2C_DATE);
 	memset(adapters,0,sizeof(adapters));
 	memset(drivers,0,sizeof(drivers));
 	adap_count=0;
@@ -1401,6 +1438,8 @@
 EXPORT_SYMBOL(i2c_smbus_process_call);
 EXPORT_SYMBOL(i2c_smbus_read_block_data);
 EXPORT_SYMBOL(i2c_smbus_write_block_data);
+EXPORT_SYMBOL(i2c_smbus_read_i2c_block_data);
+EXPORT_SYMBOL(i2c_smbus_write_i2c_block_data);
 
 EXPORT_SYMBOL(i2c_get_functionality);
 EXPORT_SYMBOL(i2c_check_functionality);
diff -Nru a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c
--- a/drivers/i2c/i2c-dev.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/i2c/i2c-dev.c	Thu Jun 20 15:54:01 2002
@@ -28,7 +28,7 @@
 /* The devfs code is contributed by Philipp Matthias Hahn 
    <pmhahn@titan.lahn.de> */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -49,7 +49,6 @@
 
 #include <linux/init.h>
 #include <asm/uaccess.h>
-
 #include <linux/i2c.h>
 #include <linux/i2c-dev.h>
 
@@ -140,7 +139,7 @@
 {
 #ifdef DEBUG
 	struct inode *inode = file->f_dentry->d_inode;
-	printk("i2c-dev.o: i2c-%d lseek to %ld bytes relative to %d.\n",
+	printk(KERN_DEBUG "i2c-dev.o: i2c-%d lseek to %ld bytes relative to %d.\n",
 	       minor(inode->i_rdev),(long) offset,origin);
 #endif /* DEBUG */
 	return -ESPIPE;
@@ -165,7 +164,7 @@
 		return -ENOMEM;
 
 #ifdef DEBUG
-	printk("i2c-dev.o: i2c-%d reading %d bytes.\n",minor(inode->i_rdev),
+	printk(KERN_DEBUG "i2c-dev.o: i2c-%d reading %d bytes.\n",minor(inode->i_rdev),
 	       count);
 #endif
 
@@ -197,7 +196,7 @@
 	}
 
 #ifdef DEBUG
-	printk("i2c-dev.o: i2c-%d writing %d bytes.\n",minor(inode->i_rdev),
+	printk(KERN_DEBUG "i2c-dev.o: i2c-%d writing %d bytes.\n",minor(inode->i_rdev),
 	       count);
 #endif
 	ret = i2c_master_send(client,tmp,count);
@@ -217,7 +216,7 @@
 	unsigned long funcs;
 
 #ifdef DEBUG
-	printk("i2c-dev.o: i2c-%d ioctl, cmd: 0x%x, arg: %lx.\n", 
+	printk(KERN_DEBUG "i2c-dev.o: i2c-%d ioctl, cmd: 0x%x, arg: %lx.\n", 
 	       minor(inode->i_rdev),cmd, arg);
 #endif /* DEBUG */
 
@@ -315,7 +314,7 @@
 		    (data_arg.size != I2C_SMBUS_BLOCK_DATA) &&
 		    (data_arg.size != I2C_SMBUS_I2C_BLOCK_DATA)) {
 #ifdef DEBUG
-			printk("i2c-dev.o: size out of range (%x) in ioctl I2C_SMBUS.\n",
+			printk(KERN_DEBUG "i2c-dev.o: size out of range (%x) in ioctl I2C_SMBUS.\n",
 			       data_arg.size);
 #endif
 			return -EINVAL;
@@ -325,7 +324,7 @@
 		if ((data_arg.read_write != I2C_SMBUS_READ) && 
 		    (data_arg.read_write != I2C_SMBUS_WRITE)) {
 #ifdef DEBUG
-			printk("i2c-dev.o: read_write out of range (%x) in ioctl I2C_SMBUS.\n",
+			printk(KERN_DEBUG "i2c-dev.o: read_write out of range (%x) in ioctl I2C_SMBUS.\n",
 			       data_arg.read_write);
 #endif
 			return -EINVAL;
@@ -345,7 +344,7 @@
 
 		if (data_arg.data == NULL) {
 #ifdef DEBUG
-			printk("i2c-dev.o: data is NULL pointer in ioctl I2C_SMBUS.\n");
+			printk(KERN_DEBUG "i2c-dev.o: data is NULL pointer in ioctl I2C_SMBUS.\n");
 #endif
 			return -EINVAL;
 		}
@@ -387,7 +386,7 @@
 
 	if ((minor >= I2CDEV_ADAPS_MAX) || ! (i2cdev_adaps[minor])) {
 #ifdef DEBUG
-		printk("i2c-dev.o: Trying to open unattached adapter i2c-%d\n",
+		printk(KERN_DEBUG "i2c-dev.o: Trying to open unattached adapter i2c-%d\n",
 		       minor);
 #endif
 		return -ENODEV;
@@ -408,7 +407,7 @@
 #endif /* LINUX_KERNEL_VERSION < KERNEL_VERSION(2,4,0) */
 
 #ifdef DEBUG
-	printk("i2c-dev.o: opened i2c-%d\n",minor);
+	printk(KERN_DEBUG "i2c-dev.o: opened i2c-%d\n",minor);
 #endif
 	return 0;
 }
@@ -419,13 +418,18 @@
 	kfree(file->private_data);
 	file->private_data=NULL;
 #ifdef DEBUG
-	printk("i2c-dev.o: Closed: i2c-%d\n", minor);
+	printk(KERN_DEBUG "i2c-dev.o: Closed: i2c-%d\n", minor);
 #endif
 #if LINUX_KERNEL_VERSION < KERNEL_VERSION(2,4,0)
 	MOD_DEC_USE_COUNT;
+#else /* LINUX_KERNEL_VERSION >= KERNEL_VERSION(2,4,0) */
+	lock_kernel();
 #endif /* LINUX_KERNEL_VERSION < KERNEL_VERSION(2,4,0) */
 	if (i2cdev_adaps[minor]->dec_use)
 		i2cdev_adaps[minor]->dec_use(i2cdev_adaps[minor]);
+#if LINUX_KERNEL_VERSION >= KERNEL_VERSION(2,4,0)
+	unlock_kernel();
+#endif /* LINUX_KERNEL_VERSION >= KERNEL_VERSION(2,4,0) */
 	return 0;
 }
 
@@ -435,11 +439,11 @@
 	char name[8];
 
 	if ((i = i2c_adapter_id(adap)) < 0) {
-		printk("i2c-dev.o: Unknown adapter ?!?\n");
+		printk(KERN_DEBUG "i2c-dev.o: Unknown adapter ?!?\n");
 		return -ENODEV;
 	}
 	if (i >= I2CDEV_ADAPS_MAX) {
-		printk("i2c-dev.o: Adapter number too large?!? (%d)\n",i);
+		printk(KERN_DEBUG "i2c-dev.o: Adapter number too large?!? (%d)\n",i);
 		return -ENODEV;
 	}
 
@@ -452,7 +456,7 @@
 			S_IFCHR | S_IRUSR | S_IWUSR,
 			&i2cdev_fops, NULL);
 #endif
-		printk("i2c-dev.o: Registered '%s' as minor %d\n",adap->name,i);
+		printk(KERN_DEBUG "i2c-dev.o: Registered '%s' as minor %d\n",adap->name,i);
 	} else {
 		/* This is actually a detach_adapter call! */
 #ifdef CONFIG_DEVFS_FS
@@ -460,7 +464,7 @@
 #endif
 		i2cdev_adaps[i] = NULL;
 #ifdef DEBUG
-		printk("i2c-dev.o: Adapter unregistered: %s\n",adap->name);
+		printk(KERN_DEBUG "i2c-dev.o: Adapter unregistered: %s\n",adap->name);
 #endif
 	}
 
@@ -482,7 +486,7 @@
 {
 	int res;
 
-	printk("i2c-dev.o: i2c /dev entries driver module\n");
+	printk(KERN_INFO "i2c-dev.o: i2c /dev entries driver module version %s (%s)\n", I2C_VERSION, I2C_DATE);
 
 	i2cdev_initialized = 0;
 #ifdef CONFIG_DEVFS_FS
@@ -490,7 +494,7 @@
 #else
 	if (register_chrdev(I2C_MAJOR,"i2c",&i2cdev_fops)) {
 #endif
-		printk("i2c-dev.o: unable to get major %d for i2c bus\n",
+		printk(KERN_ERR "i2c-dev.o: unable to get major %d for i2c bus\n",
 		       I2C_MAJOR);
 		return -EIO;
 	}
@@ -500,7 +504,7 @@
 	i2cdev_initialized ++;
 
 	if ((res = i2c_add_driver(&i2cdev_driver))) {
-		printk("i2c-dev.o: Driver registration failed, module not inserted.\n");
+		printk(KERN_ERR "i2c-dev.o: Driver registration failed, module not inserted.\n");
 		i2cdev_cleanup();
 		return res;
 	}
@@ -514,7 +518,7 @@
 
 	if (i2cdev_initialized >= 2) {
 		if ((res = i2c_del_driver(&i2cdev_driver))) {
-			printk("i2c-dev.o: Driver deregistration failed, "
+			printk(KERN_ERR "i2c-dev.o: Driver deregistration failed, "
 			       "module not removed.\n");
 			return res;
 		}
@@ -528,7 +532,7 @@
 #else
 		if ((res = unregister_chrdev(I2C_MAJOR,"i2c"))) {
 #endif
-			printk("i2c-dev.o: unable to release major %d for i2c bus\n",
+			printk(KERN_ERR "i2c-dev.o: unable to release major %d for i2c bus\n",
 			       I2C_MAJOR);
 			return res;
 		}
diff -Nru a/drivers/i2c/i2c-elektor.c b/drivers/i2c/i2c-elektor.c
--- a/drivers/i2c/i2c-elektor.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/i2c/i2c-elektor.c	Thu Jun 20 15:54:00 2002
@@ -74,11 +74,12 @@
 {
 	int address = ctl ? (base + 1) : base;
 
-	if (ctl && irq) {
+	/* enable irq if any specified for serial operation */
+	if (ctl && irq && (val & I2C_PCF_ESO)) {
 		val |= I2C_PCF_ENI;
 	}
 
-	DEB3(printk("i2c-elektor.o: Write 0x%X 0x%02X\n", address, val & 255));
+	DEB3(printk(KERN_DEBUG "i2c-elektor.o: Write 0x%X 0x%02X\n", address, val & 255));
 
 	switch (mmapped) {
 	case 0: /* regular I/O */
@@ -99,7 +100,7 @@
 	int address = ctl ? (base + 1) : base;
 	int val = mmapped ? readb(address) : inb(address);
 
-	DEB3(printk("i2c-elektor.o: Read 0x%X 0x%02X\n", address, val));
+	DEB3(printk(KERN_DEBUG "i2c-elektor.o: Read 0x%X 0x%02X\n", address, val));
 
 	return (val);
 }
@@ -142,7 +143,7 @@
 {
 	if (!mmapped) {
 		if (check_region(base, 2) < 0 ) {
-			printk("i2c-elektor.o: requested I/O region (0x%X:2) is in use.\n", base);
+			printk(KERN_ERR "i2c-elektor.o: requested I/O region (0x%X:2) is in use.\n", base);
 			return -ENODEV;
 		} else {
 			request_region(base, 2, "i2c (isa bus adapter)");
@@ -150,7 +151,7 @@
 	}
 	if (irq > 0) {
 		if (request_irq(irq, pcf_isa_handler, 0, "PCF8584", 0) < 0) {
-			printk("i2c-elektor.o: Request irq%d failed\n", irq);
+			printk(KERN_ERR "i2c-elektor.o: Request irq%d failed\n", irq);
 			irq = 0;
 		} else
 			enable_irq(irq);
@@ -159,7 +160,7 @@
 }
 
 
-static void __exit pcf_isa_exit(void)
+static void pcf_isa_exit(void)
 {
 	if (irq > 0) {
 		disable_irq(irq);
@@ -238,7 +239,7 @@
 			/* yeap, we've found cypress, let's check config */
 			if (!pci_read_config_byte(cy693_dev, 0x47, &config)) {
 				
-				DEB3(printk("i2c-elektor.o: found cy82c693, config register 0x47 = 0x%02x.\n", config));
+				DEB3(printk(KERN_DEBUG "i2c-elektor.o: found cy82c693, config register 0x47 = 0x%02x.\n", config));
 
 				/* UP2000 board has this register set to 0xe1,
                                    but the most significant bit as seems can be 
@@ -260,7 +261,7 @@
 					   8.25 MHz (PCI/4) clock
 					   (this can be read from cypress) */
 					clock = I2C_PCF_CLK | I2C_PCF_TRNS90;
-					printk("i2c-elektor.o: found API UP2000 like board, will probe PCF8584 later.\n");
+					printk(KERN_INFO "i2c-elektor.o: found API UP2000 like board, will probe PCF8584 later.\n");
 				}
 			}
 		}
@@ -269,11 +270,11 @@
 
 	/* sanity checks for mmapped I/O */
 	if (mmapped && base < 0xc8000) {
-		printk("i2c-elektor.o: incorrect base address (0x%0X) specified for mmapped I/O.\n", base);
+		printk(KERN_ERR "i2c-elektor.o: incorrect base address (0x%0X) specified for mmapped I/O.\n", base);
 		return -ENODEV;
 	}
 
-	printk("i2c-elektor.o: i2c pcf8584-isa adapter module\n");
+	printk(KERN_INFO "i2c-elektor.o: i2c pcf8584-isa adapter module version %s (%s)\n", I2C_VERSION, I2C_DATE);
 
 	if (base == 0) {
 		base = DEFAULT_BASE;
@@ -283,13 +284,15 @@
 	init_waitqueue_head(&pcf_wait);
 #endif
 	if (pcf_isa_init() == 0) {
-		if (i2c_pcf_add_bus(&pcf_isa_ops) < 0)
+		if (i2c_pcf_add_bus(&pcf_isa_ops) < 0) {
+			pcf_isa_exit();
 			return -ENODEV;
+		}
 	} else {
 		return -ENODEV;
 	}
 	
-	printk("i2c-elektor.o: found device at %#x.\n", base);
+	printk(KERN_ERR "i2c-elektor.o: found device at %#x.\n", base);
 
 	return 0;
 }
diff -Nru a/drivers/i2c/i2c-elv.c b/drivers/i2c/i2c-elv.c
--- a/drivers/i2c/i2c-elv.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/i2c/i2c-elv.c	Thu Jun 20 15:54:01 2002
@@ -21,7 +21,7 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
    Frodo Looijaard <frodol@dds.nl> */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -29,9 +29,7 @@
 #include <linux/slab.h>
 #include <linux/version.h>
 #include <linux/init.h>
-
 #include <asm/uaccess.h>
-
 #include <linux/ioport.h>
 #include <asm/io.h>
 #include <linux/errno.h>
@@ -95,14 +93,14 @@
 	} else {
 						/* test for ELV adap. 	*/
 		if (inb(base+1) & 0x80) {	/* BUSY should be high	*/
-			DEBINIT(printk("i2c-elv.o: Busy was low.\n"));
+			DEBINIT(printk(KERN_DEBUG "i2c-elv.o: Busy was low.\n"));
 			return -ENODEV;
 		} else {
 			outb(0x0c,base+2);	/* SLCT auf low		*/
 			udelay(400);
 			if ( !(inb(base+1) && 0x10) ) {
 				outb(0x04,base+2);
-				DEBINIT(printk("i2c-elv.o: Select was high.\n"));
+				DEBINIT(printk(KERN_DEBUG "i2c-elv.o: Select was high.\n"));
 				return -ENODEV;
 			}
 		}
@@ -170,7 +168,7 @@
 
 int __init i2c_bitelv_init(void)
 {
-	printk("i2c-elv.o: i2c ELV parallel port adapter module\n");
+	printk(KERN_INFO "i2c-elv.o: i2c ELV parallel port adapter module version %s (%s)\n", I2C_VERSION, I2C_DATE);
 	if (base==0) {
 		/* probe some values */
 		base=DEFAULT_BASE;
@@ -190,7 +188,7 @@
 			return -ENODEV;
 		}
 	}
-	printk("i2c-elv.o: found device at %#x.\n",base);
+	printk(KERN_DEBUG "i2c-elv.o: found device at %#x.\n",base);
 	return 0;
 }
 
diff -Nru a/drivers/i2c/i2c-philips-par.c b/drivers/i2c/i2c-philips-par.c
--- a/drivers/i2c/i2c-philips-par.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/i2c/i2c-philips-par.c	Thu Jun 20 15:54:00 2002
@@ -21,7 +21,7 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
    Frodo Looijaard <frodol@dds.nl> */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/kernel.h>
 #include <linux/ioport.h>
@@ -29,7 +29,6 @@
 #include <linux/init.h>
 #include <linux/stddef.h>
 #include <linux/parport.h>
-
 #include <linux/i2c.h>
 #include <linux/i2c-algo-bit.h>
 
@@ -190,18 +189,18 @@
 	struct i2c_par *adapter = kmalloc(sizeof(struct i2c_par),
 					  GFP_KERNEL);
 	if (!adapter) {
-		printk("i2c-philips-par: Unable to malloc.\n");
+		printk(KERN_ERR "i2c-philips-par: Unable to malloc.\n");
 		return;
 	}
 
-	printk("i2c-philips-par.o: attaching to %s\n", port->name);
+	printk(KERN_DEBUG "i2c-philips-par.o: attaching to %s\n", port->name);
 
 	adapter->pdev = parport_register_device(port, "i2c-philips-par",
 						NULL, NULL, NULL, 
 						PARPORT_FLAG_EXCL,
 						NULL);
 	if (!adapter->pdev) {
-		printk("i2c-philips-par: Unable to register with parport.\n");
+		printk(KERN_ERR "i2c-philips-par: Unable to register with parport.\n");
 		return;
 	}
 
@@ -210,15 +209,18 @@
 	adapter->bit_lp_data = type ? bit_lp_data2 : bit_lp_data;
 	adapter->bit_lp_data.data = port;
 
+	if (parport_claim_or_block(adapter->pdev) < 0 ) {
+		printk(KERN_ERR "i2c-philips-par: Could not claim parallel port.\n");
+		return;
+	}
 	/* reset hardware to sane state */
-	parport_claim_or_block(adapter->pdev);
 	bit_lp_setsda(port, 1);
 	bit_lp_setscl(port, 1);
 	parport_release(adapter->pdev);
 
 	if (i2c_bit_add_bus(&adapter->adapter) < 0)
 	{
-		printk("i2c-philips-par: Unable to register with I2C.\n");
+		printk(KERN_ERR "i2c-philips-par: Unable to register with I2C.\n");
 		parport_unregister_device(adapter->pdev);
 		kfree(adapter);
 		return;		/* No good */
@@ -264,7 +266,7 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,4)
 	struct parport *port;
 #endif
-	printk("i2c-philips-par.o: i2c Philips parallel port adapter module\n");
+	printk(KERN_INFO "i2c-philips-par.o: i2c Philips parallel port adapter module version %s (%s)\n", I2C_VERSION, I2C_DATE);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,4)
 	parport_register_driver(&i2c_driver);
diff -Nru a/drivers/i2c/i2c-proc.c b/drivers/i2c/i2c-proc.c
--- a/drivers/i2c/i2c-proc.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/i2c/i2c-proc.c	Thu Jun 20 15:54:01 2002
@@ -32,16 +32,10 @@
 #include <linux/proc_fs.h>
 #include <linux/ioport.h>
 #include <asm/uaccess.h>
-
 #include <linux/i2c.h>
 #include <linux/i2c-proc.h>
-
 #include <linux/init.h>
 
-/* FIXME need i2c versioning */
-#define LM_DATE "20010825"
-#define LM_VERSION "2.6.1"
-
 #ifndef THIS_MODULE
 #define THIS_MODULE NULL
 #endif
@@ -175,6 +169,7 @@
 		new_table[i].extra2 = client;
 
 	if (!(new_header = register_sysctl_table(new_table, 0))) {
+		printk(KERN_ERR "i2c-proc.o: error: sysctl interface not supported by kernel!\n");
 		kfree(new_table);
 		kfree(name);
 		return -ENOMEM;
@@ -189,7 +184,7 @@
 	    !new_header->ctl_table->child->child ||
 	    !new_header->ctl_table->child->child->de) {
 		printk
-		    ("i2c-proc.o: NULL pointer when trying to install fill_inode fix!\n");
+		    (KERN_ERR "i2c-proc.o: NULL pointer when trying to install fill_inode fix!\n");
 		return id;
 	}
 #endif				/* DEBUG */
@@ -629,7 +624,7 @@
 				    && (addr == this_force->force[j + 1])) {
 #ifdef DEBUG
 					printk
-					    ("i2c-proc.o: found force parameter for adapter %d, addr %04x\n",
+					    (KERN_DEBUG "i2c-proc.o: found force parameter for adapter %d, addr %04x\n",
 					     adapter_id, addr);
 #endif
 					if (
@@ -659,7 +654,7 @@
 			    && (addr == address_data->ignore[i + 1])) {
 #ifdef DEBUG
 				printk
-				    ("i2c-proc.o: found ignore parameter for adapter %d, "
+				    (KERN_DEBUG "i2c-proc.o: found ignore parameter for adapter %d, "
 				     "addr %04x\n", adapter_id, addr);
 #endif
 				found = 1;
@@ -679,7 +674,7 @@
 			    && (addr <= address_data->ignore_range[i + 2])) {
 #ifdef DEBUG
 				printk
-				    ("i2c-proc.o: found ignore_range parameter for adapter %d, "
+				    (KERN_DEBUG "i2c-proc.o: found ignore_range parameter for adapter %d, "
 				     "addr %04x\n", adapter_id, addr);
 #endif
 				found = 1;
@@ -698,7 +693,7 @@
 				if (addr == address_data->normal_isa[i]) {
 #ifdef DEBUG
 					printk
-					    ("i2c-proc.o: found normal isa entry for adapter %d, "
+					    (KERN_DEBUG "i2c-proc.o: found normal isa entry for adapter %d, "
 					     "addr %04x\n", adapter_id,
 					     addr);
 #endif
@@ -720,7 +715,7 @@
 				     0)) {
 #ifdef DEBUG
 					printk
-					    ("i2c-proc.o: found normal isa_range entry for adapter %d, "
+					    (KERN_DEBUG "i2c-proc.o: found normal isa_range entry for adapter %d, "
 					     "addr %04x", adapter_id, addr);
 #endif
 					found = 1;
@@ -734,7 +729,7 @@
 					found = 1;
 #ifdef DEBUG
 					printk
-					    ("i2c-proc.o: found normal i2c entry for adapter %d, "
+					    (KERN_DEBUG "i2c-proc.o: found normal i2c entry for adapter %d, "
 					     "addr %02x", adapter_id, addr);
 #endif
 				}
@@ -750,7 +745,7 @@
 				{
 #ifdef DEBUG
 					printk
-					    ("i2c-proc.o: found normal i2c_range entry for adapter %d, "
+					    (KERN_DEBUG "i2c-proc.o: found normal i2c_range entry for adapter %d, "
 					     "addr %04x\n", adapter_id, addr);
 #endif
 					found = 1;
@@ -767,7 +762,7 @@
 			    && (addr == address_data->probe[i + 1])) {
 #ifdef DEBUG
 				printk
-				    ("i2c-proc.o: found probe parameter for adapter %d, "
+				    (KERN_DEBUG "i2c-proc.o: found probe parameter for adapter %d, "
 				     "addr %04x\n", adapter_id, addr);
 #endif
 				found = 1;
@@ -786,7 +781,7 @@
 				found = 1;
 #ifdef DEBUG
 				printk
-				    ("i2c-proc.o: found probe_range parameter for adapter %d, "
+				    (KERN_DEBUG "i2c-proc.o: found probe_range parameter for adapter %d, "
 				     "addr %04x\n", adapter_id, addr);
 #endif
 			}
@@ -807,11 +802,14 @@
 
 int __init sensors_init(void)
 {
-	printk("i2c-proc.o version %s (%s)\n", LM_VERSION, LM_DATE);
+	printk(KERN_INFO "i2c-proc.o version %s (%s)\n", I2C_VERSION, I2C_DATE);
 	i2c_initialized = 0;
 	if (!
 	    (i2c_proc_header =
-	     register_sysctl_table(i2c_proc, 0))) return -ENOMEM;
+	     register_sysctl_table(i2c_proc, 0))) {
+		printk(KERN_ERR "i2c-proc.o: error: sysctl interface not supported by kernel!\n");
+		return -EPERM;
+	}
 	i2c_proc_header->ctl_table->child->de->owner = THIS_MODULE;
 	i2c_initialized++;
 	return 0;
@@ -847,4 +845,5 @@
 {
 	return i2c_cleanup();
 }
+
 #endif				/* MODULE */
diff -Nru a/drivers/i2c/i2c-velleman.c b/drivers/i2c/i2c-velleman.c
--- a/drivers/i2c/i2c-velleman.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/i2c/i2c-velleman.c	Thu Jun 20 15:54:00 2002
@@ -18,7 +18,7 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
 /* ------------------------------------------------------------------------- */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <linux/kernel.h>
 #include <linux/ioport.h>
@@ -27,7 +27,6 @@
 #include <linux/string.h>  /* for 2.0 kernels to get NULL   */
 #include <asm/errno.h>     /* for 2.0 kernels to get ENODEV */
 #include <asm/io.h>
-
 #include <linux/i2c.h>
 #include <linux/i2c-algo-bit.h>
 
@@ -91,7 +90,7 @@
 static int bit_velle_init(void)
 {
 	if (check_region(base,(base == 0x3bc)? 3 : 8) < 0 ) {
-		DEBE(printk("i2c-velleman.o: Port %#x already in use.\n",
+		DEBE(printk(KERN_DEBUG "i2c-velleman.o: Port %#x already in use.\n",
 		     base));
 		return -ENODEV;
 	} else {
@@ -160,7 +159,7 @@
 
 int __init  i2c_bitvelle_init(void)
 {
-	printk("i2c-velleman.o: i2c Velleman K8000 adapter module\n");
+	printk(KERN_INFO "i2c-velleman.o: i2c Velleman K8000 adapter module version %s (%s)\n", I2C_VERSION, I2C_DATE);
 	if (base==0) {
 		/* probe some values */
 		base=DEFAULT_BASE;
@@ -180,7 +179,7 @@
 			return -ENODEV;
 		}
 	}
-	printk("i2c-velleman.o: found device at %#x.\n",base);
+	printk(KERN_DEBUG "i2c-velleman.o: found device at %#x.\n",base);
 	return 0;
 }
 
diff -Nru a/drivers/ide/Config.in b/drivers/ide/Config.in
--- a/drivers/ide/Config.in	Thu Jun 20 15:54:01 2002
+++ b/drivers/ide/Config.in	Thu Jun 20 15:54:01 2002
@@ -142,8 +142,8 @@
    define_bool CONFIG_IDEDMA_AUTO n
 fi
 
-dep_tristate 'Support for IDE Raid controllers' CONFIG_BLK_DEV_ATARAID $CONFIG_BLK_DEV_IDE $CONFIG_EXPERIMENTAL
-dep_tristate '   Support Promise software RAID (Fasttrak(tm))' CONFIG_BLK_DEV_ATARAID_PDC $CONFIG_BLK_DEV_IDE $CONFIG_EXPERIMENTAL $CONFIG_BLK_DEV_ATARAID
-dep_tristate '   Highpoint 370 software RAID' CONFIG_BLK_DEV_ATARAID_HPT $CONFIG_BLK_DEV_IDE $CONFIG_EXPERIMENTAL $CONFIG_BLK_DEV_ATARAID
+dep_tristate 'Support for IDE Raid controllers (EXPERIMENTAL)' CONFIG_BLK_DEV_ATARAID $CONFIG_BLK_DEV_IDE $CONFIG_EXPERIMENTAL
+dep_tristate '   Support Promise software RAID (Fasttrak(tm)) (EXPERIMENTAL)' CONFIG_BLK_DEV_ATARAID_PDC $CONFIG_BLK_DEV_IDE $CONFIG_EXPERIMENTAL $CONFIG_BLK_DEV_ATARAID
+dep_tristate '   Highpoint 370 software RAID (EXPERIMENTAL)' CONFIG_BLK_DEV_ATARAID_HPT $CONFIG_BLK_DEV_IDE $CONFIG_EXPERIMENTAL $CONFIG_BLK_DEV_ATARAID
 
 endmenu
diff -Nru a/drivers/ide/cmd64x.c b/drivers/ide/cmd64x.c
--- a/drivers/ide/cmd64x.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/ide/cmd64x.c	Thu Jun 20 15:54:00 2002
@@ -597,7 +597,6 @@
 	struct pci_dev *dev	= ch->pci_dev;
 	u8 jack_slap		= ((dev->device == PCI_DEVICE_ID_CMD_648) || (dev->device == PCI_DEVICE_ID_CMD_649)) ? 1 : 0;
 
-	drive->waiting_for_dma = 0;
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(dma_stat|6, dma_base+2);		/* clear the INTR & ERROR bits */
@@ -647,7 +646,6 @@
 	unsigned long dma_base = ch->dma_base;
 	u8 dma_stat;
 
-	drive->waiting_for_dma = 0;
 	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	outb(dma_stat|6, dma_base+2);		/* clear the INTR & ERROR bits */
diff -Nru a/drivers/ide/hpt34x.c b/drivers/ide/hpt34x.c
--- a/drivers/ide/hpt34x.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/ide/hpt34x.c	Thu Jun 20 15:54:00 2002
@@ -157,7 +157,6 @@
 	unsigned long dma_base = ch->dma_base;
 	u8 dma_stat;
 
-	drive->waiting_for_dma = 0;
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(dma_stat|6, dma_base+2);		/* clear the INTR & ERROR bits */
@@ -184,7 +183,6 @@
 	outl(ch->dmatable_dma, dma_base + 4);	/* PRD table */
 	outb(cmd, dma_base);			/* specify r/w */
 	outb(inb(dma_base+2)|6, dma_base+2);	/* clear INTR & ERROR flags */
-	drive->waiting_for_dma = 1;
 
 	if (drive->type == ATA_DISK) {
 		ata_set_handler(drive, ide_dma_intr, WAIT_CMD, NULL);	/* issue cmd to drive */
diff -Nru a/drivers/ide/hpt366.c b/drivers/ide/hpt366.c
--- a/drivers/ide/hpt366.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/ide/hpt366.c	Thu Jun 20 15:54:00 2002
@@ -890,7 +890,6 @@
 		do_udma_start(drive);
 	}
 
-	drive->waiting_for_dma = 0;
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(dma_stat|6, dma_base+2);		/* clear the INTR & ERROR bits */
@@ -913,7 +912,6 @@
 	if ((bwsr_stat & bwsr_mask) == bwsr_mask)
 	        pci_write_config_byte(dev, mscreg, msc_stat|0x30);
 
-	drive->waiting_for_dma = 0;
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(dma_stat|6, dma_base+2);		/* clear the INTR & ERROR bits */
diff -Nru a/drivers/ide/icside.c b/drivers/ide/icside.c
--- a/drivers/ide/icside.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/ide/icside.c	Thu Jun 20 15:54:00 2002
@@ -440,7 +440,6 @@
 {
 	struct ata_channel *ch = drive->channel;
 
-	drive->waiting_for_dma = 0;
 	disable_dma(ch->hw.dma);
 	icside_destroy_dmatable(drive);
 
@@ -507,8 +506,6 @@
 	 */
 	set_dma_sg(ch->hw.dma, ch->sg_table, count);
 	set_dma_mode(ch->hw.dma, dma_mode);
-
-	drive->waiting_for_dma = 1;
 
 	return 0;
 }
diff -Nru a/drivers/ide/ide-disk.c b/drivers/ide/ide-disk.c
--- a/drivers/ide/ide-disk.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/ide/ide-disk.c	Thu Jun 20 15:53:59 2002
@@ -93,74 +93,61 @@
 /*
  * Handler for command with PIO data-in phase.
  */
-static ide_startstop_t pio_in_intr(struct ata_device *drive, struct request *rq)
+static ide_startstop_t task_in_intr(struct ata_device *drive, struct request *rq)
 {
 	unsigned long flags;
 	struct ata_channel *ch = drive->channel;
-	unsigned int msect;
+	int ret;
 
 	spin_lock_irqsave(ch->lock, flags);
+
 	if (!ata_status(drive, DATA_READY, BAD_R_STAT)) {
-		if (drive->status & (ERR_STAT|DRQ_STAT)) {
+		if (drive->status & (ERR_STAT | DRQ_STAT)) {
 			spin_unlock_irqrestore(ch->lock, flags);
 
 			return ata_error(drive, rq, __FUNCTION__);
 		}
 
-		if (!(drive->status & BUSY_STAT))
-			goto cont;
-	}
-
-	msect = drive->mult_count;
-	do {
-		unsigned int nsect;
+		/* no data yet, so wait for another interrupt */
+		ata_set_handler(drive, task_in_intr, WAIT_CMD, NULL);
 
-		if (drive->mult_count) {
-			nsect = rq->current_nr_sectors;
-			/* Don't try to transfer more sectors at once then one
-			 * multi sector command can swallow.
-			 */
-			if (nsect > msect)
-				nsect = msect;
-		} else {
-			nsect = rq->current_nr_sectors;
-			nsect = 1;
-		}
+		ret = ide_started;
+	} else {
 
-//		printk("Read: rq->current_nr_sectors: %d %d %d\n", msect, nsect,  (int) rq->current_nr_sectors);
+		//	printk("Read: %p, rq->current_nr_sectors: %d\n", buf, (int) rq->current_nr_sectors);
 		{
 			unsigned long flags;
 			char *buf;
 
 			buf = ide_map_rq(rq, &flags);
-			ata_read(drive, buf, nsect * SECTOR_WORDS);
+			ata_read(drive, buf, SECTOR_WORDS);
 			ide_unmap_rq(rq, buf, &flags);
 		}
 
-		/* Segment of the request is complete. note that this does not
-		 * necessarily mean that the entire request is done!! this is
-		 * only true if ata_end_request() returns 0.
+		/* First segment of the request is complete. note that this does not
+		 * necessarily mean that the entire request is done!! this is only true
+		 * if ata_end_request() returns 0.
 		 */
-
 		rq->errors = 0;
-		rq->current_nr_sectors -= nsect;
+		--rq->current_nr_sectors;
 
 		if (rq->current_nr_sectors <= 0) {
 			if (!__ata_end_request(drive, rq, 1, 0)) {
+			//		printk("Request Ended stat: %02x\n", drive->status);
 				spin_unlock_irqrestore(ch->lock, flags);
 
 				return ide_stopped;
 			}
 		}
-		msect -= nsect;
-	} while (msect > 0);
 
-cont:
-	/* still data left to transfer */
-	ata_set_handler(drive, pio_in_intr,  WAIT_CMD, NULL);
+		/* still data left to transfer */
+		ata_set_handler(drive, task_in_intr,  WAIT_CMD, NULL);
+
+		ret = ide_started;
+	}
 	spin_unlock_irqrestore(ch->lock, flags);
 
-	return ide_started;
+	return ret;
 }
 
 /*
@@ -203,6 +190,77 @@
 	return ret;
 }
 
+/*
+ * Handler for command with Read Multiple
+ */
+static ide_startstop_t task_mulin_intr(struct ata_device *drive, struct request *rq)
+{
+	unsigned long flags;
+	struct ata_channel *ch = drive->channel;
+	int ret;
+
+	spin_lock_irqsave(ch->lock, flags);
+	if (!ata_status(drive, DATA_READY, BAD_R_STAT)) {
+		if (drive->status & (ERR_STAT | DRQ_STAT)) {
+			spin_unlock_irqrestore(ch->lock, flags);
+
+			return ata_error(drive, rq, __FUNCTION__);
+		}
+
+		/* no data yet, so wait for another interrupt */
+		ata_set_handler(drive, task_mulin_intr, WAIT_CMD, NULL);
+
+		ret = ide_started;
+	} else {
+		unsigned int msect;
+
+		/* (ks/hs): Fixed Multi-Sector transfer */
+		msect = drive->mult_count;
+
+		do {
+			unsigned int nsect;
+
+			nsect = rq->current_nr_sectors;
+			if (nsect > msect)
+				nsect = msect;
+
+#if 0
+			printk("Multiread: %p, nsect: %d , rq->current_nr_sectors: %d\n",
+					buf, nsect, rq->current_nr_sectors);
+#endif
+			{
+				unsigned long flags;
+				char *buf;
+
+				buf = ide_map_rq(rq, &flags);
+				ata_read(drive, buf, nsect * SECTOR_WORDS);
+				ide_unmap_rq(rq, buf, &flags);
+			}
+
+			rq->errors = 0;
+			rq->current_nr_sectors -= nsect;
+
+			/* FIXME: this seems buggy */
+			if (rq->current_nr_sectors <= 0) {
+				if (!__ata_end_request(drive, rq, 1, 0)) {
+					spin_unlock_irqrestore(ch->lock, flags);
+
+					return ide_stopped;
+				}
+			}
+			msect -= nsect;
+		} while (msect);
+
+		/* more data left */
+		ata_set_handler(drive, task_mulin_intr, WAIT_CMD, NULL);
+
+		ret = ide_started;
+	}
+	spin_unlock_irqrestore(ch->lock, flags);
+
+	return ret;
+}
+
 static ide_startstop_t task_mulout_intr(struct ata_device *drive, struct request *rq)
 {
 	unsigned long flags;
@@ -552,10 +610,10 @@
 			} else if (drive->using_dma) {
 				args.cmd = WIN_READDMA_EXT;
 			} else if (drive->mult_count) {
-				args.XXX_handler = pio_in_intr;
+				args.XXX_handler = task_mulin_intr;
 				args.cmd = WIN_MULTREAD_EXT;
 			} else {
-				args.XXX_handler = pio_in_intr;
+				args.XXX_handler = task_in_intr;
 				args.cmd = WIN_READ_EXT;
 			}
 		} else {
@@ -564,10 +622,11 @@
 			} else if (drive->using_dma) {
 				args.cmd = WIN_READDMA;
 			} else if (drive->mult_count) {
-				args.XXX_handler = pio_in_intr;
+				/* FIXME : Shouldn't this be task_mulin_intr?! */
+				args.XXX_handler = task_in_intr;
 				args.cmd = WIN_MULTREAD;
 			} else {
-				args.XXX_handler = pio_in_intr;
+				args.XXX_handler = task_in_intr;
 				args.cmd = WIN_READ;
 			}
 		}
@@ -614,19 +673,6 @@
 	return __do_request(drive, &args, rq);
 }
 
-/*
- * Small helper function used to execute simple commands.
- */
-static int simple_taskfile(struct ata_device *drive, u8 cmd)
-{
-	struct ata_taskfile args;
-
-	memset(&args, 0, sizeof(args));
-	args.cmd = cmd;
-
-	return ide_raw_taskfile(drive, &args, NULL);
-}
-
 static int idedisk_open(struct inode *inode, struct file *__fp, struct ata_device *drive)
 {
 	MOD_INC_USE_COUNT;
@@ -635,11 +681,15 @@
 
 		/*
 		 * Ignore the return code from door_lock, since the open() has
-		 * already succeeded once, and the door_lock is irrelevant at
-		 * this time.
+		 * already succeeded once, and the door_lock is irrelevant at this
+		 * time.
 		 */
 		if (drive->doorlocking) {
-			if (simple_taskfile(drive, WIN_DOORLOCK))
+			struct ata_taskfile args;
+
+			memset(&args, 0, sizeof(args));
+			args.cmd = WIN_DOORLOCK;
+			if (ide_raw_taskfile(drive, &args))
 				drive->doorlocking = 0;
 		}
 	}
@@ -649,21 +699,30 @@
 
 static int flush_cache(struct ata_device *drive)
 {
-	u8 cmd;
+	struct ata_taskfile args;
+
+	memset(&args, 0, sizeof(args));
 
 	if (drive->id->cfs_enable_2 & 0x2400)
-		cmd = WIN_FLUSH_CACHE_EXT;
+		args.cmd = WIN_FLUSH_CACHE_EXT;
 	else
-		cmd = WIN_FLUSH_CACHE;
+		args.cmd = WIN_FLUSH_CACHE;
 
-	return simple_taskfile(drive, cmd);
+	return ide_raw_taskfile(drive, &args);
 }
 
 static void idedisk_release(struct inode *inode, struct file *filp, struct ata_device *drive)
 {
 	if (drive->removable && !drive->usage) {
+		/* XXX I don't think this is up to the lowlevel drivers..  --hch */
+		invalidate_bdev(inode->i_bdev, 0);
+
 		if (drive->doorlocking) {
-			if (simple_taskfile(drive, WIN_DOORUNLOCK))
+			struct ata_taskfile args;
+
+			memset(&args, 0, sizeof(args));
+			args.cmd = WIN_DOORUNLOCK;
+			if (ide_raw_taskfile(drive, &args))
 				drive->doorlocking = 0;
 		}
 	}
@@ -710,7 +769,7 @@
 	memset(&args, 0, sizeof(args));
 	args.taskfile.sector_count = arg;
 	args.cmd = WIN_SETMULT;
-	if (!ide_raw_taskfile(drive, &args, NULL)) {
+	if (!ide_raw_taskfile(drive, &args)) {
 		/* all went well track this setting as valid */
 		drive->mult_count = arg;
 
@@ -739,7 +798,7 @@
 	memset(&args, 0, sizeof(args));
 	args.taskfile.feature	= (arg) ? SETFEATURES_EN_WCACHE : SETFEATURES_DIS_WCACHE;
 	args.cmd = WIN_SETFEATURES;
-	ide_raw_taskfile(drive, &args, NULL);
+	ide_raw_taskfile(drive, &args);
 
 	drive->wcache = arg;
 
@@ -748,7 +807,11 @@
 
 static int idedisk_standby(struct ata_device *drive)
 {
-	return simple_taskfile(drive, WIN_STANDBYNOW1);
+	struct ata_taskfile args;
+
+	memset(&args, 0, sizeof(args));
+	args.cmd = WIN_STANDBYNOW1;
+	return ide_raw_taskfile(drive, &args);
 }
 
 static int set_acoustic(struct ata_device *drive, int arg)
@@ -759,7 +822,7 @@
 	args.taskfile.feature = (arg)?SETFEATURES_EN_AAM:SETFEATURES_DIS_AAM;
 	args.taskfile.sector_count = arg;
 	args.cmd = WIN_SETFEATURES;
-	ide_raw_taskfile(drive, &args, NULL);
+	ide_raw_taskfile(drive, &args);
 
 	drive->acoustic = arg;
 
@@ -879,7 +942,7 @@
 	memset(&args, 0, sizeof(args));
 	args.taskfile.device_head = 0x40;
 	args.cmd = WIN_READ_NATIVE_MAX;
-	ide_raw_taskfile(drive, &args, NULL);
+	ide_raw_taskfile(drive, &args);
 
 	/* if OK, compute maximum address value */
 	if (!(drive->status & ERR_STAT)) {
@@ -901,9 +964,10 @@
 
 	/* Create IDE/ATA command request structure */
 	memset(&args, 0, sizeof(args));
+
 	args.taskfile.device_head = 0x40;
 	args.cmd = WIN_READ_NATIVE_MAX_EXT;
-        ide_raw_taskfile(drive, &args, NULL);
+        ide_raw_taskfile(drive, &args);
 
 	/* if OK, compute maximum address value */
 	if (!(drive->status & ERR_STAT)) {
@@ -941,7 +1005,7 @@
 
 	args.taskfile.device_head = ((addr_req >> 24) & 0x0f) | 0x40;
 	args.cmd = WIN_SET_MAX;
-	ide_raw_taskfile(drive, &args, NULL);
+	ide_raw_taskfile(drive, &args);
 
 	/* if OK, read new maximum address value */
 	if (!(drive->status & ERR_STAT)) {
@@ -974,7 +1038,7 @@
 	args.hobfile.high_cylinder = (addr_req >>= 8);
 	args.hobfile.device_head = 0x40;
 
-	ide_raw_taskfile(drive, &args, NULL);
+	ide_raw_taskfile(drive, &args);
 
 	/* if OK, compute maximum address value */
 	if (!(drive->status & ERR_STAT)) {
@@ -1292,11 +1356,7 @@
 			if (arg < 0 || arg > (id ? id->max_multsect : 0))
 				return -EINVAL;
 
-			if (ide_spin_wait_hwgroup(drive))
-				return -EBUSY;
-
 			val = set_multcount(drive, arg);
-			spin_unlock_irq(drive->channel->lock);
 
 			return val;
 		}
@@ -1316,11 +1376,7 @@
 			if (arg < 0 || arg > 1)
 				return -EINVAL;
 
-			if (ide_spin_wait_hwgroup(drive))
-				return -EBUSY;
-
 			val = set_nowerr(drive, arg);
-			spin_unlock_irq(drive->channel->lock);
 
 			return val;
 		}
@@ -1340,11 +1396,7 @@
 			if (arg < 0 || arg > 1)
 				return -EINVAL;
 
-			if (ide_spin_wait_hwgroup(drive))
-				return -EBUSY;
-
 			val = write_cache(drive, arg);
-			spin_unlock_irq(drive->channel->lock);
 
 			return val;
 		}
@@ -1363,11 +1415,7 @@
 			if (arg < 0 || arg > 254)
 				return -EINVAL;
 
-			if (ide_spin_wait_hwgroup(drive))
-				return -EBUSY;
-
 			val = set_acoustic(drive, arg);
-			spin_unlock_irq(drive->channel->lock);
 
 			return val;
 		}
diff -Nru a/drivers/ide/ide-pmac.c b/drivers/ide/ide-pmac.c
--- a/drivers/ide/ide-pmac.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/ide/ide-pmac.c	Thu Jun 20 15:54:01 2002
@@ -1378,7 +1378,6 @@
 	ata4 = (pmac_ide[ix].kind == controller_kl_ata4 ||
 		pmac_ide[ix].kind == controller_kl_ata4_80);
 
-	drive->waiting_for_dma = 0;
 	dstat = in_le32(&dma->status);
 	out_le32(&dma->control, ((RUN|WAKE|DEAD) << 16));
 	pmac_ide_destroy_dmatable(drive->channel, ix);
@@ -1418,7 +1417,7 @@
 			((reading) ? 0x00800000UL : 0));
 		(void)in_le32((unsigned *)(IDE_DATA_REG + IDE_TIMING_CONFIG + _IO_BASE));
 	}
-	drive->waiting_for_dma = 1;
+
 	if (drive->type != ATA_DISK)
 		return ide_started;
 
@@ -1466,6 +1465,8 @@
 	 * - The dbdma fifo hasn't yet finished flushing to to system memory
 	 * when the disk interrupt occurs.
 	 *
+	 * FIXME: The following *trick* is broken:
+	 *
 	 * The trick here is to increment drive->waiting_for_dma, and return as
 	 * if no interrupt occured. If the counter reach a certain timeout
 	 * value, we then return 1. If we really got the interrupt, it will
@@ -1480,15 +1481,16 @@
 	 */
 	if (!(in_le32(&dma->status) & ACTIVE))
 		return 1;
-	if (!drive->waiting_for_dma)
+
+	if (!test_bit(IDE_DMA, drive->channel->active))
 		printk(KERN_WARNING "ide%d, ide_dma_test_irq \
 				called while not waiting\n", ix);
 
 	/* If dbdma didn't execute the STOP command yet, the
 	 * active bit is still set */
-	drive->waiting_for_dma++;
-	if (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {
-		printk(KERN_WARNING "ide%d, timeout waiting \
+	set_bit(IDE_DMA, drive->channel->active);
+//	if (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {
+//		printk(KERN_WARNING "ide%d, timeout waiting \
 				for dbdma command stop\n", ix);
 		return 1;
 	}
diff -Nru a/drivers/ide/ide-taskfile.c b/drivers/ide/ide-taskfile.c
--- a/drivers/ide/ide-taskfile.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/ide/ide-taskfile.c	Thu Jun 20 15:54:01 2002
@@ -148,7 +148,7 @@
  */
 int drive_is_ready(struct ata_device *drive)
 {
-	if (drive->waiting_for_dma)
+	if (test_bit(IDE_DMA, drive->channel->active))
 		return udma_irq_status(drive);
 
 	/*
@@ -242,9 +242,8 @@
 /*
  * Invoked on completion of a special REQ_SPECIAL command.
  */
-static ide_startstop_t special_intr(struct ata_device *drive,
-		struct request *rq)
-{
+ide_startstop_t ata_special_intr(struct ata_device *drive, struct
+		request *rq) {
 
 	struct ata_taskfile *ar = rq->special;
 	ide_startstop_t ret = ide_stopped;
@@ -293,18 +292,16 @@
 	return ret;
 }
 
-int ide_raw_taskfile(struct ata_device *drive, struct ata_taskfile *ar,
-		char *buffer)
+int ide_raw_taskfile(struct ata_device *drive, struct ata_taskfile *ar)
 {
 	struct request req;
 
 	ar->command_type = IDE_DRIVE_TASK_NO_DATA;
-	ar->XXX_handler = special_intr;
+	ar->XXX_handler = ata_special_intr;
 
 	memset(&req, 0, sizeof(req));
 	req.flags = REQ_SPECIAL;
 	req.special = ar;
-	req.buffer = buffer;
 
 	return ide_do_drive_cmd(drive, &req, ide_wait);
 }
@@ -313,4 +310,5 @@
 EXPORT_SYMBOL(ide_do_drive_cmd);
 EXPORT_SYMBOL(ata_read);
 EXPORT_SYMBOL(ata_write);
+EXPORT_SYMBOL(ata_special_intr);
 EXPORT_SYMBOL(ide_raw_taskfile);
diff -Nru a/drivers/ide/ide.c b/drivers/ide/ide.c
--- a/drivers/ide/ide.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/ide/ide.c	Thu Jun 20 15:54:01 2002
@@ -262,14 +262,14 @@
  * Poll the interface for completion every 50ms during an ATAPI drive reset
  * operation. If the drive has not yet responded, and we have not yet hit our
  * maximum waiting time, then the timer is restarted for another 50ms.
+ *
+ * Channel lock should be held.
  */
 static ide_startstop_t atapi_reset_pollfunc(struct ata_device *drive, struct request *__rq)
 {
-	unsigned long flags;
 	struct ata_channel *ch = drive->channel;
 	int ret = ide_stopped;
 
-	spin_lock_irqsave(ch->lock, flags);
 	ata_select(drive, 10);
 	if (!ata_status(drive, 0, BUSY_STAT)) {
 		if (time_before(jiffies, ch->poll_timeout)) {
@@ -287,7 +287,6 @@
 
 		ret = ide_stopped;
 	}
-	spin_unlock_irqrestore(ch->lock, flags);
 
 	return ret;
 }
@@ -296,14 +295,14 @@
  * Poll the interface for completion every 50ms during an ata reset operation.
  * If the drives have not yet responded, and we have not yet hit our maximum
  * waiting time, then the timer is restarted for another 50ms.
+ *
+ * Channel lock should be held.
  */
 static ide_startstop_t reset_pollfunc(struct ata_device *drive, struct request *__rq)
 {
-	unsigned long flags;
 	struct ata_channel *ch = drive->channel;
 	int ret;
 
-	spin_lock_irqsave(ch->lock, flags);
 	if (!ata_status(drive, 0, BUSY_STAT)) {
 		if (time_before(jiffies, ch->poll_timeout)) {
 			ata_set_handler(drive, reset_pollfunc, HZ/20, NULL);
@@ -347,7 +346,6 @@
 		ret = ide_stopped;
 	}
 	ch->poll_timeout = 0;	/* done polling */
-	spin_unlock_irqrestore(ch->lock, flags);
 
 	return ide_stopped;
 }
@@ -443,12 +441,17 @@
 static void dump_bits(struct ata_bit_messages *msgs, int nr, byte bits)
 {
 	int i;
+	int first = 1;
 
 	printk(" [ ");
 
 	for (i = 0; i < nr; i++, msgs++)
-		if ((bits & msgs->mask) == msgs->match)
-			printk("%s ", msgs->msg);
+		if ((bits & msgs->mask) == msgs->match) {
+			if (!first)
+				printk(",");
+			printk("%s", msgs->msg);
+			first = 0;
+		}
 
 	printk("] ");
 }
@@ -560,7 +563,7 @@
 		memset(&args, 0, sizeof(args));
 		args.taskfile.sector_count = drive->sect;
 		args.cmd = WIN_RESTORE;
-		ide_raw_taskfile(drive, &args, NULL);
+		ide_raw_taskfile(drive, &args);
 		printk(KERN_INFO "%s: done!\n", drive->name);
 	}
 
@@ -1030,12 +1033,12 @@
 		if (ch->poll_timeout) {
 			ret = handler(drive, drive->rq);
 		} else if (drive_is_ready(drive)) {
-			if (drive->waiting_for_dma)
+			if (test_bit(IDE_DMA, ch->active))
 				udma_irq_lost(drive);
 			(void) ide_ack_intr(ch);
 			printk("%s: lost interrupt\n", drive->name);
 			ret = handler(drive, drive->rq);
-		} else if (drive->waiting_for_dma) {
+		} else if (test_bit(IDE_DMA, ch->active)) {
 			struct request *rq = drive->rq;
 
 			/*
diff -Nru a/drivers/ide/ioctl.c b/drivers/ide/ioctl.c
--- a/drivers/ide/ioctl.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/ide/ioctl.c	Thu Jun 20 15:54:00 2002
@@ -47,6 +47,7 @@
 	u8 *argbuf = vals;
 	int argsize = 4;
 	struct ata_taskfile args;
+	struct request req;
 
 	/* Second phase.
 	 */
@@ -77,7 +78,17 @@
 		memset(argbuf + 4, 0, argsize - 4);
 	}
 
-	err = ide_raw_taskfile(drive, &args, argbuf + 4);
+	/* Issue ATA command and wait for completion.
+	 */
+	args.command_type = IDE_DRIVE_TASK_NO_DATA;
+	args.XXX_handler = ata_special_intr;
+
+	memset(&req, 0, sizeof(req));
+	req.flags = REQ_SPECIAL;
+	req.special = &args;
+
+	req.buffer = argbuf + 4;
+	err = ide_do_drive_cmd(drive, &req, ide_wait);
 
 	argbuf[0] = drive->status;
 	argbuf[1] = args.taskfile.feature;
diff -Nru a/drivers/ide/ns87415.c b/drivers/ide/ns87415.c
--- a/drivers/ide/ns87415.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/ide/ns87415.c	Thu Jun 20 15:54:00 2002
@@ -91,7 +91,6 @@
 	unsigned long dma_base = ch->dma_base;
 	u8 dma_stat;
 
-	drive->waiting_for_dma = 0;
 	dma_stat = inb(ch->dma_base+2);
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	outb(inb(dma_base)|6, dma_base);	/* from ERRATA: clear the INTR & ERROR bits */
diff -Nru a/drivers/ide/pcidma.c b/drivers/ide/pcidma.c
--- a/drivers/ide/pcidma.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/ide/pcidma.c	Thu Jun 20 15:54:00 2002
@@ -167,7 +167,6 @@
 	outl(ch->dmatable_dma, dma_base + 4); /* PRD table */
 	outb(reading, dma_base);		/* specify r/w */
 	outb(inb(dma_base+2)|6, dma_base+2);	/* clear INTR & ERROR flags */
-	drive->waiting_for_dma = 1;
 
 	return 0;
 }
@@ -436,7 +435,6 @@
 	unsigned long dma_base = ch->dma_base;
 	u8 dma_stat;
 
-	drive->waiting_for_dma = 0;
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(dma_stat|6, dma_base+2);		/* clear the INTR & ERROR bits */
diff -Nru a/drivers/ide/pdc202xx.c b/drivers/ide/pdc202xx.c
--- a/drivers/ide/pdc202xx.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/ide/pdc202xx.c	Thu Jun 20 15:54:01 2002
@@ -571,7 +571,7 @@
 	outb(inb(ch->dma_base) | 1, ch->dma_base); /* start DMA */
 }
 
-int pdc202xx_udma_stop(struct ata_device *drive)
+static int pdc202xx_udma_stop(struct ata_device *drive)
 {
 	struct ata_channel *ch = drive->channel;
 	u32 high_16 = pci_resource_start(ch->pci_dev, 4);
@@ -585,7 +585,6 @@
 		OUT_BYTE(clock & ~(ch->unit ? 0x08:0x02), high_16 + PDC_CLK);
 	}
 
-	drive->waiting_for_dma = 0;
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(dma_stat|6, dma_base+2);		/* clear the INTR & ERROR bits */
@@ -604,7 +603,7 @@
 
 #endif
 
-void pdc202xx_new_reset(struct ata_device *drive)
+static void pdc202xx_new_reset(struct ata_device *drive)
 {
 	ata_reset(drive->channel);
 	mdelay(1000);
diff -Nru a/drivers/ide/serverworks.c b/drivers/ide/serverworks.c
--- a/drivers/ide/serverworks.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/ide/serverworks.c	Thu Jun 20 15:54:01 2002
@@ -331,7 +331,6 @@
 #endif
 	}
 
-	drive->waiting_for_dma = 0;
 	outb(inb(dma_base)&~1, dma_base);	/* stop DMA */
 	dma_stat = inb(dma_base+2);		/* get DMA status */
 	outb(dma_stat|6, dma_base+2);		/* clear the INTR & ERROR bits */
diff -Nru a/drivers/ide/tcq.c b/drivers/ide/tcq.c
--- a/drivers/ide/tcq.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/ide/tcq.c	Thu Jun 20 15:54:01 2002
@@ -441,7 +441,7 @@
 	memset(&args, 0, sizeof(args));
 	args.taskfile.feature = 0x01;
 	args.cmd = WIN_NOP;
-	ide_raw_taskfile(drive, &args, NULL);
+	ide_raw_taskfile(drive, &args);
 	if (args.taskfile.feature & ABRT_ERR)
 		return 1;
 
@@ -469,7 +469,7 @@
 	memset(&args, 0, sizeof(args));
 	args.taskfile.feature = SETFEATURES_EN_WCACHE;
 	args.cmd = WIN_SETFEATURES;
-	if (ide_raw_taskfile(drive, &args, NULL)) {
+	if (ide_raw_taskfile(drive, &args)) {
 		printk("%s: failed to enable write cache\n", drive->name);
 		return 1;
 	}
@@ -481,7 +481,7 @@
 	memset(&args, 0, sizeof(args));
 	args.taskfile.feature = SETFEATURES_DIS_RI;
 	args.cmd = WIN_SETFEATURES;
-	if (ide_raw_taskfile(drive, &args, NULL)) {
+	if (ide_raw_taskfile(drive, &args)) {
 		printk("%s: disabling release interrupt fail\n", drive->name);
 		return 1;
 	}
@@ -493,7 +493,7 @@
 	memset(&args, 0, sizeof(args));
 	args.taskfile.feature = SETFEATURES_EN_SI;
 	args.cmd = WIN_SETFEATURES;
-	if (ide_raw_taskfile(drive, &args, NULL)) {
+	if (ide_raw_taskfile(drive, &args)) {
 		printk("%s: enabling service interrupt fail\n", drive->name);
 		return 1;
 	}
diff -Nru a/drivers/ide/trm290.c b/drivers/ide/trm290.c
--- a/drivers/ide/trm290.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/ide/trm290.c	Thu Jun 20 15:54:00 2002
@@ -185,8 +185,8 @@
 {
 	struct ata_channel *ch = drive->channel;
 
-	drive->waiting_for_dma = 0;
 	udma_destroy_table(ch);	/* purge DMA mappings */
+
 	return (inw(ch->dma_base + 2) != 0x00ff);
 }
 
@@ -224,7 +224,6 @@
 	trm290_prepare_drive(drive, 1);	/* select DMA xfer */
 
 	outl(ch->dmatable_dma|reading|writing, ch->dma_base);
-	drive->waiting_for_dma = 1;
 	outw((count * 2) - 1, ch->dma_base+2); /* start DMA */
 
 	if (drive->type == ATA_DISK) {
diff -Nru a/drivers/isdn/act2000/Config.in b/drivers/isdn/act2000/Config.in
--- a/drivers/isdn/act2000/Config.in	Thu Jun 20 15:54:01 2002
+++ b/drivers/isdn/act2000/Config.in	Thu Jun 20 15:54:01 2002
@@ -2,5 +2,5 @@
 # Config.in for IBM Active 2000 ISDN driver
 #
 
-dep_tristate       'IBM Active 2000 support' CONFIG_ISDN_DRV_ACT2000 $CONFIG_ISDN
+dep_tristate       'IBM Active 2000 support' CONFIG_ISDN_DRV_ACT2000 $CONFIG_ISDN $CONFIG_ISA
 
diff -Nru a/drivers/isdn/eicon/eicon_idi.c b/drivers/isdn/eicon/eicon_idi.c
--- a/drivers/isdn/eicon/eicon_idi.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/isdn/eicon/eicon_idi.c	Thu Jun 20 15:53:59 2002
@@ -2972,7 +2972,7 @@
 			spin_unlock_irqrestore(&eicon_lock, flags);
         	        eicon_log(card, 1, "idi_err: Ch%d: alloc_skb failed in send_data()\n", chan->No);
 			if (xmit_skb) 
-				dev_kfree_skb(skb);
+				dev_kfree_skb(xmit_skb);
 			if (skb2) 
 				dev_kfree_skb(skb2);
                 	return -ENOMEM;
diff -Nru a/drivers/isdn/hardware/avm/Config.in b/drivers/isdn/hardware/avm/Config.in
--- a/drivers/isdn/hardware/avm/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/isdn/hardware/avm/Config.in	Thu Jun 20 15:54:00 2002
@@ -8,12 +8,12 @@
 bool 'Support AVM cards' CONFIG_CAPI_AVM
 
 if [ "$CONFIG_CAPI_AVM" != "n" ]; then
-   dep_tristate '  AVM B1 ISA support' CONFIG_ISDN_DRV_AVMB1_B1ISA               $CONFIG_ISDN_CAPI
+   dep_tristate '  AVM B1 ISA support' CONFIG_ISDN_DRV_AVMB1_B1ISA               $CONFIG_ISDN_CAPI $CONFIG_SA
 
    dep_tristate '  AVM B1 PCI support'            CONFIG_ISDN_DRV_AVMB1_B1PCI    $CONFIG_ISDN_CAPI $CONFIG_PCI
    dep_mbool    '    AVM B1 PCI V4 support'       CONFIG_ISDN_DRV_AVMB1_B1PCIV4  $CONFIG_ISDN_DRV_AVMB1_B1PCI
 
-   dep_tristate '  AVM T1/T1-B ISA support'       CONFIG_ISDN_DRV_AVMB1_T1ISA    $CONFIG_ISDN_CAPI
+   dep_tristate '  AVM T1/T1-B ISA support'       CONFIG_ISDN_DRV_AVMB1_T1ISA    $CONFIG_ISDN_CAPI $CONFIG_ISA
 
    dep_tristate '  AVM B1/M1/M2 PCMCIA support'   CONFIG_ISDN_DRV_AVMB1_B1PCMCIA $CONFIG_ISDN_CAPI
 
diff -Nru a/drivers/isdn/hardware/avm/b1pci.c b/drivers/isdn/hardware/avm/b1pci.c
--- a/drivers/isdn/hardware/avm/b1pci.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/isdn/hardware/avm/b1pci.c	Thu Jun 20 15:54:00 2002
@@ -211,7 +211,7 @@
 		goto err_free_dma;
 	}
 
-	card->mbase = ioremap_nocache(card->membase, 64);
+	card->mbase = ioremap(card->membase, 64);
 	if (!card->mbase) {
 		printk(KERN_NOTICE "b1pci: can't remap memory at 0x%lx\n",
 		       card->membase);
diff -Nru a/drivers/isdn/hardware/avm/c4.c b/drivers/isdn/hardware/avm/c4.c
--- a/drivers/isdn/hardware/avm/c4.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/isdn/hardware/avm/c4.c	Thu Jun 20 15:53:59 2002
@@ -1129,7 +1129,7 @@
 		goto err_free_dma;
 	}
 
-	card->mbase = ioremap_nocache(card->membase, 128);
+	card->mbase = ioremap(card->membase, 128);
 	if (card->mbase == 0) {
 		printk(KERN_NOTICE "c4: can't remap memory at 0x%lx\n",
 		       card->membase);
diff -Nru a/drivers/isdn/hardware/avm/t1pci.c b/drivers/isdn/hardware/avm/t1pci.c
--- a/drivers/isdn/hardware/avm/t1pci.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/isdn/hardware/avm/t1pci.c	Thu Jun 20 15:54:00 2002
@@ -79,7 +79,7 @@
 		goto err_free_dma;
 	}
 
-	card->mbase = ioremap_nocache(card->membase, 64);
+	card->mbase = ioremap(card->membase, 64);
 	if (!card->mbase) {
 		printk(KERN_NOTICE "t1pci: can't remap memory at 0x%lx\n",
 		       card->membase);
diff -Nru a/drivers/isdn/hisax/Config.help b/drivers/isdn/hisax/Config.help
--- a/drivers/isdn/hisax/Config.help	Thu Jun 20 15:54:01 2002
+++ b/drivers/isdn/hisax/Config.help	Thu Jun 20 15:54:01 2002
@@ -251,6 +251,10 @@
   This enables the PCMCIA client driver for the Sedlbauer Speed Star
   and Speed Star II cards.
 
+CONFIG_HISAX_AVM_A1_CS
+  This enables the PCMCIA client driver for the AVM A1 / Fritz!Card
+  PCMCIA cards.
+
 CONFIG_HISAX_ST5481
   This enables the driver for ST5481 based USB ISDN adapters,
   e.g. the BeWan Gazel 128 USB
diff -Nru a/drivers/isdn/hisax/Config.in b/drivers/isdn/hisax/Config.in
--- a/drivers/isdn/hisax/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/isdn/hisax/Config.in	Thu Jun 20 15:54:00 2002
@@ -14,28 +14,28 @@
    bool '  HiSax Support for US NI1' CONFIG_HISAX_NI1
    int  '  Maximum number of cards supported by HiSax' CONFIG_HISAX_MAX_CARDS 8
    comment '  HiSax supported cards'
-   bool '  Teles 16.0/8.0' CONFIG_HISAX_16_0
+   bool '  Teles 16.0/8.0' CONFIG_HISAX_16_0 $CONFIG_ISA
    bool '  Teles 16.3 or PNP or PCMCIA' CONFIG_HISAX_16_3
    bool '  Teles PCI' CONFIG_HISAX_TELESPCI 
    bool '  Teles S0Box' CONFIG_HISAX_S0BOX 
-   bool '  AVM A1 (Fritz)' CONFIG_HISAX_AVM_A1
+   bool '  AVM A1 (Fritz)' CONFIG_HISAX_AVM_A1 $CONFIG_ISA
    bool '  AVM PnP/PCI (Fritz!PnP/PCI)' CONFIG_HISAX_FRITZPCI
    bool '  AVM A1 PCMCIA (Fritz)' CONFIG_HISAX_AVM_A1_PCMCIA
    bool '  Elsa cards' CONFIG_HISAX_ELSA
-   bool '  ITK ix1-micro Revision 2' CONFIG_HISAX_IX1MICROR2
+   bool '  ITK ix1-micro Revision 2' CONFIG_HISAX_IX1MICROR2 $CONFIG_ISA
    bool '  Eicon.Diehl Diva cards' CONFIG_HISAX_DIEHLDIVA
-   bool '  ASUSCOM ISA cards' CONFIG_HISAX_ASUSCOM
-   bool '  TELEINT cards' CONFIG_HISAX_TELEINT
-   bool '  HFC-S based cards' CONFIG_HISAX_HFCS
+   bool '  ASUSCOM ISA cards' CONFIG_HISAX_ASUSCOM $CONFIG_ISA
+   bool '  TELEINT cards' CONFIG_HISAX_TELEINT $CONFIG_ISA
+   bool '  HFC-S based cards' CONFIG_HISAX_HFCS $CONFIG_ISA
    bool '  Sedlbauer cards' CONFIG_HISAX_SEDLBAUER
-   bool '  USR Sportster internal TA' CONFIG_HISAX_SPORTSTER
-   bool '  MIC card' CONFIG_HISAX_MIC
+   bool '  USR Sportster internal TA' CONFIG_HISAX_SPORTSTER $CONFIG_ISA
+   bool '  MIC card' CONFIG_HISAX_MIC $CONFIG_ISA
    bool '  NETjet card' CONFIG_HISAX_NETJET
    bool '  NETspider U card' CONFIG_HISAX_NETJET_U
    bool '  Niccy PnP/PCI card' CONFIG_HISAX_NICCY
-   bool '  Siemens I-Surf card' CONFIG_HISAX_ISURF
-   bool '  HST Saphir card' CONFIG_HISAX_HSTSAPHIR
-   bool '  Telekom A4T card' CONFIG_HISAX_BKM_A4T
+   bool '  Siemens I-Surf card' CONFIG_HISAX_ISURF $CONFIG_ISA
+   bool '  HST Saphir card' CONFIG_HISAX_HSTSAPHIR $CONFIG_ISA
+   bool '  Telekom A4T card' CONFIG_HISAX_BKM_A4T 
    bool '  Scitel Quadro card' CONFIG_HISAX_SCT_QUADRO
    bool '  Gazel cards' CONFIG_HISAX_GAZEL
    bool '  HFC PCI-Bus cards' CONFIG_HISAX_HFC_PCI
@@ -52,6 +52,7 @@
 
    dep_tristate 'Sedlbauer PCMCIA cards'                              CONFIG_HISAX_SEDLBAUER_CS  $CONFIG_ISDN_DRV_HISAX $CONFIG_PCMCIA
    dep_tristate 'ELSA PCMCIA MicroLink cards'                         CONFIG_HISAX_ELSA_CS       $CONFIG_ISDN_DRV_HISAX $CONFIG_PCMCIA
+   dep_tristate 'AVM A1 PCMCIA cards'                                 CONFIG_HISAX_AVM_A1_CS     $CONFIG_ISDN_DRV_HISAX $CONFIG_PCMCIA
    dep_tristate 'ST5481 USB ISDN modem (EXPERIMENTAL)'                CONFIG_HISAX_ST5481        $CONFIG_ISDN_DRV_HISAX $CONFIG_USB $CONFIG_EXPERIMENTAL
    dep_tristate 'AVM Fritz!Card PCI/PCIv2/PnP support (EXPERIMENTAL)' CONFIG_HISAX_FRITZ_PCIPNP  $CONFIG_ISDN_DRV_HISAX $CONFIG_EXPERIMENTAL
    dep_tristate 'AVM Fritz!Card classic support (EXPERIMENTAL)'       CONFIG_HISAX_FRITZ_CLASSIC $CONFIG_ISDN_DRV_HISAX  $CONFIG_EXPERIMENTAL
diff -Nru a/drivers/isdn/hisax/Makefile b/drivers/isdn/hisax/Makefile
--- a/drivers/isdn/hisax/Makefile	Thu Jun 20 15:54:00 2002
+++ b/drivers/isdn/hisax/Makefile	Thu Jun 20 15:54:00 2002
@@ -13,6 +13,7 @@
 obj-$(CONFIG_ISDN_DRV_HISAX)		+= hisax.o
 obj-$(CONFIG_HISAX_SEDLBAUER_CS)	+= sedlbauer_cs.o
 obj-$(CONFIG_HISAX_ELSA_CS)		+= elsa_cs.o
+obj-$(CONFIG_HISAX_AVM_A1_CS)		+= avma1_cs.o
 obj-$(CONFIG_HISAX_ST5481)		+= hisax_st5481.o
 obj-$(CONFIG_HISAX_FRITZ_PCIPNP)        += hisax_isac.o hisax_fcpcipnp.o
 obj-$(CONFIG_HISAX_FRITZ_CLASSIC)       += hisax_isac.o hisax_hscx.o hisax_fcclassic.o
diff -Nru a/drivers/isdn/hisax/avma1_cs.c b/drivers/isdn/hisax/avma1_cs.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/isdn/hisax/avma1_cs.c	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,553 @@
+/*
+ * PCMCIA client driver for AVM A1 / Fritz!PCMCIA
+ *
+ * Author       Carsten Paeth
+ * Copyright    1998-2001 by Carsten Paeth <calle@calle.in-berlin.de>
+ * 
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#include <linux/module.h>
+
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+
+MODULE_DESCRIPTION("ISDN4Linux: PCMCIA client driver for AVM A1/Fritz!PCMCIA cards");
+MODULE_AUTHOR("Carsten Paeth");
+MODULE_LICENSE("GPL");
+
+int avm_a1_init_pcmcia(void *pcm_iob, int pcm_irq, int *busy_flag, int prot);
+void HiSax_closecard(int cardnr);
+
+
+/*
+   All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If
+   you do not define PCMCIA_DEBUG at all, all the debug code will be
+   left out.  If you compile with PCMCIA_DEBUG=0, the debug code will
+   be present but disabled -- but it can then be enabled for specific
+   modules at load time with a 'pc_debug=#' option to insmod.
+*/
+#ifdef PCMCIA_DEBUG
+static int pc_debug = PCMCIA_DEBUG;
+MODULE_PARM(pc_debug, "i");
+#define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args);
+static char *version =
+"avma1_cs.c 1.00 1998/01/23 10:00:00 (Carsten Paeth)";
+#else
+#define DEBUG(n, args...)
+#endif
+
+/*====================================================================*/
+
+/* Parameters that can be set with 'insmod' */
+
+static int default_irq_list[11] = { 15, 13, 12, 11, 10, 9, 7, 5, 4, 3, -1 };
+static int irq_list[11] = { -1 };
+static int isdnprot = 2;
+
+MODULE_PARM(irq_list, "1-11i");
+MODULE_PARM(isdnprot, "1-4i");
+
+/*====================================================================*/
+
+/*
+   The event() function is this driver's Card Services event handler.
+   It will be called by Card Services when an appropriate card status
+   event is received.  The config() and release() entry points are
+   used to configure or release a socket, in response to card insertion
+   and ejection events.  They are invoked from the skeleton event
+   handler.
+*/
+
+static void avma1cs_config(dev_link_t *link);
+static void avma1cs_release(u_long arg);
+static int avma1cs_event(event_t event, int priority,
+			  event_callback_args_t *args);
+
+/*
+   The attach() and detach() entry points are used to create and destroy
+   "instances" of the driver, where each instance represents everything
+   needed to manage one actual PCMCIA card.
+*/
+
+static dev_link_t *avma1cs_attach(void);
+static void avma1cs_detach(dev_link_t *);
+
+/*
+   The dev_info variable is the "key" that is used to match up this
+   device driver with appropriate cards, through the card configuration
+   database.
+*/
+
+static dev_info_t dev_info = "avma1_cs";
+
+/*
+   A linked list of "instances" of the skeleton device.  Each actual
+   PCMCIA card corresponds to one device instance, and is described
+   by one dev_link_t structure (defined in ds.h).
+
+   You may not want to use a linked list for this -- for example, the
+   memory card driver uses an array of dev_link_t pointers, where minor
+   device numbers are used to derive the corresponding array index.
+*/
+
+static dev_link_t *dev_list = NULL;
+
+/*
+   A dev_link_t structure has fields for most things that are needed
+   to keep track of a socket, but there will usually be some device
+   specific information that also needs to be kept track of.  The
+   'priv' pointer in a dev_link_t structure can be used to point to
+   a device-specific private data structure, like this.
+
+   A driver needs to provide a dev_node_t structure for each device
+   on a card.  In some cases, there is only one device per card (for
+   example, ethernet cards, modems).  In other cases, there may be
+   many actual or logical devices (SCSI adapters, memory cards with
+   multiple partitions).  The dev_node_t structures need to be kept
+   in a linked list starting at the 'dev' field of a dev_link_t
+   structure.  We allocate them in the card's private data structure,
+   because they generally can't be allocated dynamically.
+*/
+   
+typedef struct local_info_t {
+    dev_node_t	node;
+} local_info_t;
+
+/*====================================================================*/
+
+static void cs_error(client_handle_t handle, int func, int ret)
+{
+    error_info_t err = { func, ret };
+    CardServices(ReportError, handle, &err);
+}
+
+/*======================================================================
+
+    avma1cs_attach() creates an "instance" of the driver, allocating
+    local data structures for one device.  The device is registered
+    with Card Services.
+
+    The dev_link structure is initialized, but we don't actually
+    configure the card at this point -- we wait until we receive a
+    card insertion event.
+    
+======================================================================*/
+
+static dev_link_t *avma1cs_attach(void)
+{
+    client_reg_t client_reg;
+    dev_link_t *link;
+    local_info_t *local;
+    int ret, i;
+    
+    DEBUG(0, "avma1cs_attach()\n");
+
+    /* Initialize the dev_link_t structure */
+    link = kmalloc(sizeof(struct dev_link_t), GFP_KERNEL);
+    memset(link, 0, sizeof(struct dev_link_t));
+    link->release.function = &avma1cs_release;
+    link->release.data = (u_long)link;
+
+    /* The io structure describes IO port mapping */
+    link->io.NumPorts1 = 16;
+    link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+    link->io.NumPorts2 = 16;
+    link->io.Attributes2 = IO_DATA_PATH_WIDTH_16;
+    link->io.IOAddrLines = 5;
+
+    /* Interrupt setup */
+    link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
+    link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING|IRQ_FIRST_SHARED;
+
+    link->irq.IRQInfo1 = IRQ_INFO2_VALID|IRQ_LEVEL_ID;
+    if (irq_list[0] != -1) {
+	    for (i = 0; i < 10 && irq_list[i] > 0; i++)
+	       link->irq.IRQInfo2 |= 1 << irq_list[i];
+    } else {
+	    for (i = 0; i < 10 && default_irq_list[i] > 0; i++)
+	       link->irq.IRQInfo2 |= 1 << default_irq_list[i];
+    }
+    
+    /* General socket configuration */
+    link->conf.Attributes = CONF_ENABLE_IRQ;
+    link->conf.Vcc = 50;
+    link->conf.IntType = INT_MEMORY_AND_IO;
+    link->conf.ConfigIndex = 1;
+    link->conf.Present = PRESENT_OPTION;
+
+    /* Allocate space for private device-specific data */
+    local = kmalloc(sizeof(local_info_t), GFP_KERNEL);
+    memset(local, 0, sizeof(local_info_t));
+    link->priv = local;
+    
+    /* Register with Card Services */
+    link->next = dev_list;
+    dev_list = link;
+    client_reg.dev_info = &dev_info;
+    client_reg.Attributes = INFO_IO_CLIENT | INFO_CARD_SHARE;
+    client_reg.EventMask =
+	CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL |
+	CS_EVENT_RESET_PHYSICAL | CS_EVENT_CARD_RESET |
+	CS_EVENT_PM_SUSPEND | CS_EVENT_PM_RESUME;
+    client_reg.event_handler = &avma1cs_event;
+    client_reg.Version = 0x0210;
+    client_reg.event_callback_args.client_data = link;
+    ret = CardServices(RegisterClient, &link->handle, &client_reg);
+    if (ret != 0) {
+	cs_error(link->handle, RegisterClient, ret);
+	avma1cs_detach(link);
+	return NULL;
+    }
+
+    return link;
+} /* avma1cs_attach */
+
+/*======================================================================
+
+    This deletes a driver "instance".  The device is de-registered
+    with Card Services.  If it has been released, all local data
+    structures are freed.  Otherwise, the structures will be freed
+    when the device is released.
+
+======================================================================*/
+
+static void avma1cs_detach(dev_link_t *link)
+{
+    dev_link_t **linkp;
+
+    DEBUG(0, "avma1cs_detach(0x%p)\n", link);
+    
+    /* Locate device structure */
+    for (linkp = &dev_list; *linkp; linkp = &(*linkp)->next)
+	if (*linkp == link) break;
+    if (*linkp == NULL)
+	return;
+
+    /*
+       If the device is currently configured and active, we won't
+       actually delete it yet.  Instead, it is marked so that when
+       the release() function is called, that will trigger a proper
+       detach().
+    */
+    if (link->state & DEV_CONFIG) {
+#ifdef PCMCIA_DEBUG
+	printk(KERN_DEBUG "avma1_cs: detach postponed, '%s' "
+	       "still locked\n", link->dev->dev_name);
+#endif
+	link->state |= DEV_STALE_LINK;
+	return;
+    }
+
+    /* Break the link with Card Services */
+    if (link->handle)
+	CardServices(DeregisterClient, link->handle);
+    
+    /* Unlink device structure, free pieces */
+    *linkp = link->next;
+    if (link->priv) {
+	kfree(link->priv);
+    }
+    kfree(link);
+    
+} /* avma1cs_detach */
+
+/*======================================================================
+
+    avma1cs_config() is scheduled to run after a CARD_INSERTION event
+    is received, to configure the PCMCIA socket, and to make the
+    ethernet device available to the system.
+    
+======================================================================*/
+
+static int get_tuple(int fn, client_handle_t handle, tuple_t *tuple,
+		     cisparse_t *parse)
+{
+    int i;
+    i = CardServices(fn, handle, tuple);
+    if (i != CS_SUCCESS) return i;
+    i = CardServices(GetTupleData, handle, tuple);
+    if (i != CS_SUCCESS) return i;
+    return CardServices(ParseTuple, handle, tuple, parse);
+}
+
+#define first_tuple(a, b, c) get_tuple(GetFirstTuple, a, b, c)
+#define next_tuple(a, b, c) get_tuple(GetNextTuple, a, b, c)
+
+static void avma1cs_config(dev_link_t *link)
+{
+    client_handle_t handle;
+    tuple_t tuple;
+    cisparse_t parse;
+    cistpl_cftable_entry_t *cf = &parse.cftable_entry;
+    local_info_t *dev;
+    int i;
+    u_char buf[64];
+    char devname[128];
+    int busy = 0;
+    
+    handle = link->handle;
+    dev = link->priv;
+
+    DEBUG(0, "avma1cs_config(0x%p)\n", link);
+
+    /*
+       This reads the card's CONFIG tuple to find its configuration
+       registers.
+    */
+    do {
+	tuple.DesiredTuple = CISTPL_CONFIG;
+	i = CardServices(GetFirstTuple, handle, &tuple);
+	if (i != CS_SUCCESS) break;
+	tuple.TupleData = buf;
+	tuple.TupleDataMax = 64;
+	tuple.TupleOffset = 0;
+	i = CardServices(GetTupleData, handle, &tuple);
+	if (i != CS_SUCCESS) break;
+	i = CardServices(ParseTuple, handle, &tuple, &parse);
+	if (i != CS_SUCCESS) break;
+	link->conf.ConfigBase = parse.config.base;
+    } while (0);
+    if (i != CS_SUCCESS) {
+	cs_error(link->handle, ParseTuple, i);
+	link->state &= ~DEV_CONFIG_PENDING;
+	return;
+    }
+    
+    /* Configure card */
+    link->state |= DEV_CONFIG;
+
+    do {
+
+	tuple.Attributes = 0;
+	tuple.TupleData = buf;
+	tuple.TupleDataMax = 254;
+	tuple.TupleOffset = 0;
+	tuple.DesiredTuple = CISTPL_VERS_1;
+
+	devname[0] = 0;
+	if( !first_tuple(handle, &tuple, &parse) && parse.version_1.ns > 1 ) {
+	    strncpy(devname,parse.version_1.str + parse.version_1.ofs[1], 
+			sizeof(devname));
+	}
+	/*
+         * find IO port
+         */
+	tuple.TupleData = (cisdata_t *)buf;
+	tuple.TupleOffset = 0; tuple.TupleDataMax = 255;
+	tuple.Attributes = 0;
+	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
+	i = first_tuple(handle, &tuple, &parse);
+	while (i == CS_SUCCESS) {
+	    if (cf->io.nwin > 0) {
+		link->conf.ConfigIndex = cf->index;
+		link->io.BasePort1 = cf->io.win[0].base;
+		link->io.NumPorts1 = cf->io.win[0].len;
+		link->io.NumPorts2 = 0;
+                printk(KERN_INFO "avma1_cs: testing i/o %#x-%#x\n",
+			link->io.BasePort1,
+		        link->io.BasePort1+link->io.NumPorts1 - 1);
+		i = CardServices(RequestIO, link->handle, &link->io);
+		if (i == CS_SUCCESS) goto found_port;
+	    }
+	    i = next_tuple(handle, &tuple, &parse);
+	}
+
+found_port:
+	if (i != CS_SUCCESS) {
+	    cs_error(link->handle, RequestIO, i);
+	    break;
+	}
+	
+	/*
+	 * allocate an interrupt line
+	 */
+	i = CardServices(RequestIRQ, link->handle, &link->irq);
+	if (i != CS_SUCCESS) {
+	    cs_error(link->handle, RequestIRQ, i);
+	    CardServices(ReleaseIO, link->handle, &link->io);
+	    break;
+	}
+	
+	/*
+         * configure the PCMCIA socket
+	  */
+	i = CardServices(RequestConfiguration, link->handle, &link->conf);
+	if (i != CS_SUCCESS) {
+	    cs_error(link->handle, RequestConfiguration, i);
+	    CardServices(ReleaseIO, link->handle, &link->io);
+	    CardServices(ReleaseIRQ, link->handle, &link->irq);
+	    break;
+	}
+
+    } while (0);
+
+    /* At this point, the dev_node_t structure(s) should be
+       initialized and arranged in a linked list at link->dev. */
+
+    strcpy(dev->node.dev_name, "A1");
+    dev->node.major = 45;
+    dev->node.minor = 0;
+    link->dev = &dev->node;
+    
+    link->state &= ~DEV_CONFIG_PENDING;
+    /* If any step failed, release any partially configured state */
+    if (i != 0) {
+	avma1cs_release((u_long)link);
+	return;
+    }
+
+    printk(KERN_NOTICE "avma1_cs: checking at i/o %#x, irq %d\n",
+				link->io.BasePort1, link->irq.AssignedIRQ);
+
+    if (avm_a1_init_pcmcia((void *)(int)link->io.BasePort1,
+                           link->irq.AssignedIRQ,
+                           &busy, isdnprot) != 0) {
+       printk(KERN_ERR "avma1_cs: failed to initialize AVM A1 PCMCIA %d at i/o %#x\n", i, link->io.BasePort1);
+       return;
+    }
+
+    i = 0; /* no returncode for cardnr :-( */
+
+    dev->node.minor = i;
+
+} /* avma1cs_config */
+
+/*======================================================================
+
+    After a card is removed, avma1cs_release() will unregister the net
+    device, and release the PCMCIA configuration.  If the device is
+    still open, this will be postponed until it is closed.
+    
+======================================================================*/
+
+static void avma1cs_release(u_long arg)
+{
+    dev_link_t *link = (dev_link_t *)arg;
+    local_info_t *local = link->priv;
+
+    DEBUG(0, "avma1cs_release(0x%p)\n", link);
+
+    /*
+       If the device is currently in use, we won't release until it
+       is actually closed.
+    */
+    if (link->open) {
+	DEBUG(1, "avma1_cs: release postponed, '%s' still open\n",
+	      link->dev->dev_name);
+	link->state |= DEV_STALE_CONFIG;
+	return;
+    }
+
+    /* no unregister function with hisax */
+    HiSax_closecard(local->node.minor);
+
+    /* Unlink the device chain */
+    link->dev = NULL;
+    
+    /* Don't bother checking to see if these succeed or not */
+    CardServices(ReleaseConfiguration, link->handle);
+    CardServices(ReleaseIO, link->handle, &link->io);
+    CardServices(ReleaseIRQ, link->handle, &link->irq);
+    link->state &= ~DEV_CONFIG;
+    
+    if (link->state & DEV_STALE_LINK)
+	avma1cs_detach(link);
+    
+} /* avma1cs_release */
+
+/*======================================================================
+
+    The card status event handler.  Mostly, this schedules other
+    stuff to run after an event is received.  A CARD_REMOVAL event
+    also sets some flags to discourage the net drivers from trying
+    to talk to the card any more.
+
+    When a CARD_REMOVAL event is received, we immediately set a flag
+    to block future accesses to this device.  All the functions that
+    actually access the device should check this flag to make sure
+    the card is still present.
+    
+======================================================================*/
+
+static int avma1cs_event(event_t event, int priority,
+			  event_callback_args_t *args)
+{
+    dev_link_t *link = args->client_data;
+
+    DEBUG(1, "avma1cs_event(0x%06x)\n", event);
+    
+    switch (event) {
+    case CS_EVENT_CARD_REMOVAL:
+	link->state &= ~DEV_PRESENT;
+	if (link->state & DEV_CONFIG) {
+	    link->release.expires =  jiffies + HZ/20;
+	    add_timer(&link->release);
+	}
+	break;
+    case CS_EVENT_CARD_INSERTION:
+	link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+	avma1cs_config(link);
+	break;
+    case CS_EVENT_PM_SUSPEND:
+	link->state |= DEV_SUSPEND;
+	/* Fall through... */
+    case CS_EVENT_RESET_PHYSICAL:
+	if (link->state & DEV_CONFIG)
+	    CardServices(ReleaseConfiguration, link->handle);
+	break;
+    case CS_EVENT_PM_RESUME:
+	link->state &= ~DEV_SUSPEND;
+	/* Fall through... */
+    case CS_EVENT_CARD_RESET:
+	if (link->state & DEV_CONFIG)
+	    CardServices(RequestConfiguration, link->handle, &link->conf);
+	break;
+    }
+    return 0;
+} /* avma1cs_event */
+
+/*====================================================================*/
+
+static int __init init_avma1_cs(void)
+{
+    servinfo_t serv;
+    DEBUG(0, "%s\n", version);
+    CardServices(GetCardServicesInfo, &serv);
+    if (serv.Revision != CS_RELEASE_CODE) {
+        printk(KERN_NOTICE "avma1_cs: Card Services release "
+               "does not match!\n");
+        return -1;
+    }
+    register_pccard_driver(&dev_info, &avma1cs_attach, &avma1cs_detach);
+    return 0;
+}
+
+static void __exit exit_avma1_cs(void)
+{
+    DEBUG(0, "avma1_cs: unloading\n");
+    unregister_pccard_driver(&dev_info);
+    while (dev_list != NULL)
+	if (dev_list->state & DEV_CONFIG)
+	    avma1cs_release((u_long)dev_list);
+        avma1cs_detach(dev_list);
+}
+
+module_init(init_avma1_cs);
+module_exit(exit_avma1_cs);
diff -Nru a/drivers/isdn/icn/Config.in b/drivers/isdn/icn/Config.in
--- a/drivers/isdn/icn/Config.in	Thu Jun 20 15:54:01 2002
+++ b/drivers/isdn/icn/Config.in	Thu Jun 20 15:54:01 2002
@@ -2,4 +2,4 @@
 # Config.in for ICN ISDN driver
 #
 
-dep_tristate       'ICN 2B and 4B support' CONFIG_ISDN_DRV_ICN $CONFIG_ISDN
+dep_tristate       'ICN 2B and 4B support' CONFIG_ISDN_DRV_ICN $CONFIG_ISDN $CONFIG_ISA
diff -Nru a/drivers/isdn/pcbit/Config.in b/drivers/isdn/pcbit/Config.in
--- a/drivers/isdn/pcbit/Config.in	Thu Jun 20 15:54:01 2002
+++ b/drivers/isdn/pcbit/Config.in	Thu Jun 20 15:54:01 2002
@@ -2,4 +2,4 @@
 # Config.in for PCBIT ISDN driver
 #
 
-dep_tristate       'PCBIT-D support' CONFIG_ISDN_DRV_PCBIT $CONFIG_ISDN
+dep_tristate       'PCBIT-D support' CONFIG_ISDN_DRV_PCBIT $CONFIG_ISDN $CONFIG_ISA
diff -Nru a/drivers/isdn/pcbit/pcbit.h b/drivers/isdn/pcbit/pcbit.h
--- a/drivers/isdn/pcbit/pcbit.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/isdn/pcbit/pcbit.h	Thu Jun 20 15:54:00 2002
@@ -12,6 +12,8 @@
 #ifndef PCBIT_H
 #define PCBIT_H
 
+#include <linux/tqueue.h>
+
 #define MAX_PCBIT_CARDS 4
 
 
diff -Nru a/drivers/isdn/sc/Config.in b/drivers/isdn/sc/Config.in
--- a/drivers/isdn/sc/Config.in	Thu Jun 20 15:53:59 2002
+++ b/drivers/isdn/sc/Config.in	Thu Jun 20 15:53:59 2002
@@ -2,4 +2,4 @@
 # Config.in for Spellcaster ISDN driver
 #
 
-dep_tristate       'Spellcaster support' CONFIG_ISDN_DRV_SC $CONFIG_ISDN
+dep_tristate       'Spellcaster support' CONFIG_ISDN_DRV_SC $CONFIG_ISDN $CONFIG_ISA
diff -Nru a/drivers/isdn/tpam/Config.in b/drivers/isdn/tpam/Config.in
--- a/drivers/isdn/tpam/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/isdn/tpam/Config.in	Thu Jun 20 15:54:00 2002
@@ -3,5 +3,5 @@
 #
 
 if [ "$CONFIG_EXPERIMENTAL" != "n" ]; then
-   dep_tristate    'Auvertech TurboPAM support' CONFIG_ISDN_DRV_TPAM $CONFIG_ISDN $CONFIG_PCI
+   dep_tristate    'Auvertech TurboPAM support (EXPERIMENTAL)' CONFIG_ISDN_DRV_TPAM $CONFIG_ISDN $CONFIG_PCI
 fi
diff -Nru a/drivers/isdn/tpam/tpam.h b/drivers/isdn/tpam/tpam.h
--- a/drivers/isdn/tpam/tpam.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/isdn/tpam/tpam.h	Thu Jun 20 15:54:00 2002
@@ -16,6 +16,7 @@
 
 #include <linux/isdnif.h>
 #include <linux/init.h>
+#include <linux/tqueue.h>
 
 /* Maximum number of channels for this board */
 #define TPAM_NBCHANNEL		30
diff -Nru a/drivers/md/md.c b/drivers/md/md.c
--- a/drivers/md/md.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/md/md.c	Thu Jun 20 15:54:00 2002
@@ -144,17 +144,17 @@
  */
 #define ITERATE_MDDEV(mddev,tmp)					\
 									\
-	for (spin_lock(&all_mddevs_lock), 				\
-		     (tmp = all_mddevs.next),				\
-		     (mddev = NULL);					\
-	     (void)(tmp != &all_mddevs &&				\
-			mddev_get(list_entry(tmp, mddev_t, all_mddevs))),\
-		     spin_unlock(&all_mddevs_lock),			\
-		     (mddev ? mddev_put(mddev):(void)NULL),		\
-		     (mddev = list_entry(tmp, mddev_t, all_mddevs)),	\
-		     (tmp != &all_mddevs);				\
-	     spin_lock(&all_mddevs_lock),				\
-		     (tmp = tmp->next)					\
+	for (({ spin_lock(&all_mddevs_lock); 				\
+		tmp = all_mddevs.next;					\
+		mddev = NULL;});					\
+	     ({ if (tmp != &all_mddevs)					\
+			mddev_get(list_entry(tmp, mddev_t, all_mddevs));\
+		spin_unlock(&all_mddevs_lock);				\
+		if (mddev) mddev_put(mddev);				\
+		mddev = list_entry(tmp, mddev_t, all_mddevs);		\
+		tmp != &all_mddevs;});					\
+	     ({ spin_lock(&all_mddevs_lock);				\
+		tmp = tmp->next;})					\
 		)
 
 static mddev_t *mddev_map[MAX_MD_DEVS];
@@ -2546,6 +2546,20 @@
 		goto abort;
 	}
 
+
+	if (cmd == START_ARRAY) {
+		/* START_ARRAY doesn't need to lock the array as autostart_array
+		 * does the locking, and it could even be a different array
+		 */
+		err = autostart_array(val_to_kdev(arg));
+		if (err) {
+			printk(KERN_WARNING "md: autostart %s failed!\n",
+			       partition_name(val_to_kdev(arg)));
+			goto abort;
+		}
+		goto done;
+	}
+
 	err = mddev_lock(mddev);
 	if (err) {
 		printk(KERN_INFO "md: ioctl lock interrupted, reason %d, cmd %d\n",
@@ -2583,18 +2597,6 @@
 			}
 			goto done_unlock;
 
-		case START_ARRAY:
-			/*
-			 * possibly make it lock the array ...
-			 */
-			err = autostart_array(val_to_kdev(arg));
-			if (err) {
-				printk(KERN_WARNING "md: autostart %s failed!\n",
-					partition_name(val_to_kdev(arg)));
-				goto abort_unlock;
-			}
-			goto done_unlock;
-
 		default:;
 	}
 
@@ -3228,7 +3230,7 @@
 					flush_curr_signals();
 					err = -EINTR;
 					mddev_put(mddev2);
-					goto out;
+					goto skip;
 				}
 			}
 		}
@@ -3329,11 +3331,11 @@
 	/*
 	 * this also signals 'finished resyncing' to md_stop
 	 */
-out:
+ out:
 	wait_event(mddev->recovery_wait, !atomic_read(&mddev->recovery_active));
 	/* tell personality that we are finished */
 	mddev->pers->sync_request(mddev, max_sectors, 1);
-
+ skip:
 	mddev->curr_resync = 0;
 	if (err)
 		mddev->recovery_running = err;
@@ -3873,8 +3875,8 @@
 static void free_device_names(void)
 {
 	while (!list_empty(&device_names)) {
-		struct dname *tmp = list_entry(device_names.next,
-					       dev_name_t, list);
+		dev_name_t *tmp = list_entry(device_names.next,
+					     dev_name_t, list);
 		list_del(&tmp->list);
 		kfree(tmp);
 	}
diff -Nru a/drivers/media/video/Config.in b/drivers/media/video/Config.in
--- a/drivers/media/video/Config.in	Thu Jun 20 15:54:01 2002
+++ b/drivers/media/video/Config.in	Thu Jun 20 15:54:01 2002
@@ -49,7 +49,7 @@
 dep_tristate '  Linux Media Labs LML33 support' CONFIG_VIDEO_ZORAN_LML33 $CONFIG_VIDEO_ZORAN $CONFIG_VIDEO_DEV $CONFIG_PCI $CONFIG_I2C
 dep_tristate '  Zoran ZR36120/36125 Video For Linux' CONFIG_VIDEO_ZR36120 $CONFIG_VIDEO_DEV $CONFIG_PCI $CONFIG_I2C
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-  dep_tristate '  Sony Vaio Picturebook Motion Eye Video For Linux' CONFIG_VIDEO_MEYE $CONFIG_VIDEO_DEV $CONFIG_PCI $CONFIG_SONYPI
+  dep_tristate '  Sony Vaio Picturebook Motion Eye Video For Linux (EXPERIMENTAL)' CONFIG_VIDEO_MEYE $CONFIG_VIDEO_DEV $CONFIG_PCI $CONFIG_SONYPI
 fi
 
 endmenu
diff -Nru a/drivers/media/video/cpia_pp.c b/drivers/media/video/cpia_pp.c
--- a/drivers/media/video/cpia_pp.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/media/video/cpia_pp.c	Thu Jun 20 15:54:00 2002
@@ -32,6 +32,7 @@
 #include <linux/parport.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <linux/tqueue.h>
 #include <linux/smp_lock.h>
 
 #include <linux/kmod.h>
diff -Nru a/drivers/message/fusion/Config.in b/drivers/message/fusion/Config.in
--- a/drivers/message/fusion/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/Config.in	Thu Jun 20 15:54:00 2002
@@ -5,20 +5,32 @@
 
 if [ "$CONFIG_FUSION" = "y" -o "$CONFIG_FUSION" = "m" ]; then
 
-  if [ "$CONFIG_FUSION" = "y" ]; then
-    comment "(ability to boot linux kernel from Fusion device is ENABLED!)"
+  if [ "$CONFIG_BLK_DEV_SD" = "y" -a "$CONFIG_FUSION" = "y" ]; then
+    define_bool CONFIG_FUSION_BOOT y
   else
-    comment "(ability to boot linux kernel from Fusion device is DISABLED!)"
+    define_bool CONFIG_FUSION_BOOT n
   fi
 
-  # Modular only
-  dep_tristate "  Enhanced SCSI error reporting" CONFIG_FUSION_ISENSE $CONFIG_FUSION m
-  dep_tristate "  Fusion MPT misc device (ioctl) driver" CONFIG_FUSION_CTL $CONFIG_FUSION m
+  if [ "$CONFIG_MODULES" = "y" ]; then
+    #  How can we force these options to module or nothing?
+    dep_tristate "  Enhanced SCSI error reporting" CONFIG_FUSION_ISENSE $CONFIG_FUSION m
+    dep_tristate "  Fusion MPT misc device (ioctl) driver" CONFIG_FUSION_CTL $CONFIG_FUSION m
+  fi
 
   dep_tristate "  Fusion MPT LAN driver" CONFIG_FUSION_LAN $CONFIG_FUSION $CONFIG_NET
   if [ "$CONFIG_FUSION_LAN" != "n" ]; then
     define_bool CONFIG_NET_FC y
   fi
+
+else
+
+  define_bool CONFIG_FUSION_BOOT n
+  # These <should> be define_tristate, but we leave them define_bool
+  # for backward compatibility with pre-linux-2.2.15 kernels.
+  # (Bugzilla:fibrebugs, #384)
+  define_bool CONFIG_FUSION_ISENSE n
+  define_bool CONFIG_FUSION_CTL n
+  define_bool CONFIG_FUSION_LAN n
 
 fi
 
diff -Nru a/drivers/message/fusion/isense.c b/drivers/message/fusion/isense.c
--- a/drivers/message/fusion/isense.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/message/fusion/isense.c	Thu Jun 20 15:54:01 2002
@@ -5,12 +5,13 @@
  *      Error Report logging output.  This module implements SCSI-3
  *      Opcode lookup and a sorted table of SCSI-3 ASC/ASCQ strings.
  *
- *  Copyright (c) 1991-2001 Steven J. Ralston
+ *  Copyright (c) 1991-2002 Steven J. Ralston
  *  Written By: Steven J. Ralston
  *  (yes I wrote some of the orig. code back in 1991!)
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id$
+ *  $Id$
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -49,11 +50,15 @@
 */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-#include <linux/module.h>
+#include <linux/version.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/init.h>
-#include <linux/version.h>
+#include <asm/io.h>
+#if defined (__sparc__)
+#include <linux/timer.h>
+#endif
 
 /* Hmmm, avoid undefined spinlock_t on lk-2.2.14-5.0 */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
@@ -61,7 +66,7 @@
 #endif
 
 #define MODULEAUTHOR "Steven J. Ralston"
-#define COPYRIGHT "Copyright (c) 2001 " MODULEAUTHOR
+#define COPYRIGHT "Copyright (c) 2001-2002 " MODULEAUTHOR
 #include "mptbase.h"
 
 #include "isense.h"
@@ -84,9 +89,9 @@
 #define my_VERSION	MPT_LINUX_VERSION_COMMON
 #define MYNAM		"isense"
 
+EXPORT_NO_SYMBOLS;
 MODULE_AUTHOR(MODULEAUTHOR);
 MODULE_DESCRIPTION(my_NAME);
-MODULE_LICENSE("GPL");
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 int __init isense_init(void)
diff -Nru a/drivers/message/fusion/linux_compat.h b/drivers/message/fusion/linux_compat.h
--- a/drivers/message/fusion/linux_compat.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/linux_compat.h	Thu Jun 20 15:54:00 2002
@@ -11,6 +11,30 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
+#ifndef rwlock_init
+#define rwlock_init(x) do { *(x) = RW_LOCK_UNLOCKED; } while(0)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#define SET_NICE(current,x)	do {(current)->nice = (x);} while (0)
+#else
+#define SET_NICE(current,x)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#define pci_enable_device(pdev)	(0)
+#define SCSI_DATA_UNKNOWN	0
+#define SCSI_DATA_WRITE		1
+#define SCSI_DATA_READ		2
+#define SCSI_DATA_NONE		3
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+#define pci_set_dma_mask(pdev, mask)	(0)
+#define scsi_set_pci_device(sh, pdev)	(0)
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
 #	if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
 		typedef unsigned int dma_addr_t;
@@ -58,12 +82,33 @@
 	extern inline __cleanup_module_func_t __cleanup_module_inline(void) \
 	{ return x; }
 
-#else 
+#else
 #define module_init(x)	__initcall(x);
 #define module_exit(x)	__exitcall(x);
 #endif
 /* } block snipped from lk-2.2.18/include/linux/init.h */
 
+/* This block snipped from lk-2.2.18/include/linux/sched.h { */
+/*
+ * Used prior to schedule_timeout calls..
+ */
+#define __set_current_state(state_value)	do { current->state = state_value; } while (0)
+#ifdef __SMP__
+#define set_current_state(state_value)		do { __set_current_state(state_value); mb(); } while (0)
+#else
+#define set_current_state(state_value)		__set_current_state(state_value)
+#endif
+/* } block snipped from lk-2.2.18/include/linux/sched.h */
+
+/* procfs compat stuff... */
+#define proc_mkdir(x,y)			create_proc_entry(x, S_IFDIR, y)
+
+/* MUTEX compat stuff... */
+#define DECLARE_MUTEX(name)		struct semaphore name=MUTEX
+#define DECLARE_MUTEX_LOCKED(name)	struct semaphore name=MUTEX_LOCKED
+#define init_MUTEX(x)			*(x)=MUTEX
+#define init_MUTEX_LOCKED(x)		*(x)=MUTEX_LOCKED
+
 /* Wait queues. */
 #define DECLARE_WAIT_QUEUE_HEAD(name)	\
 	struct wait_queue * (name) = NULL
@@ -90,6 +135,17 @@
 #endif		/* LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18) */
 
 
+/*
+ * Inclined to use:
+ *   #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+ * here, but MODULE_LICENSE defined in 2.4.9-6 and 2.4.9-13
+ * breaks the rule:-(
+ */
+#ifndef MODULE_LICENSE
+#define MODULE_LICENSE(license)
+#endif
+
+
 /* PCI/driver subsystem { */
 #ifndef pci_for_each_dev
 #define pci_for_each_dev(dev)		for((dev)=pci_devices; (dev)!=NULL; (dev)=(dev)->next)
@@ -120,26 +176,6 @@
 #endif		/* } ifndef pci_for_each_dev */
 
 
-/* procfs compat stuff... */
-#ifdef CONFIG_PROC_FS
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,28)
-#define CREATE_PROCDIR_ENTRY(x,y)  create_proc_entry(x, S_IFDIR, y)
-/* This is a macro so we don't need to pull all the procfs
- * headers into this file. -DaveM
- */
-#define create_proc_read_entry(name, mode, base, __read_proc, __data) \
-({      struct proc_dir_entry *__res=create_proc_entry(name,mode,base); \
-        if (__res) { \
-                __res->read_proc=(__read_proc); \
-                __res->data=(__data); \
-        } \
-        __res; \
-})
-#else
-#define CREATE_PROCDIR_ENTRY(x,y)  proc_mkdir(x, y)
-#endif
-#endif
-
 /* Compatability for the 2.3.x PCI DMA API. */
 #ifndef PCI_DMA_BIDIRECTIONAL
 /*{-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -193,6 +229,28 @@
 
 /*}-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #endif /* PCI_DMA_BIDIRECTIONAL */
+
+/*
+ *  With the new command queuing code in the SCSI mid-layer we no longer have
+ *  to hold the io_request_lock spin lock when calling the scsi_done routine.
+ *  For now we only do this with the 2.5.1 kernel or newer.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1)
+        #define MPT_HOST_LOCK(flags)
+        #define MPT_HOST_UNLOCK(flags)
+#else
+        #define MPT_HOST_LOCK(flags) \
+                spin_lock_irqsave(&io_request_lock, flags)
+        #define MPT_HOST_UNLOCK(flags) \
+                spin_unlock_irqrestore(&io_request_lock, flags)
+#endif
+
+/*
+ *  We use our new error handling code if the kernel version is 2.5.1 or newer.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1)
+        #define MPT_SCSI_USE_NEW_EH
+#endif
 
 /*}-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #endif /* _LINUX_COMPAT_H */
diff -Nru a/drivers/message/fusion/lsi/fc_log.h b/drivers/message/fusion/lsi/fc_log.h
--- a/drivers/message/fusion/lsi/fc_log.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/lsi/fc_log.h	Thu Jun 20 15:54:00 2002
@@ -7,7 +7,7 @@
  *                  in the IOCLogInfo field of a MPI Default Reply Message.
  *
  *  CREATION DATE:  6/02/2000
- *  ID:             $Id$
+ *  ID:             $Id$
  */
 
 
@@ -62,7 +62,7 @@
     MPI_IOCLOGINFO_FC_TARGET_MRSP_KILLED_BY_LIP     = 0x2100000a, /* Manual Response not sent due to a LIP */
     MPI_IOCLOGINFO_FC_TARGET_NO_CLASS_3             = 0x2100000b, /* not sent because remote node does not support Class 3 */
     MPI_IOCLOGINFO_FC_TARGET_LOGIN_NOT_VALID        = 0x2100000c, /* not sent because login to remote node not validated */
-    MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND          = 0x2100000e, /* cleared from the outbound after a logout */
+    MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND          = 0x2100000e, /* cleared from the outbound queue after a logout */
     MPI_IOCLOGINFO_FC_TARGET_WAITING_FOR_DATA_IN    = 0x2100000f, /* cleared waiting for data after a logout */
 
     MPI_IOCLOGINFO_FC_LAN_BASE                      = 0x22000000,
diff -Nru a/drivers/message/fusion/lsi/mpi.h b/drivers/message/fusion/lsi/mpi.h
--- a/drivers/message/fusion/lsi/mpi.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/lsi/mpi.h	Thu Jun 20 15:54:00 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Message independent structures and definitions
  *  Creation Date:  July 27, 2000
  *
- *    MPI Version:  01.01.07
+ *    MPI Version:  01.02.03
  *
  *  Version History
  *  ---------------
@@ -39,6 +39,11 @@
  *                      Added function codes for RAID.
  *  04-09-01  01.01.07  Added alternate define for MPI_DOORBELL_ACTIVE,
  *                      MPI_DOORBELL_USED, to better match the spec.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *                      Changed MPI_VERSION_MINOR from 0x01 to 0x02.
+ *                      Added define MPI_FUNCTION_TOOLBOX.
+ *  09-28-01  01.02.02  New function code MPI_SCSI_ENCLOSURE_PROCESSOR.
+ *  11-01-01  01.02.03  Changed name to MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR.
  *  --------------------------------------------------------------------------
  */
 
@@ -53,7 +58,7 @@
 *****************************************************************************/
 
 #define MPI_VERSION_MAJOR                   (0x01)
-#define MPI_VERSION_MINOR                   (0x01)
+#define MPI_VERSION_MINOR                   (0x02)
 #define MPI_VERSION            ((MPI_VERSION_MAJOR << 8) | MPI_VERSION_MINOR)
 
 /* Note: The major versions of 0xe0 through 0xff are reserved */
@@ -216,8 +221,12 @@
 #define MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND       (0x13)
 #define MPI_FUNCTION_FC_PRIMITIVE_SEND              (0x14)
 
-#define MPI_FUNCTION_RAID_VOLUME                    (0x15)
+#define MPI_FUNCTION_RAID_ACTION                    (0x15)
 #define MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH       (0x16)
+
+#define MPI_FUNCTION_TOOLBOX                        (0x17)
+
+#define MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR       (0x18)
 
 #define MPI_FUNCTION_LAN_SEND                       (0x20)
 #define MPI_FUNCTION_LAN_RECEIVE                    (0x21)
diff -Nru a/drivers/message/fusion/lsi/mpi_cnfg.h b/drivers/message/fusion/lsi/mpi_cnfg.h
--- a/drivers/message/fusion/lsi/mpi_cnfg.h	Thu Jun 20 15:53:59 2002
+++ b/drivers/message/fusion/lsi/mpi_cnfg.h	Thu Jun 20 15:53:59 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Config message, structures, and Pages
  *  Creation Date:  July 27, 2000
  *
- *    MPI Version:  01.01.11
+ *    MPI Version:  01.02.05
  *
  *  Version History
  *  ---------------
@@ -72,6 +72,42 @@
  *                      Added IO Unit Page 3.
  *                      Modified defines for Scsi Port Page 2.
  *                      Modified RAID Volume Pages.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *                      Added SepID and SepBus to RVP2 IMPhysicalDisk struct.
+ *                      Added defines for the SEP bits in RVP2 VolumeSettings.
+ *                      Modified the DeviceSettings field in RVP2 to use the
+ *                      proper structure.
+ *                      Added defines for SES, SAF-TE, and cross channel for
+ *                      IOCPage2 CapabilitiesFlags.
+ *                      Removed define for MPI_IOUNITPAGE2_FLAGS_RAID_DISABLE.
+ *                      Removed define for
+ *                      MPI_SCSIPORTPAGE2_PORT_FLAGS_PARITY_ENABLE.
+ *                      Added define for MPI_CONFIG_PAGEATTR_RO_PERSISTENT.
+ *  08-29-01 01.02.02   Fixed value for MPI_MANUFACTPAGE_DEVID_53C1035.
+ *                      Added defines for MPI_FCPORTPAGE1_FLAGS_HARD_ALPA_ONLY
+ *                      and MPI_FCPORTPAGE1_FLAGS_IMMEDIATE_ERROR_REPLY.
+ *                      Removed MPI_SCSIPORTPAGE0_CAP_PACING_TRANSFERS,
+ *                      MPI_SCSIDEVPAGE0_NP_PACING_TRANSFERS, and
+ *                      MPI_SCSIDEVPAGE1_RP_PACING_TRANSFERS, and
+ *                      MPI_SCSIDEVPAGE1_CONF_PPR_ALLOWED.
+ *                      Added defines for MPI_SCSIDEVPAGE1_CONF_WDTR_DISALLOWED
+ *                      and MPI_SCSIDEVPAGE1_CONF_SDTR_DISALLOWED.
+ *                      Added OnBusTimerValue to CONFIG_PAGE_SCSI_PORT_1.
+ *                      Added rejected bits to SCSI Device Page 0 Information.
+ *                      Increased size of ALPA array in FC Port Page 2 by one
+ *                      and removed a one byte reserved field.
+ *  09-28-01 01.02.03   Swapped NegWireSpeedLow and NegWireSpeedLow in
+ *                      CONFIG_PAGE_LAN_1 to match preferred 64-bit ordering.
+ *                      Added structures for Manufacturing Page 4, IO Unit
+ *                      Page 3, IOC Page 3, IOC Page 4, RAID Volume Page 0, and
+ *                      RAID PhysDisk Page 0.
+ *  10-04-01 01.02.04   Added define for MPI_CONFIG_PAGETYPE_RAID_PHYSDISK.
+ *                      Modified some of the new defines to make them 32
+ *                      character unique.
+ *                      Modified how variable length pages (arrays) are defined.
+ *                      Added generic defines for hot spare pools and RAID
+ *                      volume types.
+ *  11-01-01 01.02.05   Added define for MPI_IOUNITPAGE1_DISABLE_IR.
  *  --------------------------------------------------------------------------
  */
 
@@ -104,12 +140,13 @@
   fCONFIG_PAGE_HEADER_UNION, MPI_POINTER PTR_CONFIG_PAGE_HEADER_UNION;
 
 
-/****************************************************************************/
-/*  PageType field values                                                   */
-/****************************************************************************/
+/****************************************************************************
+*   PageType field values
+****************************************************************************/
 #define MPI_CONFIG_PAGEATTR_READ_ONLY               (0x00)
 #define MPI_CONFIG_PAGEATTR_CHANGEABLE              (0x10)
 #define MPI_CONFIG_PAGEATTR_PERSISTENT              (0x20)
+#define MPI_CONFIG_PAGEATTR_RO_PERSISTENT           (0x30)
 #define MPI_CONFIG_PAGEATTR_MASK                    (0xF0)
 
 #define MPI_CONFIG_PAGETYPE_IO_UNIT                 (0x00)
@@ -122,29 +159,21 @@
 #define MPI_CONFIG_PAGETYPE_LAN                     (0x07)
 #define MPI_CONFIG_PAGETYPE_RAID_VOLUME             (0x08)
 #define MPI_CONFIG_PAGETYPE_MANUFACTURING           (0x09)
+#define MPI_CONFIG_PAGETYPE_RAID_PHYSDISK           (0x0A)
 #define MPI_CONFIG_PAGETYPE_MASK                    (0x0F)
 
 #define MPI_CONFIG_TYPENUM_MASK                     (0x0FFF)
 
 
 /****************************************************************************
- *  PageAddres field values
- ****************************************************************************/
+*   PageAddress field values
+****************************************************************************/
 #define MPI_SCSI_PORT_PGAD_PORT_MASK                (0x000000FF)
 
-#define MPI_SCSI_DEVICE_FORM_MASK                   (0xF0000000)
-#define MPI_SCSI_DEVICE_FORM_TARGETID               (0x00000000)
-#define MPI_SCSI_DEVICE_FORM_RAID_PHYS_DEV_NUM      (0x10000000)
 #define MPI_SCSI_DEVICE_TARGET_ID_MASK              (0x000000FF)
 #define MPI_SCSI_DEVICE_TARGET_ID_SHIFT             (0)
 #define MPI_SCSI_DEVICE_BUS_MASK                    (0x0000FF00)
 #define MPI_SCSI_DEVICE_BUS_SHIFT                   (8)
-#define MPI_SCSI_DEVICE_VOLUME_TARG_ID_MASK         (0x000000FF)
-#define MPI_SCSI_DEVICE_VOLUME_TARG_ID_SHIFT        (0)
-#define MPI_SCSI_DEVICE_VOLUME_BUS_MASK             (0x0000FF00)
-#define MPI_SCSI_DEVICE_VOLUME_BUS_SHIFT            (8)
-#define MPI_SCSI_DEVICE_PHYS_DISK_NUM_MASK          (0x00FF0000)
-#define MPI_SCSI_DEVICE_PHYS_DISK_NUM_SHIFT         (16)
 
 #define MPI_FC_PORT_PGAD_PORT_MASK                  (0xF0000000)
 #define MPI_FC_PORT_PGAD_PORT_SHIFT                 (28)
@@ -167,10 +196,14 @@
 #define MPI_FC_DEVICE_PGAD_BT_TID_MASK              (0x000000FF)
 #define MPI_FC_DEVICE_PGAD_BT_TID_SHIFT             (0)
 
+#define MPI_PHYSDISK_PGAD_PHYSDISKNUM_MASK          (0x000000FF)
+#define MPI_PHYSDISK_PGAD_PHYSDISKNUM_SHIFT         (0)
+
 
-/****************************************************************************/
-/*  Config Request Message                                                          */
-/****************************************************************************/
+
+/****************************************************************************
+*   Config Request Message
+****************************************************************************/
 typedef struct _MSG_CONFIG
 {
     U8                      Action;                     /* 00h */
@@ -181,16 +214,16 @@
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
     U8                      Reserved2[8];               /* 0Ch */
-   fCONFIG_PAGE_HEADER      Header;                     /* 14h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 14h */
     U32                     PageAddress;                /* 18h */
     SGE_IO_UNION            PageBufferSGE;              /* 1Ch */
 } MSG_CONFIG, MPI_POINTER PTR_MSG_CONFIG,
   Config_t, MPI_POINTER pConfig_t;
 
 
-/****************************************************************************/
-/*  Action field values                                                     */
-/****************************************************************************/
+/****************************************************************************
+*   Action field values
+****************************************************************************/
 #define MPI_CONFIG_ACTION_PAGE_HEADER               (0x00)
 #define MPI_CONFIG_ACTION_PAGE_READ_CURRENT         (0x01)
 #define MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT        (0x02)
@@ -213,7 +246,7 @@
     U8                      Reserved2[2];               /* 0Ch */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
-   fCONFIG_PAGE_HEADER      Header;                     /* 14h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 14h */
 } MSG_CONFIG_REPLY, MPI_POINTER PTR_MSG_CONFIG_REPLY,
   ConfigReply_t, MPI_POINTER pConfigReply_t;
 
@@ -225,19 +258,24 @@
 *
 *****************************************************************************/
 
-/****************************************************************************/
-/*  Manufacturing Config pages                                              */
-/****************************************************************************/
+/****************************************************************************
+*   Manufacturing Config pages
+****************************************************************************/
 #define MPI_MANUFACTPAGE_DEVICEID_FC909             (0x0621)
 #define MPI_MANUFACTPAGE_DEVICEID_FC919             (0x0624)
 #define MPI_MANUFACTPAGE_DEVICEID_FC929             (0x0622)
+#define MPI_MANUFACTPAGE_DEVICEID_FC919X            (0x0628)
+#define MPI_MANUFACTPAGE_DEVICEID_FC929X            (0x0626)
 #define MPI_MANUFACTPAGE_DEVID_53C1030              (0x0030)
 #define MPI_MANUFACTPAGE_DEVID_53C1030ZC            (0x0031)
-#define MPI_MANUFACTPAGE_DEVID_53C1035              (0x0035)
+#define MPI_MANUFACTPAGE_DEVID_1030_53C1035         (0x0032)
+#define MPI_MANUFACTPAGE_DEVID_1030ZC_53C1035       (0x0033)
+#define MPI_MANUFACTPAGE_DEVID_53C1035              (0x0040)
+#define MPI_MANUFACTPAGE_DEVID_53C1035ZC            (0x0041)
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      ChipName[16];               /* 04h */
     U8                      ChipRevision[8];            /* 14h */
     U8                      BoardName[16];              /* 1Ch */
@@ -252,7 +290,7 @@
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      VPD[256];                   /* 04h */
 } fCONFIG_PAGE_MANUFACTURING_1, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_1,
   ManufacturingPage1_t, MPI_POINTER pManufacturingPage1_t;
@@ -269,35 +307,72 @@
   MpiChipRevisionId_t, MPI_POINTER pMpiChipRevisionId_t;
 
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_MAN_PAGE_2_HW_SETTINGS_WORDS
+#define MPI_MAN_PAGE_2_HW_SETTINGS_WORDS    (1)
+#endif
+
 typedef struct _CONFIG_PAGE_MANUFACTURING_2
 {
-   fCONFIG_PAGE_HEADER                  Header;         /* 00h */
-    MPI_CHIP_REVISION_ID                ChipId;         /* 04h */
-    U32                                 HwSettings[1];  /* 08h */
+    fCONFIG_PAGE_HEADER      Header;                                 /* 00h */
+    MPI_CHIP_REVISION_ID    ChipId;                                 /* 04h */
+    U32                     HwSettings[MPI_MAN_PAGE_2_HW_SETTINGS_WORDS];/* 08h */
 } fCONFIG_PAGE_MANUFACTURING_2, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_2,
   ManufacturingPage2_t, MPI_POINTER pManufacturingPage2_t;
 
 #define MPI_MANUFACTURING2_PAGEVERSION                  (0x00)
 
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_MAN_PAGE_3_INFO_WORDS
+#define MPI_MAN_PAGE_3_INFO_WORDS           (1)
+#endif
+
 typedef struct _CONFIG_PAGE_MANUFACTURING_3
 {
-   fCONFIG_PAGE_HEADER                  Header;         /* 00h */
-    MPI_CHIP_REVISION_ID                ChipId;         /* 04h */
-    U32                                 Info[1];        /* 08h */
+    fCONFIG_PAGE_HEADER                  Header;                     /* 00h */
+    MPI_CHIP_REVISION_ID                ChipId;                     /* 04h */
+    U32                                 Info[MPI_MAN_PAGE_3_INFO_WORDS];/* 08h */
 } fCONFIG_PAGE_MANUFACTURING_3, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_3,
   ManufacturingPage3_t, MPI_POINTER pManufacturingPage3_t;
 
 #define MPI_MANUFACTURING3_PAGEVERSION                  (0x00)
 
 
-/****************************************************************************/
-/*  IO Unit Config Pages                                                    */
-/****************************************************************************/
+typedef struct _CONFIG_PAGE_MANUFACTURING_4
+{
+    fCONFIG_PAGE_HEADER              Header;             /* 00h */
+    U32                             Reserved1;          /* 04h */
+    U8                              InfoOffset0;        /* 08h */
+    U8                              InfoSize0;          /* 09h */
+    U8                              InfoOffset1;        /* 0Ah */
+    U8                              InfoSize1;          /* 0Bh */
+    U8                              InquirySize;        /* 0Ch */
+    U8                              Reserved2;          /* 0Dh */
+    U16                             Reserved3;          /* 0Eh */
+    U8                              InquiryData[56];    /* 10h */
+    U32                             ISVolumeSettings;   /* 48h */
+    U32                             IMEVolumeSettings;  /* 4Ch */
+    U32                             IMVolumeSettings;   /* 50h */
+} fCONFIG_PAGE_MANUFACTURING_4, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_4,
+  ManufacturingPage4_t, MPI_POINTER pManufacturingPage4_t;
+
+#define MPI_MANUFACTURING4_PAGEVERSION                  (0x00)
+
+
+/****************************************************************************
+*   IO Unit Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_IO_UNIT_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U64                     UniqueValue;                /* 04h */
 } fCONFIG_PAGE_IO_UNIT_0, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_0,
   IOUnitPage0_t, MPI_POINTER pIOUnitPage0_t;
@@ -307,18 +382,20 @@
 
 typedef struct _CONFIG_PAGE_IO_UNIT_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
 } fCONFIG_PAGE_IO_UNIT_1, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_1,
   IOUnitPage1_t, MPI_POINTER pIOUnitPage1_t;
 
 #define MPI_IOUNITPAGE1_PAGEVERSION                     (0x00)
 
+/* IO Unit Page 1 Flags defines */
+
 #define MPI_IOUNITPAGE1_MULTI_FUNCTION                  (0x00000000)
 #define MPI_IOUNITPAGE1_SINGLE_FUNCTION                 (0x00000001)
 #define MPI_IOUNITPAGE1_MULTI_PATHING                   (0x00000002)
 #define MPI_IOUNITPAGE1_SINGLE_PATHING                  (0x00000000)
-
+#define MPI_IOUNITPAGE1_DISABLE_IR                      (0x00000040)
 #define MPI_IOUNITPAGE1_FORCE_32                        (0x00000080)
 
 
@@ -335,7 +412,7 @@
 
 typedef struct _CONFIG_PAGE_IO_UNIT_2
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U32                     BiosVersion;                /* 08h */
     MPI_ADAPTER_INFO        AdapterOrder[4];            /* 0Ch */
@@ -344,38 +421,45 @@
 
 #define MPI_IOUNITPAGE2_PAGEVERSION                     (0x00)
 
-#define MPI_IOUNITPAGE2_FLAGS_RAID_DISABLE              (0x00000001)
 #define MPI_IOUNITPAGE2_FLAGS_PAUSE_ON_ERROR            (0x00000002)
 #define MPI_IOUNITPAGE2_FLAGS_VERBOSE_ENABLE            (0x00000004)
 #define MPI_IOUNITPAGE2_FLAGS_COLOR_VIDEO_DISABLE       (0x00000008)
 #define MPI_IOUNITPAGE2_FLAGS_DONT_HOOK_INT_40          (0x00000010)
 
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_IO_UNIT_PAGE_3_GPIO_VAL_MAX
+#define MPI_IO_UNIT_PAGE_3_GPIO_VAL_MAX     (1)
+#endif
+
 typedef struct _CONFIG_PAGE_IO_UNIT_3
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
-    U32                     VolumeSettings;             /* 04h */
-    U8                      InfoOffset0;                /* 08h */
-    U8                      InfoSize0;                  /* 09h */
-    U8                      InfoOffset1;                /* 0Ah */
-    U8                      InfoSize1;                  /* 0Bh */
-    U8                      InquirySize;                /* 0Ch */
-    U8                      Reserved;                   /* 0Dh */
-    U16                     Reserved2;                  /* 0Eh */
-    U8                      InquiryData[56];            /* 10h */
+    fCONFIG_PAGE_HEADER      Header;                                   /* 00h */
+    U8                      GPIOCount;                                /* 04h */
+    U8                      Reserved1;                                /* 05h */
+    U16                     Reserved2;                                /* 06h */
+    U16                     GPIOVal[MPI_IO_UNIT_PAGE_3_GPIO_VAL_MAX]; /* 08h */
 } fCONFIG_PAGE_IO_UNIT_3, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_3,
   IOUnitPage3_t, MPI_POINTER pIOUnitPage3_t;
 
-#define MPI_IOUNITPAGE3_PAGEVERSION                     (0x00)
+#define MPI_IOUNITPAGE3_PAGEVERSION                     (0x01)
+
+#define MPI_IOUNITPAGE3_GPIO_FUNCTION_MASK              (0xFC)
+#define MPI_IOUNITPAGE3_GPIO_FUNCTION_SHIFT             (2)
+#define MPI_IOUNITPAGE3_GPIO_SETTING_OFF                (0x00)
+#define MPI_IOUNITPAGE3_GPIO_SETTING_ON                 (0x01)
 
 
-/****************************************************************************/
-/*  IOC Config Pages                                                        */
-/****************************************************************************/
+/****************************************************************************
+*   IOC Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_IOC_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     TotalNVStore;               /* 04h */
     U32                     FreeNVStore;                /* 08h */
     U16                     VendorID;                   /* 0Ch */
@@ -393,7 +477,7 @@
 
 typedef struct _CONFIG_PAGE_IOC_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U32                     CoalescingTimeout;          /* 08h */
     U8                      CoalescingDepth;            /* 0Ch */
@@ -408,53 +492,120 @@
 
 typedef struct _CONFIG_PAGE_IOC_2_RAID_VOL
 {
-    U8                      VolumeTargetID;             /* 00h */
-    U8                      VolumeBus;                  /* 01h */
-    U16                     Reserved;                   /* 02h */
-    U8                      VolumeVersionMinor;         /* 04h */
-    U8                      VolumeVersionMajor;         /* 05h */
-    U8                      VolumeRaidType;             /* 06h */
-    U8                      Reserved1;                  /* 07h */
+    U8                          VolumeID;               /* 00h */
+    U8                          VolumeBus;              /* 01h */
+    U8                          VolumeIOC;              /* 02h */
+    U8                          VolumePageNumber;       /* 03h */
+    U8                          VolumeType;             /* 04h */
+    U8                          Reserved2;              /* 05h */
+    U16                         Reserved3;              /* 06h */
 } fCONFIG_PAGE_IOC_2_RAID_VOL, MPI_POINTER PTR_CONFIG_PAGE_IOC_2_RAID_VOL,
   ConfigPageIoc2RaidVol_t, MPI_POINTER pConfigPageIoc2RaidVol_t;
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_IOC_PAGE_2_RAID_VOLUME_MAX
+#define MPI_IOC_PAGE_2_RAID_VOLUME_MAX      (1)
+#endif
+
 typedef struct _CONFIG_PAGE_IOC_2
 {
-   fCONFIG_PAGE_HEADER          Header;                 /* 00h */
-    U32                         CapabilitiesFlags;      /* 04h */
-    U8                          NumActiveVolumes;       /* 08h */
-    U8                          MaxVolumes;             /* 09h */
-    U16                         Reserved;               /* 0Ah */
-   fCONFIG_PAGE_IOC_2_RAID_VOL  RaidVolume[1];          /* 0Ch */
+    fCONFIG_PAGE_HEADER          Header;                              /* 00h */
+    U32                         CapabilitiesFlags;                   /* 04h */
+    U8                          NumActiveVolumes;                    /* 08h */
+    U8                          MaxVolumes;                          /* 09h */
+    U8                          NumActivePhysDisks;                  /* 0Ah */
+    U8                          MaxPhysDisks;                        /* 0Bh */
+    fCONFIG_PAGE_IOC_2_RAID_VOL  RaidVolume[MPI_IOC_PAGE_2_RAID_VOLUME_MAX];/* 0Ch */
 } fCONFIG_PAGE_IOC_2, MPI_POINTER PTR_CONFIG_PAGE_IOC_2,
   IOCPage2_t, MPI_POINTER pIOCPage2_t;
 
-#define MPI_IOCPAGE2_PAGEVERSION                        (0x00)
+#define MPI_IOCPAGE2_PAGEVERSION                        (0x01)
 
 /* IOC Page 2 Capabilities flags */
 
-#define MPI_IOCPAGE2_CAP_FLAGS_RAID_0_SUPPORT           (0x00000001)
-#define MPI_IOCPAGE2_CAP_FLAGS_RAID_1_SUPPORT           (0x00000002)
-#define MPI_IOCPAGE2_CAP_FLAGS_LSI_MIRROR_SUPPORT       (0x00000004)
-#define MPI_IOCPAGE2_CAP_FLAGS_RAID_5_SUPPORT           (0x00000008)
-#define MPI_IOCPAGE2_CAP_FLAGS_RAID_10_SUPPORT          (0x00000010)
-
-/* IOC Page 2 Volume RAID Type values */
-
-#define MPI_IOCPAGE2_VOL_TYPE_RAID_0                    (0x00)
-#define MPI_IOCPAGE2_VOL_TYPE_RAID_1                    (0x01)
-#define MPI_IOCPAGE2_VOL_TYPE_LSI_MIRROR                (0x02)
-#define MPI_IOCPAGE2_VOL_TYPE_RAID_5                    (0x05)
-#define MPI_IOCPAGE2_VOL_TYPE_RAID_10                   (0x0A)
-
-
-/****************************************************************************/
-/*  SCSI Port Config Pages                                                  */
-/****************************************************************************/
+#define MPI_IOCPAGE2_CAP_FLAGS_IS_SUPPORT               (0x00000001)
+#define MPI_IOCPAGE2_CAP_FLAGS_IME_SUPPORT              (0x00000002)
+#define MPI_IOCPAGE2_CAP_FLAGS_IM_SUPPORT               (0x00000004)
+#define MPI_IOCPAGE2_CAP_FLAGS_SES_SUPPORT              (0x20000000)
+#define MPI_IOCPAGE2_CAP_FLAGS_SAFTE_SUPPORT            (0x40000000)
+#define MPI_IOCPAGE2_CAP_FLAGS_CROSS_CHANNEL_SUPPORT    (0x80000000)
+
+/* IOC Page 2 Volume RAID Type values, also used in RAID Volume pages */
+
+#define MPI_RAID_VOL_TYPE_IS                        (0x00)
+#define MPI_RAID_VOL_TYPE_IME                       (0x01)
+#define MPI_RAID_VOL_TYPE_IM                        (0x02)
+
+
+typedef struct _IOC_3_PHYS_DISK
+{
+    U8                          PhysDiskID;             /* 00h */
+    U8                          PhysDiskBus;            /* 01h */
+    U8                          PhysDiskIOC;            /* 02h */
+    U8                          PhysDiskNum;            /* 03h */
+} IOC_3_PHYS_DISK, MPI_POINTER PTR_IOC_3_PHYS_DISK,
+  Ioc3PhysDisk_t, MPI_POINTER pIoc3PhysDisk_t;
+
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_IOC_PAGE_3_PHYSDISK_MAX
+#define MPI_IOC_PAGE_3_PHYSDISK_MAX         (1)
+#endif
+
+typedef struct _CONFIG_PAGE_IOC_3
+{
+    fCONFIG_PAGE_HEADER          Header;                                /* 00h */
+    U8                          NumPhysDisks;                          /* 04h */
+    U8                          Reserved1;                             /* 05h */
+    U16                         Reserved2;                             /* 06h */
+    IOC_3_PHYS_DISK             PhysDisk[MPI_IOC_PAGE_3_PHYSDISK_MAX]; /* 08h */
+} fCONFIG_PAGE_IOC_3, MPI_POINTER PTR_CONFIG_PAGE_IOC_3,
+  IOCPage3_t, MPI_POINTER pIOCPage3_t;
+
+#define MPI_IOCPAGE3_PAGEVERSION                        (0x00)
+
+
+typedef struct _IOC_4_SEP
+{
+    U8                          SEPTargetID;            /* 00h */
+    U8                          SEPBus;                 /* 01h */
+    U16                         Reserved;               /* 02h */
+} IOC_4_SEP, MPI_POINTER PTR_IOC_4_SEP,
+  Ioc4Sep_t, MPI_POINTER pIoc4Sep_t;
+
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_IOC_PAGE_4_SEP_MAX
+#define MPI_IOC_PAGE_4_SEP_MAX              (1)
+#endif
+
+typedef struct _CONFIG_PAGE_IOC_4
+{
+    fCONFIG_PAGE_HEADER          Header;                         /* 00h */
+    U8                          ActiveSEP;                      /* 04h */
+    U8                          MaxSEP;                         /* 05h */
+    U16                         Reserved1;                      /* 06h */
+    IOC_4_SEP                   SEP[MPI_IOC_PAGE_4_SEP_MAX];    /* 08h */
+} fCONFIG_PAGE_IOC_4, MPI_POINTER PTR_CONFIG_PAGE_IOC_4,
+  IOCPage4_t, MPI_POINTER pIOCPage4_t;
+
+#define MPI_IOCPAGE4_PAGEVERSION                        (0x00)
+
+
+/****************************************************************************
+*   SCSI Port Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Capabilities;               /* 04h */
     U32                     PhysicalInterface;          /* 08h */
 } fCONFIG_PAGE_SCSI_PORT_0, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_0,
@@ -465,7 +616,6 @@
 #define MPI_SCSIPORTPAGE0_CAP_IU                        (0x00000001)
 #define MPI_SCSIPORTPAGE0_CAP_DT                        (0x00000002)
 #define MPI_SCSIPORTPAGE0_CAP_QAS                       (0x00000004)
-#define MPI_SCSIPORTPAGE0_CAP_PACING_TRANSFERS          (0x00000008)
 #define MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK      (0x0000FF00)
 #define MPI_SCSIPORTPAGE0_CAP_MAX_SYNC_OFFSET_MASK      (0x00FF0000)
 #define MPI_SCSIPORTPAGE0_CAP_WIDE                      (0x20000000)
@@ -479,12 +629,13 @@
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Configuration;              /* 04h */
+    U32                     OnBusTimerValue;            /* 08h */
 } fCONFIG_PAGE_SCSI_PORT_1, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_1,
   SCSIPortPage1_t, MPI_POINTER pSCSIPortPage1_t;
 
-#define MPI_SCSIPORTPAGE1_PAGEVERSION                   (0x01)
+#define MPI_SCSIPORTPAGE1_PAGEVERSION                   (0x02)
 
 #define MPI_SCSIPORTPAGE1_CFG_PORT_SCSI_ID_MASK         (0x000000FF)
 #define MPI_SCSIPORTPAGE1_CFG_PORT_RESPONSE_ID_MASK     (0xFFFF0000)
@@ -500,7 +651,7 @@
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_2
 {
-   fCONFIG_PAGE_HEADER  Header;                         /* 00h */
+    fCONFIG_PAGE_HEADER  Header;                         /* 00h */
     U32                 PortFlags;                      /* 04h */
     U32                 PortSettings;                   /* 08h */
     MPI_DEVICE_INFO     DeviceSettings[16];             /* 0Ch */
@@ -510,7 +661,6 @@
 #define MPI_SCSIPORTPAGE2_PAGEVERSION                       (0x01)
 
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_SCAN_HIGH_TO_LOW       (0x00000001)
-#define MPI_SCSIPORTPAGE2_PORT_FLAGS_PARITY_ENABLE          (0x00000002)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_AVOID_SCSI_RESET       (0x00000004)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_ALTERNATE_CHS          (0x00000008)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_TERMINATION_DISABLE    (0x00000010)
@@ -536,47 +686,48 @@
 #define MPI_SCSIPORTPAGE2_DEVICE_BOOT_CHOICE                (0x0020)
 
 
-/****************************************************************************/
-/*  SCSI Target Device Config Pages                                         */
-/****************************************************************************/
+/****************************************************************************
+*   SCSI Target Device Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     NegotiatedParameters;       /* 04h */
     U32                     Information;                /* 08h */
 } fCONFIG_PAGE_SCSI_DEVICE_0, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_0,
   SCSIDevicePage0_t, MPI_POINTER pSCSIDevicePage0_t;
 
-#define MPI_SCSIDEVPAGE0_PAGEVERSION                    (0x01)
+#define MPI_SCSIDEVPAGE0_PAGEVERSION                    (0x02)
 
 #define MPI_SCSIDEVPAGE0_NP_IU                          (0x00000001)
 #define MPI_SCSIDEVPAGE0_NP_DT                          (0x00000002)
 #define MPI_SCSIDEVPAGE0_NP_QAS                         (0x00000004)
-#define MPI_SCSIDEVPAGE0_NP_PACING_TRANSFERS            (0x00000008)
 #define MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK        (0x0000FF00)
 #define MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK        (0x00FF0000)
 #define MPI_SCSIDEVPAGE0_NP_WIDE                        (0x20000000)
 #define MPI_SCSIDEVPAGE0_NP_AIP                         (0x80000000)
 
 #define MPI_SCSIDEVPAGE0_INFO_PARAMS_NEGOTIATED         (0x00000001)
+#define MPI_SCSIDEVPAGE0_INFO_SDTR_REJECTED             (0x00000002)
+#define MPI_SCSIDEVPAGE0_INFO_WDTR_REJECTED             (0x00000004)
+#define MPI_SCSIDEVPAGE0_INFO_PPR_REJECTED              (0x00000008)
 
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     RequestedParameters;        /* 04h */
     U32                     Reserved;                   /* 08h */
     U32                     Configuration;              /* 0Ch */
 } fCONFIG_PAGE_SCSI_DEVICE_1, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_1,
   SCSIDevicePage1_t, MPI_POINTER pSCSIDevicePage1_t;
 
-#define MPI_SCSIDEVPAGE1_PAGEVERSION                    (0x02)
+#define MPI_SCSIDEVPAGE1_PAGEVERSION                    (0x03)
 
 #define MPI_SCSIDEVPAGE1_RP_IU                          (0x00000001)
 #define MPI_SCSIDEVPAGE1_RP_DT                          (0x00000002)
 #define MPI_SCSIDEVPAGE1_RP_QAS                         (0x00000004)
-#define MPI_SCSIDEVPAGE1_RP_PACING_TRANSFERS            (0x00000008)
 #define MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK        (0x0000FF00)
 #define MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK        (0x00FF0000)
 #define MPI_SCSIDEVPAGE1_RP_WIDE                        (0x20000000)
@@ -585,12 +736,13 @@
 #define MPI_SCSIDEVPAGE1_DV_LVD_DRIVE_STRENGTH_MASK     (0x00000003)
 #define MPI_SCSIDEVPAGE1_DV_SE_SLEW_RATE_MASK           (0x00000300)
 
-#define MPI_SCSIDEVPAGE1_CONF_PPR_ALLOWED               (0x00000001)
+#define MPI_SCSIDEVPAGE1_CONF_WDTR_DISALLOWED           (0x00000002)
+#define MPI_SCSIDEVPAGE1_CONF_SDTR_DISALLOWED           (0x00000004)
 
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_2
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     DomainValidation;           /* 04h */
     U32                     ParityPipeSelect;           /* 08h */
     U32                     DataPipeSelect;             /* 0Ch */
@@ -629,13 +781,13 @@
 #define MPI_SCSIDEVPAGE2_DPS_BIT_15_PL_SELECT_MASK      (0xC0000000)
 
 
-/****************************************************************************/
-/*  FC Port Config Pages                                                    */
-/****************************************************************************/
+/****************************************************************************
+*   FC Port Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_FC_PORT_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U8                      MPIPortNumber;              /* 08h */
     U8                      LinkType;                   /* 09h */
@@ -715,7 +867,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U64                     NoSEEPROMWWNN;              /* 08h */
     U64                     NoSEEPROMWWPN;              /* 10h */
@@ -726,8 +878,10 @@
 } fCONFIG_PAGE_FC_PORT_1, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_1,
   FCPortPage1_t, MPI_POINTER pFCPortPage1_t;
 
-#define MPI_FCPORTPAGE1_PAGEVERSION                     (0x01)
+#define MPI_FCPORTPAGE1_PAGEVERSION                     (0x02)
 
+#define MPI_FCPORTPAGE1_FLAGS_EXT_FCP_STATUS_EN         (0x08000000)
+#define MPI_FCPORTPAGE1_FLAGS_IMMEDIATE_ERROR_REPLY     (0x04000000)
 #define MPI_FCPORTPAGE1_FLAGS_SORT_BY_DID               (0x00000001)
 #define MPI_FCPORTPAGE1_FLAGS_SORT_BY_WWN               (0x00000000)
 
@@ -747,22 +901,21 @@
 #define MPI_FCPORTPAGE1_LCONFIG_SPEED_10GIG             (0x03)
 #define MPI_FCPORTPAGE1_LCONFIG_SPEED_AUTO              (0x0F)
 
-#define MPI_FCPORTPAGE1_TOPOLGY_MASK                    (0x0F)
-#define MPI_FCPORTPAGE1_TOPOLGY_NLPORT                  (0x01)
-#define MPI_FCPORTPAGE1_TOPOLGY_NPORT                   (0x02)
-#define MPI_FCPORTPAGE1_TOPOLGY_AUTO                    (0x0F)
+#define MPI_FCPORTPAGE1_TOPOLOGY_MASK                   (0x0F)
+#define MPI_FCPORTPAGE1_TOPOLOGY_NLPORT                 (0x01)
+#define MPI_FCPORTPAGE1_TOPOLOGY_NPORT                  (0x02)
+#define MPI_FCPORTPAGE1_TOPOLOGY_AUTO                   (0x0F)
 
 
 typedef struct _CONFIG_PAGE_FC_PORT_2
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      NumberActive;               /* 04h */
-    U8                      ALPA[126];                  /* 05h */
-    U8                      Reserved;                   /* 83h */
+    U8                      ALPA[127];                  /* 05h */
 } fCONFIG_PAGE_FC_PORT_2, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_2,
   FCPortPage2_t, MPI_POINTER pFCPortPage2_t;
 
-#define MPI_FCPORTPAGE2_PAGEVERSION                     (0x00)
+#define MPI_FCPORTPAGE2_PAGEVERSION                     (0x01)
 
 
 typedef struct _WWN_FORMAT
@@ -795,10 +948,18 @@
 #define MPI_PERSISTENT_FLAGS_BOOT_DEVICE                (0x0008)
 #define MPI_PERSISTENT_FLAGS_BY_DID                     (0x0080)
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_FC_PORT_PAGE_3_ENTRY_MAX
+#define MPI_FC_PORT_PAGE_3_ENTRY_MAX        (1)
+#endif
+
 typedef struct _CONFIG_PAGE_FC_PORT_3
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
-    FC_PORT_PERSISTENT      Entry[1];                   /* 04h */
+    fCONFIG_PAGE_HEADER      Header;                                 /* 00h */
+    FC_PORT_PERSISTENT      Entry[MPI_FC_PORT_PAGE_3_ENTRY_MAX];    /* 04h */
 } fCONFIG_PAGE_FC_PORT_3, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_3,
   FCPortPage3_t, MPI_POINTER pFCPortPage3_t;
 
@@ -807,7 +968,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_4
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     PortFlags;                  /* 04h */
     U32                     PortSettings;               /* 08h */
 } fCONFIG_PAGE_FC_PORT_4, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_4,
@@ -833,13 +994,22 @@
     U16     Reserved;                                   /* 02h */
     U64     AliasWWNN;                                  /* 04h */
     U64     AliasWWPN;                                  /* 0Ch */
-} fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
+} fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
+  MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
   FcPortPage5AliasInfo_t, MPI_POINTER pFcPortPage5AliasInfo_t;
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_FC_PORT_PAGE_5_ALIAS_MAX
+#define MPI_FC_PORT_PAGE_5_ALIAS_MAX        (1)
+#endif
+
 typedef struct _CONFIG_PAGE_FC_PORT_5
 {
-   fCONFIG_PAGE_HEADER                  Header;         /* 00h */
-   fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO    AliasInfo[1];   /* 04h */
+    fCONFIG_PAGE_HEADER                  Header;                     /* 00h */
+    fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO    AliasInfo[MPI_FC_PORT_PAGE_5_ALIAS_MAX];/* 04h */
 } fCONFIG_PAGE_FC_PORT_5, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5,
   FCPortPage5_t, MPI_POINTER pFCPortPage5_t;
 
@@ -851,7 +1021,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_6
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U64                     TimeSinceReset;             /* 08h */
     U64                     TxFrames;                   /* 10h */
@@ -877,7 +1047,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_7
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U8                      PortSymbolicName[256];      /* 08h */
 } fCONFIG_PAGE_FC_PORT_7, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_7,
@@ -888,7 +1058,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_8
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     BitVector[8];               /* 04h */
 } fCONFIG_PAGE_FC_PORT_8, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_8,
   FCPortPage8_t, MPI_POINTER pFCPortPage8_t;
@@ -898,7 +1068,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_9
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U64                     GlobalWWPN;                 /* 08h */
     U64                     GlobalWWNN;                 /* 10h */
@@ -916,13 +1086,13 @@
 #define MPI_FCPORTPAGE9_PAGEVERSION                     (0x00)
 
 
-/****************************************************************************/
-/*  FC Device Config Pages                                                  */
-/****************************************************************************/
+/****************************************************************************
+*   FC Device Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_FC_DEVICE_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U64                     WWNN;                       /* 04h */
     U64                     WWPN;                       /* 0Ch */
     U32                     PortIdentifier;             /* 14h */
@@ -947,112 +1117,191 @@
 #define MPI_FC_DEVICE_PAGE0_PROT_FCP_TARGET             (0x02)
 #define MPI_FC_DEVICE_PAGE0_PROT_FCP_INITIATOR          (0x04)
 
-#define MPI_FC_DEVICE_PAGE0_PGAD_PORT_MASK              (MPI_FC_DEVICE_PGAD_PORT_MASK)
-#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_MASK              (MPI_FC_DEVICE_PGAD_FORM_MASK)
-#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_NEXT_DID          (MPI_FC_DEVICE_PGAD_FORM_NEXT_DID)
-#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_BUS_TID           (MPI_FC_DEVICE_PGAD_FORM_BUS_TID)
-#define MPI_FC_DEVICE_PAGE0_PGAD_DID_MASK               (MPI_FC_DEVICE_PGAD_ND_DID_MASK)
-#define MPI_FC_DEVICE_PAGE0_PGAD_BUS_MASK               (MPI_FC_DEVICE_PGAD_BT_BUS_MASK)
-#define MPI_FC_DEVICE_PAGE0_PGAD_BUS_SHIFT              (MPI_FC_DEVICE_PGAD_BT_BUS_SHIFT)
-#define MPI_FC_DEVICE_PAGE0_PGAD_TID_MASK               (MPI_FC_DEVICE_PGAD_BT_TID_MASK)
-
-
-/****************************************************************************/
-/*  RAID Volume Config Pages                                                  */
-/****************************************************************************/
-
-typedef struct _RAIDVOL2_IM_PHYS_ID
-{
-    U8                      TargetID;                   /* 00h */
-    U8                      Bus;                        /* 01h */
-    U8                      IocNumber;                  /* 02h */
-    U8                      PhysDiskNumber;             /* 03h */
-    U8                      Reserved[8];                /* 04h */
-    U8                      PhysicalDiskIdentifier[16]; /* 0Ch */
-    U8                      VendorId[8];                /* 1Ch */
-    U8                      ProductId[16];              /* 24h */
-    U8                      ProductRevLevel[4];         /* 34h */
-    U32                     Reserved1;                  /* 38h */
-    U8                      Info[32];                   /* 3Ch */
-} RAIDVOL2_IM_PHYS_ID, MPI_POINTER PTR_RAIDVOL2_IM_PHYS_ID,
-  RaidVol2ImPhysicalID_t, MPI_POINTER pRaidVol2ImPhysicalID_t;
-
-typedef struct _RAIDVOL2_IM_DISK_INFO
-{
-    U32                     DiskStatus;                 /* 00h */
-    U32                     DeviceSettings;             /* 04h */
-    U16                     ErrorCount;                 /* 08h */
-    U16                     Reserved;                   /* 0Ah */
-    U8                      ErrorCdbByte;               /* 0Ch */
-    U8                      ErrorSenseKey;              /* 0Dh */
-    U8                      ErrorASC;                   /* 0Eh */
-    U8                      ErrorASCQ;                  /* 0Fh */
-    U16                     SmartCount;                 /* 10h */
-    U8                      SmartASC;                   /* 12h */
-    U8                      SmartASCQ;                  /* 13h */
-} RAIDVOL2_IM_DISK_INFO, MPI_POINTER PTR_RAIDVOL2_IM_DISK_INFO,
-  RaidVol2ImDiskInfo_t, MPI_POINTER pRaidVol2ImDiskInfo_t;
+#define MPI_FC_DEVICE_PAGE0_PGAD_PORT_MASK      (MPI_FC_DEVICE_PGAD_PORT_MASK)
+#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_MASK      (MPI_FC_DEVICE_PGAD_FORM_MASK)
+#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_NEXT_DID  (MPI_FC_DEVICE_PGAD_FORM_NEXT_DID)
+#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_BUS_TID   (MPI_FC_DEVICE_PGAD_FORM_BUS_TID)
+#define MPI_FC_DEVICE_PAGE0_PGAD_DID_MASK       (MPI_FC_DEVICE_PGAD_ND_DID_MASK)
+#define MPI_FC_DEVICE_PAGE0_PGAD_BUS_MASK       (MPI_FC_DEVICE_PGAD_BT_BUS_MASK)
+#define MPI_FC_DEVICE_PAGE0_PGAD_BUS_SHIFT      (MPI_FC_DEVICE_PGAD_BT_BUS_SHIFT)
+#define MPI_FC_DEVICE_PAGE0_PGAD_TID_MASK       (MPI_FC_DEVICE_PGAD_BT_TID_MASK)
+
+
+/****************************************************************************
+*   RAID Volume Config Pages
+****************************************************************************/
+
+typedef struct _RAID_VOL0_PHYS_DISK
+{
+    U16                         Reserved;               /* 00h */
+    U8                          PhysDiskMap;            /* 02h */
+    U8                          PhysDiskNum;            /* 03h */
+} RAID_VOL0_PHYS_DISK, MPI_POINTER PTR_RAID_VOL0_PHYS_DISK,
+  RaidVol0PhysDisk_t, MPI_POINTER pRaidVol0PhysDisk_t;
+
+#define MPI_RAIDVOL0_PHYSDISK_PRIMARY                   (0x01)
+#define MPI_RAIDVOL0_PHYSDISK_SECONDARY                 (0x02)
+
+typedef struct _RAID_VOL0_STATUS
+{
+    U8                          Flags;                  /* 00h */
+    U8                          State;                  /* 01h */
+    U16                         Reserved;               /* 02h */
+} RAID_VOL0_STATUS, MPI_POINTER PTR_RAID_VOL0_STATUS,
+  RaidVol0Status_t, MPI_POINTER pRaidVol0Status_t;
+
+/* RAID Volume Page 0 VolumeStatus defines */
+
+#define MPI_RAIDVOL0_STATUS_FLAG_ENABLED                (0x01)
+#define MPI_RAIDVOL0_STATUS_FLAG_QUIESCED               (0x02)
+#define MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS     (0x04)
+
+#define MPI_RAIDVOL0_STATUS_STATE_OPTIMAL               (0x00)
+#define MPI_RAIDVOL0_STATUS_STATE_DEGRADED              (0x01)
+#define MPI_RAIDVOL0_STATUS_STATE_FAILED                (0x02)
+
+typedef struct _RAID_VOL0_SETTINGS
+{
+    U16                         Settings;       /* 00h */
+    U8                          HotSparePool;   /* 01h */ /* MPI_RAID_HOT_SPARE_POOL_ */
+    U8                          Reserved;       /* 02h */
+} RAID_VOL0_SETTINGS, MPI_POINTER PTR_RAID_VOL0_SETTINGS,
+  RaidVol0Settings, MPI_POINTER pRaidVol0Settings;
+
+/* RAID Volume Page 0 VolumeSettings defines */
+
+#define MPI_RAIDVOL0_SETTING_WRITE_CACHING_ENABLE       (0x0001)
+#define MPI_RAIDVOL0_SETTING_OFFLINE_ON_SMART           (0x0002)
+#define MPI_RAIDVOL0_SETTING_AUTO_CONFIGURE             (0x0004)
+#define MPI_RAIDVOL0_SETTING_PRIORITY_RESYNC            (0x0008)
+#define MPI_RAIDVOL0_SETTING_USE_PRODUCT_ID_SUFFIX      (0x0010)
+#define MPI_RAIDVOL0_SETTING_USE_DEFAULTS               (0x8000)
+
+/* RAID Volume Page 0 HotSparePool defines, also used in RAID Physical Disk */
+#define MPI_RAID_HOT_SPARE_POOL_0                       (0x01)
+#define MPI_RAID_HOT_SPARE_POOL_1                       (0x02)
+#define MPI_RAID_HOT_SPARE_POOL_2                       (0x04)
+#define MPI_RAID_HOT_SPARE_POOL_3                       (0x08)
+#define MPI_RAID_HOT_SPARE_POOL_4                       (0x10)
+#define MPI_RAID_HOT_SPARE_POOL_5                       (0x20)
+#define MPI_RAID_HOT_SPARE_POOL_6                       (0x40)
+#define MPI_RAID_HOT_SPARE_POOL_7                       (0x80)
+
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_RAID_VOL_PAGE_0_PHYSDISK_MAX
+#define MPI_RAID_VOL_PAGE_0_PHYSDISK_MAX        (1)
+#endif
+
+typedef struct _CONFIG_PAGE_RAID_VOL_0
+{
+    fCONFIG_PAGE_HEADER      Header;         /* 00h */
+    U8                      VolumeID;       /* 04h */
+    U8                      VolumeBus;      /* 05h */
+    U8                      VolumeIOC;      /* 06h */
+    U8                      VolumeType;     /* 07h */ /* MPI_RAID_VOL_TYPE_ */
+    RAID_VOL0_STATUS        VolumeStatus;   /* 08h */
+    RAID_VOL0_SETTINGS      VolumeSettings; /* 0Ch */
+    U32                     MaxLBA;         /* 10h */
+    U32                     Reserved1;      /* 14h */
+    U32                     StripeSize;     /* 18h */
+    U32                     Reserved2;      /* 1Ch */
+    U32                     Reserved3;      /* 20h */
+    U8                      NumPhysDisks;   /* 24h */
+    U8                      Reserved4;      /* 25h */
+    U16                     Reserved5;      /* 26h */
+    RAID_VOL0_PHYS_DISK     PhysDisk[MPI_RAID_VOL_PAGE_0_PHYSDISK_MAX];/* 28h */
+} fCONFIG_PAGE_RAID_VOL_0, MPI_POINTER PTR_CONFIG_PAGE_RAID_VOL_0,
+  RaidVolumePage0_t, MPI_POINTER pRaidVolumePage0_t;
+
+#define MPI_RAIDVOLPAGE0_PAGEVERSION                    (0x00)
+
+
+/****************************************************************************
+*   RAID Physical Disk Config Pages
+****************************************************************************/
+
+typedef struct _RAID_PHYS_DISK0_ERROR_DATA
+{
+    U8                      ErrorCdbByte;               /* 00h */
+    U8                      ErrorSenseKey;              /* 01h */
+    U16                     Reserved;                   /* 02h */
+    U16                     ErrorCount;                 /* 04h */
+    U8                      ErrorASC;                   /* 06h */
+    U8                      ErrorASCQ;                  /* 07h */
+    U16                     SmartCount;                 /* 08h */
+    U8                      SmartASC;                   /* 0Ah */
+    U8                      SmartASCQ;                  /* 0Bh */
+} RAID_PHYS_DISK0_ERROR_DATA, MPI_POINTER PTR_RAID_PHYS_DISK0_ERROR_DATA,
+  RaidPhysDisk0ErrorData_t, MPI_POINTER pRaidPhysDisk0ErrorData_t;
+
+typedef struct _RAID_PHYS_DISK_INQUIRY_DATA
+{
+    U8                          VendorID[8];            /* 00h */
+    U8                          ProductID[16];          /* 08h */
+    U8                          ProductRevLevel[4];     /* 18h */
+    U8                          Info[32];               /* 1Ch */
+} RAID_PHYS_DISK0_INQUIRY_DATA, MPI_POINTER PTR_RAID_PHYS_DISK0_INQUIRY_DATA,
+  RaidPhysDisk0InquiryData, MPI_POINTER pRaidPhysDisk0InquiryData;
+
+typedef struct _RAID_PHYS_DISK0_SETTINGS
+{
+    U8              SepID;              /* 00h */
+    U8              SepBus;             /* 01h */
+    U8              HotSparePool;       /* 02h */ /* MPI_RAID_HOT_SPARE_POOL_ */
+    U8              PhysDiskSettings;   /* 03h */
+} RAID_PHYS_DISK0_SETTINGS, MPI_POINTER PTR_RAID_PHYS_DISK0_SETTINGS,
+  RaidPhysDiskSettings_t, MPI_POINTER pRaidPhysDiskSettings_t;
+
+typedef struct _RAID_PHYS_DISK0_STATUS
+{
+    U8                              Flags;              /* 00h */
+    U8                              State;              /* 01h */
+    U16                             Reserved;           /* 02h */
+} RAID_PHYS_DISK0_STATUS, MPI_POINTER PTR_RAID_PHYS_DISK0_STATUS,
+  RaidPhysDiskStatus_t, MPI_POINTER pRaidPhysDiskStatus_t;
 
 /* RAID Volume 2 IM Physical Disk DiskStatus flags */
 
-#define MPI_RVP2_PHYS_DISK_PRIMARY                      (0x00000001)
-#define MPI_RVP2_PHYS_DISK_SECONDARY                    (0x00000002)
-#define MPI_RVP2_PHYS_DISK_HOT_SPARE                    (0x00000004)
-#define MPI_RVP2_PHYS_DISK_OUT_OF_SYNC                  (0x00000008)
-#define MPI_RVP2_PHYS_DISK_STATUS_MASK                  (0x00000F00)
-#define MPI_RVP2_PHYS_DISK_STATUS_ONLINE                (0x00000000)
-#define MPI_RVP2_PHYS_DISK_STATUS_MISSING               (0x00000100)
-#define MPI_RVP2_PHYS_DISK_STATUS_NOT_COMPATIBLE        (0x00000200)
-#define MPI_RVP2_PHYS_DISK_STATUS_FAILED                (0x00000300)
-#define MPI_RVP2_PHYS_DISK_STATUS_INITIALIZING          (0x00000400)
-#define MPI_RVP2_PHYS_DISK_STATUS_OFFLINE_REQUESTED     (0x00000500)
-#define MPI_RVP2_PHYS_DISK_STATUS_OTHER_OFFLINE         (0x00000F00)
-
-
-typedef struct _RAIDVOL2_IM_PHYSICAL_DISK
-{
-    RAIDVOL2_IM_PHYS_ID     Id;                         /* 00h */
-    RAIDVOL2_IM_DISK_INFO   Info;                       /* 5Ch */
-} RAIDVOL2_IM_PHYSICAL_DISK, MPI_POINTER PTR_RAIDVOL2_IM_PHYSICAL_DISK,
-  RaidVol2ImPhysicalDisk_t, MPI_POINTER pRaidVol2ImPhysicalDisk_t;
-
-#define MPI_RAIDVOLPAGE2_MAX_DISKS                      (3)
-
-typedef struct _CONFIG_PAGE_RAID_VOL_2
-{
-   fCONFIG_PAGE_HEADER          Header;                 /* 00h */
-    U32                         VolumeStatus;           /* 04h */
-    U32                         VolumeSettings;         /* 08h */
-    U32                         Reserved;               /* 0Ch */
-    U64                         MaxLba;                 /* 10h */
-    U32                         BlockSize;              /* 18h */
-    U8                          Reserved1;              /* 1Ch */
-    U8                          NumPhysicalDisks;       /* 1Dh */
-    U16                         Reserved2;              /* 1Eh */
-    RAIDVOL2_IM_PHYSICAL_DISK   IMPhysicalDisk[MPI_RAIDVOLPAGE2_MAX_DISKS];
-} fCONFIG_PAGE_RAID_VOL_2, MPI_POINTER PTR_CONFIG_PAGE_RAID_VOL_2,
-  RaidVolumePage2_t, MPI_POINTER pRaidVolumePage2_t;
-
-#define MPI_RAIDVOLPAGE2_PAGEVERSION                    (0x00)
-
-/* RAID Volume Page 2 VolumeStatus defines */
-
-#define MPI_RAIDVOLPAGE2_STATUS_ENABLED                 (0x00000001)
-#define MPI_RAIDVOLPAGE2_STATUS_QUIESCED                (0x00000002)
-#define MPI_RAIDVOLPAGE2_STATUS_RESYNC_IN_PROGRESS      (0x00000004)
-#define MPI_RAIDVOLPAGE2_STATUS_DEGRADED                (0x00000008)
-
-/* RAID Volume Page 2 VolumeSettings defines */
-
-#define MPI_RAIDVOLPAGE2_SETTING_WRITE_CACHING_ENABLE   (0x00000001)
-#define MPI_RAIDVOLPAGE2_SETTING_OFFLINE_ON_SMART       (0x00000002)
-#define MPI_RAIDVOLPAGE2_SETTING_AUTO_CONFIGURE         (0x00000004)
-#define MPI_RAIDVOLPAGE2_SETTING_USE_DEFAULTS           (0x80000000)
-
-
-/****************************************************************************/
-/* LAN Config Pages                                                         */
-/****************************************************************************/
+#define MPI_PHYSDISK0_STATUS_FLAG_OUT_OF_SYNC           (0x01)
+#define MPI_PHYSDISK0_STATUS_FLAG_QUIESCED              (0x02)
+
+#define MPI_PHYSDISK0_STATUS_ONLINE                     (0x00)
+#define MPI_PHYSDISK0_STATUS_MISSING                    (0x01)
+#define MPI_PHYSDISK0_STATUS_NOT_COMPATIBLE             (0x02)
+#define MPI_PHYSDISK0_STATUS_FAILED                     (0x03)
+#define MPI_PHYSDISK0_STATUS_INITIALIZING               (0x04)
+#define MPI_PHYSDISK0_STATUS_OFFLINE_REQUESTED          (0x05)
+#define MPI_PHYSDISK0_STATUS_FAILED_REQUESTED           (0x06)
+#define MPI_PHYSDISK0_STATUS_OTHER_OFFLINE              (0xFF)
+
+typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_0
+{
+    fCONFIG_PAGE_HEADER              Header;             /* 00h */
+    U8                              PhysDiskID;         /* 04h */
+    U8                              PhysDiskBus;        /* 05h */
+    U8                              PhysDiskIOC;        /* 06h */
+    U8                              PhysDiskNum;        /* 07h */
+    RAID_PHYS_DISK0_SETTINGS        PhysDiskSettings;   /* 08h */
+    U32                             Reserved1;          /* 0Ch */
+    U32                             Reserved2;          /* 10h */
+    U32                             Reserved3;          /* 14h */
+    U8                              DiskIdentifier[16]; /* 18h */
+    RAID_PHYS_DISK0_INQUIRY_DATA    InquiryData;        /* 28h */
+    RAID_PHYS_DISK0_STATUS          PhysDiskStatus;     /* 64h */
+    U32                             MaxLBA;             /* 68h */
+    RAID_PHYS_DISK0_ERROR_DATA      ErrorData;          /* 6Ch */
+} fCONFIG_PAGE_RAID_PHYS_DISK_0, MPI_POINTER PTR_CONFIG_PAGE_RAID_PHYS_DISK_0,
+  RaidPhysDiskPage0_t, MPI_POINTER pRaidPhysDiskPage0_t;
+
+#define MPI_RAIDPHYSDISKPAGE0_PAGEVERSION           (0x00)
+
+
+/****************************************************************************
+*   LAN Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_LAN_0
 {
@@ -1083,8 +1332,8 @@
     U32                     MaxWireSpeedHigh;           /* 1Ch */
     U32                     BucketsRemaining;           /* 20h */
     U32                     MaxReplySize;               /* 24h */
-    U32                     NegWireSpeedHigh;           /* 28h */
-    U32                     NegWireSpeedLow;            /* 2Ch */
+    U32                     NegWireSpeedLow;            /* 28h */
+    U32                     NegWireSpeedHigh;           /* 2Ch */
 } fCONFIG_PAGE_LAN_1, MPI_POINTER PTR_CONFIG_PAGE_LAN_1,
   LANPage1_t, MPI_POINTER pLANPage1_t;
 
diff -Nru a/drivers/message/fusion/lsi/mpi_fc.h b/drivers/message/fusion/lsi/mpi_fc.h
--- a/drivers/message/fusion/lsi/mpi_fc.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/lsi/mpi_fc.h	Thu Jun 20 15:54:00 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Fibre Channel messages and structures
  *  Creation Date:  June 12, 2000
  *
- *    MPI Version:  01.01.07
+ *    MPI Version:  01.02.02
  *
  *  Version History
  *  ---------------
@@ -32,6 +32,9 @@
  *                      Added MPI_FC_PRIM_SEND_FLAGS_RESET_LINK define.
  *                      Added structure offset comments.
  *  04-09-01  01.01.07  Added RspLength field to MSG_LINK_SERVICE_RSP_REQUEST.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  09-28-01  01.02.02  Change name of reserved field in
+ *                      MSG_LINK_SERVICE_RSP_REPLY.
  *  --------------------------------------------------------------------------
  */
 
@@ -172,7 +175,7 @@
     U8                      MsgLength;          /* 02h */
     U8                      Function;           /* 03h */
     U16                     Reserved1;          /* 04h */
-    U8                      Reserved2;          /* 06h */
+    U8                      Reserved_0100_InitiatorIndex; /* 06h */ /* obsolete InitiatorIndex */
     U8                      MsgFlags;           /* 07h */
     U32                     MsgContext;         /* 08h */
     U16                     Reserved3;          /* 0Ch */
diff -Nru a/drivers/message/fusion/lsi/mpi_init.h b/drivers/message/fusion/lsi/mpi_init.h
--- a/drivers/message/fusion/lsi/mpi_init.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/lsi/mpi_init.h	Thu Jun 20 15:54:00 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI initiator mode messages and structures
  *  Creation Date:  June 8, 2000
  *
- *    MPI Version:  01.01.05
+ *    MPI Version:  01.02.04
  *
  *  Version History
  *  ---------------
@@ -22,6 +22,13 @@
  *  02-20-01  01.01.03  Started using MPI_POINTER.
  *  03-27-01  01.01.04  Added structure offset comments.
  *  04-10-01  01.01.05  Added new MsgFlag for MSG_SCSI_TASK_MGMT.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  08-29-01  01.02.02  Added MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET.
+ *                      Added MPI_SCSI_STATE_QUEUE_TAG_REJECTED for
+ *                      MSG_SCSI_IO_REPLY.
+ *  09-28-01  01.02.03  Added structures and defines for SCSI Enclosure
+ *                      Processor messages.
+ *  10-04-01  01.02.04  Added defines for SEP request Action field.
  *  --------------------------------------------------------------------------
  */
 
@@ -151,6 +158,7 @@
 #define MPI_SCSI_STATE_NO_SCSI_STATUS           (0x04)
 #define MPI_SCSI_STATE_TERMINATED               (0x08)
 #define MPI_SCSI_STATE_RESPONSE_INFO_VALID      (0x10)
+#define MPI_SCSI_STATE_QUEUE_TAG_REJECTED       (0x20)
 
 /* SCSIIO Reply ResponseInfo values */
 /* (FCP-1 RSP_CODE values and SPI-3 Packetized Failure codes) */
@@ -191,6 +199,7 @@
 #define MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET         (0x02)
 #define MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET          (0x03)
 #define MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS             (0x04)
+#define MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET    (0x05)
 
 /* MsgFlags bits */
 #define MPI_SCSITASKMGMT_MSGFLAGS_TARGET_RESET_OPTION   (0x00)
@@ -215,5 +224,92 @@
     U32                     TerminationCount;   /* 14h */
 } MSG_SCSI_TASK_MGMT_REPLY, MPI_POINTER PTR_MSG_SCSI_TASK_MGMT_REPLY,
   SCSITaskMgmtReply_t, MPI_POINTER pSCSITaskMgmtReply_t;
+
+
+/****************************************************************************/
+/*  SCSI Enclosure Processor messages                                       */
+/****************************************************************************/
+
+typedef struct _MSG_SEP_REQUEST
+{
+    U8                      TargetID;           /* 00h */
+    U8                      Bus;                /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      Action;             /* 04h */
+    U8                      Reserved1;          /* 05h */
+    U8                      Reserved2;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     SlotStatus;         /* 0Ch */
+} MSG_SEP_REQUEST, MPI_POINTER PTR_MSG_SEP_REQUEST,
+  SEPRequest_t, MPI_POINTER pSEPRequest_t;
+
+/* Action defines */
+#define MPI_SEP_REQ_ACTION_WRITE_STATUS                 (0x00)
+#define MPI_SEP_REQ_ACTION_READ_STATUS                  (0x01)
+
+/* SlotStatus bits for MSG_SEP_REQUEST */
+#define MPI_SEP_REQ_SLOTSTATUS_NO_ERROR                 (0x00000001)
+#define MPI_SEP_REQ_SLOTSTATUS_DEV_FAULTY               (0x00000002)
+#define MPI_SEP_REQ_SLOTSTATUS_DEV_REBUILDING           (0x00000004)
+#define MPI_SEP_REQ_SLOTSTATUS_IN_FAILED_ARRAY          (0x00000008)
+#define MPI_SEP_REQ_SLOTSTATUS_IN_CRITICAL_ARRAY        (0x00000010)
+#define MPI_SEP_REQ_SLOTSTATUS_PARITY_CHECK             (0x00000020)
+#define MPI_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT          (0x00000040)
+#define MPI_SEP_REQ_SLOTSTATUS_UNCONFIGURED             (0x00000080)
+#define MPI_SEP_REQ_SLOTSTATUS_HOT_SPARE                (0x00000100)
+#define MPI_SEP_REQ_SLOTSTATUS_REBUILD_STOPPED          (0x00000200)
+#define MPI_SEP_REQ_SLOTSTATUS_IDENTIFY_REQUEST         (0x00020000)
+#define MPI_SEP_REQ_SLOTSTATUS_REQUEST_REMOVE           (0x00040000)
+#define MPI_SEP_REQ_SLOTSTATUS_REQUEST_INSERT           (0x00080000)
+#define MPI_SEP_REQ_SLOTSTATUS_DO_NOT_MOVE              (0x00400000)
+#define MPI_SEP_REQ_SLOTSTATUS_B_ENABLE_BYPASS          (0x04000000)
+#define MPI_SEP_REQ_SLOTSTATUS_A_ENABLE_BYPASS          (0x08000000)
+#define MPI_SEP_REQ_SLOTSTATUS_DEV_OFF                  (0x10000000)
+#define MPI_SEP_REQ_SLOTSTATUS_SWAP_RESET               (0x80000000)
+
+
+typedef struct _MSG_SEP_REPLY
+{
+    U8                      TargetID;           /* 00h */
+    U8                      Bus;                /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      Action;             /* 04h */
+    U8                      Reserved1;          /* 05h */
+    U8                      Reserved2;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     Reserved3;          /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     SlotStatus;         /* 14h */
+} MSG_SEP_REPLY, MPI_POINTER PTR_MSG_SEP_REPLY,
+  SEPReply_t, MPI_POINTER pSEPReply_t;
+
+/* SlotStatus bits for MSG_SEP_REPLY */
+#define MPI_SEP_REPLY_SLOTSTATUS_NO_ERROR               (0x00000001)
+#define MPI_SEP_REPLY_SLOTSTATUS_DEV_FAULTY             (0x00000002)
+#define MPI_SEP_REPLY_SLOTSTATUS_DEV_REBUILDING         (0x00000004)
+#define MPI_SEP_REPLY_SLOTSTATUS_IN_FAILED_ARRAY        (0x00000008)
+#define MPI_SEP_REPLY_SLOTSTATUS_IN_CRITICAL_ARRAY      (0x00000010)
+#define MPI_SEP_REPLY_SLOTSTATUS_PARITY_CHECK           (0x00000020)
+#define MPI_SEP_REPLY_SLOTSTATUS_PREDICTED_FAULT        (0x00000040)
+#define MPI_SEP_REPLY_SLOTSTATUS_UNCONFIGURED           (0x00000080)
+#define MPI_SEP_REPLY_SLOTSTATUS_HOT_SPARE              (0x00000100)
+#define MPI_SEP_REPLY_SLOTSTATUS_REBUILD_STOPPED        (0x00000200)
+#define MPI_SEP_REPLY_SLOTSTATUS_REPORT                 (0x00010000)
+#define MPI_SEP_REPLY_SLOTSTATUS_IDENTIFY_REQUEST       (0x00020000)
+#define MPI_SEP_REPLY_SLOTSTATUS_REMOVE_READY           (0x00040000)
+#define MPI_SEP_REPLY_SLOTSTATUS_INSERT_READY           (0x00080000)
+#define MPI_SEP_REPLY_SLOTSTATUS_DO_NOT_REMOVE          (0x00400000)
+#define MPI_SEP_REPLY_SLOTSTATUS_B_BYPASS_ENABLED       (0x01000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_A_BYPASS_ENABLED       (0x02000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_B_ENABLE_BYPASS        (0x04000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_A_ENABLE_BYPASS        (0x08000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_DEV_OFF                (0x10000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_FAULT_SENSED           (0x40000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_SWAPPED                (0x80000000)
 
 #endif
diff -Nru a/drivers/message/fusion/lsi/mpi_ioc.h b/drivers/message/fusion/lsi/mpi_ioc.h
--- a/drivers/message/fusion/lsi/mpi_ioc.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/lsi/mpi_ioc.h	Thu Jun 20 15:54:00 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI IOC, Port, Event, FW Download, and FW Upload messages
  *  Creation Date:  August 11, 2000
  *
- *    MPI Version:  01.01.07
+ *    MPI Version:  01.02.04
  *
  *  Version History
  *  ---------------
@@ -38,6 +38,19 @@
  *  03-27-01  01.01.06  Added defines for ProductId field of MPI_FW_HEADER.
  *                      Added structure offset comments.
  *  04-09-01  01.01.07  Added structure EVENT_DATA_EVENT_CHANGE.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *                      New format for FWVersion and ProductId in
+ *                      MSG_IOC_FACTS_REPLY and MPI_FW_HEADER.
+ *  08-31-01  01.02.02  Addded event MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE and
+ *                      related structure and defines.
+ *                      Added event MPI_EVENT_ON_BUS_TIMER_EXPIRED.
+ *                      Added MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE.
+ *                      Replaced a reserved field in MSG_IOC_FACTS_REPLY with
+ *                      IOCExceptions and changed DataImageSize to reserved.
+ *                      Added MPI_FW_DOWNLOAD_ITYPE_NVSTORE_DATA and
+ *                      MPI_FW_UPLOAD_ITYPE_NVDATA.
+ *  09-28-01  01.02.03  Modified Event Data for Integrated RAID.
+ *  11-01-01  01.02.04  Added defines for MPI_EXT_IMAGE_HEADER ImageType field.
  *  --------------------------------------------------------------------------
  */
 
@@ -73,6 +86,17 @@
 } MSG_IOC_INIT, MPI_POINTER PTR_MSG_IOC_INIT,
   IOCInit_t, MPI_POINTER pIOCInit_t;
 
+/* WhoInit values */
+#define MPI_WHOINIT_NO_ONE                      (0x00)
+#define MPI_WHOINIT_SYSTEM_BIOS                 (0x01)
+#define MPI_WHOINIT_ROM_BIOS                    (0x02)
+#define MPI_WHOINIT_PCI_PEER                    (0x03)
+#define MPI_WHOINIT_HOST_DRIVER                 (0x04)
+#define MPI_WHOINIT_MANUFACTURER                (0x05)
+
+/* Flags values */
+#define MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE      (0x01)
+
 typedef struct _MSG_IOC_INIT_REPLY
 {
     U8                      WhoInit;                    /* 00h */
@@ -90,14 +114,6 @@
 } MSG_IOC_INIT_REPLY, MPI_POINTER PTR_MSG_IOC_INIT_REPLY,
   IOCInitReply_t, MPI_POINTER pIOCInitReply_t;
 
-/* WhoInit values */
-
-#define MPI_WHOINIT_NO_ONE                      (0x00)
-#define MPI_WHOINIT_SYSTEM_BIOS                 (0x01)
-#define MPI_WHOINIT_ROM_BIOS                    (0x02)
-#define MPI_WHOINIT_PCI_PEER                    (0x03)
-#define MPI_WHOINIT_HOST_DRIVER                 (0x04)
-#define MPI_WHOINIT_MANUFACTURER                (0x05)
 
 
 /****************************************************************************/
@@ -115,8 +131,21 @@
 } MSG_IOC_FACTS, MPI_POINTER PTR_IOC_FACTS,
   IOCFacts_t, MPI_POINTER pIOCFacts_t;
 
-/* IOC Facts Reply */
+typedef struct _MPI_FW_VERSION_STRUCT
+{
+    U8                      Dev;                        /* 00h */
+    U8                      Unit;                       /* 01h */
+    U8                      Minor;                      /* 02h */
+    U8                      Major;                      /* 03h */
+} MPI_FW_VERSION_STRUCT;
+
+typedef union _MPI_FW_VERSION
+{
+    MPI_FW_VERSION_STRUCT   Struct;
+    U32                     Word;
+} MPI_FW_VERSION;
 
+/* IOC Facts Reply */
 typedef struct _MSG_IOC_FACTS_REPLY
 {
     U16                     MsgVersion;                 /* 00h */
@@ -126,7 +155,7 @@
     U8                      IOCNumber;                  /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
-    U16                     Reserved2;                  /* 0Ch */
+    U16                     IOCExceptions;              /* 0Ch */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
     U8                      MaxChainDepth;              /* 14h */
@@ -135,7 +164,7 @@
     U8                      Flags;                      /* 17h */
     U16                     ReplyQueueDepth;            /* 18h */
     U16                     RequestFrameSize;           /* 1Ah */
-    U16                     FWVersion;                  /* 1Ch */
+    U16                     Reserved_0101_FWVersion;    /* 1Ch */ /* obsolete 16-bit FWVersion */
     U16                     ProductID;                  /* 1Eh */
     U32                     CurrentHostMfaHighAddr;     /* 20h */
     U16                     GlobalCredits;              /* 24h */
@@ -146,18 +175,20 @@
     U8                      MaxDevices;                 /* 2Eh */
     U8                      MaxBuses;                   /* 2Fh */
     U32                     FWImageSize;                /* 30h */
-    U32                     DataImageSize;              /* 34h */
+    U32                     Reserved4;                  /* 34h */
+    MPI_FW_VERSION          FWVersion;                  /* 38h */
 } MSG_IOC_FACTS_REPLY, MPI_POINTER PTR_MSG_IOC_FACTS_REPLY,
   IOCFactsReply_t, MPI_POINTER pIOCFactsReply_t;
 
-#define MPI_IOCFACTS_MSGVERSION_MAJOR_MASK      (0xFF00)
-#define MPI_IOCFACTS_MSGVERSION_MINOR_MASK      (0x00FF)
+#define MPI_IOCFACTS_MSGVERSION_MAJOR_MASK          (0xFF00)
+#define MPI_IOCFACTS_MSGVERSION_MINOR_MASK          (0x00FF)
+
+#define MPI_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL    (0x0001)
 
-#define MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT     (0x01)
-#define MPI_IOCFACTS_FLAGS_DATA_IMAGE_UPLOAD    (0x02)
+#define MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT         (0x01)
 
-#define MPI_IOCFACTS_EVENTSTATE_DISABLED        (0x00)
-#define MPI_IOCFACTS_EVENTSTATE_ENABLED         (0x01)
+#define MPI_IOCFACTS_EVENTSTATE_DISABLED            (0x00)
+#define MPI_IOCFACTS_EVENTSTATE_ENABLED             (0x01)
 
 
 
@@ -326,7 +357,6 @@
 } MSG_EVENT_ACK_REPLY, MPI_POINTER PTR_MSG_EVENT_ACK_REPLY,
   EventAckReply_t, MPI_POINTER pEventAckReply_t;
 
-
 /* Switch */
 
 #define MPI_EVENT_NOTIFICATION_SWITCH_OFF   (0x00)
@@ -345,7 +375,9 @@
 #define MPI_EVENT_LOOP_STATE_CHANGE         (0x00000008)
 #define MPI_EVENT_LOGOUT                    (0x00000009)
 #define MPI_EVENT_EVENT_CHANGE              (0x0000000A)
-#define MPI_EVENT_RAID_STATUS_CHANGE        (0x0000000B)
+#define MPI_EVENT_INTEGRATED_RAID           (0x0000000B)
+#define MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE (0x0000000C)
+#define MPI_EVENT_ON_BUS_TIMER_EXPIRED      (0x0000000D)
 
 /* AckRequired field values */
 
@@ -372,6 +404,27 @@
 } EVENT_DATA_SCSI, MPI_POINTER PTR_EVENT_DATA_SCSI,
   EventDataScsi_t, MPI_POINTER pEventDataScsi_t;
 
+/* SCSI Device Status Change Event data */
+
+typedef struct _EVENT_DATA_SCSI_DEVICE_STATUS_CHANGE
+{
+    U8                      TargetID;                   /* 00h */
+    U8                      Bus;                        /* 01h */
+    U8                      ReasonCode;                 /* 02h */
+    U8                      LUN;                        /* 03h */
+    U8                      ASC;                        /* 04h */
+    U8                      ASCQ;                       /* 05h */
+    U16                     Reserved;                   /* 06h */
+} EVENT_DATA_SCSI_DEVICE_STATUS_CHANGE,
+  MPI_POINTER PTR_EVENT_DATA_SCSI_DEVICE_STATUS_CHANGE,
+  MpiEventDataScsiDeviceStatusChange_t,
+  MPI_POINTER pMpiEventDataScsiDeviceStatusChange_t;
+
+/* MPI SCSI Device Status Change Event data ReasonCode values */
+#define MPI_EVENT_SCSI_DEV_STAT_RC_ADDED                (0x03)
+#define MPI_EVENT_SCSI_DEV_STAT_RC_NOT_RESPONDING       (0x04)
+#define MPI_EVENT_SCSI_DEV_STAT_RC_SMART_DATA           (0x05)
+
 /* MPI Link Status Change Event data */
 
 typedef struct _EVENT_DATA_LINK_STATUS
@@ -417,29 +470,34 @@
 } EVENT_DATA_LOGOUT, MPI_POINTER PTR_EVENT_DATA_LOGOUT,
   EventDataLogout_t, MPI_POINTER pEventDataLogout_t;
 
-/* MPI RAID Status Change Event data */
+/* MPI Integrated RAID Event data */
 
-typedef struct _EVENT_DATA_RAID_STATUS_CHANGE
+typedef struct _EVENT_DATA_RAID
 {
-    U8                      VolumeTargetID;             /* 00h */
+    U8                      VolumeID;                   /* 00h */
     U8                      VolumeBus;                  /* 01h */
     U8                      ReasonCode;                 /* 02h */
     U8                      PhysDiskNum;                /* 03h */
     U8                      ASC;                        /* 04h */
     U8                      ASCQ;                       /* 05h */
     U16                     Reserved;                   /* 06h */
-} EVENT_DATA_RAID_STATUS_CHANGE, MPI_POINTER PTR_EVENT_DATA_RAID_STATUS_CHANGE,
-  MpiEventDataRaidStatusChange_t, MPI_POINTER pMpiEventDataRaidStatusChange_t;
-
-
-/* MPI RAID Status Change Event data ReasonCode values */
-
-#define MPI_EVENT_RAID_DATA_RC_VOLUME_OPTIMAL       (0x00)
-#define MPI_EVENT_RAID_DATA_RC_VOLUME_DEGRADED      (0x01)
-#define MPI_EVENT_RAID_DATA_RC_STARTED_RESYNC       (0x02)
-#define MPI_EVENT_RAID_DATA_RC_DISK_ADDED           (0x03)
-#define MPI_EVENT_RAID_DATA_RC_DISK_NOT_RESPONDING  (0x04)
-#define MPI_EVENT_RAID_DATA_RC_SMART_DATA           (0x05)
+    U32                     SettingsStatus;             /* 08h */
+} EVENT_DATA_RAID, MPI_POINTER PTR_EVENT_DATA_RAID,
+  MpiEventDataRaid_t, MPI_POINTER pMpiEventDataRaid_t;
+
+/* MPI Integrated RAID Event data ReasonCode values */
+#define MPI_EVENT_RAID_RC_VOLUME_CREATED                (0x00)
+#define MPI_EVENT_RAID_RC_VOLUME_DELETED                (0x01)
+#define MPI_EVENT_RAID_RC_VOLUME_SETTINGS_CHANGED       (0x02)
+#define MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED         (0x03)
+#define MPI_EVENT_RAID_RC_VOLUME_PHYSDISK_CHANGED       (0x04)
+#define MPI_EVENT_RAID_RC_PHYSDISK_CREATED              (0x05)
+#define MPI_EVENT_RAID_RC_PHYSDISK_DELETED              (0x06)
+#define MPI_EVENT_RAID_RC_PHYSDISK_SETTINGS_CHANGED     (0x07)
+#define MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED       (0x08)
+#define MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED             (0x09)
+#define MPI_EVENT_RAID_RC_SMART_DATA                    (0x0A)
+#define MPI_EVENT_RAID_RC_REPLACE_ACTION_STARTED        (0x0B)
 
 
 /*****************************************************************************
@@ -468,6 +526,7 @@
 #define MPI_FW_DOWNLOAD_ITYPE_RESERVED      (0x00)
 #define MPI_FW_DOWNLOAD_ITYPE_FW            (0x01)
 #define MPI_FW_DOWNLOAD_ITYPE_BIOS          (0x02)
+#define MPI_FW_DOWNLOAD_ITYPE_NVDATA        (0x03)
 
 
 typedef struct _FWDownloadTCSGE
@@ -476,7 +535,7 @@
     U8                      ContextSize;                /* 01h */
     U8                      DetailsLength;              /* 02h */
     U8                      Flags;                      /* 03h */
-    U32                     Reserved1;                  /* 04h */
+    U32                     Reserved_0100_Checksum;     /* 04h */ /* obsolete Checksum */
     U32                     ImageOffset;                /* 08h */
     U32                     ImageSize;                  /* 0Ch */
 } FW_DOWNLOAD_TCSGE, MPI_POINTER PTR_FW_DOWNLOAD_TCSGE,
@@ -519,7 +578,7 @@
 #define MPI_FW_UPLOAD_ITYPE_FW_IOC_MEM      (0x00)
 #define MPI_FW_UPLOAD_ITYPE_FW_FLASH        (0x01)
 #define MPI_FW_UPLOAD_ITYPE_BIOS_FLASH      (0x02)
-#define MPI_FW_UPLOAD_ITYPE_DATA_IOC_MEM    (0x03)
+#define MPI_FW_UPLOAD_ITYPE_NVDATA          (0x03)
 
 typedef struct _FWUploadTCSGE
 {
@@ -563,11 +622,10 @@
     U32                     Checksum;                   /* 1Ch */
     U16                     VendorId;                   /* 20h */
     U16                     ProductId;                  /* 22h */
-    U16                     FwVersion;                  /* 24h */
-    U16                     Reserved1;                  /* 26h */
+    MPI_FW_VERSION          FWVersion;                  /* 24h */
     U32                     SeqCodeVersion;             /* 28h */
     U32                     ImageSize;                  /* 2Ch */
-    U32                     Reserved2;                  /* 30h */
+    U32                     NextImageHeaderOffset;      /* 30h */
     U32                     LoadStartAddress;           /* 34h */
     U32                     IopResetVectorValue;        /* 38h */
     U32                     IopResetRegAddr;            /* 3Ch */
@@ -581,30 +639,49 @@
 #define MPI_FW_HEADER_WHAT_SIGNATURE        (0x29232840)
 
 /* defines for using the ProductId field */
-#define MPI_FW_HEADER_PID_TYPE_MASK         (0xF000)
-#define MPI_FW_HEADER_PID_TYPE_SCSI         (0x0000)
-#define MPI_FW_HEADER_PID_TYPE_FC           (0x1000)
-
-#define MPI_FW_HEADER_PID_FW_VENDOR_MASK    (0x0F00)
-#define MPI_FW_HEADER_PID_FW_VENDOR_LSI     (0x0000)
-
-#define MPI_FW_HEADER_PID_FAMILY_MASK       (0x000F)
-#define MPI_FW_HEADER_PID_FAMILY_1030_SCSI  (0x0000)
-#define MPI_FW_HEADER_PID_FAMILY_909_FC     (0x0000)
-#define MPI_FW_HEADER_PID_FAMILY_919_FC     (0x0001)
-#define MPI_FW_HEADER_PID_FAMILY_919X_FC    (0x0002)
-
-
-typedef struct _MPI_DATA_HEADER
-{
-    U32                     Signature;                  /* 00h */
-    U16                     FunctionNumber;             /* 04h */
-    U16                     Length;                     /* 06h */
-    U32                     Checksum;                   /* 08h */
-    U32                     LoadStartAddress;           /* 0Ch */
-} MPI_DATA_HEADER, MPI_POINTER PTR_MPI_DATA_HEADER,
-  MpiDataHeader_t, MPI_POINTER pMpiDataHeader_t;
+#define MPI_FW_HEADER_PID_TYPE_MASK             (0xF000)
+#define MPI_FW_HEADER_PID_TYPE_SCSI             (0x0000)
+#define MPI_FW_HEADER_PID_TYPE_FC               (0x1000)
+
+#define MPI_FW_HEADER_PID_PROD_MASK                     (0x0F00)
+#define MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI           (0x0100)
+#define MPI_FW_HEADER_PID_PROD_TARGET_INITIATOR_SCSI    (0x0200)
+#define MPI_FW_HEADER_PID_PROD_TARGET_SCSI              (0x0300)
+#define MPI_FW_HEADER_PID_PROD_IM_SCSI                  (0x0400)
+#define MPI_FW_HEADER_PID_PROD_IS_SCSI                  (0x0500)
+#define MPI_FW_HEADER_PID_PROD_CTX_SCSI                 (0x0600)
+
+#define MPI_FW_HEADER_PID_FAMILY_MASK           (0x00FF)
+#define MPI_FW_HEADER_PID_FAMILY_1030A0_SCSI    (0x0001)
+#define MPI_FW_HEADER_PID_FAMILY_1030B0_SCSI    (0x0002)
+#define MPI_FW_HEADER_PID_FAMILY_1030B1_SCSI    (0x0003)
+#define MPI_FW_HEADER_PID_FAMILY_1030C0_SCSI    (0x0004)
+#define MPI_FW_HEADER_PID_FAMILY_1020A0_SCSI    (0x0005)
+#define MPI_FW_HEADER_PID_FAMILY_1020B0_SCSI    (0x0006)
+#define MPI_FW_HEADER_PID_FAMILY_1020B1_SCSI    (0x0007)
+#define MPI_FW_HEADER_PID_FAMILY_1020C0_SCSI    (0x0008)
+#define MPI_FW_HEADER_PID_FAMILY_1035A0_SCSI    (0x0009)
+#define MPI_FW_HEADER_PID_FAMILY_1035B0_SCSI    (0x000A)
+#define MPI_FW_HEADER_PID_FAMILY_909_FC         (0x0000)
+#define MPI_FW_HEADER_PID_FAMILY_919_FC         (0x0001)
+#define MPI_FW_HEADER_PID_FAMILY_919X_FC        (0x0002)
 
-#define MPI_DATA_HEADER_SIGNATURE           (0x43504147)
+typedef struct _MPI_EXT_IMAGE_HEADER
+{
+    U8                      ImageType;                  /* 00h */
+    U8                      Reserved;                   /* 01h */
+    U16                     Reserved1;                  /* 02h */
+    U32                     Checksum;                   /* 04h */
+    U32                     ImageSize;                  /* 08h */
+    U32                     NextImageHeaderOffset;      /* 0Ch */
+    U32                     LoadStartAddress;           /* 10h */
+    U32                     Reserved2;                  /* 14h */
+} MPI_EXT_IMAGE_HEADER, MPI_POINTER PTR_MPI_EXT_IMAGE_HEADER,
+  MpiExtImageHeader_t, MPI_POINTER pMpiExtImageHeader_t;
+
+/* defines for the ImageType field */
+#define MPI_EXT_IMAGE_TYPE_UNSPECIFIED          (0x00)
+#define MPI_EXT_IMAGE_TYPE_FW                   (0x01)
+#define MPI_EXT_IMAGE_TYPE_NVDATA               (0x03)
 
 #endif
diff -Nru a/drivers/message/fusion/lsi/mpi_lan.h b/drivers/message/fusion/lsi/mpi_lan.h
--- a/drivers/message/fusion/lsi/mpi_lan.h	Thu Jun 20 15:54:01 2002
+++ b/drivers/message/fusion/lsi/mpi_lan.h	Thu Jun 20 15:54:01 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI LAN messages and structures
  *  Creation Date:  June 30, 2000
  *
- *    MPI Version:  01.01.03
+ *    MPI Version:  01.02.01
  *
  *  Version History
  *  ---------------
@@ -27,6 +27,7 @@
  *  11-02-00  01.01.01  Original release for post 1.0 work
  *  02-20-01  01.01.02  Started using MPI_POINTER.
  *  03-27-01  01.01.03  Added structure offset comments.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
  *  --------------------------------------------------------------------------
  */
 
diff -Nru a/drivers/message/fusion/lsi/mpi_raid.h b/drivers/message/fusion/lsi/mpi_raid.h
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/message/fusion/lsi/mpi_raid.h	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,178 @@
+/*
+ *  Copyright (c) 2001 LSI Logic Corporation.
+ *
+ *
+ *           Name:  MPI_RAID.H
+ *          Title:  MPI RAID message and structures
+ *  Creation Date:  February 27, 2001
+ *
+ *    MPI Version:  01.02.04
+ *
+ *  Version History
+ *  ---------------
+ *
+ *  Date      Version   Description
+ *  --------  --------  ------------------------------------------------------
+ *  02-27-01  01.01.01  Original release for this file.
+ *  03-27-01  01.01.02  Added structure offset comments.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  09-28-01  01.02.02  Major rework for MPI v1.2 Integrated RAID changes.
+ *  10-04-01  01.02.03  Added ActionData defines for
+ *                      MPI_RAID_ACTION_DELETE_VOLUME action.
+ *  11-01-01  01.02.04  Added define for MPI_RAID_ACTION_ADATA_DO_NOT_SYNC.
+ *  --------------------------------------------------------------------------
+ */
+
+#ifndef MPI_RAID_H
+#define MPI_RAID_H
+
+
+/******************************************************************************
+*
+*        R A I D    M e s s a g e s
+*
+*******************************************************************************/
+
+
+/****************************************************************************/
+/* RAID Volume Request                                                      */
+/****************************************************************************/
+
+typedef struct _MSG_RAID_ACTION
+{
+    U8                      Action;             /* 00h */
+    U8                      Reserved1;          /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      VolumeID;           /* 04h */
+    U8                      VolumeBus;          /* 05h */
+    U8                      PhysDiskNum;        /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     Reserved2;          /* 0Ch */
+    U32                     ActionDataWord;     /* 10h */
+    SGE_SIMPLE_UNION        ActionDataSGE;      /* 14h */
+} MSG_RAID_ACTION_REQUEST, MPI_POINTER PTR_MSG_RAID_ACTION_REQUEST,
+  MpiRaidActionRequest_t , MPI_POINTER pMpiRaidActionRequest_t;
+
+
+/* RAID Action request Action values */
+
+#define MPI_RAID_ACTION_STATUS                      (0x00)
+#define MPI_RAID_ACTION_INDICATOR_STRUCT            (0x01)
+#define MPI_RAID_ACTION_CREATE_VOLUME               (0x02)
+#define MPI_RAID_ACTION_DELETE_VOLUME               (0x03)
+#define MPI_RAID_ACTION_DISABLE_VOLUME              (0x04)
+#define MPI_RAID_ACTION_ENABLE_VOLUME               (0x05)
+#define MPI_RAID_ACTION_QUIESCE_PHYS_IO             (0x06)
+#define MPI_RAID_ACTION_ENABLE_PHYS_IO              (0x07)
+#define MPI_RAID_ACTION_CHANGE_VOLUME_SETTINGS      (0x08)
+#define MPI_RAID_ACTION_PHYSDISK_OFFLINE            (0x0A)
+#define MPI_RAID_ACTION_PHYSDISK_ONLINE             (0x0B)
+#define MPI_RAID_ACTION_CHANGE_PHYSDISK_SETTINGS    (0x0C)
+#define MPI_RAID_ACTION_CREATE_PHYSDISK             (0x0D)
+#define MPI_RAID_ACTION_DELETE_PHYSDISK             (0x0E)
+#define MPI_RAID_ACTION_FAIL_PHYSDISK               (0x0F)
+#define MPI_RAID_ACTION_REPLACE_PHYSDISK            (0x10)
+
+/* ActionDataWord defines for use with MPI_RAID_ACTION_CREATE_VOLUME action */
+#define MPI_RAID_ACTION_ADATA_DO_NOT_SYNC           (0x00000001)
+
+/* ActionDataWord defines for use with MPI_RAID_ACTION_DELETE_VOLUME action */
+#define MPI_RAID_ACTION_ADATA_KEEP_PHYS_DISKS       (0x00000000)
+#define MPI_RAID_ACTION_ADATA_DEL_PHYS_DISKS        (0x00000001)
+
+
+/* RAID Action reply message */
+
+typedef struct _MSG_RAID_ACTION_REPLY
+{
+    U8                      Action;             /* 00h */
+    U8                      Reserved;           /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      VolumeID;           /* 04h */
+    U8                      VolumeBus;          /* 05h */
+    U8                      PhysDiskNum;        /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     ActionStatus;       /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     VolumeStatus;       /* 14h */
+    U32                     ActionData;         /* 18h */
+} MSG_RAID_ACTION_REPLY, MPI_POINTER PTR_MSG_RAID_ACTION_REPLY,
+  MpiRaidActionReply_t, MPI_POINTER pMpiRaidActionReply_t;
+
+
+/* RAID Volume reply ActionStatus values */
+
+#define MPI_RAID_ACTION_ASTATUS_SUCCESS             (0x0000)
+#define MPI_RAID_ACTION_ASTATUS_INVALID_ACTION      (0x0001)
+#define MPI_RAID_ACTION_ASTATUS_FAILURE             (0x0002)
+#define MPI_RAID_ACTION_ASTATUS_IN_PROGRESS         (0x0003)
+
+
+/* RAID Volume reply RAID Volume Indicator structure */
+
+typedef struct _MPI_RAID_VOL_INDICATOR
+{
+    U64                     TotalBlocks;        /* 00h */
+    U64                     BlocksRemaining;    /* 08h */
+} MPI_RAID_VOL_INDICATOR, MPI_POINTER PTR_MPI_RAID_VOL_INDICATOR,
+  MpiRaidVolIndicator_t, MPI_POINTER pMpiRaidVolIndicator_t;
+
+
+/****************************************************************************/
+/* SCSI IO RAID Passthrough Request                                         */
+/****************************************************************************/
+
+typedef struct _MSG_SCSI_IO_RAID_PT_REQUEST
+{
+    U8                      PhysDiskNum;        /* 00h */
+    U8                      Reserved1;          /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      CDBLength;          /* 04h */
+    U8                      SenseBufferLength;  /* 05h */
+    U8                      Reserved2;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U8                      LUN[8];             /* 0Ch */
+    U32                     Control;            /* 14h */
+    U8                      CDB[16];            /* 18h */
+    U32                     DataLength;         /* 28h */
+    U32                     SenseBufferLowAddr; /* 2Ch */
+    SGE_IO_UNION            SGL;                /* 30h */
+} MSG_SCSI_IO_RAID_PT_REQUEST, MPI_POINTER PTR_MSG_SCSI_IO_RAID_PT_REQUEST,
+  SCSIIORaidPassthroughRequest_t, MPI_POINTER pSCSIIORaidPassthroughRequest_t;
+
+
+/* SCSI IO RAID Passthrough reply structure */
+
+typedef struct _MSG_SCSI_IO_RAID_PT_REPLY
+{
+    U8                      PhysDiskNum;        /* 00h */
+    U8                      Reserved1;          /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      CDBLength;          /* 04h */
+    U8                      SenseBufferLength;  /* 05h */
+    U8                      Reserved2;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U8                      SCSIStatus;         /* 0Ch */
+    U8                      SCSIState;          /* 0Dh */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     TransferCount;      /* 14h */
+    U32                     SenseCount;         /* 18h */
+    U32                     ResponseInfo;       /* 1Ch */
+} MSG_SCSI_IO_RAID_PT_REPLY, MPI_POINTER PTR_MSG_SCSI_IO_RAID_PT_REPLY,
+  SCSIIORaidPassthroughReply_t, MPI_POINTER pSCSIIORaidPassthroughReply_t;
+
+
+#endif
+
+
+
diff -Nru a/drivers/message/fusion/lsi/mpi_targ.h b/drivers/message/fusion/lsi/mpi_targ.h
--- a/drivers/message/fusion/lsi/mpi_targ.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/lsi/mpi_targ.h	Thu Jun 20 15:54:00 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Target mode messages and structures
  *  Creation Date:  June 22, 2000
  *
- *    MPI Version:  01.01.04
+ *    MPI Version:  01.02.04
  *
  *  Version History
  *  ---------------
@@ -26,6 +26,14 @@
  *                      Added structures for MPI_TARGET_SCSI_SPI_CMD_BUFFER and
  *                      MPI_TARGET_FCP_CMD_BUFFER.
  *  03-27-01  01.01.04  Added structure offset comments.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  09-28-01  01.02.02  Added structure for MPI_TARGET_SCSI_SPI_STATUS_IU.
+ *                      Added PriorityReason field to some replies and
+ *                      defined more PriorityReason codes.
+ *                      Added some defines for to support previous version
+ *                      of MPI.
+ *  10-04-01  01.02.03  Added PriorityReason to MSG_TARGET_ERROR_REPLY.
+ *  11-01-01  01.02.04  Added define for TARGET_STATUS_SEND_FLAGS_HIGH_PRIORITY.
  *  --------------------------------------------------------------------------
  */
 
@@ -78,6 +86,7 @@
 #define CMD_BUFFER_POST_FLAGS_64_BIT_ADDR       (0x80)
 
 #define CMD_BUFFER_POST_IO_INDEX_MASK           (0x00003FFF)
+#define CMD_BUFFER_POST_IO_INDEX_MASK_0100      (0x000003FF) /* obsolete */
 
 
 typedef struct _MSG_TARGET_CMD_BUFFER_POST_REPLY
@@ -97,7 +106,7 @@
 } MSG_TARGET_CMD_BUFFER_POST_REPLY, MPI_POINTER PTR_MSG_TARGET_CMD_BUFFER_POST_REPLY,
   TargetCmdBufferPostReply_t, MPI_POINTER pTargetCmdBufferPostReply_t;
 
-
+/* the following structure is obsolete as of MPI v1.2 */
 typedef struct _MSG_PRIORITY_CMD_RECEIVED_REPLY
 {
     U16                     Reserved;                   /* 00h */
@@ -117,6 +126,13 @@
 
 #define PRIORITY_REASON_NO_DISCONNECT           (0x00)
 #define PRIORITY_REASON_SCSI_TASK_MANAGEMENT    (0x01)
+#define PRIORITY_REASON_CMD_PARITY_ERR          (0x02)
+#define PRIORITY_REASON_MSG_OUT_PARITY_ERR      (0x03)
+#define PRIORITY_REASON_LQ_CRC_ERR              (0x04)
+#define PRIORITY_REASON_CMD_CRC_ERR             (0x05)
+#define PRIORITY_REASON_PROTOCOL_ERR            (0x06)
+#define PRIORITY_REASON_DATA_OUT_PARITY_ERR     (0x07)
+#define PRIORITY_REASON_DATA_OUT_CRC_ERR        (0x08)
 #define PRIORITY_REASON_UNKNOWN                 (0xFF)
 
 
@@ -129,7 +145,8 @@
     U8                      Reserved2;                  /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
-    U16                     Reserved3;                  /* 0Ch */
+    U8                      PriorityReason;             /* 0Ch */
+    U8                      Reserved3;                  /* 0Dh */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
     U32                     ReplyWord;                  /* 14h */
@@ -204,7 +221,8 @@
     U8                      Reserved2;                  /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
-    U16                     Reserved3;                  /* 0Ch */
+    U8                      PriorityReason;             /* 0Ch */
+    U8                      Reserved3;                  /* 0Dh */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
     U32                     ReplyWord;                  /* 14h */
@@ -234,8 +252,34 @@
   TargetStatusSendRequest_t, MPI_POINTER pTargetStatusSendRequest_t;
 
 #define TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS   (0x01)
+#define TARGET_STATUS_SEND_FLAGS_HIGH_PRIORITY      (0x04)
 #define TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER  (0x80)
 
+typedef struct _MPI_TARGET_FCP_RSP_BUFFER
+{
+    U8      Reserved0[8];                               /* 00h */
+    U8      FcpStatus;                                  /* 08h */
+    U8      FcpFlags;                                   /* 09h */
+    U8      Reserved1[2];                               /* 0Ah */
+    U32     FcpResid;                                   /* 0Ch */
+    U32     FcpSenseLength;                             /* 10h */
+    U32     FcpResponseLength;                          /* 14h */
+    U8      FcpResponseData[8];                         /* 18h */
+    U8      FcpSenseData[32]; /* Pad to 64 bytes */     /* 20h */
+} MPI_TARGET_FCP_RSP_BUFFER, MPI_POINTER PTR_MPI_TARGET_FCP_RSP_BUFFER,
+  MpiTargetFcpRspBuffer, MPI_POINTER pMpiTargetFcpRspBuffer;
+
+typedef struct _MPI_TARGET_SCSI_SPI_STATUS_IU
+{
+    U8      Reserved0;                                  /* 00h */
+    U8      Reserved1;                                  /* 01h */
+    U8      Valid;                                      /* 02h */
+    U8      Status;                                     /* 03h */
+    U32     SenseDataListLength;                        /* 04h */
+    U32     PktFailuresListLength;                      /* 08h */
+    U8      SenseData[52]; /* Pad the IU to 64 bytes */ /* 0Ch */
+} MPI_TARGET_SCSI_SPI_STATUS_IU, MPI_POINTER PTR_MPI_TARGET_SCSI_SPI_STATUS_IU,
+  TargetScsiSpiStatusIU_t, MPI_POINTER pTargetScsiSpiStatusIU_t;
 
 /****************************************************************************/
 /* Target Mode Abort Request                                                */
@@ -323,6 +367,41 @@
 #define SET_PORT(t, p)  ((t) = ((t) & ~TARGET_MODE_REPLY_PORT_MASK) |          \
                                     (((p) << TARGET_MODE_REPLY_PORT_SHIFT) &   \
                                                   TARGET_MODE_REPLY_PORT_MASK))
+
+/* the following obsolete values are for MPI v1.0 support */
+#define TARGET_MODE_REPLY_0100_MASK_HOST_INDEX       (0x000003FF)
+#define TARGET_MODE_REPLY_0100_SHIFT_HOST_INDEX      (0)
+#define TARGET_MODE_REPLY_0100_MASK_IOC_INDEX        (0x001FF800)
+#define TARGET_MODE_REPLY_0100_SHIFT_IOC_INDEX       (11)
+#define TARGET_MODE_REPLY_0100_PORT_MASK             (0x00400000)
+#define TARGET_MODE_REPLY_0100_PORT_SHIFT            (22)
+#define TARGET_MODE_REPLY_0100_MASK_INITIATOR_INDEX  (0x1F800000)
+#define TARGET_MODE_REPLY_0100_SHIFT_INITIATOR_INDEX (23)
+
+#define GET_HOST_INDEX_0100(x) (((x) & TARGET_MODE_REPLY_0100_MASK_HOST_INDEX) \
+                                  >> TARGET_MODE_REPLY_0100_SHIFT_HOST_INDEX)
+
+#define SET_HOST_INDEX_0100(t, hi)                                             \
+            ((t) = ((t) & ~TARGET_MODE_REPLY_0100_MASK_HOST_INDEX) |           \
+                         (((hi) << TARGET_MODE_REPLY_0100_SHIFT_HOST_INDEX) &  \
+                                      TARGET_MODE_REPLY_0100_MASK_HOST_INDEX))
+
+#define GET_IOC_INDEX_0100(x)   (((x) & TARGET_MODE_REPLY_0100_MASK_IOC_INDEX) \
+                                  >> TARGET_MODE_REPLY_0100_SHIFT_IOC_INDEX)
+
+#define SET_IOC_INDEX_0100(t, ii)                                              \
+            ((t) = ((t) & ~TARGET_MODE_REPLY_0100_MASK_IOC_INDEX) |            \
+                        (((ii) << TARGET_MODE_REPLY_0100_SHIFT_IOC_INDEX) &    \
+                                     TARGET_MODE_REPLY_0100_MASK_IOC_INDEX))
+
+#define GET_INITIATOR_INDEX_0100(x)                                            \
+            (((x) & TARGET_MODE_REPLY_0100_MASK_INITIATOR_INDEX)               \
+                              >> TARGET_MODE_REPLY_0100_SHIFT_INITIATOR_INDEX)
+
+#define SET_INITIATOR_INDEX_0100(t, ii)                                        \
+        ((t) = ((t) & ~TARGET_MODE_REPLY_0100_MASK_INITIATOR_INDEX) |          \
+                   (((ii) << TARGET_MODE_REPLY_0100_SHIFT_INITIATOR_INDEX) &   \
+                                TARGET_MODE_REPLY_0100_MASK_INITIATOR_INDEX))
 
 
 #endif
diff -Nru a/drivers/message/fusion/lsi/mpi_type.h b/drivers/message/fusion/lsi/mpi_type.h
--- a/drivers/message/fusion/lsi/mpi_type.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/lsi/mpi_type.h	Thu Jun 20 15:54:00 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Basic type definitions
  *  Creation Date:  June 6, 2000
  *
- *    MPI Version:  01.01.02
+ *    MPI Version:  01.02.01
  *
  *  Version History
  *  ---------------
@@ -17,6 +17,7 @@
  *  06-06-00  01.00.01  Update version number for 1.0 release.
  *  11-02-00  01.01.01  Original release for post 1.0 work
  *  02-20-01  01.01.02  Added define and ifdef for MPI_POINTER.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
  *  --------------------------------------------------------------------------
  */
 
diff -Nru a/drivers/message/fusion/mptbase.c b/drivers/message/fusion/mptbase.c
--- a/drivers/message/fusion/mptbase.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/mptbase.c	Thu Jun 20 15:54:00 2002
@@ -20,6 +20,12 @@
  *      And to Roger Hickerson (LSI Logic) for tirelessly supporting
  *      this driver project.
  *
+ *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
+ *      and countless enhancements while adding support for the 1030
+ *      chip family.  Pam has been instrumental in the development of
+ *      of the 2.xx.xx series fusion drivers, and her contributions are
+ *      far too numerous to hope to list in one place.
+ *
  *      All manner of help from Stephen Shirron (LSI Logic):
  *      low-level FC analysis, debug + various fixes in FCxx firmware,
  *      initial port to alpha platform, various driver code optimizations,
@@ -38,11 +44,12 @@
  *      for gobs of hard work fixing and optimizing LAN code.
  *      THANK YOU!
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id$
+ *  $Id$
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -93,11 +100,14 @@
 #include <linux/kdev_t.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
-#include <linux/proc_fs.h>
+#include <linux/interrupt.h>		/* needed for in_interrupt() proto */
 #include <asm/io.h>
 #ifdef CONFIG_MTRR
 #include <asm/mtrr.h>
 #endif
+#ifdef __sparc__
+#include <asm/irq.h>			/* needed for __irq_itoa() proto */
+#endif
 
 #include "mptbase.h"
 
@@ -110,27 +120,33 @@
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
 
-
 /*
  *  cmd line parameters
  */
 MODULE_PARM(PortIo, "0-1i");
 MODULE_PARM_DESC(PortIo, "[0]=Use mmap, 1=Use port io");
-MODULE_PARM(HardReset, "0-1i");
-MODULE_PARM_DESC(HardReset, "0=Disable HardReset, [1]=Enable HardReset");
 static int PortIo = 0;
-static int HardReset = 1;
+
+#ifdef MFCNT
+static int mfcounter = 0;
+#define PRINT_MF_COUNT 20000
+#endif
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Public data...
  */
-int mpt_lan_index = 0;
-int mpt_stm_index = 0;
+int mpt_lan_index = -1;
+int mpt_stm_index = -1;
+
+struct proc_dir_entry *mpt_proc_root_dir;
+
+DmpServices_t *DmpService;
+
+void *mpt_v_ASCQ_TablePtr;
+const char **mpt_ScsiOpcodesPtr;
+int mpt_ASCQ_TableSz;
 
-void *mpt_v_ASCQ_TablePtr = NULL;
-const char **mpt_ScsiOpcodesPtr = NULL;
-int mpt_ASCQ_TableSz = 0;
 
 #define WHOINIT_UNKNOWN		0xAA
 
@@ -139,12 +155,12 @@
  *  Private data...
  */
 					/* Adapter lookup table */
-static MPT_ADAPTER		*mpt_adapters[MPT_MAX_ADAPTERS] = {0};
+       MPT_ADAPTER		*mpt_adapters[MPT_MAX_ADAPTERS];
 static MPT_ADAPTER_TRACKER	 MptAdapters;
 					/* Callback lookup table */
 static MPT_CALLBACK		 MptCallbacks[MPT_MAX_PROTOCOL_DRIVERS];
 					/* Protocol driver class lookup table */
-static int	 		 MptDriverClass[MPT_MAX_PROTOCOL_DRIVERS];
+static int			 MptDriverClass[MPT_MAX_PROTOCOL_DRIVERS];
 					/* Event handler lookup table */
 static MPT_EVHANDLER		 MptEvHandlers[MPT_MAX_PROTOCOL_DRIVERS];
 					/* Reset handler lookup table */
@@ -152,6 +168,10 @@
 
 static int	FusionInitCalled = 0;
 static int	mpt_base_index = -1;
+static int	last_drv_idx = -1;
+static int	isense_idx = -1;
+
+static DECLARE_WAIT_QUEUE_HEAD(mpt_waitq);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -160,49 +180,84 @@
 static void	mpt_interrupt(int irq, void *bus_id, struct pt_regs *r);
 static int	mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply);
 
-static int 	mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason);
-static int 	mpt_adapter_install(struct pci_dev *pdev);
-static void	mpt_detect_929_bound_ports(MPT_ADAPTER *this, struct pci_dev *pdev);
+static int	mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag);
+static int	mpt_adapter_install(struct pci_dev *pdev);
+static void	mpt_detect_bound_ports(MPT_ADAPTER *this, struct pci_dev *pdev);
 static void	mpt_adapter_disable(MPT_ADAPTER *ioc, int freeup);
 static void	mpt_adapter_dispose(MPT_ADAPTER *ioc);
 
 static void	MptDisplayIocCapabilities(MPT_ADAPTER *ioc);
-static int	MakeIocReady(MPT_ADAPTER *ioc, int force);
-static u32	GetIocState(MPT_ADAPTER *ioc, int cooked);
-static int	GetIocFacts(MPT_ADAPTER *ioc);
-static int	GetPortFacts(MPT_ADAPTER *ioc, int portnum);
-static int	SendIocInit(MPT_ADAPTER *ioc);
-static int	SendPortEnable(MPT_ADAPTER *ioc, int portnum);
-static int	mpt_fc9x9_reset(MPT_ADAPTER *ioc, int ignore);
-static int	KickStart(MPT_ADAPTER *ioc, int ignore);
-static int	SendIocReset(MPT_ADAPTER *ioc, u8 reset_type);
+static int	MakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag);
+//static u32	mpt_GetIocState(MPT_ADAPTER *ioc, int cooked);
+static int	GetIocFacts(MPT_ADAPTER *ioc, int sleepFlag, int reason);
+static int	GetPortFacts(MPT_ADAPTER *ioc, int portnum, int sleepFlag);
+static int	SendIocInit(MPT_ADAPTER *ioc, int sleepFlag);
+static int	SendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag);
+static int	mpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag);
+static int	mpt_downloadboot(MPT_ADAPTER *ioc, int sleepFlag);
+static int	mpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag);
+static int	KickStart(MPT_ADAPTER *ioc, int ignore, int sleepFlag);
+static int	SendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag);
 static int	PrimeIocFifos(MPT_ADAPTER *ioc);
-static int	HandShakeReqAndReply(MPT_ADAPTER *ioc, int reqBytes, u32 *req, int replyBytes, u16 *u16reply, int maxwait);
-static int	WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong);
-static int	WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong);
-static int	WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong);
+static int	WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag);
+static int	WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag);
+static int	WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong, int sleepFlag);
 static int	GetLanConfigPages(MPT_ADAPTER *ioc);
+static int	GetFcPortPage0(MPT_ADAPTER *ioc, int portnum);
+static int	GetIoUnitPage2(MPT_ADAPTER *ioc);
+static int	mpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum);
+static int	mpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum);
+static int	mpt_findImVolumes(MPT_ADAPTER *ioc);
+static void	mpt_timer_expired(unsigned long data);
 static int	SendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch);
 static int	SendEventAck(MPT_ADAPTER *ioc, EventNotificationReply_t *evnp);
 
-static int	procmpt_create(void);
 #ifdef CONFIG_PROC_FS
+static int	procmpt_create(void);
 static int	procmpt_destroy(void);
+static int	procmpt_summary_read(char *buf, char **start, off_t offset,
+				int request, int *eof, void *data);
+static int	procmpt_version_read(char *buf, char **start, off_t offset,
+				int request, int *eof, void *data);
+static int	procmpt_iocinfo_read(char *buf, char **start, off_t offset,
+				int request, int *eof, void *data);
 #endif
-static int	procmpt_read_summary(char *page, char **start, off_t off, int count, int *eof, void *data);
-static int	procmpt_read_dbg(char *page, char **start, off_t off, int count, int *eof, void *data);
-/*static int	procmpt_info(char *buf, char **start, off_t offset, int len);*/
+static void	mpt_get_fw_exp_ver(char *buf, MPT_ADAPTER *ioc);
 
+//int		mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag);
 static int	ProcessEventNotification(MPT_ADAPTER *ioc, EventNotificationReply_t *evReply, int *evHandlers);
 static void	mpt_fc_log_info(MPT_ADAPTER *ioc, u32 log_info);
 static void	mpt_sp_log_info(MPT_ADAPTER *ioc, u32 log_info);
 
-static struct proc_dir_entry	*procmpt_root_dir = NULL;
-
 int		fusion_init(void);
 static void	fusion_exit(void);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  more Private data...
+ */
+#ifdef CONFIG_PROC_FS
+struct _mpt_proc_list {
+	const char	*name;
+	int		(*f)(char *, char **, off_t, int, int *, void *);
+} mpt_proc_list[] = {
+	{ "summary", procmpt_summary_read},
+	{ "version", procmpt_version_read},
+};
+#define MPT_PROC_ENTRIES (sizeof(mpt_proc_list)/sizeof(mpt_proc_list[0]))
+
+struct _mpt_ioc_proc_list {
+	const char	*name;
+	int		(*f)(char *, char **, off_t, int, int *, void *);
+} mpt_ioc_proc_list[] = {
+	{ "info", procmpt_iocinfo_read},
+	{ "summary", procmpt_summary_read},
+};
+#define MPT_IOC_PROC_ENTRIES (sizeof(mpt_ioc_proc_list)/sizeof(mpt_ioc_proc_list[0]))
+
+#endif
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /* 20000207 -sralston
  *  GRRRRR...  IOSpace (port i/o) register access (for the 909) is back!
  * 20000517 -sralston
@@ -225,9 +280,18 @@
 		writel(v, a);
 }
 
+static inline void CHIPREG_PIO_WRITE32(volatile u32 *a, u32 v)
+{
+	outl(v, (unsigned long)a);
+}
+
+static inline u32 CHIPREG_PIO_READ32(volatile u32 *a)
+{
+	return inl((unsigned long)a);
+}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	mpt_interrupt - MPT adapter (IOC) specific interrupt handler.
  *	@irq: irq number (not used)
  *	@bus_id: bus identifier cookie == pointer to MPT_ADAPTER structure
@@ -252,8 +316,7 @@
 	MPT_FRAME_HDR	*mf;
 	MPT_FRAME_HDR	*mr;
 	u32		 pa;
-	u32		*m;
-	int		 req_idx;
+	int		 req_idx = -1;
 	int		 cb_idx;
 	int		 type;
 	int		 freeme;
@@ -262,6 +325,21 @@
 	ioc = bus_id;
 
 	/*
+	 * Verify ioc pointer is ok
+	 */
+	{
+		MPT_ADAPTER	*iocCmp;
+		iocCmp = mpt_adapter_find_first();
+		while ((ioc != iocCmp)  && iocCmp)
+			iocCmp = mpt_adapter_find_next(iocCmp);
+
+		if (!iocCmp) {
+			printk(KERN_WARNING "mpt_interrupt: Invalid ioc!\n");
+			return;
+		}
+	}
+
+	/*
 	 *  Drain the reply FIFO!
 	 *
 	 * NOTES: I've seen up to 10 replies processed in this loop, so far...
@@ -281,25 +359,27 @@
 		 *  Check for non-TURBO reply!
 		 */
 		if (pa & MPI_ADDRESS_REPLY_A_BIT) {
-			dma_addr_t reply_dma_addr;
+			u32 reply_dma_low;
 			u16 ioc_stat;
 
 			/* non-TURBO reply!  Hmmm, something may be up...
 			 *  Newest turbo reply mechanism; get address
 			 *  via left shift 1 (get rid of MPI_ADDRESS_REPLY_A_BIT)!
 			 */
-			reply_dma_addr = (pa = (pa << 1));
 
-			/* Map DMA address of reply header to cpu address. */
-			m = (u32 *) ((u8 *)ioc->reply_frames +
-					(reply_dma_addr - ioc->reply_frames_dma));
+			/* Map DMA address of reply header to cpu address.
+			 * pa is 32 bits - but the dma address may be 32 or 64 bits
+			 * get offset based only only the low addresses
+			 */
+			reply_dma_low = (pa = (pa << 1));
+			mr = (MPT_FRAME_HDR *)((u8 *)ioc->reply_frames +
+					 (reply_dma_low - ioc->reply_frames_low_dma));
 
-			mr = (MPT_FRAME_HDR *) m;
 			req_idx = le16_to_cpu(mr->u.frame.hwhdr.msgctxu.fld.req_idx);
 			cb_idx = mr->u.frame.hwhdr.msgctxu.fld.cb_idx;
 			mf = MPT_INDEX_2_MFPTR(ioc, req_idx);
 
-			dprintk((KERN_INFO MYNAM ": %s: Got non-TURBO reply=%p\n",
+			dprintk((MYIOC_s_INFO_FMT "Got non-TURBO reply=%p\n",
 					ioc->name, mr));
 			DBG_DUMP_REPLY_FRAME(mr)
 
@@ -307,7 +387,7 @@
 			 *  Check/log IOC log info
 			 */
 			ioc_stat = le16_to_cpu(mr->u.reply.IOCStatus);
-	 		if (ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
+			if (ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
 				u32	 log_info = le32_to_cpu(mr->u.reply.IOCLogInfo);
 				if ((int)ioc->chip_type <= (int)FC929)
 					mpt_fc_log_info(ioc, log_info);
@@ -318,7 +398,7 @@
 			/*
 			 *  Process turbo (context) reply...
 			 */
-			dirqprintk((KERN_INFO MYNAM ": %s: Got TURBO reply(=%08x)\n", ioc->name, pa));
+			dirqprintk((MYIOC_s_INFO_FMT "Got TURBO reply(=%08x)\n", ioc->name, pa));
 			type = (pa >> MPI_CONTEXT_REPLY_TYPE_SHIFT);
 			if (type == MPI_CONTEXT_REPLY_TYPE_SCSI_TARGET) {
 				cb_idx = mpt_stm_index;
@@ -357,6 +437,34 @@
 			pa = 0;					/* No reply flush! */
 		}
 
+		if ((int)ioc->chip_type > (int)FC929) {
+			/* Verify mf, mf are reasonable.
+			 */
+			if ((mf) && ((mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))
+				|| (mf < ioc->req_frames)) ) {
+				printk(MYIOC_s_WARN_FMT 
+					"mpt_interrupt: Invalid mf (%p) req_idx (%d)!\n", ioc->name, (void *)mf, req_idx);
+				cb_idx = 0;
+				pa = 0;
+				freeme = 0;
+			}
+			if ((pa) && (mr) && ((mr >= MPT_INDEX_2_RFPTR(ioc, ioc->req_depth))
+				|| (mr < ioc->reply_frames)) ) {
+				printk(MYIOC_s_WARN_FMT 
+					"mpt_interrupt: Invalid rf (%p)!\n", ioc->name, (void *)mr);
+				cb_idx = 0;
+				pa = 0;
+				freeme = 0;
+			}
+			if (cb_idx > (MPT_MAX_PROTOCOL_DRIVERS-1)) {
+				printk(MYIOC_s_WARN_FMT 
+					"mpt_interrupt: Invalid cb_idx (%d)!\n", ioc->name, cb_idx);
+				cb_idx = 0;
+				pa = 0;
+				freeme = 0;
+			}
+		}
+
 		/*  Check for (valid) IO callback!  */
 		if (cb_idx) {
 			/*  Do the callback!  */
@@ -374,15 +482,18 @@
 			/*  Put Request back on FreeQ!  */
 			spin_lock_irqsave(&ioc->FreeQlock, flags);
 			Q_ADD_TAIL(&ioc->FreeQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+#ifdef MFCNT
+			ioc->mfcnt--;
+#endif
 			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 		}
 
 		count++;
-		dirqprintk((KERN_INFO MYNAM ": %s: ISR processed frame #%d\n", ioc->name, count));
+		dirqprintk((MYIOC_s_INFO_FMT "ISR processed frame #%d\n", ioc->name, count));
 		mb();
 
 		if (count >= MPT_MAX_REPLIES_PER_ISR) {
-			dirqprintk((KERN_INFO MYNAM ": %s: ISR processed %d replies.",
+			dirqprintk((MYIOC_s_INFO_FMT "ISR processed %d replies.",
 					ioc->name, count));
 			dirqprintk((" Giving this ISR a break!\n"));
 			return;
@@ -409,17 +520,17 @@
 	int freereq = 1;
 	u8 func;
 
-	dprintk((KERN_INFO MYNAM ": %s: mpt_base_reply() called\n", ioc->name));
+	dprintk((MYIOC_s_INFO_FMT "mpt_base_reply() called\n", ioc->name));
 
 	if ((mf == NULL) ||
 	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
-		printk(KERN_ERR MYNAM ": %s: ERROR - NULL or BAD request frame ptr! (=%p)\n",
-				ioc->name, mf);
+		printk(MYIOC_s_ERR_FMT "NULL or BAD request frame ptr! (=%p)\n",
+				ioc->name, (void *)mf);
 		return 1;
 	}
 
 	if (reply == NULL) {
-		dprintk((KERN_ERR MYNAM ": %s: ERROR - Unexpected NULL Event (turbo?) reply!\n",
+		dprintk((MYIOC_s_ERR_FMT "Unexpected NULL Event (turbo?) reply!\n",
 				ioc->name));
 		return 1;
 	}
@@ -430,7 +541,7 @@
 	}
 
 	func = reply->u.hdr.Function;
-	dprintk((KERN_INFO MYNAM ": %s: mpt_base_reply, Function=%02Xh\n",
+	dprintk((MYIOC_s_INFO_FMT "mpt_base_reply, Function=%02Xh\n",
 			ioc->name, func));
 
 	if (func == MPI_FUNCTION_EVENT_NOTIFICATION) {
@@ -441,30 +552,77 @@
 		results = ProcessEventNotification(ioc, pEvReply, &evHandlers);
 		if (results != evHandlers) {
 			/* CHECKME! Any special handling needed here? */
-			dprintk((KERN_WARNING MYNAM ": %s: Hmmm... Called %d event handlers, sum results = %d\n",
+			dprintk((MYIOC_s_WARN_FMT "Called %d event handlers, sum results = %d\n",
 					ioc->name, evHandlers, results));
 		}
 
 		/*
-		 *  Hmmm...  It seems that EventNotificationReply is an exception
-		 *  to the rule of one reply per request.
+		 *	Hmmm...  It seems that EventNotificationReply is an exception
+		 *	to the rule of one reply per request.
 		 */
 		if (pEvReply->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY)
 			freereq = 0;
+
 #ifdef CONFIG_PROC_FS
 //		LogEvent(ioc, pEvReply);
 #endif
+
 	} else if (func == MPI_FUNCTION_EVENT_ACK) {
-		dprintk((KERN_INFO MYNAM ": %s: mpt_base_reply, EventAck reply received\n",
+		dprintk((MYIOC_s_INFO_FMT "mpt_base_reply, EventAck reply received\n",
 				ioc->name));
+	} else if (func == MPI_FUNCTION_CONFIG) {
+		CONFIGPARMS *pCfg;
+		unsigned long flags;
+
+		dprintk((MYIOC_s_INFO_FMT "config_complete (mf=%p,mr=%p)\n",
+				ioc->name, mf, reply));
+
+		pCfg = * ((CONFIGPARMS **)((u8 *) mf + ioc->req_sz - sizeof(void *)));
+
+		if (pCfg) {
+			/* disable timer and remove from linked list */
+			del_timer(&pCfg->timer);
+
+			spin_lock_irqsave(&ioc->FreeQlock, flags);
+			Q_DEL_ITEM(&pCfg->linkage);
+			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+			/*
+			 *	If IOC Status is SUCCESS, save the header
+			 *	and set the status code to GOOD.
+			 */
+			pCfg->status = MPT_CONFIG_ERROR;
+			if (reply) {
+				ConfigReply_t	*pReply = (ConfigReply_t *)reply;
+				u16		 status;
+
+				status = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+				dprintk((KERN_NOTICE "  IOCStatus=%04xh, IOCLogInfo=%08xh\n",
+				     status, le32_to_cpu(pReply->IOCLogInfo)));
+
+				pCfg->status = status;
+				if (status == MPI_IOCSTATUS_SUCCESS) {
+					pCfg->hdr->PageVersion = pReply->Header.PageVersion;
+					pCfg->hdr->PageLength = pReply->Header.PageLength;
+					pCfg->hdr->PageNumber = pReply->Header.PageNumber;
+					pCfg->hdr->PageType = pReply->Header.PageType;
+				}
+			}
+
+			/*
+			 *	Wake up the original calling thread
+			 */
+			pCfg->wait_done = 1;
+			wake_up(&mpt_waitq);
+		}
 	} else {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Unexpected msg function (=%02Xh) reply received!\n",
+		printk(MYIOC_s_ERR_FMT "Unexpected msg function (=%02Xh) reply received!\n",
 				ioc->name, func);
 	}
 
 	/*
-	 *  Conditionally tell caller to free the original
-	 *  EventNotification/EventAck/unexpected request frame!
+	 *	Conditionally tell caller to free the original
+	 *	EventNotification/EventAck/unexpected request frame!
 	 */
 	return freereq;
 }
@@ -480,21 +638,22 @@
  *	protocol-specific driver must do this before it will be able to
  *	use any IOC resources, such as obtaining request frames.
  *
- *	NOTES: The SCSI protocol driver currently calls this routine twice
- *	in order to register separate callbacks; one for "normal" SCSI IO
- *	and another for MptScsiTaskMgmt requests.
+ *	NOTES: The SCSI protocol driver currently calls this routine thrice
+ *	in order to register separate callbacks; one for "normal" SCSI IO;
+ *	one for MptScsiTaskMgmt requests; one for Scan/DV requests.
  *
  *	Returns a positive integer valued "handle" in the
- *	range (and S.O.D. order) {7,6,...,1} if successful.
+ *	range (and S.O.D. order) {N,...,7,6,5,...,1} if successful.
  *	Any non-positive return value (including zero!) should be considered
  *	an error by the caller.
  */
 int
 mpt_register(MPT_CALLBACK cbfunc, MPT_DRIVER_CLASS dclass)
 {
-	int r = -1;
 	int i;
 
+	last_drv_idx = -1;
+
 #ifndef MODULE
 	/*
 	 *  Handle possibility of the mptscsih_detect() routine getting
@@ -512,7 +671,7 @@
 #endif
 
 	/*
-	 *  Search for empty callback slot in this order: {7,6,...,1}
+	 *  Search for empty callback slot in this order: {N,...,7,6,5,...,1}
 	 *  (slot/handle 0 is reserved!)
 	 */
 	for (i = MPT_MAX_PROTOCOL_DRIVERS-1; i; i--) {
@@ -520,7 +679,7 @@
 			MptCallbacks[i] = cbfunc;
 			MptDriverClass[i] = dclass;
 			MptEvHandlers[i] = NULL;
-			r = i;
+			last_drv_idx = i;
 			if (cbfunc != mpt_base_reply) {
 				MOD_INC_USE_COUNT;
 			}
@@ -528,7 +687,7 @@
 		}
 	}
 
-	return r;
+	return last_drv_idx;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -546,6 +705,11 @@
 		MptCallbacks[cb_idx] = NULL;
 		MptDriverClass[cb_idx] = MPTUNKNOWN_DRIVER;
 		MptEvHandlers[cb_idx] = NULL;
+
+		last_drv_idx++;
+		if (isense_idx != -1 && isense_idx <= cb_idx)
+			isense_idx++;
+
 		if (cb_idx != mpt_base_index) {
 			MOD_DEC_USE_COUNT;
 		}
@@ -639,7 +803,8 @@
  *	@handle: Handle of registered MPT protocol driver
  *	@iocid: IOC unique identifier (integer)
  *
- *	Returns pointer to a MPT request frame or %NULL if none are available.
+ *	Returns pointer to a MPT request frame or %NULL if none are available
+ *	or IOC is not active.
  */
 MPT_FRAME_HDR*
 mpt_get_msg_frame(int handle, int iocid)
@@ -650,6 +815,16 @@
 
 	/* validate handle and ioc identifier */
 	iocp = mpt_adapters[iocid];
+
+#ifdef MFCNT
+	if (!iocp->active)
+		printk(KERN_WARNING "IOC Not Active! mpt_get_msg_frame returning NULL!\n");
+#endif
+
+	/* If interrupts are not attached, do not return a request frame */
+	if (!iocp->active)
+		return NULL;
+
 	spin_lock_irqsave(&iocp->FreeQlock, flags);
 	if (! Q_IS_EMPTY(&iocp->FreeQ)) {
 		int req_offset;
@@ -662,8 +837,20 @@
 		mf->u.frame.hwhdr.msgctxu.fld.req_idx =
 				cpu_to_le16(req_offset / iocp->req_sz);
 		mf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;
+#ifdef MFCNT
+		iocp->mfcnt++;
+#endif
 	}
 	spin_unlock_irqrestore(&iocp->FreeQlock, flags);
+
+#ifdef MFCNT
+	if (mf == NULL)
+		printk(KERN_WARNING "IOC Active. No free Msg Frames! Count 0x%x Max 0x%x\n", iocp->mfcnt, iocp->req_depth);
+	mfcounter++;
+	if (mfcounter == PRINT_MF_COUNT)
+		printk(KERN_INFO "MF Count 0x%x Max 0x%x \n", iocp->mfcnt, iocp->req_depth);
+#endif
+
 	dmfprintk((KERN_INFO MYNAM ": %s: mpt_get_msg_frame(%d,%d), got mf=%p\n",
 			iocp->name, handle, iocid, mf));
 	return mf;
@@ -687,7 +874,7 @@
 
 	iocp = mpt_adapters[iocid];
 	if (iocp != NULL) {
-		dma_addr_t mf_dma_addr;
+		u32 mf_dma_addr;
 		int req_offset;
 
 		/* ensure values are reset properly! */
@@ -700,23 +887,23 @@
 #ifdef MPT_DEBUG_MSG_FRAME
 		{
 			u32	*m = mf->u.frame.hwhdr.__hdr;
-			int	 i, n;
+			int	 ii, n;
 
 			printk(KERN_INFO MYNAM ": %s: About to Put msg frame @ %p:\n" KERN_INFO " ",
 					iocp->name, m);
 			n = iocp->req_sz/4 - 1;
 			while (m[n] == 0)
 				n--;
-			for (i=0; i<=n; i++) {
-				if (i && ((i%8)==0))
+			for (ii=0; ii<=n; ii++) {
+				if (ii && ((ii%8)==0))
 					printk("\n" KERN_INFO " ");
-				printk(" %08x", le32_to_cpu(m[i]));
+				printk(" %08x", le32_to_cpu(m[ii]));
 			}
 			printk("\n");
 		}
 #endif
 
-		mf_dma_addr = iocp->req_frames_dma + req_offset;
+		mf_dma_addr = iocp->req_frames_low_dma + req_offset;
 		CHIPREG_WRITE32(&iocp->chip->RequestFifo, mf_dma_addr);
 	}
 }
@@ -742,20 +929,88 @@
 		/*  Put Request back on FreeQ!  */
 		spin_lock_irqsave(&iocp->FreeQlock, flags);
 		Q_ADD_TAIL(&iocp->FreeQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+#ifdef MFCNT
+		iocp->mfcnt--;
+#endif
 		spin_unlock_irqrestore(&iocp->FreeQlock, flags);
 	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
+ *	mpt_add_sge - Place a simple SGE at address pAddr.
+ *	@pAddr: virtual address for SGE
+ *	@flagslength: SGE flags and data transfer length
+ *	@dma_addr: Physical address 
+ *
+ *	This routine places a MPT request frame back on the MPT adapter's
+ *	FreeQ.
+ */
+void
+mpt_add_sge(char *pAddr, u32 flagslength, dma_addr_t dma_addr)
+{
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+		SGESimple64_t *pSge = (SGESimple64_t *) pAddr;
+		u32 tmp = dma_addr & 0xFFFFFFFF;
+
+		pSge->FlagsLength = cpu_to_le32(flagslength);
+		pSge->Address.Low = cpu_to_le32(tmp);
+		tmp = (u32) ((u64)dma_addr >> 32);
+		pSge->Address.High = cpu_to_le32(tmp);
+
+	} else {
+		SGESimple32_t *pSge = (SGESimple32_t *) pAddr;
+		pSge->FlagsLength = cpu_to_le32(flagslength);
+		pSge->Address = cpu_to_le32(dma_addr);
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mpt_add_chain - Place a chain SGE at address pAddr.
+ *	@pAddr: virtual address for SGE
+ *	@next: nextChainOffset value (u32's)
+ *	@length: length of next SGL segment
+ *	@dma_addr: Physical address 
+ *
+ *	This routine places a MPT request frame back on the MPT adapter's
+ *	FreeQ.
+ */
+void
+mpt_add_chain(char *pAddr, u8 next, u16 length, dma_addr_t dma_addr)
+{
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+		SGEChain64_t *pChain = (SGEChain64_t *) pAddr;
+		u32 tmp = dma_addr & 0xFFFFFFFF;
+
+		pChain->Length = cpu_to_le16(length);
+		pChain->Flags = MPI_SGE_FLAGS_CHAIN_ELEMENT | mpt_addr_size(); 
+
+		pChain->NextChainOffset = next;
+
+		pChain->Address.Low = cpu_to_le32(tmp);
+		tmp = (u32) ((u64)dma_addr >> 32);
+		pChain->Address.High = cpu_to_le32(tmp);
+	} else {
+		SGEChain32_t *pChain = (SGEChain32_t *) pAddr;
+		pChain->Length = cpu_to_le16(length);
+		pChain->Flags = MPI_SGE_FLAGS_CHAIN_ELEMENT | mpt_addr_size();
+		pChain->NextChainOffset = next;
+		pChain->Address = cpu_to_le32(dma_addr);
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
  *	mpt_send_handshake_request - Send MPT request via doorbell
  *	handshake method.
  *	@handle: Handle of registered MPT protocol driver
  *	@iocid: IOC unique identifier (integer)
  *	@reqBytes: Size of the request in bytes
  *	@req: Pointer to MPT request frame
+ *	@sleepFlag: Use schedule if CAN_SLEEP else use udelay.
  *
- *	This routine is used exclusively by mptscsih to send MptScsiTaskMgmt
+ *	This routine is used exclusively to send MptScsiTaskMgmt
  *	requests since they are required to be sent via doorbell handshake.
  *
  *	NOTE: It is the callers responsibility to byte-swap fields in the
@@ -764,41 +1019,30 @@
  *	Returns 0 for success, non-zero for failure.
  */
 int
-mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req)
+mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req, int sleepFlag)
 {
 	MPT_ADAPTER	*iocp;
 	int		 r = 0;
 
 	iocp = mpt_adapters[iocid];
 	if (iocp != NULL) {
-		u8		*req_as_bytes;
-		u32		 ioc_raw_state;
-		int		 i;
-
-		/* YIKES!  We already know something is amiss.
-		 * Do upfront check on IOC state.
-		 */
-		ioc_raw_state = GetIocState(iocp, 0);
-		if ((ioc_raw_state & MPI_DOORBELL_ACTIVE) ||
-		    ((ioc_raw_state & MPI_IOC_STATE_MASK) != MPI_IOC_STATE_OPERATIONAL)) {
-			printk(KERN_WARNING MYNAM ": %s: Bad IOC state (%08x) WARNING!\n",
-					iocp->name, ioc_raw_state);
-			if ((r = mpt_do_ioc_recovery(iocp, MPT_HOSTEVENT_IOC_RECOVER)) != 0) {
-				printk(KERN_WARNING MYNAM ": WARNING - (%d) Cannot recover %s\n",
-						r, iocp->name);
-				return r;
-			}
-		}
+		u8	*req_as_bytes;
+		int	 ii;
+
+		/* State is known to be good upon entering
+		 * this function so issue the bus reset
+		 * request.
+		 */
 
 		/*
 		 * Emulate what mpt_put_msg_frame() does /wrt to sanity
 		 * setting cb_idx/req_idx.  But ONLY if this request
 		 * is in proper (pre-alloc'd) request buffer range...
 		 */
-		i = MFPTR_2_MPT_INDEX(iocp,(MPT_FRAME_HDR*)req);
-		if (reqBytes >= 12 && i >= 0 && i < iocp->req_depth) {
+		ii = MFPTR_2_MPT_INDEX(iocp,(MPT_FRAME_HDR*)req);
+		if (reqBytes >= 12 && ii >= 0 && ii < iocp->req_depth) {
 			MPT_FRAME_HDR *mf = (MPT_FRAME_HDR*)req;
-			mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(i);
+			mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(ii);
 			mf->u.frame.hwhdr.msgctxu.fld.cb_idx = handle;
 		}
 
@@ -810,36 +1054,40 @@
 				 ((reqBytes/4)<<MPI_DOORBELL_ADD_DWORDS_SHIFT)));
 
 		/* Wait for IOC doorbell int */
-		if ((i = WaitForDoorbellInt(iocp, 2)) < 0) {
-			return i;
+		if ((ii = WaitForDoorbellInt(iocp, 2, sleepFlag)) < 0) {
+			return ii;
 		}
 
+		/* Read doorbell and check for active bit */
+		if (!(CHIPREG_READ32(&iocp->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
+				return -5;
+
 		dhsprintk((KERN_INFO MYNAM ": %s: mpt_send_handshake_request start, WaitCnt=%d\n",
-				iocp->name, i));
+				iocp->name, ii));
 
 		CHIPREG_WRITE32(&iocp->chip->IntStatus, 0);
 
-		if ((r = WaitForDoorbellAck(iocp, 1)) < 0) {
+		if ((r = WaitForDoorbellAck(iocp, 1, sleepFlag)) < 0) {
 			return -2;
 		}
 
 		/* Send request via doorbell handshake */
 		req_as_bytes = (u8 *) req;
-		for (i = 0; i < reqBytes/4; i++) {
+		for (ii = 0; ii < reqBytes/4; ii++) {
 			u32 word;
 
-			word = ((req_as_bytes[(i*4) + 0] <<  0) |
-				(req_as_bytes[(i*4) + 1] <<  8) |
-				(req_as_bytes[(i*4) + 2] << 16) |
-				(req_as_bytes[(i*4) + 3] << 24));
+			word = ((req_as_bytes[(ii*4) + 0] <<  0) |
+				(req_as_bytes[(ii*4) + 1] <<  8) |
+				(req_as_bytes[(ii*4) + 2] << 16) |
+				(req_as_bytes[(ii*4) + 3] << 24));
 			CHIPREG_WRITE32(&iocp->chip->Doorbell, word);
-			if ((r = WaitForDoorbellAck(iocp, 1)) < 0) {
+			if ((r = WaitForDoorbellAck(iocp, 1, sleepFlag)) < 0) {
 				r = -3;
 				break;
 			}
 		}
 
-		if ((r = WaitForDoorbellInt(iocp, 2)) >= 0)
+		if (r >= 0 && WaitForDoorbellInt(iocp, 10, sleepFlag) >= 0)
 			r = 0;
 		else
 			r = -4;
@@ -871,8 +1119,8 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- * 	mpt_adapter_find_next - Find next MPT adapter pointer.
- * 	@prev: Pointer to previous MPT adapter
+ *	mpt_adapter_find_next - Find next MPT adapter pointer.
+ *	@prev: Pointer to previous MPT adapter
  *
  *	Returns next MPT adapter pointer or %NULL if there are no more.
  */
@@ -888,13 +1136,13 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	mpt_pci_scan - Scan PCI devices for MPT adapters.
  *
  *	Returns count of MPT adapters found, keying off of PCI vendor and
  *	device_id's.
  */
-int __init
+static int __init
 mpt_pci_scan(void)
 {
 	struct pci_dev *pdev;
@@ -906,7 +1154,7 @@
 	dprintk((KERN_INFO MYNAM ": Checking for MPT adapters...\n"));
 
 	/*
-	 *  NOTE: The 929 (I believe) will appear as 2 separate PCI devices,
+	 *  NOTE: The 929, 929X and 1030 will appear as 2 separate PCI devices,
 	 *  one for each channel.
 	 */
 	pci_for_each_dev(pdev) {
@@ -917,9 +1165,11 @@
 		if ((pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC909) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC929) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC919) &&
+		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC929X) &&
+		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC919X) &&
+		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1030) &&
 #if 0
 		    /* FIXME! C103x family */
-		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1030) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1030_ZC) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1035) &&
 #endif
@@ -929,7 +1179,7 @@
 		}
 
 		/* GRRRRR
-		 * 929 dual function devices may be presented in Func 1,0 order,
+		 * dual function devices (929, 929X, 1030) may be presented in Func 1,0 order,
 		 * but we'd really really rather have them in Func 0,1 order.
 		 * Do some kind of look ahead here...
 		 */
@@ -937,11 +1187,11 @@
 			pdev2 = pci_peek_next_dev(pdev);
 			if (pdev2 && (pdev2->vendor == 0x1000) &&
 			    (PCI_SLOT(pdev2->devfn) == PCI_SLOT(pdev->devfn)) &&
-			    (pdev2->device == MPI_MANUFACTPAGE_DEVICEID_FC929) &&
+			    (pdev2->device == pdev->device) &&
 			    (pdev2->bus->number == pdev->bus->number) &&
 			    !(pdev2->devfn & 1)) {
 				dprintk((KERN_INFO MYNAM ": MPT adapter found: PCI bus/dfn=%02x/%02xh, class=%08x, id=%xh\n",
-			 		pdev2->bus->number, pdev2->devfn, pdev2->class, pdev2->device));
+					pdev2->bus->number, pdev2->devfn, pdev2->class, pdev2->device));
 				found++;
 				if ((r = mpt_adapter_install(pdev2)) == 0)
 					count++;
@@ -969,9 +1219,7 @@
 	}
 
 #ifdef CONFIG_PROC_FS
-	if (procmpt_create() != 0)
-		printk(KERN_WARNING MYNAM ": WARNING! - %s creation failed!\n",
-				MPT_PROCFS_MPTBASEDIR);
+	(void) procmpt_create();
 #endif
 
 	return count;
@@ -1004,7 +1252,7 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	mpt_adapter_install - Install a PCI intelligent MPT adapter.
  *	@pdev: Pointer to pci_dev structure
  *
@@ -1024,57 +1272,91 @@
 mpt_adapter_install(struct pci_dev *pdev)
 {
 	MPT_ADAPTER	*ioc;
-	char		*myname;
 	u8		*mem;
 	unsigned long	 mem_phys;
 	unsigned long	 port;
 	u32		 msize;
 	u32		 psize;
-	int		 i;
+	int		 ii;
 	int		 r = -ENODEV;
-	int		 len;
+	u64		 mask = 0xffffffffffffffff;
+
+	if (pci_enable_device(pdev))
+		return r;
+
+	if (!pci_set_dma_mask(pdev, mask)) {
+		dprintk((KERN_INFO MYNAM 
+			": 64 BIT PCI BUS DMA ADDRESSING SUPPORTED\n"));
+	} else if (pci_set_dma_mask(pdev, (u64) 0xffffffff)) {
+		printk(KERN_WARNING MYNAM ": 32 BIT PCI BUS DMA ADDRESSING NOT SUPPORTED\n");
+		return r;
+	}
 
-	ioc = kmalloc(sizeof(MPT_ADAPTER), GFP_KERNEL);
+	ioc = kmalloc(sizeof(MPT_ADAPTER), GFP_ATOMIC);
 	if (ioc == NULL) {
 		printk(KERN_ERR MYNAM ": ERROR - Insufficient memory to add adapter!\n");
 		return -ENOMEM;
 	}
 	memset(ioc, 0, sizeof(*ioc));
-	ioc->req_sz = MPT_REQ_SIZE;			/* avoid div by zero! */
 	ioc->alloc_total = sizeof(MPT_ADAPTER);
+	ioc->req_sz = MPT_DEFAULT_FRAME_SIZE;		/* avoid div by zero! */
+	ioc->reply_sz = ioc->req_sz;
 
 	ioc->pcidev = pdev;
+	ioc->diagPending = 0;
+	spin_lock_init(&ioc->diagLock);
+
+	/* Initialize the event logging.
+	 */
+	ioc->eventTypes = 0;	/* None */
+	ioc->eventContext = 0;
+	ioc->eventLogSize = 0;
+	ioc->events = NULL;
+
+#ifdef MFCNT
+	ioc->mfcnt = 0;
+#endif
+
+	ioc->cached_fw = NULL;
+
+	/* Initilize SCSI Config Data structure
+	 */
+	memset(&ioc->spi_data, 0, sizeof(ScsiCfgData));
+
+	/* Initialize the running configQ head.
+	 */
+	Q_INIT(&ioc->configQ, Q_ITEM);
 
 	/* Find lookup slot. */
-	for (i=0; i < MPT_MAX_ADAPTERS; i++) {
-		if (mpt_adapters[i] == NULL) {
-			ioc->id = i;		/* Assign adapter unique id (lookup) */
+	for (ii=0; ii < MPT_MAX_ADAPTERS; ii++) {
+		if (mpt_adapters[ii] == NULL) {
+			ioc->id = ii;		/* Assign adapter unique id (lookup) */
 			break;
 		}
 	}
-	if (i == MPT_MAX_ADAPTERS) {
-		printk(KERN_ERR MYNAM ": ERROR - mpt_adapters[%d] table overflow!\n", i);
+	if (ii == MPT_MAX_ADAPTERS) {
+		printk(KERN_ERR MYNAM ": ERROR - mpt_adapters[%d] table overflow!\n", ii);
 		kfree(ioc);
 		return -ENFILE;
 	}
 
 	mem_phys = msize = 0;
 	port = psize = 0;
-	for (i=0; i < DEVICE_COUNT_RESOURCE; i++) {
-		if (pdev->PCI_BASEADDR_FLAGS(i) & PCI_BASE_ADDRESS_SPACE_IO) {
+	for (ii=0; ii < DEVICE_COUNT_RESOURCE; ii++) {
+		if (pdev->PCI_BASEADDR_FLAGS(ii) & PCI_BASE_ADDRESS_SPACE_IO) {
 			/* Get I/O space! */
-			port = pdev->PCI_BASEADDR_START(i);
-			psize = PCI_BASEADDR_SIZE(pdev,i);
+			port = pdev->PCI_BASEADDR_START(ii);
+			psize = PCI_BASEADDR_SIZE(pdev,ii);
 		} else {
 			/* Get memmap */
-			mem_phys = pdev->PCI_BASEADDR_START(i);
-			msize = PCI_BASEADDR_SIZE(pdev,i);
+			mem_phys = pdev->PCI_BASEADDR_START(ii);
+			msize = PCI_BASEADDR_SIZE(pdev,ii);
 			break;
 		}
 	}
 	ioc->mem_size = msize;
 
-	if (i == DEVICE_COUNT_RESOURCE) {
+	if (ii == DEVICE_COUNT_RESOURCE) {
 		printk(KERN_ERR MYNAM ": ERROR - MPT adapter has no memory regions defined!\n");
 		kfree(ioc);
 		return -EINVAL;
@@ -1098,6 +1380,8 @@
 	}
 	dprintk((KERN_INFO MYNAM ": mem = %p, mem_phys = %lx\n", mem, mem_phys));
 
+	dprintk((KERN_INFO MYNAM ": facts @ %p, pfacts[0] @ %p\n",
+			&ioc->facts, &ioc->pfacts[0]));
 	if (PortIo) {
 		u8 *pmem = (u8*)port;
 		ioc->mem_phys = port;
@@ -1107,6 +1391,13 @@
 		ioc->chip = (SYSIF_REGS*)mem;
 	}
 
+	/* Save Port IO values incase we need to do downloadboot */
+	{
+		u8 *pmem = (u8*)port;
+		ioc->pio_mem_phys = port;
+		ioc->pio_chip = (SYSIF_REGS*)pmem;
+	}
+
 	ioc->chip_type = FCUNK;
 	if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC909) {
 		ioc->chip_type = FC909;
@@ -1120,17 +1411,29 @@
 		ioc->chip_type = FC919;
 		ioc->prod_name = "LSIFC919";
 	}
-#if 0
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_53C1030) {
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC929X) {
+		ioc->chip_type = FC929X;
+		ioc->prod_name = "LSIFC929X";
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC919X) {
+		ioc->chip_type = FC919X;
+		ioc->prod_name = "LSIFC919X";
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_53C1030) {
 		ioc->chip_type = C1030;
 		ioc->prod_name = "LSI53C1030";
+		{
+			/* 1030 Chip Fix. Disable Split transactions
+			 * for PCIX. Set bits 4 - 6 to zero.
+			 */
+			u16 pcixcmd = 0;
+			pci_read_config_word(pdev, 0x6a, &pcixcmd);
+			pcixcmd &= 0xFF8F;
+			pci_write_config_word(pdev, 0x6a, pcixcmd);
+		}
 	}
-#endif
 
-	myname = "iocN";
-	len = strlen(myname);
-	memcpy(ioc->name, myname, len+1);
-	ioc->name[len-1] = '0' + ioc->id;
+	sprintf(ioc->name, "ioc%d", ioc->id);
 
 	Q_INIT(&ioc->FreeQ, MPT_FRAME_HDR);
 	spin_lock_init(&ioc->FreeQlock);
@@ -1145,8 +1448,13 @@
 		r = request_irq(pdev->irq, mpt_interrupt, SA_SHIRQ, ioc->name, ioc);
 
 		if (r < 0) {
-			printk(KERN_ERR MYNAM ": %s: ERROR - Unable to allocate interrupt %d!\n",
+#ifndef __sparc__
+			printk(MYIOC_s_ERR_FMT "Unable to allocate interrupt %d!\n",
 					ioc->name, pdev->irq);
+#else
+			printk(MYIOC_s_ERR_FMT "Unable to allocate interrupt %s!\n",
+					ioc->name, __irq_itoa(pdev->irq));
+#endif
 			iounmap(mem);
 			kfree(ioc);
 			return -EBUSY;
@@ -1156,7 +1464,11 @@
 
 		pci_set_master(pdev);			/* ?? */
 
+#ifndef __sparc__
 		dprintk((KERN_INFO MYNAM ": %s installed at interrupt %d\n", ioc->name, pdev->irq));
+#else
+		dprintk((KERN_INFO MYNAM ": %s installed at interrupt %s\n", ioc->name, __irq_itoa(pdev->irq)));
+#endif
 	}
 
 	/* tack onto tail of our MPT adapter list */
@@ -1166,12 +1478,12 @@
 	mpt_adapters[ioc->id] = ioc;
 
 	/* NEW!  20010220 -sralston
-	 * Check for "929 bound ports" to reduce redundant resets.
+	 * Check for "bound ports" (929, 929X, 1030) to reduce redundant resets.
 	 */
-	if (ioc->chip_type == FC929)
-		mpt_detect_929_bound_ports(ioc, pdev);
+	if ((ioc->chip_type == FC929) || (ioc->chip_type == C1030) || (ioc->chip_type == FC929X))
+		mpt_detect_bound_ports(ioc, pdev);
 
-	if ((r = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP)) != 0) {
+	if ((r = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP, CAN_SLEEP)) != 0) {
 		printk(KERN_WARNING MYNAM ": WARNING - %s did not initialize properly! (%d)\n",
 				ioc->name, r);
 	}
@@ -1180,10 +1492,11 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	mpt_do_ioc_recovery - Initialize or recover MPT adapter.
  *	@ioc: Pointer to MPT adapter structure
  *	@reason: Event word / reason
+ *	@sleepFlag: Use schedule if CAN_SLEEP else use udelay.
  *
  *	This routine performs all the steps necessary to bring the IOC
  *	to a OPERATIONAL state.
@@ -1191,16 +1504,21 @@
  *	This routine also pre-fetches the LAN MAC address of a Fibre Channel
  *	MPT adapter.
  *
- *	Returns 0 for success.
+ *	Returns:
+ *		 0 for success
+ *		-1 if failed to get board READY
+ *		-2 if READY but IOCFacts Failed
+ *		-3 if READY but PrimeIOCFifos Failed
+ *		-4 if READY but IOCInit Failed
  */
 static int
-mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason)
+mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag)
 {
 	int	 hard_reset_done = 0;
 	int	 alt_ioc_ready = 0;
 	int	 hard;
 	int	 r;
-	int	 i;
+	int	 ii;
 	int	 handlers;
 
 	printk(KERN_INFO MYNAM ": Initiating %s %s\n",
@@ -1211,156 +1529,106 @@
 	ioc->active = 0;
 	/* NOTE: Access to IOC's request FreeQ is now blocked! */
 
-// FIXME? Cleanup all IOC requests here! (or below?)
-// But watch out for event associated request?
+	if (ioc->alt_ioc) {
+		/* Disable alt-IOC's reply interrupts for a bit ... */
+		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, 0xFFFFFFFF);
+		ioc->alt_ioc->active = 0;
+		/* NOTE: Access to alt-IOC's request FreeQ is now blocked! */
+	}
 
-	hard = HardReset;
-	if (ioc->alt_ioc && (reason == MPT_HOSTEVENT_IOC_BRINGUP))
+	hard = 1;
+	if (reason == MPT_HOSTEVENT_IOC_BRINGUP)
 		hard = 0;
 
-	if ((hard_reset_done = MakeIocReady(ioc, hard)) < 0) {
+	if ((hard_reset_done = MakeIocReady(ioc, hard, sleepFlag)) < 0) {
 		printk(KERN_WARNING MYNAM ": %s NOT READY WARNING!\n",
 				ioc->name);
 		return -1;
 	}
 
-// NEW!
-#if 0						// Kiss-of-death!?!
-	if (ioc->alt_ioc) {
-// Grrr... Hold off any alt-IOC interrupts (and events) while
-// handshaking to <this> IOC, needed because?
-		/* Disable alt-IOC's reply interrupts for a bit ... */
-		alt_ioc_intmask = CHIPREG_READ32(&ioc->alt_ioc->chip->IntMask);
-		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, 0xFFFFFFFF);
-		ioc->alt_ioc->active = 0;
-		/* NOTE: Access to alt-IOC's request FreeQ is now blocked! */
-	}
-#endif
-
+	/* hard_reset_done = 0 if a soft reset was performed
+	 * and 1 if a hard reset was performed.
+	 */
 	if (hard_reset_done && ioc->alt_ioc) {
-		if ((r = MakeIocReady(ioc->alt_ioc, 0)) == 0)
+		if ((r = MakeIocReady(ioc->alt_ioc, 0, sleepFlag)) == 0)
 			alt_ioc_ready = 1;
 		else
-			printk(KERN_WARNING MYNAM ": alt-%s: (%d) Not ready WARNING!\n",
+			printk(KERN_WARNING MYNAM
+					": alt-%s: (%d) Not ready WARNING!\n",
 					ioc->alt_ioc->name, r);
 	}
 
+	/* Get IOC facts! */
+	if ((r = GetIocFacts(ioc, sleepFlag, reason)) != 0)
+		return -2;
 	if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
-		/* Get IOC facts! */
-		if ((r = GetIocFacts(ioc)) != 0)
-			return -2;
 		MptDisplayIocCapabilities(ioc);
 	}
 
-	/*
-	 * Call each currently registered protocol IOC reset handler
-	 * with pre-reset indication.
-	 * NOTE: If we're doing _IOC_BRINGUP, there can be no
-	 * MptResetHandlers[] registered yet.
-	 */
-	if (hard_reset_done) {
-		r = handlers = 0;
-		for (i=MPT_MAX_PROTOCOL_DRIVERS-1; i; i--) {
-			if (MptResetHandlers[i]) {
-				dprintk((KERN_INFO MYNAM ": %s: Calling IOC pre_reset handler #%d\n",
-						ioc->name, i));
-				r += (*(MptResetHandlers[i]))(ioc, MPT_IOC_PRE_RESET);
-				handlers++;
-
-				if (alt_ioc_ready) {
-					dprintk((KERN_INFO MYNAM ": %s: Calling alt-IOC pre_reset handler #%d\n",
-							ioc->alt_ioc->name, i));
-					r += (*(MptResetHandlers[i]))(ioc->alt_ioc, MPT_IOC_PRE_RESET);
-					handlers++;
-				}
-			}
-		}
-		/* FIXME?  Examine results here? */
-	}
-
-	// May need to check/upload firmware & data here!
-
-	if ((r = SendIocInit(ioc)) != 0)
-		return -3;
-// NEW!
 	if (alt_ioc_ready) {
-		if ((r = SendIocInit(ioc->alt_ioc)) != 0) {
-			alt_ioc_ready = 0;
-			printk(KERN_WARNING MYNAM ": alt-%s: (%d) init failure WARNING!\n",
-					ioc->alt_ioc->name, r);
-		}
-	}
-
-	/*
-	 * Call each currently registered protocol IOC reset handler
-	 * with post-reset indication.
-	 * NOTE: If we're doing _IOC_BRINGUP, there can be no
-	 * MptResetHandlers[] registered yet.
-	 */
-	if (hard_reset_done) {
-		r = handlers = 0;
-		for (i=MPT_MAX_PROTOCOL_DRIVERS-1; i; i--) {
-			if (MptResetHandlers[i]) {
-				dprintk((KERN_INFO MYNAM ": %s: Calling IOC post_reset handler #%d\n",
-						ioc->name, i));
-				r += (*(MptResetHandlers[i]))(ioc, MPT_IOC_POST_RESET);
-				handlers++;
-
-				if (alt_ioc_ready) {
-					dprintk((KERN_INFO MYNAM ": %s: Calling alt-IOC post_reset handler #%d\n",
-							ioc->alt_ioc->name, i));
-					r += (*(MptResetHandlers[i]))(ioc->alt_ioc, MPT_IOC_POST_RESET);
-					handlers++;
-				}
-			}
+		if ((r = GetIocFacts(ioc->alt_ioc, sleepFlag, reason)) != 0)
+			return -2;
+		if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+			MptDisplayIocCapabilities(ioc->alt_ioc);
 		}
-		/* FIXME?  Examine results here? */
 	}
 
 	/*
 	 * Prime reply & request queues!
-	 * (mucho alloc's)
+	 * (mucho alloc's) Must be done prior to
+	 * init as upper addresses are needed for init.
 	 */
 	if ((r = PrimeIocFifos(ioc)) != 0)
+		return -3;
+
+	// May need to check/upload firmware & data here!
+	if ((r = SendIocInit(ioc, sleepFlag)) != 0)
 		return -4;
 // NEW!
 	if (alt_ioc_ready && ((r = PrimeIocFifos(ioc->alt_ioc)) != 0)) {
 		printk(KERN_WARNING MYNAM ": alt-%s: (%d) FIFO mgmt alloc WARNING!\n",
 				ioc->alt_ioc->name, r);
+		alt_ioc_ready = 0;
 	}
 
-// FIXME! Cleanup all IOC (and alt-IOC?) requests here!
+	if (alt_ioc_ready) {
+		if ((r = SendIocInit(ioc->alt_ioc, sleepFlag)) != 0) {
+			alt_ioc_ready = 0;
+			printk(KERN_WARNING MYNAM
+				": alt-%s: (%d) init failure WARNING!\n",
+					ioc->alt_ioc->name, r);
+		}
+	}
 
-	if ((ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) &&
-	    (ioc->lan_cnfg_page0.Header.PageLength == 0)) {
-		/*
-		 *  Pre-fetch the ports LAN MAC address!
-		 *  (LANPage1_t stuff)
-		 */
-		(void) GetLanConfigPages(ioc);
-#ifdef MPT_DEBUG
-		{
-			u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
-			dprintk((KERN_INFO MYNAM ": %s: LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
-					ioc->name, a[5], a[4], a[3], a[2], a[1], a[0] ));
+	if (reason == MPT_HOSTEVENT_IOC_BRINGUP){
+		if (ioc->upload_fw) {
+			dprintk((MYIOC_s_INFO_FMT
+				"firmware upload required!\n", ioc->name));
+
+			r = mpt_do_upload(ioc, sleepFlag);
+			if (r != 0)
+				printk(KERN_WARNING MYNAM ": firmware upload failure!\n");
+			/* Handle the alt IOC too */
+			if ((alt_ioc_ready) && (ioc->alt_ioc->upload_fw)){
+				r = mpt_do_upload(ioc->alt_ioc, sleepFlag);
+				if (r != 0)
+					printk(KERN_WARNING MYNAM ": firmware upload failure!\n");
+			}
 		}
-#endif
 	}
 
+
 	/* Enable! (reply interrupt) */
 	CHIPREG_WRITE32(&ioc->chip->IntMask, ~(MPI_HIM_RIM));
 	ioc->active = 1;
 
-// NEW!
-#if 0						// Kiss-of-death!?!
-	if (alt_ioc_ready && (r==0)) {
+	if (ioc->alt_ioc) {
 		/* (re)Enable alt-IOC! (reply interrupt) */
 		dprintk((KERN_INFO MYNAM ": alt-%s reply irq re-enabled\n",
 				ioc->alt_ioc->name));
 		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, ~(MPI_HIM_RIM));
 		ioc->alt_ioc->active = 1;
 	}
-#endif
 
 	/* NEW!  20010120 -sralston
 	 *  Enable MPT base driver management of EventNotification
@@ -1368,19 +1636,95 @@
 	 */
 	if (!ioc->facts.EventState)
 		(void) SendEventNotification(ioc, 1);	/* 1=Enable EventNotification */
-// NEW!
-// FIXME!?!
-//	if (ioc->alt_ioc && alt_ioc_ready && !ioc->alt_ioc->facts.EventState) {
-//		(void) SendEventNotification(ioc->alt_ioc, 1);	/* 1=Enable EventNotification */
-//	}
+
+	if (ioc->alt_ioc && alt_ioc_ready && !ioc->alt_ioc->facts.EventState)
+		(void) SendEventNotification(ioc->alt_ioc, 1);	/* 1=Enable EventNotification */
+
+	/* (Bugzilla:fibrebugs, #513)
+	 * Bug fix (part 2)!  20010905 -sralston
+	 *	Add additional "reason" check before call to GetLanConfigPages
+	 *	(combined with GetIoUnitPage2 call).  This prevents a somewhat
+	 *	recursive scenario; GetLanConfigPages times out, timer expired
+	 *	routine calls HardResetHandler, which calls into here again,
+	 *	and we try GetLanConfigPages again...
+	 */
+	if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+		if ((int)ioc->chip_type <= (int)FC929) {
+			/*
+			 *  Pre-fetch FC port WWN and stuff...
+			 *  (FCPortPage0_t stuff)
+			 */
+			for (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {
+				(void) GetFcPortPage0(ioc, ii);
+			}
+
+			if ((ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) &&
+			    (ioc->lan_cnfg_page0.Header.PageLength == 0)) {
+				/*
+				 *  Pre-fetch the ports LAN MAC address!
+				 *  (LANPage1_t stuff)
+				 */
+				(void) GetLanConfigPages(ioc);
+#ifdef MPT_DEBUG
+				{
+					u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
+					dprintk((MYIOC_s_INFO_FMT "LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
+							ioc->name, a[5], a[4], a[3], a[2], a[1], a[0] ));
+				}
+#endif
+			}
+		} else {
+			/* Get NVRAM and adapter maximums from SPP 0 and 2
+			 */
+			mpt_GetScsiPortSettings(ioc, 0);
+
+			/* Get version and length of SDP 1 
+			 */
+			mpt_readScsiDevicePageHeaders(ioc, 0);
+
+			/* Find IM volumes 
+			 */
+			if (ioc->facts.MsgVersion >= 0x0102)
+				mpt_findImVolumes(ioc);
+		}
+
+		GetIoUnitPage2(ioc);
+	}
+
+	/*
+	 * Call each currently registered protocol IOC reset handler
+	 * with post-reset indication.
+	 * NOTE: If we're doing _IOC_BRINGUP, there can be no
+	 * MptResetHandlers[] registered yet.
+	 */
+	if (hard_reset_done) {
+		r = handlers = 0;
+		for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+			if (MptResetHandlers[ii]) {
+				dprintk((MYIOC_s_INFO_FMT "Calling IOC post_reset handler #%d\n",
+						ioc->name, ii));
+				r += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_POST_RESET);
+				handlers++;
+
+				if (alt_ioc_ready) {
+					dprintk((MYIOC_s_INFO_FMT "Calling alt-%s post_reset handler #%d\n",
+							ioc->name, ioc->alt_ioc->name, ii));
+					r += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_POST_RESET);
+					handlers++;
+				}
+			}
+		}
+		/* FIXME?  Examine results here? */
+	}
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	mpt_detect_929_bound_ports - Search for PCI bus/dev_function
- *	which matches PCI bus/dev_function (+/-1) for newly discovered 929.
+ *	mpt_detect_bound_ports - Search for PCI bus/dev_function
+ *	which matches PCI bus/dev_function (+/-1) for newly discovered 929,
+ *	929X or 1030.
  *	@ioc: Pointer to MPT adapter structure
  *	@pdev: Pointer to (struct pci_dev) structure
  *
@@ -1388,22 +1732,22 @@
  *	using alt_ioc pointer fields in their %MPT_ADAPTER structures.
  */
 static void
-mpt_detect_929_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev)
+mpt_detect_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev)
 {
 	MPT_ADAPTER *ioc_srch = mpt_adapter_find_first();
 	unsigned int match_lo, match_hi;
 
 	match_lo = pdev->devfn-1;
 	match_hi = pdev->devfn+1;
-	dprintk((KERN_INFO MYNAM ": %s: PCI bus/devfn=%x/%x, searching for devfn match on %x or %x\n",
+	dprintk((MYIOC_s_INFO_FMT "PCI bus/devfn=%x/%x, searching for devfn match on %x or %x\n",
 			ioc->name, pdev->bus->number, pdev->devfn, match_lo, match_hi));
 
 	while (ioc_srch != NULL) {
 		struct pci_dev *_pcidev = ioc_srch->pcidev;
 
-		if ( (_pcidev->device == MPI_MANUFACTPAGE_DEVICEID_FC929) &&
-		     (_pcidev->bus->number == pdev->bus->number) &&
-		     (_pcidev->devfn == match_lo || _pcidev->devfn == match_hi) ) {
+		if ((_pcidev->device == pdev->device) &&
+		    (_pcidev->bus->number == pdev->bus->number) &&
+		    (_pcidev->devfn == match_lo || _pcidev->devfn == match_hi) ) {
 			/* Paranoia checks */
 			if (ioc->alt_ioc != NULL) {
 				printk(KERN_WARNING MYNAM ": Oops, already bound (%s <==> %s)!\n",
@@ -1418,8 +1762,6 @@
 					ioc->name, ioc_srch->name));
 			ioc_srch->alt_ioc = ioc;
 			ioc->alt_ioc = ioc_srch;
-			ioc->sod_reset = ioc->alt_ioc->sod_reset;
-			ioc->last_kickstart = ioc->alt_ioc->last_kickstart;
 			break;
 		}
 		ioc_srch = mpt_adapter_find_next(ioc_srch);
@@ -1440,10 +1782,10 @@
 		u32 state;
 
 		/* Disable the FW */
-		state = GetIocState(this, 1);
+		state = mpt_GetIocState(this, 1);
 		if (state == MPI_IOC_STATE_OPERATIONAL) {
-			if (SendIocReset(this, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET) != 0)
-				(void) KickStart(this, 1);
+			if (SendIocReset(this, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, NO_SLEEP) != 0)
+				(void) KickStart(this, 1, NO_SLEEP);
 		}
 
 		/* Disable adapter interrupts! */
@@ -1475,12 +1817,52 @@
 		}
 
 		if (freeup && this->sense_buf_pool != NULL) {
-			sz = (this->req_depth * 256);
+			sz = (this->req_depth * MPT_SENSE_BUFFER_ALLOC);
 			pci_free_consistent(this->pcidev, sz,
 					this->sense_buf_pool, this->sense_buf_pool_dma);
 			this->sense_buf_pool = NULL;
 			this->alloc_total -= sz;
 		}
+
+		if (freeup && this->events != NULL){
+			sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
+			kfree(this->events);
+			this->events = NULL;
+			this->alloc_total -= sz;
+		}
+
+		if (freeup && this->cached_fw != NULL) {
+			int ii = 0;
+
+			while ((ii < this->num_fw_frags) && (this->cached_fw[ii]!= NULL)) {
+				sz = this->cached_fw[ii]->size;
+				pci_free_consistent(this->pcidev, sz,
+					this->cached_fw[ii]->fw, this->cached_fw[ii]->fw_dma);
+				this->cached_fw[ii]->fw = NULL;
+				this->alloc_total -= sz;
+
+				kfree(this->cached_fw[ii]);
+				this->cached_fw[ii] = NULL;
+				this->alloc_total -= sizeof(fw_image_t);
+
+				ii++;
+			}
+
+			kfree(this->cached_fw);
+			this->cached_fw = NULL;
+			sz = this->num_fw_frags * sizeof(void *);
+			this->alloc_total -= sz;
+		}
+
+		if (freeup && this->spi_data.nvram != NULL) {
+			kfree(this->spi_data.nvram);
+			this->spi_data.nvram = NULL;
+		}
+
+		if (freeup && this->spi_data.pIocPg3 != NULL) {
+			kfree(this->spi_data.pIocPg3);
+			this->spi_data.pIocPg3 = NULL;
+		}
 	}
 }
 
@@ -1575,23 +1957,30 @@
 /*
  *	MakeIocReady - Get IOC to a READY state, using KickStart if needed.
  *	@ioc: Pointer to MPT_ADAPTER structure
- *	@kick: Force hard KickStart of IOC
+ *	@force: Force hard KickStart of IOC
+ *	@sleepFlag: Specifies whether the process can sleep
  *
- *	Returns 0 for already-READY, 1 for hard reset success,
- *	else negative for failure.
+ *	Returns:
+ *		 1 - DIAG reset and READY
+ *		 0 - READY initially OR soft reset and READY 
+ *		-1 - Any failure on KickStart 
+ *		-2 - Msg Unit Reset Failed
+ *		-3 - IO Unit Reset Failed
+ *		-4 - IOC owned by a PEER
  */
 static int
-MakeIocReady(MPT_ADAPTER *ioc, int force)
+MakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag)
 {
 	u32	 ioc_state;
 	int	 statefault = 0;
-	int 	 cntdn;
+	int	 cntdn;
 	int	 hard_reset_done = 0;
 	int	 r;
-	int	 i;
+	int	 ii;
+	int	 whoinit;
 
 	/* Get current [raw] IOC state  */
-	ioc_state = GetIocState(ioc, 0);
+	ioc_state = mpt_GetIocState(ioc, 0);
 	dhsprintk((KERN_INFO MYNAM "::MakeIocReady, %s [raw] state=%08x\n", ioc->name, ioc_state));
 
 	/*
@@ -1600,7 +1989,7 @@
 	 */
 	if (ioc_state & MPI_DOORBELL_ACTIVE) {
 		statefault = 1;
-		printk(KERN_WARNING MYNAM ": %s: Uh-oh, unexpected doorbell active!\n",
+		printk(MYIOC_s_WARN_FMT "Unexpected doorbell active!\n",
 				ioc->name);
 	}
 
@@ -1613,7 +2002,7 @@
 	 */
 	if ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT) {
 		statefault = 2;
-		printk(KERN_WARNING MYNAM ": %s: Uh-oh, IOC is in FAULT state!!!\n",
+		printk(MYIOC_s_WARN_FMT "IOC is in FAULT state!!!\n",
 				ioc->name);
 		printk(KERN_WARNING "           FAULT code = %04xh\n",
 				ioc_state & MPI_DOORBELL_DATA_MASK);
@@ -1623,28 +2012,49 @@
 	 *	Hmmm...  Did it get left operational?
 	 */
 	if ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_OPERATIONAL) {
-		statefault = 3;
-		dprintk((KERN_WARNING MYNAM ": %s: Hmmm... IOC operational unexpected\n",
+		dprintk((MYIOC_s_WARN_FMT "IOC operational unexpected\n",
 				ioc->name));
+
+		/* Check WhoInit.
+		 * If PCI Peer, exit.
+		 * Else, if no fault conditions are present, issue a MessageUnitReset
+		 * Else, fall through to KickStart case
+		 */
+		whoinit = (ioc_state & MPI_DOORBELL_WHO_INIT_MASK) >> MPI_DOORBELL_WHO_INIT_SHIFT;
+		dprintk((KERN_WARNING MYNAM
+			": whoinit 0x%x\n statefault %d force %d\n",
+			whoinit, statefault, force));
+		if (whoinit == MPI_WHOINIT_PCI_PEER)
+			return -4;
+		else {
+			if ((statefault == 0 ) && (force == 0)) {
+				if ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) == 0)
+					return 0;
+			}
+			statefault = 3;
+		}
 	}
 
-	hard_reset_done = KickStart(ioc, statefault||force);
+	hard_reset_done = KickStart(ioc, statefault||force, sleepFlag);
 	if (hard_reset_done < 0)
 		return -1;
 
 	/*
 	 *  Loop here waiting for IOC to come READY.
 	 */
-	i = 0;
+	ii = 0;
 	cntdn = HZ * 15;
-	while ((ioc_state = GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
+	if (sleepFlag != CAN_SLEEP)
+		cntdn *= 10;	/* 1500 iterations @ 1msec per */
+
+	while ((ioc_state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
 		if (ioc_state == MPI_IOC_STATE_OPERATIONAL) {
 			/*
 			 *  BIOS or previous driver load left IOC in OP state.
 			 *  Reset messaging FIFOs.
 			 */
-			if ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET)) != 0) {
-				printk(KERN_ERR MYNAM ": %s: ERROR - IOC msg unit reset failed!\n", ioc->name);
+			if ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) != 0) {
+				printk(MYIOC_s_ERR_FMT "IOC msg unit reset failed!\n", ioc->name);
 				return -2;
 			}
 		} else if (ioc_state == MPI_IOC_STATE_RESET) {
@@ -1652,25 +2062,30 @@
 			 *  Something is wrong.  Try to get IOC back
 			 *  to a known state.
 			 */
-			if ((r = SendIocReset(ioc, MPI_FUNCTION_IO_UNIT_RESET)) != 0) {
-				printk(KERN_ERR MYNAM ": %s: ERROR - IO unit reset failed!\n", ioc->name);
+			if ((r = SendIocReset(ioc, MPI_FUNCTION_IO_UNIT_RESET, sleepFlag)) != 0) {
+				printk(MYIOC_s_ERR_FMT "IO unit reset failed!\n", ioc->name);
 				return -3;
 			}
 		}
 
-		i++; cntdn--;
+		ii++; cntdn--;
 		if (!cntdn) {
-			printk(KERN_ERR MYNAM ": %s: ERROR - Wait IOC_READY state timeout(%d)!\n",
-					ioc->name, (i+5)/HZ);
+			printk(MYIOC_s_ERR_FMT "Wait IOC_READY state timeout(%d)!\n",
+					ioc->name, (ii+5)/HZ);
 			return -ETIME;
 		}
 
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		} else {
+			mdelay (1);	/* 1 msec delay */
+		}
+
 	}
 
 	if (statefault < 3) {
-		printk(KERN_WARNING MYNAM ": %s: Whew!  Recovered from %s\n",
+		printk(MYIOC_s_INFO_FMT "Recovered from %s\n",
 				ioc->name,
 				statefault==1 ? "stuck handshake" : "IOC FAULT");
 	}
@@ -1680,21 +2095,21 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	GetIocState - Get the current state of a MPT adapter.
+ *	mpt_GetIocState - Get the current state of a MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@cooked: Request raw or cooked IOC state
  *
  *	Returns all IOC Doorbell register bits if cooked==0, else just the
  *	Doorbell bits in MPI_IOC_STATE_MASK.
  */
-static u32
-GetIocState(MPT_ADAPTER *ioc, int cooked)
+u32
+mpt_GetIocState(MPT_ADAPTER *ioc, int cooked)
 {
 	u32 s, sc;
 
 	/*  Get!  */
 	s = CHIPREG_READ32(&ioc->chip->Doorbell);
-	dprintk((KERN_INFO MYNAM ": %s: raw state = %08x\n", ioc->name, s));
+//	dprintk((MYIOC_s_INFO_FMT "raw state = %08x\n", ioc->name, s));
 	sc = s & MPI_IOC_STATE_MASK;
 
 	/*  Save!  */
@@ -1707,11 +2122,13 @@
 /*
  *	GetIocFacts - Send IOCFacts request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@sleepFlag: Specifies whether the process can sleep
+ *	@reason: If recovery, only update facts.
  *
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-GetIocFacts(MPT_ADAPTER *ioc)
+GetIocFacts(MPT_ADAPTER *ioc, int sleepFlag, int reason)
 {
 	IOCFacts_t		 get_facts;
 	IOCFactsReply_t		*facts;
@@ -1741,14 +2158,13 @@
 	get_facts.Function = MPI_FUNCTION_IOC_FACTS;
 	/* Assert: All other get_facts fields are zero! */
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending get IocFacts request\n", ioc->name));
+	dprintk((MYIOC_s_INFO_FMT "Sending get IocFacts request\n", ioc->name));
 
 	/* No non-zero fields in the get_facts request are greater than
 	 * 1 byte in size, so we can just fire it off as is.
 	 */
-	r = HandShakeReqAndReply(ioc,
-			req_sz, (u32*)&get_facts,
-			reply_sz, (u16*)facts, 3);
+	r = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_facts,
+			reply_sz, (u16*)facts, 3 /*seconds*/, sleepFlag);
 	if (r != 0)
 		return r;
 
@@ -1761,14 +2177,17 @@
 	 */
 	/* Did we get a valid reply? */
 	if (facts->MsgLength > offsetof(IOCFactsReply_t, RequestFrameSize)/sizeof(u32)) {
-		/*
-		 * If not been here, done that, save off first WhoInit value
-		 */
-		if (ioc->FirstWhoInit == WHOINIT_UNKNOWN)
-			ioc->FirstWhoInit = facts->WhoInit;
+		if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+			/*
+			 * If not been here, done that, save off first WhoInit value
+			 */
+			if (ioc->FirstWhoInit == WHOINIT_UNKNOWN)
+				ioc->FirstWhoInit = facts->WhoInit;
+		}
 
 		facts->MsgVersion = le16_to_cpu(facts->MsgVersion);
 		facts->MsgContext = le32_to_cpu(facts->MsgContext);
+		facts->IOCExceptions = le16_to_cpu(facts->IOCExceptions);
 		facts->IOCStatus = le16_to_cpu(facts->IOCStatus);
 		facts->IOCLogInfo = le32_to_cpu(facts->IOCLogInfo);
 		status = facts->IOCStatus & MPI_IOCSTATUS_MASK;
@@ -1776,7 +2195,23 @@
 
 		facts->ReplyQueueDepth = le16_to_cpu(facts->ReplyQueueDepth);
 		facts->RequestFrameSize = le16_to_cpu(facts->RequestFrameSize);
-		facts->FWVersion = le16_to_cpu(facts->FWVersion);
+
+		/*
+		 * FC f/w version changed between 1.1 and 1.2 
+		 *	Old: u16{Major(4),Minor(4),SubMinor(8)}
+		 *	New: u32{Major(8),Minor(8),Unit(8),Dev(8)}
+		 */
+		if (facts->MsgVersion < 0x0102) {
+			/*
+			 *	Handle old FC f/w style, convert to new...
+			 */
+			u16	 oldv = le16_to_cpu(facts->Reserved_0101_FWVersion);
+			facts->FWVersion.Word =
+					((oldv<<12) & 0xFF000000) |
+					((oldv<<8)  & 0x000FFF00);
+		} else
+			facts->FWVersion.Word = le32_to_cpu(facts->FWVersion.Word);
+
 		facts->ProductID = le16_to_cpu(facts->ProductID);
 		facts->CurrentHostMfaHighAddr =
 				le32_to_cpu(facts->CurrentHostMfaHighAddr);
@@ -1791,52 +2226,42 @@
 		 * Older MPI-1.00.xx struct had 13 dwords, and enlarged
 		 * to 14 in MPI-1.01.0x.
 		 */
-		if (facts->MsgLength >= sizeof(IOCFactsReply_t)/sizeof(u32) && facts->MsgVersion > 0x0100) {
+		if (facts->MsgLength >= (offsetof(IOCFactsReply_t,FWImageSize) + 7)/4 &&
+		    facts->MsgVersion > 0x0100) {
 			facts->FWImageSize = le32_to_cpu(facts->FWImageSize);
-			facts->DataImageSize = le32_to_cpu(facts->DataImageSize);
 		}
 
-		if (facts->RequestFrameSize) {
-			/*
-			 * Set values for this IOC's REQUEST queue size & depth...
-			 */
-			ioc->req_sz = MIN(MPT_REQ_SIZE, facts->RequestFrameSize * 4);
-
-			/*
-			 *  Set values for this IOC's REPLY queue size & depth...
-			 *
-			 * BUG? FIX?  20000516 -nromer & sralston 
-			 *  GRRR...  The following did not translate well from MPI v0.09:
-			 *	ioc->reply_sz = MIN(MPT_REPLY_SIZE, facts->ReplySize * 4);
-			 *  to 0.10:
-			 *	ioc->reply_sz = MIN(MPT_REPLY_SIZE, facts->BlockSize * 4);
-			 *  Was trying to minimally optimize to smallest possible reply size
-			 *  (and greatly reduce kmalloc size).  But LAN may need larger reply?
-			 *
-			 *  So for now, just set reply size to request size.  FIXME?
-			 */
-			ioc->reply_sz = ioc->req_sz;
-		} else {
+		if (!facts->RequestFrameSize) {
 			/*  Something is wrong!  */
-			printk(KERN_ERR MYNAM ": %s: ERROR - IOC reported invalid 0 request size!\n",
+			printk(MYIOC_s_ERR_FMT "IOC reported invalid 0 request size!\n",
 					ioc->name);
-			ioc->req_sz = MPT_REQ_SIZE;
-			ioc->reply_sz = MPT_REPLY_SIZE;
 			return -55;
 		}
-		ioc->req_depth = MIN(MPT_REQ_DEPTH, facts->GlobalCredits);
-		ioc->reply_depth = MIN(MPT_REPLY_DEPTH, facts->ReplyQueueDepth);
 
-		dprintk((KERN_INFO MYNAM ": %s: reply_sz=%3d, reply_depth=%4d\n",
+		if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+			/*
+			 * Set values for this IOC's request & reply frame sizes,
+			 * and request & reply queue depths...
+			 */
+			ioc->req_sz = MIN(MPT_DEFAULT_FRAME_SIZE, facts->RequestFrameSize * 4);
+			ioc->req_depth = MIN(MPT_MAX_REQ_DEPTH, facts->GlobalCredits);
+			ioc->reply_sz = ioc->req_sz;
+			ioc->reply_depth = MIN(MPT_DEFAULT_REPLY_DEPTH, facts->ReplyQueueDepth);
+
+			/* 1030 - should we use a smaller DEFAULT_REPLY_DEPTH?
+			 * FIX
+			 */
+			dprintk((MYIOC_s_INFO_FMT "reply_sz=%3d, reply_depth=%4d\n",
 				ioc->name, ioc->reply_sz, ioc->reply_depth));
-		dprintk((KERN_INFO MYNAM ": %s: req_sz  =%3d, req_depth  =%4d\n",
+			dprintk((MYIOC_s_INFO_FMT "req_sz  =%3d, req_depth  =%4d\n",
 				ioc->name, ioc->req_sz, ioc->req_depth));
 
-		/* Get port facts! */
-		if ( (r = GetPortFacts(ioc, 0)) != 0 )
-			return r;
+			/* Get port facts! */
+			if ( (r = GetPortFacts(ioc, 0, sleepFlag)) != 0 )
+				return r;
+		}
 	} else {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Invalid IOC facts reply!\n",
+		printk(MYIOC_s_ERR_FMT "Invalid IOC facts reply!\n",
 				ioc->name);
 		return -66;
 	}
@@ -1849,15 +2274,16 @@
  *	GetPortFacts - Send PortFacts request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@portnum: Port number
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-GetPortFacts(MPT_ADAPTER *ioc, int portnum)
+GetPortFacts(MPT_ADAPTER *ioc, int portnum, int sleepFlag)
 {
 	PortFacts_t		 get_pfacts;
 	PortFactsReply_t	*pfacts;
-	int			 i;
+	int			 ii;
 	int			 req_sz;
 	int			 reply_sz;
 
@@ -1883,16 +2309,16 @@
 	get_pfacts.PortNumber = portnum;
 	/* Assert: All other get_pfacts fields are zero! */
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending get PortFacts(%d) request\n",
+	dprintk((MYIOC_s_INFO_FMT "Sending get PortFacts(%d) request\n",
 			ioc->name, portnum));
 
 	/* No non-zero fields in the get_pfacts request are greater than
 	 * 1 byte in size, so we can just fire it off as is.
 	 */
-	i = HandShakeReqAndReply(ioc, req_sz, (u32*)&get_pfacts,
-				reply_sz, (u16*)pfacts, 3);
-	if (i != 0)
-		return i;
+	ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_pfacts,
+				reply_sz, (u16*)pfacts, 3 /*seconds*/, sleepFlag);
+	if (ii != 0)
+		return ii;
 
 	/* Did we get a valid reply? */
 
@@ -1914,13 +2340,14 @@
 /*
  *	SendIocInit - Send IOCInit request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	Send IOCInit followed by PortEnable to bring IOC to OPERATIONAL state.
  *
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-SendIocInit(MPT_ADAPTER *ioc)
+SendIocInit(MPT_ADAPTER *ioc, int sleepFlag)
 {
 	IOCInit_t		 ioc_init;
 	MPIDefaultReply_t	 init_reply;
@@ -1937,20 +2364,47 @@
 	ioc_init.Function = MPI_FUNCTION_IOC_INIT;
 /*	ioc_init.Flags = 0;				*/
 
-	/*ioc_init.MaxDevices = 16;*/
-	ioc_init.MaxDevices = 255;
-/*	ioc_init.MaxBuses = 16;				*/
-	ioc_init.MaxBuses = 1;
+	/* If we are in a recovery mode and we uploaded the FW image,
+	 * then this pointer is not NULL. Skip the upload a second time.
+	 * Set this flag if cached_fw set for either IOC.
+	 */
+	ioc->upload_fw = 0;
+	ioc_init.Flags = 0;
+	if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT) {
+		if ((ioc->cached_fw) || (ioc->alt_ioc && ioc->alt_ioc->cached_fw))
+			ioc_init.Flags = MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE;
+		else 
+			ioc->upload_fw = 1;
+	}
+
+	if ((int)ioc->chip_type <= (int)FC929) {
+		ioc_init.MaxDevices = MPT_MAX_FC_DEVICES;
+	} else {
+		ioc_init.MaxDevices = MPT_MAX_SCSI_DEVICES;
+	}
+	ioc_init.MaxBuses = MPT_MAX_BUS;
 
 /*	ioc_init.MsgFlags = 0;				*/
 /*	ioc_init.MsgContext = cpu_to_le32(0x00000000);	*/
 	ioc_init.ReplyFrameSize = cpu_to_le16(ioc->reply_sz);	/* in BYTES */
-	ioc_init.HostMfaHighAddr = cpu_to_le32(0);	/* Say we 32-bit! for now */
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending IOCInit (req @ %p)\n", ioc->name, &ioc_init));
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+		/* Save the upper 32-bits of the request
+		 * (reply) and sense buffers.
+		 */
+		ioc_init.HostMfaHighAddr = cpu_to_le32((u32)((u64)ioc->req_frames_dma >> 32));
+		ioc_init.SenseBufferHighAddr = cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));
+	} else {
+		/* Force 32-bit addressing */
+		ioc_init.HostMfaHighAddr = cpu_to_le32(0);
+		ioc_init.SenseBufferHighAddr = cpu_to_le32(0);
+	}
 
-	r = HandShakeReqAndReply(ioc, sizeof(IOCInit_t), (u32*)&ioc_init,
-			sizeof(MPIDefaultReply_t), (u16*)&init_reply, 10);
+	dprintk((MYIOC_s_INFO_FMT "Sending IOCInit (req @ %p)\n",
+			ioc->name, &ioc_init));
+
+	r = mpt_handshake_req_reply_wait(ioc, sizeof(IOCInit_t), (u32*)&ioc_init,
+				sizeof(MPIDefaultReply_t), (u16*)&init_reply, 10 /*seconds*/, sleepFlag);
 	if (r != 0)
 		return r;
 
@@ -1958,7 +2412,7 @@
 	 * since we don't even look at it's contents.
 	 */
 
-	if ((r = SendPortEnable(ioc, 0)) != 0)
+	if ((r = SendPortEnable(ioc, 0, sleepFlag)) != 0)
 		return r;
 
 	/* YIKES!  SUPER IMPORTANT!!!
@@ -1967,21 +2421,27 @@
 	 */
 	count = 0;
 	cntdn = HZ * 60;					/* chg'd from 30 to 60 seconds */
-	state = GetIocState(ioc, 1);
+	if (sleepFlag != CAN_SLEEP)
+		cntdn *= 10;					/* scale for 1msec delays */
+	state = mpt_GetIocState(ioc, 1);
 	while (state != MPI_IOC_STATE_OPERATIONAL && --cntdn) {
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		} else {
+			mdelay(1);
+		}
 
 		if (!cntdn) {
-			printk(KERN_ERR MYNAM ": %s: ERROR - Wait IOC_OP state timeout(%d)!\n",
+			printk(MYIOC_s_ERR_FMT "Wait IOC_OP state timeout(%d)!\n",
 					ioc->name, (count+5)/HZ);
 			return -9;
 		}
 
-		state = GetIocState(ioc, 1);
+		state = mpt_GetIocState(ioc, 1);
 		count++;
 	}
-	dhsprintk((KERN_INFO MYNAM ": %s: INFO - Wait IOC_OPERATIONAL state (cnt=%d)\n",
+	dhsprintk((MYIOC_s_INFO_FMT "INFO - Wait IOC_OPERATIONAL state (cnt=%d)\n",
 			ioc->name, count));
 
 	return r;
@@ -1992,17 +2452,18 @@
  *	SendPortEnable - Send PortEnable request to MPT adapter port.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@portnum: Port number to enable
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	Send PortEnable to bring IOC to OPERATIONAL state.
  *
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-SendPortEnable(MPT_ADAPTER *ioc, int portnum)
+SendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag)
 {
 	PortEnable_t		 port_enable;
 	MPIDefaultReply_t	 reply_buf;
-	int	 i;
+	int	 ii;
 	int	 req_sz;
 	int	 reply_sz;
 
@@ -2019,13 +2480,21 @@
 /*	port_enable.MsgFlags = 0;		*/
 /*	port_enable.MsgContext = 0;		*/
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending Port(%d)Enable (req @ %p)\n",
+	dprintk((MYIOC_s_INFO_FMT "Sending Port(%d)Enable (req @ %p)\n",
 			ioc->name, portnum, &port_enable));
 
-	i = HandShakeReqAndReply(ioc, req_sz, (u32*)&port_enable,
-			reply_sz, (u16*)&reply_buf, 65);
-	if (i != 0)
-		return i;
+	/* RAID FW may take a long time to enable
+	 */
+	if ((int)ioc->chip_type <= (int)FC929) {
+		ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&port_enable,
+				reply_sz, (u16*)&reply_buf, 65 /*seconds*/, sleepFlag);
+	} else {
+		ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&port_enable,
+				reply_sz, (u16*)&reply_buf, 300 /*seconds*/, sleepFlag);
+	}
+
+	if (ii != 0)
+		return ii;
 
 	/* We do not even look at the reply, so we need not
 	 * swap the multi-byte fields.
@@ -2034,21 +2503,601 @@
 	return 0;
 }
 
+/*
+ * Inputs: size - total FW bytes
+ * Outputs: frags - number of fragments needed
+ * Return NULL if failed.
+ */
+void * 
+mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size, int *frags, int *alloc_sz) 
+{
+	fw_image_t	**cached_fw = NULL;
+	u8		*mem = NULL;
+	dma_addr_t	fw_dma;
+	int		alloc_total = 0;
+	int		bytes_left, bytes, num_frags;
+	int		sz, ii;
+
+	/* cached_fw 
+	 */
+	sz = ioc->num_fw_frags * sizeof(void *);
+	mem = kmalloc(sz, GFP_ATOMIC);
+	if (mem == NULL)
+		return NULL;
+
+	memset(mem, 0, sz);
+	cached_fw = (fw_image_t **)mem;
+	alloc_total += sz;
+
+	/* malloc fragment memory
+	 * fw_image_t struct and dma for fw data
+	 */
+	bytes_left = size;
+	ii = 0;
+	num_frags = 0;
+	bytes = bytes_left;
+	while((bytes_left) && (num_frags < ioc->num_fw_frags)) {
+		if (cached_fw[ii] == NULL) {
+			mem = kmalloc(sizeof(fw_image_t), GFP_ATOMIC);
+			if (mem == NULL)
+				break;
+
+			memset(mem, 0, sizeof(fw_image_t));
+			cached_fw[ii] = (fw_image_t *)mem;
+			alloc_total += sizeof(fw_image_t);
+		}
+
+		mem = pci_alloc_consistent(ioc->pcidev, bytes, &fw_dma);
+		if (mem == NULL) {
+			if (bytes > 0x10000)
+				bytes = 0x10000;
+			else if (bytes > 0x8000)
+				bytes = 0x8000;
+			else if (bytes > 0x4000)
+				bytes = 0x4000;
+			else if (bytes > 0x2000)
+				bytes = 0x2000;
+			else if (bytes > 0x1000)
+				bytes = 0x1000;
+			else
+				break;
+
+			continue;
+		}
+
+		cached_fw[ii]->fw = mem;
+		cached_fw[ii]->fw_dma = fw_dma;
+		cached_fw[ii]->size = bytes;
+		memset(mem, 0, bytes);
+		alloc_total += bytes;
+
+		bytes_left -= bytes;
+
+		num_frags++;
+		ii++;
+	}
+
+	if (bytes_left ) {
+		/* Major Failure.
+		 */
+		mpt_free_fw_memory(ioc, cached_fw);
+		return NULL;
+	}
+
+	*frags = num_frags;
+	*alloc_sz = alloc_total;
+
+	return (void *) cached_fw;
+}
+
+/*
+ * If alt_img is NULL, delete from ioc structure.
+ * Else, delete a secondary image in same format.
+ */
+void
+mpt_free_fw_memory(MPT_ADAPTER *ioc, fw_image_t **alt_img)
+{
+	fw_image_t **cached_fw;
+	int ii;
+	int sz;
+	int alloc_freed = 0;
+
+	if (alt_img != NULL)
+		cached_fw = alt_img;
+	else
+		cached_fw = ioc->cached_fw;
+
+	if (cached_fw == NULL)
+		return;
+
+	ii = 0;
+	while ((ii < ioc->num_fw_frags) && (cached_fw[ii]!= NULL)) {
+		sz = cached_fw[ii]->size;
+		if (sz > 0) {
+			pci_free_consistent(ioc->pcidev, sz,
+						cached_fw[ii]->fw, cached_fw[ii]->fw_dma);
+		}
+		cached_fw[ii]->fw = NULL;
+		alloc_freed += sz;
+
+		kfree(cached_fw[ii]);
+		cached_fw[ii] = NULL;
+		alloc_freed += sizeof(fw_image_t);
+
+		ii++;
+	}
+
+	kfree(cached_fw);
+	cached_fw = NULL;
+	sz = ioc->num_fw_frags * sizeof(void *);
+	alloc_freed += sz;
+
+	if (alt_img == NULL)
+		ioc->alloc_total -= alloc_freed;
+
+	return;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mpt_do_upload - Construct and Send FWUpload request to MPT adapter port.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@sleepFlag: Specifies whether the process can sleep
+ *
+ *	Returns 0 for success, >0 for handshake failure
+ *		<0 for fw upload failure.
+ *
+ *	Remark: If bound IOC and a successful FWUpload was performed
+ *	on the bound IOC, the second image is discarded
+ *	and memory is free'd. Both channels must upload to prevent
+ *	IOC from running in degraded mode.
+ */
+static int
+mpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag)
+{
+	u8			 request[ioc->req_sz];
+	u8			 reply[sizeof(FWUploadReply_t)];
+	FWUpload_t		*prequest;
+	FWUploadReply_t		*preply;
+	FWUploadTCSGE_t		*ptcsge = NULL;
+	int			 sgeoffset;
+	int			 ii, sz, reply_sz;
+	int			 cmdStatus, freeMem = 0;
+	int			 num_frags, alloc_sz;
+
+	/* If the image size is 0 or if the pointer is
+	 * not NULL (error), we are done.
+	 */
+	if (((sz = ioc->facts.FWImageSize) == 0) || ioc->cached_fw)
+		return 0;
+
+	ioc->num_fw_frags = ioc->req_sz - sizeof(FWUpload_t) + sizeof(dma_addr_t) + sizeof(u32) -1;
+	ioc->num_fw_frags /= sizeof(dma_addr_t) + sizeof(u32);
+
+	ioc->cached_fw = (fw_image_t **) mpt_alloc_fw_memory(ioc, 
+			ioc->facts.FWImageSize, &num_frags, &alloc_sz); 
+
+	if (ioc->cached_fw == NULL) {
+		/* Major Failure.
+		 */
+		mpt_free_fw_memory(ioc, NULL);
+		ioc->cached_fw = NULL;
+		
+		return -ENOMEM;
+	}
+	ioc->alloc_total += alloc_sz;
+
+	dprintk((KERN_INFO MYNAM ": FW Image  @ %p, sz=%d bytes\n",
+		 (void *)(ulong)ioc->cached_fw, ioc->facts.FWImageSize));
+
+	prequest = (FWUpload_t *)&request;
+	preply = (FWUploadReply_t *)&reply;
+
+	/*  Destination...  */
+	memset(prequest, 0, ioc->req_sz);
+
+	reply_sz = sizeof(reply);
+	memset(preply, 0, reply_sz);
+
+	prequest->ImageType = MPI_FW_UPLOAD_ITYPE_FW_IOC_MEM;
+	prequest->Function = MPI_FUNCTION_FW_UPLOAD;
+	prequest->MsgContext = 0;		/* anything */
+
+	ptcsge = (FWUploadTCSGE_t *) &prequest->SGL;
+	ptcsge->Reserved = 0;
+	ptcsge->ContextSize = 0;
+	ptcsge->DetailsLength = 12;
+	ptcsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
+	ptcsge->Reserved1 = 0;
+	ptcsge->ImageOffset = 0;
+	ptcsge->ImageSize = cpu_to_le32(sz);
+
+	sgeoffset = sizeof(FWUpload_t) - sizeof(SGE_MPI_UNION) + sizeof(FWUploadTCSGE_t);
+
+	for (ii = 0; ii < (num_frags-1); ii++) {
+		mpt_add_sge(&request[sgeoffset], MPT_SGE_FLAGS_SIMPLE_ELEMENT |	
+			MPT_SGE_FLAGS_ADDRESSING | MPT_TRANSFER_IOC_TO_HOST |
+			(u32) ioc->cached_fw[ii]->size, ioc->cached_fw[ii]->fw_dma);
+
+		sgeoffset += sizeof(u32) + sizeof(dma_addr_t);
+	}
+
+	mpt_add_sge(&request[sgeoffset], 
+			MPT_SGE_FLAGS_SSIMPLE_READ |(u32) ioc->cached_fw[ii]->size, 
+			ioc->cached_fw[ii]->fw_dma);
+
+	sgeoffset += sizeof(u32) + sizeof(dma_addr_t);
+
+	dprintk((MYIOC_s_INFO_FMT "Sending FW Upload (req @ %p) size %d \n",
+			ioc->name, prequest, sgeoffset));
+
+	ii = mpt_handshake_req_reply_wait(ioc, sgeoffset, (u32*)prequest,
+				reply_sz, (u16*)preply, 65 /*seconds*/, sleepFlag);
+
+	cmdStatus = -EFAULT;
+	if (ii == 0) {
+		/* Handshake transfer was complete and successful.
+		 * Check the Reply Frame.
+		 */
+		int status, transfer_sz;
+		status = le16_to_cpu(preply->IOCStatus);
+		if (status == MPI_IOCSTATUS_SUCCESS) {
+			transfer_sz = le32_to_cpu(preply->ActualImageSize);
+			if (transfer_sz == sz)
+				cmdStatus = 0;
+		}
+	}
+	dprintk((MYIOC_s_INFO_FMT ": do_upload status %d \n",
+			ioc->name, cmdStatus));
+
+	/* Check to see if we have a copy of this image in
+	 * host memory already.
+	 */
+	if (cmdStatus == 0) {
+		ioc->upload_fw = 0;
+		if (ioc->alt_ioc && ioc->alt_ioc->cached_fw)
+			freeMem = 1;
+	}
+
+	/* We already have a copy of this image or
+	 * we had some type of an error  - either the handshake
+	 * failed (i != 0) or the command did not complete successfully.
+	 */
+	if (cmdStatus || freeMem) {
+
+		dprintk((MYIOC_s_INFO_FMT ": do_upload freeing %s image \n",
+			ioc->name, cmdStatus ? "incomplete" : "duplicate"));
+		mpt_free_fw_memory(ioc, NULL);
+		ioc->cached_fw = NULL;
+	}
+
+	return cmdStatus;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mpt_downloadboot - DownloadBoot code
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@flag: Specify which part of IOC memory is to be uploaded.
+ *	@sleepFlag: Specifies whether the process can sleep
+ *
+ *	FwDownloadBoot requires Programmed IO access.
+ *
+ *	Returns 0 for success
+ *		-1 FW Image size is 0
+ *		-2 No valid cached_fw Pointer
+ *		<0 for fw upload failure.
+ */
+static int
+mpt_downloadboot(MPT_ADAPTER *ioc, int sleepFlag)
+{
+	MpiFwHeader_t		*FwHdr = NULL;
+	MpiExtImageHeader_t 	*ExtHdr;
+	fw_image_t		**pCached = NULL;
+	int			 fw_sz;
+	u32			 diag0val;
+#ifdef MPT_DEBUG
+	u32			 diag1val = 0;
+#endif
+	int			 count = 0;
+	u32			*ptru32 = NULL;
+	u32			 diagRwData;
+	u32			 nextImage;
+	u32			 ext_offset;
+	u32			 load_addr;
+	int			 max_idx, fw_idx, ext_idx;
+	int			 left_u32s;
+
+	dprintk((MYIOC_s_INFO_FMT "DbGb0: downloadboot entered.\n",
+				ioc->name));
+#ifdef MPT_DEBUG
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	if (ioc->alt_ioc)
+		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+	dprintk((MYIOC_s_INFO_FMT "DbGb1: diag0=%08x, diag1=%08x\n",
+				ioc->name, diag0val, diag1val));
+#endif
+
+	dprintk((MYIOC_s_INFO_FMT "fw size 0x%x, ioc FW Ptr %p\n",
+				ioc->name, ioc->facts.FWImageSize, ioc->cached_fw));
+	if (ioc->alt_ioc)
+		dprintk((MYIOC_s_INFO_FMT "alt ioc FW Ptr %p\n",
+				ioc->name, ioc->alt_ioc->cached_fw));
+
+	/* Get dma_addr and data transfer size.
+	 */
+	if ((fw_sz = ioc->facts.FWImageSize) == 0)
+		return -1;
+
+	/* Get the DMA from ioc or ioc->alt_ioc */
+	if (ioc->cached_fw == NULL)
+		pCached = (fw_image_t **)ioc->cached_fw;
+	else if (ioc->alt_ioc && ioc->alt_ioc->cached_fw)
+		pCached = (fw_image_t **)ioc->alt_ioc->cached_fw;
+
+	dprintk((MYIOC_s_INFO_FMT "DbGb2: FW Image @ %p\n",
+			ioc->name, FwHdr));
+	if (!pCached)
+		return -2;
+
+	/* Write magic sequence to WriteSequence register
+	 * until enter diagnostic mode
+	 */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	while ((diag0val & MPI_DIAG_DRWE) == 0) {
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
+
+		/* wait 100 msec */
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(100 * HZ / 1000);
+		} else {
+			mdelay (100);
+		}
+
+		count++;
+		if (count > 20) {
+			printk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",
+					ioc->name, diag0val);
+			return -EFAULT;
+
+		}
+
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+#ifdef MPT_DEBUG
+		if (ioc->alt_ioc)
+			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+		dprintk((MYIOC_s_INFO_FMT "DbGb3: diag0=%08x, diag1=%08x\n",
+				ioc->name, diag0val, diag1val));
+#endif
+		dprintk((MYIOC_s_INFO_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
+				ioc->name, diag0val));
+	}
+
+	/* Set the DiagRwEn and Disable ARM bits */
+	diag0val |= (MPI_DIAG_RW_ENABLE | MPI_DIAG_DISABLE_ARM);
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+
+#ifdef MPT_DEBUG
+	if (ioc->alt_ioc)
+		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+	dprintk((MYIOC_s_INFO_FMT "DbGb3: diag0=%08x, diag1=%08x\n",
+			ioc->name, diag0val, diag1val));
+#endif
+
+	/* Write the LoadStartAddress to the DiagRw Address Register
+	 * using Programmed IO
+	 */
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, FwHdr->LoadStartAddress);
+	dprintk((MYIOC_s_INFO_FMT "LoadStart addr written 0x%x \n",
+		ioc->name, FwHdr->LoadStartAddress));
+#if 1
+
+	/* max_idx = 1 + maximum valid buffer index
+	 */
+	max_idx = 0;
+	while (pCached[max_idx])
+		max_idx++;
+
+	fw_idx = 0;
+	FwHdr = (MpiFwHeader_t *) pCached[fw_idx]->fw;
+	ptru32 = (u32 *) FwHdr;
+	count = (FwHdr->ImageSize + 3)/4;
+	nextImage = FwHdr->NextImageHeaderOffset;
+
+	dprintk((MYIOC_s_INFO_FMT "Write FW Image: 0x%x u32's @ %p\n",
+				ioc->name, count, ptru32));
+	left_u32s = pCached[fw_idx]->size/4;
+	while (count--) {
+		if (left_u32s == 0) {
+			fw_idx++;
+			if (fw_idx >= max_idx) {
+				/* FIXME
+				ERROR CASE
+				*/
+				;
+			}
+			ptru32 = (u32 *) pCached[fw_idx]->fw;
+			left_u32s = pCached[fw_idx]->size / 4;
+		}
+		left_u32s--;
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptru32);
+		ptru32++;
+	}
+
+	/* left_u32s, fw_idx and ptru32 are all valid
+	 */
+	while (nextImage) {
+		ext_idx = 0;
+		ext_offset = nextImage;
+		while (ext_offset > pCached[ext_idx]->size) {
+			ext_idx++;
+			if (ext_idx >= max_idx) {
+				/* FIXME
+				ERROR CASE
+				*/
+				;
+			}
+			ext_offset -= pCached[ext_idx]->size;
+		}
+		ptru32 = (u32 *) ((char *)pCached[ext_idx]->fw + ext_offset);
+		left_u32s = pCached[ext_idx]->size - ext_offset;
+
+		if ((left_u32s * 4) >= sizeof(MpiExtImageHeader_t)) {
+			ExtHdr = (MpiExtImageHeader_t *) ptru32;
+			count = (ExtHdr->ImageSize + 3 )/4;
+			nextImage = ExtHdr->NextImageHeaderOffset;
+			load_addr = ExtHdr->LoadStartAddress;
+		} else {
+			u32 * ptmp = (u32 *)pCached[ext_idx+1]->fw;
+
+			switch (left_u32s) {
+			case 5:
+				count = *(ptru32 + 2);
+				nextImage = *(ptru32 + 3);
+				load_addr = *(ptru32 + 4);
+				break;
+			case 4:
+				count = *(ptru32 + 2);
+				nextImage = *(ptru32 + 3);
+				load_addr = *ptmp;
+				break;
+			case 3:
+				count = *(ptru32 + 2);
+				nextImage = *ptmp;
+				load_addr = *(ptmp + 1);
+				break;
+			case 2:
+				count = *ptmp;
+				nextImage = *(ptmp + 1);
+				load_addr = *(ptmp + 2);
+				break;
+
+			case 1:
+				count = *(ptmp + 1);
+				nextImage = *(ptmp + 2);
+				load_addr = *(ptmp + 3);
+				break;
+
+			default:
+				count = 0;
+				nextImage = 0;
+				load_addr = 0;
+				/* FIXME
+				ERROR CASE
+				*/
+				;
+
+			}
+			count = (count +3)/4;
+		}
+
+		dprintk((MYIOC_s_INFO_FMT "Write Ext Image: 0x%x u32's @ %p\n",
+						ioc->name, count, ptru32));
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);
+
+		while (count--) {
+			if (left_u32s == 0) {
+				fw_idx++;
+				if (fw_idx >= max_idx) {
+					/* FIXME
+					ERROR CASE
+					*/
+					;
+				}
+				ptru32 = (u32 *) pCached[fw_idx]->fw;
+				left_u32s = pCached[fw_idx]->size / 4;
+			}
+			left_u32s--;
+			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptru32);
+			ptru32++;
+		}
+	}
+
+#else
+	while (nextImage) {
+
+		/* Set the pointer to the extended image
+		 */
+		ExtHdr = (MpiExtImageHeader_t *) ((char *) FwHdr + nextImage);
+
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, ExtHdr->LoadStartAddress);
+
+		count = (ExtHdr->ImageSize + 3 )/4;
+
+		ptru32 = (u32 *) ExtHdr;
+		dprintk((MYIOC_s_INFO_FMT "Write Ext Image: 0x%x u32's @ %p\n",
+				ioc->name, count, ptru32));
+		while (count-- ) {
+			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptru32);
+			ptru32++;
+		}
+		nextImage = ExtHdr->NextImageHeaderOffset;
+	}
+#endif
+
+
+	/* Write the IopResetVectorRegAddr */
+	dprintk((MYIOC_s_INFO_FMT "Write IopResetVector Addr! \n", ioc->name));
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, FwHdr->IopResetRegAddr);
+
+	/* Write the IopResetVectorValue */
+	dprintk((MYIOC_s_INFO_FMT "Write IopResetVector Value! \n", ioc->name));
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, FwHdr->IopResetVectorValue);
+
+	/* Clear the internal flash bad bit - autoincrementing register,
+	 * so must do two writes.
+	 */
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
+	diagRwData = CHIPREG_PIO_READ32(&ioc->pio_chip->DiagRwData);
+	diagRwData |= 0x4000000;
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, diagRwData);
+
+	/* clear the RW enable and DISARM bits */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	diag0val &= ~(MPI_DIAG_DISABLE_ARM | MPI_DIAG_RW_ENABLE | MPI_DIAG_FLASH_BAD_SIG);
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+
+	/* Write 0xFF to reset the sequencer */
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
+
+	return 0;
+}
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	KickStart - Perform hard reset of MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@force: Force hard reset
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	This routine places MPT adapter in diagnostic mode via the
  *	WriteSequence register, and then performs a hard reset of adapter
  *	via the Diagnostic register.
  *
- *	Returns 0 for soft reset success, 1 for hard reset success,
- *	else a negative value for failure.
+ *	Inputs:   sleepflag - CAN_SLEEP (non-interrupt thread)
+ *			or NO_SLEEP (interrupt thread, use mdelay)
+ *		  force - 1 if doorbell active, board fault state
+ *				board operational, IOC_RECOVERY or
+ *				IOC_BRINGUP and there is an alt_ioc.
+ *			  0 else
+ *
+ *	Returns:
+ *		 1 - hard reset, READY	
+ *		 0 - no reset due to History bit, READY	
+ *		-1 - no reset due to History bit but not READY	
+ *		     OR reset but failed to come READY
+ *		-2 - no reset, could not enter DIAG mode 
+ *		-3 - reset but bad FW bit 
  */
 static int
-KickStart(MPT_ADAPTER *ioc, int force)
+KickStart(MPT_ADAPTER *ioc, int force, int sleepFlag)
 {
 	int hard_reset_done = 0;
 	u32 ioc_state;
@@ -2056,183 +3105,295 @@
 
 	dprintk((KERN_WARNING MYNAM ": KickStarting %s!\n", ioc->name));
 
-	hard_reset_done = mpt_fc9x9_reset(ioc, force);
-#if 0
-	if (ioc->chip_type == FC909 || ioc->chip-type == FC919) {
-		hard_reset_done = mpt_fc9x9_reset(ioc, force);
-	} else if (ioc->chip_type == FC929) {
-		unsigned long delta;
-
-		delta = jiffies - ioc->last_kickstart;
-		dprintk((KERN_INFO MYNAM ": %s: 929 KickStart, last=%ld, delta = %ld\n",
-				ioc->name, ioc->last_kickstart, delta));
-		if ((ioc->sod_reset == 0) || (delta >= 10*HZ))
-			hard_reset_done = mpt_fc9x9_reset(ioc, ignore);
-		else {
-			dprintk((KERN_INFO MYNAM ": %s: Skipping KickStart (delta=%ld)!\n",
-					ioc->name, delta));
-			return 0;
-		}
-	/* TODO! Add C1030!
-	} else if (ioc->chip_type == C1030) {
-	 */
-	} else {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Bad chip_type (0x%x)\n",
-				ioc->name, ioc->chip_type);
-		return -5;
-	}
-#endif
-
+	hard_reset_done = mpt_diag_reset(ioc, force, sleepFlag);
 	if (hard_reset_done < 0)
 		return hard_reset_done;
 
-	dprintk((KERN_INFO MYNAM ": %s: Diagnostic reset successful\n",
+	dprintk((MYIOC_s_INFO_FMT "Diagnostic reset successful!\n",
 			ioc->name));
 
 	for (cnt=0; cnt<HZ*20; cnt++) {
-		if ((ioc_state = GetIocState(ioc, 1)) == MPI_IOC_STATE_READY) {
-			dprintk((KERN_INFO MYNAM ": %s: KickStart successful! (cnt=%d)\n",
+		if ((ioc_state = mpt_GetIocState(ioc, 1)) == MPI_IOC_STATE_READY) {
+			dprintk((MYIOC_s_INFO_FMT "KickStart successful! (cnt=%d)\n",
 					ioc->name, cnt));
 			return hard_reset_done;
 		}
-		/* udelay(10000) ? */
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		} else {
+			mdelay (10);
+		}
 	}
 
-	printk(KERN_ERR MYNAM ": %s: ERROR - Failed to come READY after reset!\n",
+	printk(MYIOC_s_ERR_FMT "Failed to come READY after reset!\n",
 			ioc->name);
 	return -1;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	mpt_fc9x9_reset - Perform hard reset of FC9x9 adapter.
+ *	mpt_diag_reset - Perform hard reset of the adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
- *
- *	This routine places FC9x9 adapter in diagnostic mode via the
- *	WriteSequence register, and then performs a hard reset of adapter
- *	via the Diagnostic register.
- *
- *	Returns 0 for success, non-zero for failure.
+ *	@ignore: Set if to honor and clear to ignore
+ *		the reset history bit
+ *	@sleepflag: CAN_SLEEP if called in a non-interrupt thread,
+ *		else set to NO_SLEEP (use mdelay instead)
+ *
+ *	This routine places the adapter in diagnostic mode via the
+ *	WriteSequence register and then performs a hard reset of adapter
+ *	via the Diagnostic register. Adapter should be in ready state
+ *	upon successful completion.
+ *
+ *	Returns:  1  hard reset successful
+ *		  0  no reset performed because reset history bit set
+ *		 -2  enabling diagnostic mode failed
+ *		 -3  diagnostic reset failed
  */
 static int
-mpt_fc9x9_reset(MPT_ADAPTER *ioc, int ignore)
+mpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag)
 {
 	u32 diag0val;
+	u32 doorbell;
 	int hard_reset_done = 0;
+	int count = 0;
+#ifdef MPT_DEBUG
+	u32 diag1val = 0;
+#endif
 
-	/* Use "Diagnostic reset" method! (only thing available!) */
+	/* Clear any existing interrupts */
+	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
+	/* Use "Diagnostic reset" method! (only thing available!) */
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+
 #ifdef MPT_DEBUG
-{
-	u32 diag1val = 0;
 	if (ioc->alt_ioc)
 		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((KERN_INFO MYNAM ": %s: DBG1: diag0=%08x, diag1=%08x\n",
+	dprintk((MYIOC_s_INFO_FMT "DbG1: diag0=%08x, diag1=%08x\n",
 			ioc->name, diag0val, diag1val));
-}
 #endif
-	if (diag0val & MPI_DIAG_DRWE) {
-		dprintk((KERN_INFO MYNAM ": %s: DiagWriteEn bit already set\n",
-				ioc->name));
-	} else {
-		/* Write magic sequence to WriteSequence register */
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
-		dprintk((KERN_INFO MYNAM ": %s: Wrote magic DiagWriteEn sequence [spot#1]\n",
-				ioc->name));
-	}
 
-	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	/* Do the reset if we are told to ignore the reset history
+	 * or if the reset history is 0
+	 */
+	if (ignore || !(diag0val & MPI_DIAG_RESET_HISTORY)) {
+		while ((diag0val & MPI_DIAG_DRWE) == 0) {
+			/* Write magic sequence to WriteSequence register
+			 * Loop until in diagnostic mode
+			 */
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
+
+			/* wait 100 msec */
+			if (sleepFlag == CAN_SLEEP) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(100 * HZ / 1000);
+			} else {
+				mdelay (100);
+			}
+
+			count++;
+			if (count > 20) {
+				printk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",
+						ioc->name, diag0val);
+				return -2;
+
+			}
+
+			diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+
+			dprintk((MYIOC_s_INFO_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
+					ioc->name, diag0val));
+		}
+
 #ifdef MPT_DEBUG
-{
-	u32 diag1val = 0;
-	if (ioc->alt_ioc)
-		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((KERN_INFO MYNAM ": %s: DbG2: diag0=%08x, diag1=%08x\n",
-			ioc->name, diag0val, diag1val));
-}
+		if (ioc->alt_ioc)
+			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+		dprintk((MYIOC_s_INFO_FMT "DbG2: diag0=%08x, diag1=%08x\n",
+				ioc->name, diag0val, diag1val));
 #endif
-	if (!ignore && (diag0val & MPI_DIAG_RESET_HISTORY)) {
-		dprintk((KERN_INFO MYNAM ": %s: Skipping due to ResetHistory bit set!\n",
-				ioc->name));
-	} else {
+		/* Write the PreventIocBoot bit */
+		if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT) {
+			diag0val |= MPI_DIAG_PREVENT_IOC_BOOT;
+			CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+		}
+
+		/*
+		 * Disable the ARM (Bug fix)
+		 * 
+		 */
+		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);
+		mdelay (1);
+
 		/*
 		 * Now hit the reset bit in the Diagnostic register
-		 * (THE BIG HAMMER!)
+		 * (THE BIG HAMMER!) (Clears DRWE bit).
 		 */
-		CHIPREG_WRITE32(&ioc->chip->Diagnostic, MPI_DIAG_RESET_ADAPTER);
+		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);
 		hard_reset_done = 1;
-		dprintk((KERN_INFO MYNAM ": %s: Diagnostic reset performed\n",
+		dprintk((MYIOC_s_INFO_FMT "Diagnostic reset performed\n",
 				ioc->name));
 
-		/* want udelay(100) */
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		/*
+		 * Call each currently registered protocol IOC reset handler
+		 * with pre-reset indication.
+		 * NOTE: If we're doing _IOC_BRINGUP, there can be no
+		 * MptResetHandlers[] registered yet.
+		 */
+		{
+			int	 ii;
+			int	 r = 0;
+
+			for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+				if (MptResetHandlers[ii]) {
+					dprintk((MYIOC_s_INFO_FMT "Calling IOC pre_reset handler #%d\n",
+							ioc->name, ii));
+					r += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_PRE_RESET);
+					if (ioc->alt_ioc) {
+						dprintk((MYIOC_s_INFO_FMT "Calling alt-%s pre_reset handler #%d\n",
+								ioc->name, ioc->alt_ioc->name, ii));
+						r += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_PRE_RESET);
+					}
+				}
+			}
+			/* FIXME?  Examine results here? */
+		}
+
+		if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT) {
+			/* If the DownloadBoot operation fails, the
+			 * IOC will be left unusable. This is a fatal error
+			 * case.  _diag_reset will return < 0
+			 */
+			for (count = 0; count < 30; count ++) {
+				diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+#ifdef MPT_DEBUG
+				if (ioc->alt_ioc)
+					diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+				dprintk((MYIOC_s_INFO_FMT 
+					"DbG2b: diag0=%08x, diag1=%08x\n",
+					ioc->name, diag0val, diag1val));
+#endif
+				if (!(diag0val & MPI_DIAG_RESET_ADAPTER)) {
+					break;
+				}
+
+				/* wait 1 sec */
+				if (sleepFlag == CAN_SLEEP) {
+					set_current_state(TASK_INTERRUPTIBLE);
+					schedule_timeout(HZ);
+				} else {
+					mdelay (1000);
+				}
+			}
+			if ((count = mpt_downloadboot(ioc, sleepFlag)) < 0) {
+				printk(KERN_WARNING MYNAM 
+					": firmware downloadboot failure (%d)!\n", count);
+			}
+
+		} else {
+			/* Wait for FW to reload and for board
+			 * to go to the READY state.
+			 * Maximum wait is 30 seconds.
+			 * If fail, no error will check again
+			 * with calling program.
+			 */
+			for (count = 0; count < 30; count ++) {
+				doorbell = CHIPREG_READ32(&ioc->chip->Doorbell);
+				doorbell &= MPI_IOC_STATE_MASK;
+
+				if (doorbell == MPI_IOC_STATE_READY) {
+					break;
+				}
+
+				/* wait 1 sec */
+				if (sleepFlag == CAN_SLEEP) {
+					set_current_state(TASK_INTERRUPTIBLE);
+					schedule_timeout(HZ);
+				} else {
+					mdelay (1000);
+				}
+			}
+		}
+	}
 
-		/* Write magic sequence to WriteSequence register */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+#ifdef MPT_DEBUG
+	if (ioc->alt_ioc)
+		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+	dprintk((MYIOC_s_INFO_FMT "DbG3: diag0=%08x, diag1=%08x\n",
+		ioc->name, diag0val, diag1val));
+#endif
+
+	/* Clear RESET_HISTORY bit!  Place board in the
+	 * diagnostic mode to update the diag register.
+	 */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	count = 0;
+	while ((diag0val & MPI_DIAG_DRWE) == 0) {
+		/* Write magic sequence to WriteSequence register
+		 * Loop until in diagnostic mode
+		 */
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
-		dprintk((KERN_INFO MYNAM ": %s: Wrote magic DiagWriteEn sequence [spot#2]\n",
-				ioc->name));
-	}
 
-	/* Clear RESET_HISTORY bit! */
-	CHIPREG_WRITE32(&ioc->chip->Diagnostic, 0x0);
+		/* wait 100 msec */
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(100 * HZ / 1000);
+		} else {
+			mdelay (100);
+		}
 
+		count++;
+		if (count > 20) {
+			printk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",
+					ioc->name, diag0val);
+			break;
+		}
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	}
+	diag0val &= ~MPI_DIAG_RESET_HISTORY;
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-#ifdef MPT_DEBUG
-{
-	u32 diag1val = 0;
-	if (ioc->alt_ioc)
-		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((KERN_INFO MYNAM ": %s: DbG3: diag0=%08x, diag1=%08x\n",
-			ioc->name, diag0val, diag1val));
-}
-#endif
 	if (diag0val & MPI_DIAG_RESET_HISTORY) {
-		printk(KERN_WARNING MYNAM ": %s: WARNING - ResetHistory bit failed to clear!\n",
+		printk(MYIOC_s_WARN_FMT "ResetHistory bit failed to clear!\n",
 				ioc->name);
 	}
 
+	/* Disable Diagnostic Mode
+	 */
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFFFFFFFF);
+
+	/* Check FW reload status flags.
+	 */
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	if (diag0val & (MPI_DIAG_FLASH_BAD_SIG | MPI_DIAG_RESET_ADAPTER | MPI_DIAG_DISABLE_ARM)) {
+		printk(MYIOC_s_ERR_FMT "Diagnostic reset FAILED! (%02xh)\n",
+				ioc->name, diag0val);
+		return -3;
+	}
+
 #ifdef MPT_DEBUG
-{
-	u32 diag1val = 0;
 	if (ioc->alt_ioc)
 		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((KERN_INFO MYNAM ": %s: DbG4: diag0=%08x, diag1=%08x\n",
+	dprintk((MYIOC_s_INFO_FMT "DbG4: diag0=%08x, diag1=%08x\n",
 			ioc->name, diag0val, diag1val));
-}
 #endif
-	if (diag0val & (MPI_DIAG_FLASH_BAD_SIG | MPI_DIAG_RESET_ADAPTER | MPI_DIAG_DISABLE_ARM)) {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Diagnostic reset FAILED! (%02xh)\n",
-				ioc->name, diag0val);
-		return -3;
-	}
 
 	/*
 	 * Reset flag that says we've enabled event notification
 	 */
 	ioc->facts.EventState = 0;
 
-	/* NEW!  20010220 -sralston
-	 * Try to avoid redundant resets of the 929.
-	 */
-	ioc->sod_reset++;
-	ioc->last_kickstart = jiffies;
-	if (ioc->alt_ioc) {
-		ioc->alt_ioc->sod_reset = ioc->sod_reset;
-		ioc->alt_ioc->last_kickstart = ioc->last_kickstart;
-	}
+	if (ioc->alt_ioc)
+		ioc->alt_ioc->facts.EventState = 0;
 
 	return hard_reset_done;
 }
@@ -2249,16 +3410,45 @@
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-SendIocReset(MPT_ADAPTER *ioc, u8 reset_type)
+SendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag)
 {
 	int r;
+	u32 state;
+	int cntdn, count;
 
 	dprintk((KERN_WARNING MYNAM ": %s: Sending IOC reset(0x%02x)!\n",
 			ioc->name, reset_type));
 	CHIPREG_WRITE32(&ioc->chip->Doorbell, reset_type<<MPI_DOORBELL_FUNCTION_SHIFT);
-	if ((r = WaitForDoorbellAck(ioc, 2)) < 0)
+	if ((r = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
 		return r;
 
+	/* FW ACK'd request, wait for READY state 
+	 */
+	cntdn = HZ * 15;
+	count = 0;
+	if (sleepFlag != CAN_SLEEP)
+		cntdn *= 10;	/* 1500 iterations @ 1msec per */
+
+	while ((state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
+		cntdn--;
+		count++;
+		if (!cntdn) {
+			if (sleepFlag != CAN_SLEEP)
+				count *= 10;
+
+			printk(KERN_ERR MYNAM ": %s: ERROR - Wait IOC_READY state timeout(%d)!\n",
+					ioc->name, (count+5)/HZ);
+			return -ETIME;
+		}
+
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		} else {
+			mdelay (1);	/* 1 msec delay */
+		}
+	}
+
 	/* TODO!
 	 *  Cleanup all event stuff for this IOC; re-issue EventNotification
 	 *  request if needed.
@@ -2275,7 +3465,8 @@
  *	@ioc: Pointer to MPT_ADAPTER structure
  *
  *	This routine allocates memory for the MPT reply and request frame
- *	pools, and primes the IOC reply FIFO with reply frames.
+ *	pools (if necessary), and primes the IOC reply FIFO with
+ *	reply frames.
  *
  *	Returns 0 for success, non-zero for failure.
  */
@@ -2284,6 +3475,7 @@
 {
 	MPT_FRAME_HDR *mf;
 	unsigned long b;
+	unsigned long flags;
 	dma_addr_t aligned_mem_dma;
 	u8 *mem, *aligned_mem;
 	int i, sz;
@@ -2299,8 +3491,8 @@
 		memset(mem, 0, sz);
 		ioc->alloc_total += sz;
 		ioc->reply_alloc = mem;
-		dprintk((KERN_INFO MYNAM ": %s.reply_alloc  @ %p[%08x], sz=%d bytes\n",
-			 ioc->name, mem, ioc->reply_alloc_dma, sz));
+		dprintk((KERN_INFO MYNAM ": %s.reply_alloc  @ %p[%p], sz=%d bytes\n",
+			 	ioc->name, mem, (void *)(ulong)ioc->reply_alloc_dma, sz));
 
 		b = (unsigned long) mem;
 		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
@@ -2308,15 +3500,20 @@
 		ioc->reply_frames = (MPT_FRAME_HDR *) aligned_mem;
 		ioc->reply_frames_dma =
 			(ioc->reply_alloc_dma + (aligned_mem - mem));
-		aligned_mem_dma = ioc->reply_frames_dma;
-		dprintk((KERN_INFO MYNAM ": %s.reply_frames @ %p[%08x]\n",
-			 ioc->name, aligned_mem, aligned_mem_dma));
-
-		for (i = 0; i < ioc->reply_depth; i++) {
-			/*  Write each address to the IOC!  */
-			CHIPREG_WRITE32(&ioc->chip->ReplyFifo, aligned_mem_dma);
-			aligned_mem_dma += ioc->reply_sz;
-		}
+
+		ioc->reply_frames_low_dma = (u32) (ioc->reply_frames_dma & 0xFFFFFFFF);
+	}
+
+	/* Post Reply frames to FIFO
+	 */
+	aligned_mem_dma = ioc->reply_frames_dma;
+	dprintk((KERN_INFO MYNAM ": %s.reply_frames @ %p[%p]\n",
+		 	ioc->name, ioc->reply_frames, (void *)(ulong)aligned_mem_dma));
+
+	for (i = 0; i < ioc->reply_depth; i++) {
+		/*  Write each address to the IOC!  */
+		CHIPREG_WRITE32(&ioc->chip->ReplyFifo, aligned_mem_dma);
+		aligned_mem_dma += ioc->reply_sz;
 	}
 
 
@@ -2336,8 +3533,8 @@
 		memset(mem, 0, sz);
 		ioc->alloc_total += sz;
 		ioc->req_alloc = mem;
-		dprintk((KERN_INFO MYNAM ": %s.req_alloc    @ %p[%08x], sz=%d bytes\n",
-			 ioc->name, mem, ioc->req_alloc_dma, sz));
+		dprintk((KERN_INFO MYNAM ": %s.req_alloc    @ %p[%p], sz=%d bytes\n",
+			 	ioc->name, mem, (void *)(ulong)ioc->req_alloc_dma, sz));
 
 		b = (unsigned long) mem;
 		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
@@ -2345,17 +3542,16 @@
 		ioc->req_frames = (MPT_FRAME_HDR *) aligned_mem;
 		ioc->req_frames_dma =
 			(ioc->req_alloc_dma + (aligned_mem - mem));
-		aligned_mem_dma = ioc->req_frames_dma;
-
-		dprintk((KERN_INFO MYNAM ": %s.req_frames   @ %p[%08x]\n",
-			 ioc->name, aligned_mem, aligned_mem_dma));
 
-		for (i = 0; i < ioc->req_depth; i++) {
-			mf = (MPT_FRAME_HDR *) aligned_mem;
+		ioc->req_frames_low_dma = (u32) (ioc->req_frames_dma & 0xFFFFFFFF);
 
-			/*  Queue REQUESTs *internally*!  */
-			Q_ADD_TAIL(&ioc->FreeQ.head, &mf->u.frame.linkage, MPT_FRAME_HDR);
-			aligned_mem += ioc->req_sz;
+		if (sizeof(dma_addr_t) == sizeof(u64)) {
+			/* Check: upper 32-bits of the request and reply frame
+			 * physical addresses must be the same.
+			 */
+			if (((u64)ioc->req_frames_dma >> 32) != ((u64)ioc->reply_frames_dma >> 32)){
+				goto out_fail;
+			}
 		}
 
 #if defined(CONFIG_MTRR) && 0
@@ -2367,20 +3563,38 @@
 		ioc->mtrr_reg = mtrr_add(ioc->req_alloc_dma,
 					 sz,
 					 MTRR_TYPE_WRCOMB, 1);
-		dprintk((KERN_INFO MYNAM ": %s: MTRR region registered (base:size=%08x:%x)\n",
-				ioc->name, ioc->req_alloc_dma,
-				sz ));
+		dprintk((MYIOC_s_INFO_FMT "MTRR region registered (base:size=%08x:%x)\n",
+				ioc->name, ioc->req_alloc_dma, sz));
 #endif
+	}
 
+	/* Initialize Request frames linked list
+	 */
+	aligned_mem_dma = ioc->req_frames_dma;
+	aligned_mem = (u8 *) ioc->req_frames;
+	dprintk((KERN_INFO MYNAM ": %s.req_frames   @ %p[%p]\n",
+		 	ioc->name, aligned_mem, (void *)(ulong)aligned_mem_dma));
+
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	Q_INIT(&ioc->FreeQ, MPT_FRAME_HDR);
+	for (i = 0; i < ioc->req_depth; i++) {
+		mf = (MPT_FRAME_HDR *) aligned_mem;
+
+		/*  Queue REQUESTs *internally*!  */
+		Q_ADD_TAIL(&ioc->FreeQ.head, &mf->u.frame.linkage, MPT_FRAME_HDR);
+		aligned_mem += ioc->req_sz;
 	}
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
 
 	if (ioc->sense_buf_pool == NULL) {
-		sz = (ioc->req_depth * 256);
+		sz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);
 		ioc->sense_buf_pool =
 				pci_alloc_consistent(ioc->pcidev, sz, &ioc->sense_buf_pool_dma);
 		if (ioc->sense_buf_pool == NULL)
 			goto out_fail;
 
+		ioc->sense_buf_low_dma = (u32) (ioc->sense_buf_pool_dma & 0xFFFFFFFF);
 		ioc->alloc_total += sz;
 	}
 
@@ -2408,7 +3622,7 @@
 #if defined(CONFIG_MTRR) && 0
 		if (ioc->mtrr_reg > 0) {
 			mtrr_del(ioc->mtrr_reg, 0, 0);
-			dprintk((KERN_INFO MYNAM ": %s: MTRR region de-registered\n",
+			dprintk((MYIOC_s_INFO_FMT "MTRR region de-registered\n",
 					ioc->name));
 		}
 #endif
@@ -2417,7 +3631,7 @@
 		ioc->alloc_total -= sz;
 	}
 	if (ioc->sense_buf_pool != NULL) {
-		sz = (ioc->req_depth * 256);
+		sz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);
 		pci_free_consistent(ioc->pcidev,
 				sz,
 				ioc->sense_buf_pool, ioc->sense_buf_pool_dma);
@@ -2427,8 +3641,8 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *	HandShakeReqAndReply - Send MPT request to and receive reply from
+/**
+ *	mpt_handshake_req_reply_wait - Send MPT request to and receive reply from
  *	IOC via doorbell handshake method.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@reqBytes: Size of the request in bytes
@@ -2436,6 +3650,7 @@
  *	@replyBytes: Expected size of the reply in bytes
  *	@u16reply: Pointer to area where reply should be written
  *	@maxwait: Max wait time for a reply (in seconds)
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	NOTES: It is the callers responsibility to byte-swap fields in the
  *	request which are greater than 1 byte in size.  It is also the
@@ -2444,8 +3659,9 @@
  *
  *	Returns 0 for success, non-zero for failure.
  */
-static int
-HandShakeReqAndReply(MPT_ADAPTER *ioc, int reqBytes, u32 *req, int replyBytes, u16 *u16reply, int maxwait)
+int
+mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req,
+				int replyBytes, u16 *u16reply, int maxwait, int sleepFlag)
 {
 	MPIDefaultReply_t *mptReply;
 	int failcnt = 0;
@@ -2471,57 +3687,61 @@
 	/*
 	 * Wait for IOC's doorbell handshake int
 	 */
-	if ((t = WaitForDoorbellInt(ioc, 2)) < 0)
+	if ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)
 		failcnt++;
 
-	dhsprintk((KERN_INFO MYNAM ": %s: HandShake request start, WaitCnt=%d%s\n",
+	dhsprintk((MYIOC_s_INFO_FMT "HandShake request start, WaitCnt=%d%s\n",
 			ioc->name, t, failcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));
 
+	/* Read doorbell and check for active bit */
+	if (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
+			return -1;
+
 	/*
 	 * Clear doorbell int (WRITE 0 to IntStatus reg),
 	 * then wait for IOC to ACKnowledge that it's ready for
 	 * our handshake request.
 	 */
 	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
-	if (!failcnt && (t = WaitForDoorbellAck(ioc, 2)) < 0)
+	if (!failcnt && (t = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
 		failcnt++;
 
 	if (!failcnt) {
-		int	 i;
+		int	 ii;
 		u8	*req_as_bytes = (u8 *) req;
 
 		/*
 		 * Stuff request words via doorbell handshake,
 		 * with ACK from IOC for each.
 		 */
-		for (i = 0; !failcnt && i < reqBytes/4; i++) {
-			u32 word = ((req_as_bytes[(i*4) + 0] <<  0) |
-				    (req_as_bytes[(i*4) + 1] <<  8) |
-				    (req_as_bytes[(i*4) + 2] << 16) |
-				    (req_as_bytes[(i*4) + 3] << 24));
+		for (ii = 0; !failcnt && ii < reqBytes/4; ii++) {
+			u32 word = ((req_as_bytes[(ii*4) + 0] <<  0) |
+				    (req_as_bytes[(ii*4) + 1] <<  8) |
+				    (req_as_bytes[(ii*4) + 2] << 16) |
+				    (req_as_bytes[(ii*4) + 3] << 24));
 
 			CHIPREG_WRITE32(&ioc->chip->Doorbell, word);
-			if ((t = WaitForDoorbellAck(ioc, 2)) < 0)
+			if ((t = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
 				failcnt++;
 		}
 
 		dmfprintk((KERN_INFO MYNAM ": Handshake request frame (@%p) header\n", req));
 		DBG_DUMP_REQUEST_FRAME_HDR(req)
 
-		dhsprintk((KERN_INFO MYNAM ": %s: HandShake request post done, WaitCnt=%d%s\n",
+		dhsprintk((MYIOC_s_INFO_FMT "HandShake request post done, WaitCnt=%d%s\n",
 				ioc->name, t, failcnt ? " - MISSING DOORBELL ACK!" : ""));
 
 		/*
 		 * Wait for completion of doorbell handshake reply from the IOC
 		 */
-		if (!failcnt && (t = WaitForDoorbellReply(ioc, maxwait)) < 0)
+		if (!failcnt && (t = WaitForDoorbellReply(ioc, maxwait, sleepFlag)) < 0)
 			failcnt++;
 
 		/*
 		 * Copy out the cached reply...
 		 */
-		for(i=0; i < MIN(replyBytes/2,mptReply->MsgLength*2); i++)
-			u16reply[i] = ioc->hs_reply[i];
+		for (ii=0; ii < MIN(replyBytes/2,mptReply->MsgLength*2); ii++)
+			u16reply[ii] = ioc->hs_reply[ii];
 	} else {
 		return -99;
 	}
@@ -2535,6 +3755,7 @@
  *	in it's IntStatus register.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@howlong: How long to wait (in seconds)
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	This routine waits (up to ~2 seconds max) for IOC doorbell
  *	handshake ACKnowledge.
@@ -2542,28 +3763,40 @@
  *	Returns a negative value on failure, else wait loop count.
  */
 static int
-WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong)
+WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
 	int cntdn = HZ * howlong;
 	int count = 0;
 	u32 intstat;
 
-	while (--cntdn) {
-		intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
-		if (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))
-			break;
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
-		count++;
+	if (sleepFlag == CAN_SLEEP) {
+		while (--cntdn) {
+			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+			if (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))
+				break;
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+			count++;
+		}
+	} else {
+		cntdn *= 10; /* convert to msec */
+		while (--cntdn) {
+			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+			if (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))
+				break;
+			mdelay (1);
+			count++;
+		}
+		count /= 10;
 	}
 
 	if (cntdn) {
-		dhsprintk((KERN_INFO MYNAM ": %s: WaitForDoorbell ACK (cnt=%d)\n",
+		dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell ACK (cnt=%d)\n",
 				ioc->name, count));
 		return count;
 	}
 
-	printk(KERN_ERR MYNAM ": %s: ERROR - Doorbell ACK timeout(%d)!\n",
+	printk(MYIOC_s_ERR_FMT "Doorbell ACK timeout(%d)!\n",
 			ioc->name, (count+5)/HZ);
 	return -1;
 }
@@ -2574,34 +3807,47 @@
  *	in it's IntStatus register.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@howlong: How long to wait (in seconds)
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	This routine waits (up to ~2 seconds max) for IOC doorbell interrupt.
  *
  *	Returns a negative value on failure, else wait loop count.
  */
 static int
-WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong)
+WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
 	int cntdn = HZ * howlong;
 	int count = 0;
 	u32 intstat;
 
-	while (--cntdn) {
-		intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
-		if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
-			break;
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
-		count++;
+	if (sleepFlag == CAN_SLEEP) {
+		while (--cntdn) {
+			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+			if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
+				break;
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+			count++;
+		}
+	} else {
+		cntdn *= 10; /* convert to msec */
+		while (--cntdn) {
+			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+			if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
+				break;
+			mdelay(1);
+			count++;
+		}
+		count /= 10;
 	}
 
 	if (cntdn) {
-		dhsprintk((KERN_INFO MYNAM ": %s: WaitForDoorbell INT (cnt=%d)\n",
+		dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell INT (cnt=%d)\n",
 				ioc->name, count));
 		return count;
 	}
 
-	printk(KERN_ERR MYNAM ": %s: ERROR - Doorbell INT timeout(%d)!\n",
+	printk(MYIOC_s_ERR_FMT "Doorbell INT timeout(%d)!\n",
 			ioc->name, (count+5)/HZ);
 	return -1;
 }
@@ -2611,6 +3857,7 @@
  *	WaitForDoorbellReply - Wait for and capture a IOC handshake reply.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@howlong: How long to wait (in seconds)
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	This routine polls the IOC for a handshake reply, 16 bits at a time.
  *	Reply is cached to IOC private area large enough to hold a maximum
@@ -2619,13 +3866,13 @@
  *	Returns a negative value on failure, else size of reply in WORDS.
  */
 static int
-WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong)
+WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
 	int u16cnt = 0;
 	int failcnt = 0;
 	int t;
 	u16 *hs_reply = ioc->hs_reply;
- 	volatile MPIDefaultReply_t *mptReply = (MPIDefaultReply_t *) ioc->hs_reply;
+	volatile MPIDefaultReply_t *mptReply = (MPIDefaultReply_t *) ioc->hs_reply;
 	u16 hword;
 
 	hs_reply[0] = hs_reply[1] = hs_reply[7] = 0;
@@ -2634,12 +3881,12 @@
 	 * Get first two u16's so we can look at IOC's intended reply MsgLength
 	 */
 	u16cnt=0;
-	if ((t = WaitForDoorbellInt(ioc, howlong)) < 0) {
+	if ((t = WaitForDoorbellInt(ioc, howlong, sleepFlag)) < 0) {
 		failcnt++;
 	} else {
 		hs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
 		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
-		if ((t = WaitForDoorbellInt(ioc, 2)) < 0)
+		if ((t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
 			failcnt++;
 		else {
 			hs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
@@ -2647,7 +3894,7 @@
 		}
 	}
 
-	dhsprintk((KERN_INFO MYNAM ": %s: First handshake reply word=%08x%s\n",
+	dhsprintk((MYIOC_s_INFO_FMT "First handshake reply word=%08x%s\n",
 			ioc->name, le32_to_cpu(*(u32 *)hs_reply),
 			failcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));
 
@@ -2656,7 +3903,7 @@
 	 * reply 16 bits at a time.
 	 */
 	for (u16cnt=2; !failcnt && u16cnt < (2 * mptReply->MsgLength); u16cnt++) {
-		if ((t = WaitForDoorbellInt(ioc, 2)) < 0)
+		if ((t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
 			failcnt++;
 		hword = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
 		/* don't overflow our IOC hs_reply[] buffer! */
@@ -2665,12 +3912,12 @@
 		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 	}
 
-	if (!failcnt && (t = WaitForDoorbellInt(ioc, 2)) < 0)
+	if (!failcnt && (t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
 		failcnt++;
 	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
 	if (failcnt) {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Handshake reply failure!\n",
+		printk(MYIOC_s_ERR_FMT "Handshake reply failure!\n",
 				ioc->name);
 		return -failcnt;
 	}
@@ -2683,10 +3930,10 @@
 	}
 #endif
 
-	dmfprintk((KERN_INFO MYNAM ": %s: Got Handshake reply:\n", ioc->name));
+	dmfprintk((MYIOC_s_INFO_FMT "Got Handshake reply:\n", ioc->name));
 	DBG_DUMP_REPLY_FRAME(mptReply)
 
-	dhsprintk((KERN_INFO MYNAM ": %s: WaitForDoorbell REPLY (sz=%d)\n",
+	dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell REPLY (sz=%d)\n",
 			ioc->name, u16cnt/2));
 	return u16cnt/2;
 }
@@ -2696,115 +3943,616 @@
  *	GetLanConfigPages - Fetch LANConfig pages.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *
- *	Returns 0 for success, non-zero for failure.
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
  */
 static int
 GetLanConfigPages(MPT_ADAPTER *ioc)
 {
-	Config_t		 config_req;
-	ConfigReply_t		 config_reply;
-	LANPage0_t		*page0;
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	LANPage0_t		*ppage0_alloc;
 	dma_addr_t		 page0_dma;
-	LANPage1_t		*page1;
+	LANPage1_t		*ppage1_alloc;
 	dma_addr_t		 page1_dma;
-	int			 i;
-	int			 req_sz;
-	int			 reply_sz;
+	int			 rc = 0;
 	int			 data_sz;
+	int			 copy_sz;
 
-/* LANPage0 */
-	/*  Immediate destination (reply area)...  */
-	reply_sz = sizeof(config_reply);
-	memset(&config_reply, 0, reply_sz);
-
-	/*  Ultimate destination...  */
-	page0 = &ioc->lan_cnfg_page0;
-	data_sz = sizeof(*page0);
-	memset(page0, 0, data_sz);
-
-	/*  Request area (config_req on the stack right now!)  */
-	req_sz = sizeof(config_req);
-	memset(&config_req, 0, req_sz);
-	config_req.Function = MPI_FUNCTION_CONFIG;
-	config_req.Action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
-	/*	config_req.Header.PageVersion = 0;	*/
-	/*	config_req.Header.PageLength = 0;	*/
-	config_req.Header.PageNumber = 0;
-	config_req.Header.PageType = MPI_CONFIG_PAGETYPE_LAN;
-	/*	config_req.PageAddress = 0;		*/
-	config_req.PageBufferSGE.u.Simple.FlagsLength = cpu_to_le32(
-			((MPI_SGE_FLAGS_LAST_ELEMENT |
-			  MPI_SGE_FLAGS_END_OF_BUFFER |
-			  MPI_SGE_FLAGS_END_OF_LIST |
-			  MPI_SGE_FLAGS_SIMPLE_ELEMENT |
-			  MPI_SGE_FLAGS_SYSTEM_ADDRESS |
-			  MPI_SGE_FLAGS_32_BIT_ADDRESSING |
-			  MPI_SGE_FLAGS_32_BIT_CONTEXT) << MPI_SGE_FLAGS_SHIFT) |
-			(u32)data_sz
-	);
-	page0_dma = pci_map_single(ioc->pcidev, page0, data_sz, PCI_DMA_FROMDEVICE);
-	config_req.PageBufferSGE.u.Simple.u.Address32 = cpu_to_le32(page0_dma);
+	/* Get LAN Page 0 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_LAN;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength > 0) {
+		data_sz = hdr.PageLength * 4;
+		ppage0_alloc = (LANPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);
+		rc = -ENOMEM;
+		if (ppage0_alloc) {
+			memset((u8 *)ppage0_alloc, 0, data_sz);
+			cfg.physAddr = page0_dma;
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+			if ((rc = mpt_config(ioc, &cfg)) == 0) {
+				/* save the data */
+				copy_sz = MIN(sizeof(LANPage0_t), data_sz);
+				memcpy(&ioc->lan_cnfg_page0, ppage0_alloc, copy_sz);
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending Config request LAN_PAGE_0\n",
-			ioc->name));
+			}
 
-	i = HandShakeReqAndReply(ioc, req_sz, (u32*)&config_req,
-				reply_sz, (u16*)&config_reply, 3);
-	pci_unmap_single(ioc->pcidev, page0_dma, data_sz, PCI_DMA_FROMDEVICE);
-	if (i != 0)
-		return i;
+			pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
 
-	/*  Now byte swap the necessary LANPage0 fields  */
+			/* FIXME!
+			 *	Normalize endianness of structure data,
+			 *	by byte-swapping all > 1 byte fields!
+			 */
 
-/* LANPage1 */
-	/*  Immediate destination (reply area)...  */
-	reply_sz = sizeof(config_reply);
-	memset(&config_reply, 0, reply_sz);
-
-	/*  Ultimate destination...  */
-	page1 = &ioc->lan_cnfg_page1;
-	data_sz = sizeof(*page1);
-	memset(page1, 0, data_sz);
-
-	/*  Request area (config_req on the stack right now!)  */
-	req_sz = sizeof(config_req);
-	memset(&config_req, 0, req_sz);
-	config_req.Function = MPI_FUNCTION_CONFIG;
-	config_req.Action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
-	/*	config_req.Header.PageVersion = 0;	*/
-	/*	config_req.Header.PageLength = 0;	*/
-	config_req.Header.PageNumber = 1;
-	config_req.Header.PageType = MPI_CONFIG_PAGETYPE_LAN;
-	/*	config_req.PageAddress = 0;		*/
-	config_req.PageBufferSGE.u.Simple.FlagsLength = cpu_to_le32(
-			((MPI_SGE_FLAGS_LAST_ELEMENT |
-			  MPI_SGE_FLAGS_END_OF_BUFFER |
-			  MPI_SGE_FLAGS_END_OF_LIST |
-			  MPI_SGE_FLAGS_SIMPLE_ELEMENT |
-			  MPI_SGE_FLAGS_SYSTEM_ADDRESS |
-			  MPI_SGE_FLAGS_32_BIT_ADDRESSING |
-			  MPI_SGE_FLAGS_32_BIT_CONTEXT) << MPI_SGE_FLAGS_SHIFT) |
-			(u32)data_sz
-	);
-	page1_dma = pci_map_single(ioc->pcidev, page1, data_sz, PCI_DMA_FROMDEVICE);
-	config_req.PageBufferSGE.u.Simple.u.Address32 = cpu_to_le32(page1_dma);
+		}
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending Config request LAN_PAGE_1\n",
-			ioc->name));
+		if (rc)
+			return rc;
+	}
 
-	i = HandShakeReqAndReply(ioc, req_sz, (u32*)&config_req,
-				reply_sz, (u16*)&config_reply, 3);
-	pci_unmap_single(ioc->pcidev, page1_dma, data_sz, PCI_DMA_FROMDEVICE);
-	if (i != 0)
-		return i;
+	/* Get LAN Page 1 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 1;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_LAN;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength == 0)
+		return 0;
+
+	data_sz = hdr.PageLength * 4;
+	rc = -ENOMEM;
+	ppage1_alloc = (LANPage1_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page1_dma);
+	if (ppage1_alloc) {
+		memset((u8 *)ppage1_alloc, 0, data_sz);
+		cfg.physAddr = page1_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		if ((rc = mpt_config(ioc, &cfg)) == 0) {
+			/* save the data */
+			copy_sz = MIN(sizeof(LANPage1_t), data_sz);
+			memcpy(&ioc->lan_cnfg_page1, ppage1_alloc, copy_sz);
+		}
+
+		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage1_alloc, page1_dma);
+
+		/* FIXME!
+		 *	Normalize endianness of structure data,
+		 *	by byte-swapping all > 1 byte fields!
+		 */
+
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetFcPortPage0 - Fetch FCPort config Page0.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@portnum: IOC Port number
+ *
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetFcPortPage0(MPT_ADAPTER *ioc, int portnum)
+{
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	FCPortPage0_t		*ppage0_alloc;
+	FCPortPage0_t		*pp0dest;
+	dma_addr_t		 page0_dma;
+	int			 data_sz;
+	int			 copy_sz;
+	int			 rc;
+
+	/* Get FCPort Page 0 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = portnum;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength == 0)
+		return 0;
+
+	data_sz = hdr.PageLength * 4;
+	rc = -ENOMEM;
+	ppage0_alloc = (FCPortPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);
+	if (ppage0_alloc) {
+		memset((u8 *)ppage0_alloc, 0, data_sz);
+		cfg.physAddr = page0_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		if ((rc = mpt_config(ioc, &cfg)) == 0) {
+			/* save the data */
+			pp0dest = &ioc->fc_port_page0[portnum];
+			copy_sz = MIN(sizeof(FCPortPage0_t), data_sz);
+			memcpy(pp0dest, ppage0_alloc, copy_sz);
+
+			/*
+			 *	Normalize endianness of structure data,
+			 *	by byte-swapping all > 1 byte fields!
+			 */
+			pp0dest->Flags = le32_to_cpu(pp0dest->Flags);
+			pp0dest->PortIdentifier = le32_to_cpu(pp0dest->PortIdentifier);
+			pp0dest->WWNN.Low = le32_to_cpu(pp0dest->WWNN.Low);
+			pp0dest->WWNN.High = le32_to_cpu(pp0dest->WWNN.High);
+			pp0dest->WWPN.Low = le32_to_cpu(pp0dest->WWPN.Low);
+			pp0dest->WWPN.High = le32_to_cpu(pp0dest->WWPN.High);
+			pp0dest->SupportedServiceClass = le32_to_cpu(pp0dest->SupportedServiceClass);
+			pp0dest->SupportedSpeeds = le32_to_cpu(pp0dest->SupportedSpeeds);
+			pp0dest->CurrentSpeed = le32_to_cpu(pp0dest->CurrentSpeed);
+			pp0dest->MaxFrameSize = le32_to_cpu(pp0dest->MaxFrameSize);
+			pp0dest->FabricWWNN.Low = le32_to_cpu(pp0dest->FabricWWNN.Low);
+			pp0dest->FabricWWNN.High = le32_to_cpu(pp0dest->FabricWWNN.High);
+			pp0dest->FabricWWPN.Low = le32_to_cpu(pp0dest->FabricWWPN.Low);
+			pp0dest->FabricWWPN.High = le32_to_cpu(pp0dest->FabricWWPN.High);
+			pp0dest->DiscoveredPortsCount = le32_to_cpu(pp0dest->DiscoveredPortsCount);
+			pp0dest->MaxInitiators = le32_to_cpu(pp0dest->MaxInitiators);
+
+		}
+
+		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetIoUnitPage2 - Retrieve BIOS version and boot order information.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *
+ *	Returns: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetIoUnitPage2(MPT_ADAPTER *ioc)
+{
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	IOUnitPage2_t		*ppage_alloc;
+	dma_addr_t		 page_dma;
+	int			 data_sz;
+	int			 rc;
+
+	/* Get the page header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 2;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_IO_UNIT;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength == 0)
+		return 0;
+
+	/* Read the config page */
+	data_sz = hdr.PageLength * 4;
+	rc = -ENOMEM;
+	ppage_alloc = (IOUnitPage2_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page_dma);
+	if (ppage_alloc) {
+		memset((u8 *)ppage_alloc, 0, data_sz);
+		cfg.physAddr = page_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		/* If Good, save data */
+		if ((rc = mpt_config(ioc, &cfg)) == 0)
+			ioc->biosVersion = le32_to_cpu(ppage_alloc->BiosVersion);
+
+		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage_alloc, page_dma);
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mpt_GetScsiPortSettings - read SCSI Port Page 0 and 2
+ *	@ioc: Pointer to a Adapter Strucutre
+ *	@portnum: IOC port number
+ *
+ *	Return: -EFAULT if read of config page header fails
+ *			or if no nvram
+ *	If read of SCSI Port Page 0 fails,
+ *		NVRAM = MPT_HOST_NVRAM_INVALID  (0xFFFFFFFF)
+ *		Adapter settings: async, narrow
+ *		Return 1
+ *	If read of SCSI Port Page 2 fails,
+ *		Adapter settings valid
+ *		NVRAM = MPT_HOST_NVRAM_INVALID  (0xFFFFFFFF)
+ *		Return 1
+ *	Else
+ *		Both valid
+ *		Return 0
+ *	CHECK - what type of locking mechanisms should be used????
+ */
+static int
+mpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum)
+{
+	u8			*pbuf = NULL;
+	dma_addr_t		 buf_dma;
+	CONFIGPARMS		 cfg;
+	ConfigPageHeader_t	 header;
+	int			 ii;
+	int			 data, rc = 0;
+
+	/* Allocate memory 
+	 */
+	if (!ioc->spi_data.nvram) {
+		int	 sz;
+		u8	*mem;
+		sz = MPT_MAX_SCSI_DEVICES * sizeof(int);
+		mem = kmalloc(sz, GFP_ATOMIC);
+		if (mem == NULL)
+			return -EFAULT;
+
+		ioc->spi_data.nvram = (int *) mem;
+
+		dprintk((MYIOC_s_INFO_FMT "SCSI device NVRAM settings @ %p, sz=%d\n",
+			ioc->name, ioc->spi_data.nvram, sz));
+	}
+
+	/* Invalidate NVRAM information
+	 */
+	for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+		ioc->spi_data.nvram[ii] = MPT_HOST_NVRAM_INVALID;
+	}
+
+	/* Read SPP0 header, allocate memory, then read page.
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 0;
+	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;
+	cfg.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = portnum;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;	/* use default */
+	if (mpt_config(ioc, &cfg) != 0)
+		 return -EFAULT;
+
+	if (header.PageLength > 0) {
+		pbuf = pci_alloc_consistent(ioc->pcidev, header.PageLength * 4, &buf_dma);
+		if (pbuf) {
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+			cfg.physAddr = buf_dma;
+			if (mpt_config(ioc, &cfg) != 0) {
+				ioc->spi_data.maxBusWidth = MPT_NARROW;
+				ioc->spi_data.maxSyncOffset = 0;
+				ioc->spi_data.minSyncFactor = MPT_ASYNC;
+				ioc->spi_data.busType = MPT_HOST_BUS_UNKNOWN;
+				rc = 1;
+			} else {
+				/* Save the Port Page 0 data
+				 */
+				SCSIPortPage0_t  *pPP0 = (SCSIPortPage0_t  *) pbuf;
+				pPP0->Capabilities = le32_to_cpu(pPP0->Capabilities);
+				pPP0->PhysicalInterface = le32_to_cpu(pPP0->PhysicalInterface);
+
+				ioc->spi_data.maxBusWidth = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_WIDE ? 1 : 0;
+				data = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MAX_SYNC_OFFSET_MASK;
+				if (data) {
+					ioc->spi_data.maxSyncOffset = (u8) (data >> 16);
+					data = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
+					ioc->spi_data.minSyncFactor = (u8) (data >> 8);
+				} else {
+					ioc->spi_data.maxSyncOffset = 0;
+					ioc->spi_data.minSyncFactor = MPT_ASYNC;
+				}
+
+				ioc->spi_data.busType = pPP0->PhysicalInterface & MPI_SCSIPORTPAGE0_PHY_SIGNAL_TYPE_MASK;
+
+				/* Update the minSyncFactor based on bus type.
+				 */
+				if ((ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_HVD) ||
+					(ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_SE))  {
+
+					if (ioc->spi_data.minSyncFactor < MPT_ULTRA)
+						ioc->spi_data.minSyncFactor = MPT_ULTRA;
+				}
+			}
+			if (pbuf) {
+				pci_free_consistent(ioc->pcidev, header.PageLength * 4, pbuf, buf_dma);
+				pbuf = NULL;
+			}
+		}
+	}
+
+	/* SCSI Port Page 2 - Read the header then the page.
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 2;
+	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;
+	cfg.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = portnum;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	if (mpt_config(ioc, &cfg) != 0)
+		return -EFAULT;
+
+	if (header.PageLength > 0) {
+		/* Allocate memory and read SCSI Port Page 2
+		 */
+		pbuf = pci_alloc_consistent(ioc->pcidev, header.PageLength * 4, &buf_dma);
+		if (pbuf) {
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_NVRAM;
+			cfg.physAddr = buf_dma;
+			if (mpt_config(ioc, &cfg) != 0) {
+				/* Nvram data is left with INVALID mark
+				 */
+				rc = 1;
+			} else {
+				SCSIPortPage2_t *pPP2 = (SCSIPortPage2_t  *) pbuf;
+				MpiDeviceInfo_t	*pdevice = NULL;
+
+				/* Save the Port Page 2 data
+				 * (reformat into a 32bit quantity)
+				 */
+				for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+					pdevice = &pPP2->DeviceSettings[ii];
+					data = (le16_to_cpu(pdevice->DeviceFlags) << 16) |
+						(pdevice->SyncFactor << 8) | pdevice->Timeout;
+					ioc->spi_data.nvram[ii] = data;
+				}
+			}
+
+			pci_free_consistent(ioc->pcidev, header.PageLength * 4, pbuf, buf_dma);
+			pbuf = NULL;
+		}
+	}
 
-	/*  Now byte swap the necessary LANPage1 fields  */
+	/* Update Adapter limits with those from NVRAM
+	 * Comment: Don't need to do this. Target performance
+	 * parameters will never exceed the adapters limits.
+	 */
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mpt_readScsiDevicePageHeaders - save version and length of SDP1
+ *	@ioc: Pointer to a Adapter Strucutre
+ *	@portnum: IOC port number
+ *
+ *	Return: -EFAULT if read of config page header fails
+ *		or 0 if success.
+ */
+static int
+mpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum)
+{
+	CONFIGPARMS		 cfg;
+	ConfigPageHeader_t	 header;
+
+	/* Read the SCSI Device Page 1 header
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 1;
+	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+	cfg.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = portnum;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;
+	if (mpt_config(ioc, &cfg) != 0)
+		 return -EFAULT;
+
+	ioc->spi_data.sdp1version = cfg.hdr->PageVersion;
+	ioc->spi_data.sdp1length = cfg.hdr->PageLength;
+
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 0;
+	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+	if (mpt_config(ioc, &cfg) != 0)
+		 return -EFAULT;
+
+	ioc->spi_data.sdp0version = cfg.hdr->PageVersion;
+	ioc->spi_data.sdp0length = cfg.hdr->PageLength;
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
+ *	mpt_findImVolumes - Identify IDs of hidden disks and RAID Volumes 
+ *	@ioc: Pointer to a Adapter Strucutre
+ *	@portnum: IOC port number
+ *
+ *	Return:
+ *	0 on success
+ *	-EFAULT if read of config page header fails or data pointer not NULL
+ *	-ENOMEM if pci_alloc failed
+ */
+static int
+mpt_findImVolumes(MPT_ADAPTER *ioc)
+{
+	IOCPage2_t		*pIoc2 = NULL;
+	IOCPage3_t		*pIoc3 = NULL;
+	ConfigPageIoc2RaidVol_t	*pIocRv = NULL;
+	u8			*mem;
+	dma_addr_t		 ioc2_dma;
+	dma_addr_t		 ioc3_dma;
+	CONFIGPARMS		 cfg;
+	ConfigPageHeader_t	 header;
+	int			 jj;
+	int			 rc = 0;
+	int			 iocpage2sz;
+	int			 iocpage3sz = 0;
+	u8			 nVols, nPhys;
+	u8			 vid, vbus, vioc;
+
+	if (ioc->spi_data.pIocPg3)
+		return -EFAULT;	
+
+	/* Read IOCP2 header then the page.
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 2;
+	header.PageType = MPI_CONFIG_PAGETYPE_IOC;
+	cfg.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;
+	if (mpt_config(ioc, &cfg) != 0)
+		 return -EFAULT;
+
+	if (header.PageLength == 0)
+		return -EFAULT;
+
+	iocpage2sz = header.PageLength * 4;
+	pIoc2 = pci_alloc_consistent(ioc->pcidev, iocpage2sz, &ioc2_dma);
+	if (!pIoc2)
+		return -ENOMEM;
+
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+	cfg.physAddr = ioc2_dma;
+	if (mpt_config(ioc, &cfg) != 0)
+		goto done_and_free;
+
+	/* Identify RAID Volume Id's */
+	nVols = pIoc2->NumActiveVolumes;
+	if ( nVols == 0) {
+		/* No RAID Volumes.  Done.
+		 */
+	} else {
+		/* At least 1 RAID Volume
+		 */
+		pIocRv = pIoc2->RaidVolume;
+		ioc->spi_data.isRaid = 0;
+		for (jj = 0; jj < nVols; jj++, pIocRv++) {
+			vid = pIocRv->VolumeID;
+			vbus = pIocRv->VolumeBus;
+			vioc = pIocRv->VolumeIOC;
+
+			/* find the match
+			 */
+			if (vbus == 0) {
+				ioc->spi_data.isRaid |= (1 << vid);
+			} else {
+				/* Error! Always bus 0
+				 */
+			}
+		}
+	}
+
+	/* Identify Hidden Physical Disk Id's */
+	nPhys = pIoc2->NumActivePhysDisks;
+	if (nPhys == 0) {
+		/* No physical disks. Done.
+		 */
+	} else {
+		/* There is at least one physical disk.
+		 * Read and save IOC Page 3
+		 */
+		header.PageVersion = 0;
+		header.PageLength = 0;
+		header.PageNumber = 3;
+		header.PageType = MPI_CONFIG_PAGETYPE_IOC;
+		cfg.hdr = &header;
+		cfg.physAddr = -1;
+		cfg.pageAddr = 0;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+		cfg.dir = 0;
+		cfg.timeout = 0;
+		if (mpt_config(ioc, &cfg) != 0)
+			goto done_and_free;
+
+		if (header.PageLength == 0)
+			goto done_and_free;
+
+		/* Read Header good, alloc memory
+		 */
+		iocpage3sz = header.PageLength * 4;
+		pIoc3 = pci_alloc_consistent(ioc->pcidev, iocpage3sz, &ioc3_dma);
+		if (!pIoc3)
+			goto done_and_free;
+
+		/* Read the Page and save the data
+		 * into malloc'd memory.
+		 */
+		cfg.physAddr = ioc3_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+		if (mpt_config(ioc, &cfg) == 0) {
+			mem = kmalloc(iocpage3sz, GFP_ATOMIC);
+			if (mem) {
+				memcpy(mem, (u8 *)pIoc3, iocpage3sz);
+				ioc->spi_data.pIocPg3 = (IOCPage3_t *) mem;
+			}
+		}
+	}
+
+done_and_free:
+	if (pIoc2) {
+		pci_free_consistent(ioc->pcidev, iocpage2sz, pIoc2, ioc2_dma);
+		pIoc2 = NULL;
+	}
+
+	if (pIoc3) {
+		pci_free_consistent(ioc->pcidev, iocpage3sz, pIoc3, ioc3_dma);
+		pIoc3 = NULL;
+	}
+
+	return rc;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
  *	SendEventNotification - Send EventNotification (on or off) request
  *	to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -2817,13 +4565,13 @@
 
 	evnp = (EventNotification_t *) mpt_get_msg_frame(mpt_base_index, ioc->id);
 	if (evnp == NULL) {
-		dprintk((KERN_WARNING MYNAM ": %s: WARNING - Unable to allocate a event request frame!\n",
+		dprintk((MYIOC_s_WARN_FMT "Unable to allocate event request frame!\n",
 				ioc->name));
 		return 0;
 	}
 	memset(evnp, 0, sizeof(*evnp));
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending EventNotification(%d)\n", ioc->name, EvSwitch));
+	dprintk((MYIOC_s_INFO_FMT "Sending EventNotification(%d)\n", ioc->name, EvSwitch));
 
 	evnp->Function = MPI_FUNCTION_EVENT_NOTIFICATION;
 	evnp->ChainOffset = 0;
@@ -2847,13 +4595,13 @@
 	EventAck_t	*pAck;
 
 	if ((pAck = (EventAck_t *) mpt_get_msg_frame(mpt_base_index, ioc->id)) == NULL) {
-		printk(KERN_WARNING MYNAM ": %s: WARNING - Unable to allocate event ACK request frame!\n",
+		printk(MYIOC_s_WARN_FMT "Unable to allocate event ACK request frame!\n",
 				ioc->name);
 		return -1;
 	}
 	memset(pAck, 0, sizeof(*pAck));
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending EventAck\n", ioc->name));
+	dprintk((MYIOC_s_INFO_FMT "Sending EventAck\n", ioc->name));
 
 	pAck->Function     = MPI_FUNCTION_EVENT_ACK;
 	pAck->ChainOffset  = 0;
@@ -2866,27 +4614,226 @@
 	return 0;
 }
 
-#ifdef CONFIG_PROC_FS		/* { */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mpt_config - Generic function to issue config message
+ *	@ioc - Pointer to an adapter structure
+ *	@cfg - Pointer to a configuration structure. Struct contains
+ *		action, page address, direction, physical address
+ *		and pointer to a configuration page header
+ *		Page header is updated.
+ *
+ *	Returns 0 for success
+ *	-EPERM if not allowed due to ISR context
+ *	-EAGAIN if no msg frames currently available
+ *	-EFAULT for non-successful reply or no reply (timeout)
+ */
+int
+mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *pCfg)
+{
+	Config_t	*pReq;
+	MPT_FRAME_HDR	*mf;
+	unsigned long	 flags;
+	int		 ii, rc;
+	int		 flagsLength;
+	int		 in_isr;
+
+	/* (Bugzilla:fibrebugs, #513)
+	 * Bug fix (part 1)!  20010905 -sralston
+	 *	Prevent calling wait_event() (below), if caller happens
+	 *	to be in ISR context, because that is fatal!
+	 */
+	in_isr = in_interrupt();
+	if (in_isr) {
+		dprintk((MYIOC_s_WARN_FMT "Config request not allowed in ISR context!\n",
+				ioc->name));
+		return -EPERM;
+	}
+
+	/* Get and Populate a free Frame
+	 */
+	if ((mf = mpt_get_msg_frame(mpt_base_index, ioc->id)) == NULL) {
+		dprintk((MYIOC_s_WARN_FMT "mpt_config: no msg frames!\n",
+				ioc->name));
+		return -EAGAIN;
+	}
+	pReq = (Config_t *)mf;
+	pReq->Action = pCfg->action;
+	pReq->Reserved = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_CONFIG;
+	pReq->Reserved1[0] = 0;
+	pReq->Reserved1[1] = 0;
+	pReq->Reserved1[2] = 0;
+	pReq->MsgFlags = 0;
+	for (ii=0; ii < 8; ii++)
+		pReq->Reserved2[ii] = 0;
+
+	pReq->Header.PageVersion = pCfg->hdr->PageVersion;
+	pReq->Header.PageLength = pCfg->hdr->PageLength;
+	pReq->Header.PageNumber = pCfg->hdr->PageNumber;
+	pReq->Header.PageType = (pCfg->hdr->PageType & MPI_CONFIG_PAGETYPE_MASK);
+	pReq->PageAddress = cpu_to_le32(pCfg->pageAddr);
+
+	/* Add a SGE to the config request.
+	 */
+	if (pCfg->dir)
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
+	else
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
+
+	flagsLength |= pCfg->hdr->PageLength * 4;
+
+	mpt_add_sge((char *)&pReq->PageBufferSGE, flagsLength, pCfg->physAddr);
+
+	dprintk((MYIOC_s_INFO_FMT "Sending Config request type %d, page %d and action %d\n",
+		ioc->name, pReq->Header.PageType, pReq->Header.PageNumber, pReq->Action));
+
+	/* Append pCfg pointer to end of mf
+	 */
+	*((void **) (((u8 *) mf) + (ioc->req_sz - sizeof(void *)))) =  (void *) pCfg;
+
+	/* Initalize the timer
+	 */
+	init_timer(&pCfg->timer);
+	pCfg->timer.data = (unsigned long) ioc;
+	pCfg->timer.function = mpt_timer_expired;
+	pCfg->wait_done = 0;
+
+	/* Set the timer; ensure 10 second minimum */
+	if (pCfg->timeout < 10)
+		pCfg->timer.expires = jiffies + HZ*10;
+	else
+		pCfg->timer.expires = jiffies + HZ*pCfg->timeout;
+
+	/* Add to end of Q, set timer and then issue this command */
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	Q_ADD_TAIL(&ioc->configQ.head, &pCfg->linkage, Q_ITEM);
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+	add_timer(&pCfg->timer);
+	mpt_put_msg_frame(mpt_base_index, ioc->id, mf);
+	wait_event(mpt_waitq, pCfg->wait_done);
+
+	/* mf has been freed - do not access */
+
+	rc = pCfg->status;
+
+	return rc;
+}
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	procfs (%MPT_PROCFS_MPTBASEDIR/...) support stuff...
+ *	mpt_timer_expired - Call back for timer process.
+ *	Used only internal config functionality.
+ *	@data: Pointer to MPT_SCSI_HOST recast as an unsigned long
  */
+static void
+mpt_timer_expired(unsigned long data)
+{
+	MPT_ADAPTER *ioc = (MPT_ADAPTER *) data;
+
+	dprintk((MYIOC_s_WARN_FMT "mpt_timer_expired! \n", ioc->name));
+
+	/* Perform a FW reload */
+	if (mpt_HardResetHandler(ioc, NO_SLEEP) < 0)
+		printk(MYIOC_s_WARN_FMT "Firmware Reload FAILED!\n", ioc->name);
+
+	/* No more processing.
+	 * Hard reset clean-up will wake up
+	 * process and free all resources.
+	 */
+	dprintk((MYIOC_s_WARN_FMT "mpt_timer_expired complete!\n", ioc->name));
 
-#define PROC_MPT_READ_RETURN(page,start,off,count,eof,len) \
-{ \
-	len -= off;			\
-	if (len < count) {		\
-		*eof = 1;		\
-		if (len <= 0)		\
-			return 0;	\
-	} else				\
-		len = count;		\
-	*start = page + off;		\
-	return len;			\
+	return;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
+ *	mpt_ioc_reset - Base cleanup for hard reset
+ *	@ioc: Pointer to the adapter structure
+ *	@reset_phase: Indicates pre- or post-reset functionality
+ *
+ *	Remark: Free's resources with internally generated commands.
+ */
+static int
+mpt_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
+{
+	CONFIGPARMS *pCfg;
+	unsigned long flags;
+
+	dprintk((KERN_WARNING MYNAM
+			": IOC %s_reset routed to MPT base driver!\n",
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+
+	if (reset_phase == MPT_IOC_PRE_RESET) {
+		/* If the internal config Q is not empty -
+		 * delete timer. MF resources will be freed when
+		 * the FIFO's are primed.
+		 */
+		spin_lock_irqsave(&ioc->FreeQlock, flags);
+		if (! Q_IS_EMPTY(&ioc->configQ)){
+			pCfg = (CONFIGPARMS *)ioc->configQ.head;
+			do {
+				del_timer(&pCfg->timer);
+				pCfg = (CONFIGPARMS *) (pCfg->linkage.forw);
+			} while (pCfg != (CONFIGPARMS *)&ioc->configQ);
+		}
+		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+	} else {
+		CONFIGPARMS *pNext;
+
+		/* Search the configQ for internal commands. 
+		 * Flush the Q, and wake up all suspended threads.
+		 */
+#if 1
+		spin_lock_irqsave(&ioc->FreeQlock, flags);
+		if (! Q_IS_EMPTY(&ioc->configQ)){
+			pCfg = (CONFIGPARMS *)ioc->configQ.head;
+			do {
+				pNext = (CONFIGPARMS *) pCfg->linkage.forw;
+
+				Q_DEL_ITEM(&pCfg->linkage);
+
+				pCfg->status = MPT_CONFIG_ERROR;
+				pCfg->wait_done = 1;
+				wake_up(&mpt_waitq);
+
+				pCfg = pNext;
+			} while (pCfg != (CONFIGPARMS *)&ioc->configQ);
+		}
+		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+#else
+		while (1) {
+			spin_lock_irqsave(&ioc->FreeQlock, flags);
+			if (! Q_IS_EMPTY(&ioc->configQ)){
+				spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+				break;
+			}
+			pCfg = (CONFIGPARMS *)ioc->configQ.head;
+
+			Q_DEL_ITEM(&pCfg->linkage);
+			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+			pCfg->status = MPT_CONFIG_ERROR;
+			pCfg->wait_done = 1;
+			wake_up(&mpt_waitq);
+		}
+#endif
+	}
+
+	return 1;		/* currently means nothing really */
+}
+
+
+#ifdef CONFIG_PROC_FS		/* { */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	procfs (%MPT_PROCFS_MPTBASEDIR/...) support stuff...
+ */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
  *	procmpt_create - Create %MPT_PROCFS_MPTBASEDIR entries.
  *
  *	Returns 0 for success, non-zero for failure.
@@ -2894,71 +4841,62 @@
 static int
 procmpt_create(void)
 {
-	MPT_ADAPTER *ioc;
-	struct proc_dir_entry *ent;
-	int errcnt = 0;
+	MPT_ADAPTER		*ioc;
+	struct proc_dir_entry	*ent;
+	int	 ii;
 
 	/*
-	 * 	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
-	 * 	(single level) to multi level (e.g. "driver/message/fusion")
-	 * 	something here needs to change.  -sralston
+	 *	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
+	 *	(single level) to multi level (e.g. "driver/message/fusion")
+	 *	something here needs to change.  -sralston
 	 */
-	procmpt_root_dir = CREATE_PROCDIR_ENTRY(MPT_PROCFS_MPTBASEDIR, NULL);
-	if (procmpt_root_dir == NULL)
+	mpt_proc_root_dir = proc_mkdir(MPT_PROCFS_MPTBASEDIR, NULL);
+	if (mpt_proc_root_dir == NULL)
 		return -ENOTDIR;
 
-	if ((ioc = mpt_adapter_find_first()) != NULL) {
-		ent = create_proc_read_entry(MPT_PROCFS_SUMMARY_NODE, 0, NULL, procmpt_read_summary, NULL);
-		if (ent == NULL) {
-			printk(KERN_WARNING MYNAM ": WARNING - Could not create %s entry!\n",
-					MPT_PROCFS_SUMMARY_PATHNAME);
-			errcnt++;
+	for (ii=0; ii < MPT_PROC_ENTRIES; ii++) {
+		ent = create_proc_entry(mpt_proc_list[ii].name,
+				S_IFREG|S_IRUGO, mpt_proc_root_dir);
+		if (!ent) {
+			printk(KERN_WARNING MYNAM
+					": WARNING - Could not create /proc/mpt/%s entry\n",
+					mpt_proc_list[ii].name);
+			continue;
 		}
+		ent->read_proc = mpt_proc_list[ii].f;
+		ent->data      = NULL;
 	}
 
+	ioc = mpt_adapter_find_first();
 	while (ioc != NULL) {
-		char pname[32];
-		int namelen;
+		struct proc_dir_entry	*dent;
 		/*
 		 *  Create "/proc/mpt/iocN" subdirectory entry for each MPT adapter.
 		 */
-		namelen = sprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);
-		if ((ent = CREATE_PROCDIR_ENTRY(pname, NULL)) != NULL) {
+		if ((dent = proc_mkdir(ioc->name, mpt_proc_root_dir)) != NULL) {
 			/*
-			 *  And populate it with: "summary" and "dbg" file entries.
+			 *  And populate it with mpt_ioc_proc_list[] entries.
 			 */
-			(void) sprintf(pname+namelen, "/summary");
-			ent = create_proc_read_entry(pname, 0, NULL, procmpt_read_summary, ioc);
-			if (ent == NULL) {
-				errcnt++;
-				printk(KERN_WARNING MYNAM ": %s: WARNING - Could not create /proc/%s entry!\n",
-						ioc->name, pname);
-			}
-//#ifdef MPT_DEBUG
-			/* DEBUG aid! */
-			(void) sprintf(pname+namelen, "/dbg");
-			ent = create_proc_read_entry(pname, 0, NULL, procmpt_read_dbg, ioc);
-			if (ent == NULL) {
-				errcnt++;
-				printk(KERN_WARNING MYNAM ": %s: WARNING - Could not create /proc/%s entry!\n",
-						ioc->name, pname);
+			for (ii=0; ii < MPT_IOC_PROC_ENTRIES; ii++) {
+				ent = create_proc_entry(mpt_ioc_proc_list[ii].name,
+						S_IFREG|S_IRUGO, dent);
+				if (!ent) {
+					printk(KERN_WARNING MYNAM
+							": WARNING - Could not create /proc/mpt/%s/%s entry!\n",
+							ioc->name,
+							mpt_ioc_proc_list[ii].name);
+					continue;
+				}
+				ent->read_proc = mpt_ioc_proc_list[ii].f;
+				ent->data      = ioc;
 			}
-//#endif
 		} else {
-			errcnt++;
-			printk(KERN_WARNING MYNAM ": %s: WARNING - Could not create /proc/%s entry!\n",
-					ioc->name, pname);
-
+			printk(MYIOC_s_WARN_FMT "Could not create /proc/mpt/%s subdir entry!\n",
+					ioc->name, mpt_ioc_proc_list[ii].name);
 		}
-
 		ioc = mpt_adapter_find_next(ioc);
 	}
 
-	if (errcnt) {
-//		remove_proc_entry("mpt", 0);
-		return -ENOTDIR;
-	}
-
 	return 0;
 }
 
@@ -2971,44 +4909,44 @@
 static int
 procmpt_destroy(void)
 {
-	MPT_ADAPTER *ioc;
+	MPT_ADAPTER	*ioc;
+	int		 ii;
 
-	if (!procmpt_root_dir)
+	if (!mpt_proc_root_dir)
 		return 0;
 
 	/*
-	 * 	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
-	 * 	(single level) to multi level (e.g. "driver/message/fusion")
-	 * 	something here needs to change.  -sralston
+	 *	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
+	 *	(single level) to multi level (e.g. "driver/message/fusion")
+	 *	something here needs to change.  -sralston
 	 */
 
 	ioc = mpt_adapter_find_first();
-	if (ioc != NULL) {
-		remove_proc_entry(MPT_PROCFS_SUMMARY_NODE, 0);
-	}
-
 	while (ioc != NULL) {
 		char pname[32];
 		int namelen;
+
+		namelen = sprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);
+
 		/*
 		 *  Tear down each "/proc/mpt/iocN" subdirectory.
 		 */
-		namelen = sprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);
-		(void) sprintf(pname+namelen, "/summary");
-		remove_proc_entry(pname, 0);
-//#ifdef MPT_DEBUG
-		(void) sprintf(pname+namelen, "/dbg");
-		remove_proc_entry(pname, 0);
-//#endif
-		(void) sprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);
-		remove_proc_entry(pname, 0);
+		for (ii=0; ii < MPT_IOC_PROC_ENTRIES; ii++) {
+			(void) sprintf(pname+namelen, "/%s", mpt_ioc_proc_list[ii].name);
+			remove_proc_entry(pname, NULL);
+		}
+
+		remove_proc_entry(ioc->name, mpt_proc_root_dir);
 
 		ioc = mpt_adapter_find_next(ioc);
 	}
 
-	if (atomic_read((atomic_t *)&procmpt_root_dir->count) == 0) {
-		remove_proc_entry(MPT_PROCFS_MPTBASEDIR, 0);
-		procmpt_root_dir = NULL;
+	for (ii=0; ii < MPT_PROC_ENTRIES; ii++)
+		remove_proc_entry(mpt_proc_list[ii].name, mpt_proc_root_dir);
+
+	if (atomic_read((atomic_t *)&mpt_proc_root_dir->count) == 0) {
+		remove_proc_entry(MPT_PROCFS_MPTBASEDIR, NULL);
+		mpt_proc_root_dir = NULL;
 		return 0;
 	}
 
@@ -3016,23 +4954,23 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	procmpt_read_summary - Handle read request from /proc/mpt/summary
+/*
+ *	procmpt_summary_read - Handle read request from /proc/mpt/summary
  *	or from /proc/mpt/iocN/summary.
- *	@page: Pointer to area to write information
+ *	@buf: Pointer to area to write information
  *	@start: Pointer to start pointer
- *	@off: Offset to start writing
- *	@count: 
+ *	@offset: Offset to start writing
+ *	@request:
  *	@eof: Pointer to EOF integer
- *	@data: Pointer 
+ *	@data: Pointer
  *
- *	Returns numbers of characters written to process performing the read.
+ *	Returns number of characters written to process performing the read.
  */
 static int
-procmpt_read_summary(char *page, char **start, off_t off, int count, int *eof, void *data)
+procmpt_summary_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
 {
 	MPT_ADAPTER *ioc;
-	char *out = page;
+	char *out = buf;
 	int len;
 
 	if (data == NULL)
@@ -3040,84 +4978,196 @@
 	else
 		ioc = data;
 
-// Too verbose!
-//	out += sprintf(out, "Attached Fusion MPT I/O Controllers:%s\n", ioc ? "" : " none");
-
 	while (ioc) {
 		int	more = 0;
 
-// Too verbose!
-//		mpt_print_ioc_facts(ioc, out, &more, 0);
 		mpt_print_ioc_summary(ioc, out, &more, 0, 1);
 
 		out += more;
-		if ((out-page) >= count) {
+		if ((out-buf) >= request) {
 			break;
 		}
 
 		if (data == NULL)
 			ioc = mpt_adapter_find_next(ioc);
 		else
-			ioc = NULL;				/* force exit for iocN */
+			ioc = NULL;		/* force exit for iocN */
 	}
-	len = out - page;
+	len = out - buf;
 
-	PROC_MPT_READ_RETURN(page,start,off,count,eof,len);
+	MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len);
 }
 
-// debug aid!
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	procmpt_read_dbg - Handle read request from /proc/mpt/iocN/dbg.
- *	@page: Pointer to area to write information
+/*
+ *	procmpt_version_read - Handle read request from /proc/mpt/version.
+ *	@buf: Pointer to area to write information
  *	@start: Pointer to start pointer
- *	@off: Offset to start writing
- *	@count: 
+ *	@offset: Offset to start writing
+ *	@request:
  *	@eof: Pointer to EOF integer
- *	@data: Pointer 
+ *	@data: Pointer
  *
- *	Returns numbers of characters written to process performing the read.
+ *	Returns number of characters written to process performing the read.
  */
 static int
-procmpt_read_dbg(char *page, char **start, off_t off, int count, int *eof, void *data)
+procmpt_version_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
 {
-	MPT_ADAPTER *ioc;
-	char *out = page;
-	int len;
+	int	 ii;
+	int	 scsi, lan, ctl, targ, dmp;
+	char	*drvname;
+	int	 len;
+
+	len = sprintf(buf, "%s-%s\n", "mptlinux", MPT_LINUX_VERSION_COMMON);
+	len += sprintf(buf+len, "  Fusion MPT base driver\n");
+
+	scsi = lan = ctl = targ = dmp = 0;
+	for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+		drvname = NULL;
+		if (MptCallbacks[ii]) {
+			switch (MptDriverClass[ii]) {
+			case MPTSCSIH_DRIVER:
+				if (!scsi++) drvname = "SCSI host";
+				break;
+			case MPTLAN_DRIVER:
+				if (!lan++) drvname = "LAN";
+				break;
+			case MPTSTM_DRIVER:
+				if (!targ++) drvname = "SCSI target";
+				break;
+			case MPTCTL_DRIVER:
+				if (!ctl++) drvname = "ioctl";
+				break;
+			case MPTDMP_DRIVER:
+				if (!dmp++) drvname = "DMP";
+				break;
+			}
 
-	ioc = data;
+			if (drvname)
+				len += sprintf(buf+len, "  Fusion MPT %s driver\n", drvname);
+			/*
+			 *	Handle isense special case, because it
+			 *	doesn't do a formal mpt_register call.
+			 */
+			if (isense_idx == ii)
+				len += sprintf(buf+len, "  Fusion MPT isense driver\n");
+		} else
+			break;
+	}
 
-	while (ioc) {
-		int	more = 0;
+	MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len);
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	procmpt_iocinfo_read - Handle read request from /proc/mpt/iocN/info.
+ *	@buf: Pointer to area to write information
+ *	@start: Pointer to start pointer
+ *	@offset: Offset to start writing
+ *	@request:
+ *	@eof: Pointer to EOF integer
+ *	@data: Pointer
+ *
+ *	Returns number of characters written to process performing the read.
+ */
+static int
+procmpt_iocinfo_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
+{
+	MPT_ADAPTER	*ioc = data;
+	int		 len;
+	char		 expVer[32];
+	int		 sz;
+	int		 p;
 
-		mpt_print_ioc_facts(ioc, out, &more, 0);
+	mpt_get_fw_exp_ver(expVer, ioc);
 
-		out += more;
-		if ((out-page) >= count) {
-			break;
+	len = sprintf(buf, "%s:", ioc->name);
+	if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)
+		len += sprintf(buf+len, "  (f/w download boot flag set)");
+//	if (ioc->facts.IOCExceptions & MPI_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL)
+//		len += sprintf(buf+len, "  CONFIG_CHECKSUM_FAIL!");
+
+	len += sprintf(buf+len, "\n  ProductID = 0x%04x (%s)\n",
+			ioc->facts.ProductID,
+			ioc->prod_name);
+	len += sprintf(buf+len, "  FWVersion = 0x%08x%s", ioc->facts.FWVersion.Word, expVer);
+	if (ioc->facts.FWImageSize)
+		len += sprintf(buf+len, " (fw_size=%d)", ioc->facts.FWImageSize);
+	len += sprintf(buf+len, "\n  MsgVersion = 0x%04x\n", ioc->facts.MsgVersion);
+	len += sprintf(buf+len, "  FirstWhoInit = 0x%02x\n", ioc->FirstWhoInit);
+	len += sprintf(buf+len, "  EventState = 0x%02x\n", ioc->facts.EventState);
+
+	len += sprintf(buf+len, "  CurrentHostMfaHighAddr = 0x%08x\n",
+			ioc->facts.CurrentHostMfaHighAddr);
+	len += sprintf(buf+len, "  CurrentSenseBufferHighAddr = 0x%08x\n",
+			ioc->facts.CurrentSenseBufferHighAddr);
+
+	len += sprintf(buf+len, "  MaxChainDepth = 0x%02x frames\n", ioc->facts.MaxChainDepth);
+	len += sprintf(buf+len, "  MinBlockSize = 0x%02x bytes\n", 4*ioc->facts.BlockSize);
+
+	len += sprintf(buf+len, "  RequestFrames @ 0x%p (Dma @ 0x%p)\n",
+					(void *)ioc->req_alloc, (void *)(ulong)ioc->req_alloc_dma);
+	/*
+	 *  Rounding UP to nearest 4-kB boundary here...
+	 */
+	sz = (ioc->req_sz * ioc->req_depth) + 128;
+	sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
+	len += sprintf(buf+len, "    {CurReqSz=%d} x {CurReqDepth=%d} = %d bytes ^= 0x%x\n",
+					ioc->req_sz, ioc->req_depth, ioc->req_sz*ioc->req_depth, sz);
+	len += sprintf(buf+len, "    {MaxReqSz=%d}   {MaxReqDepth=%d}\n",
+					4*ioc->facts.RequestFrameSize,
+					ioc->facts.GlobalCredits);
+
+	len += sprintf(buf+len, "  ReplyFrames   @ 0x%p (Dma @ 0x%p)\n",
+					(void *)ioc->reply_alloc, (void *)(ulong)ioc->reply_alloc_dma);
+	sz = (ioc->reply_sz * ioc->reply_depth) + 128;
+	len += sprintf(buf+len, "    {CurRepSz=%d} x {CurRepDepth=%d} = %d bytes ^= 0x%x\n",
+					ioc->reply_sz, ioc->reply_depth, ioc->reply_sz*ioc->reply_depth, sz);
+	len += sprintf(buf+len, "    {MaxRepSz=%d}   {MaxRepDepth=%d}\n",
+					ioc->facts.CurReplyFrameSize,
+					ioc->facts.ReplyQueueDepth);
+
+	len += sprintf(buf+len, "  MaxDevices = %d\n",
+			(ioc->facts.MaxDevices==0) ? 255 : ioc->facts.MaxDevices);
+	len += sprintf(buf+len, "  MaxBuses = %d\n", ioc->facts.MaxBuses);
+
+	/* per-port info */
+	for (p=0; p < ioc->facts.NumberOfPorts; p++) {
+		len += sprintf(buf+len, "  PortNumber = %d (of %d)\n",
+				p+1,
+				ioc->facts.NumberOfPorts);
+		if ((int)ioc->chip_type <= (int)FC929) {
+			if (ioc->pfacts[p].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {
+				u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
+				len += sprintf(buf+len, "    LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
+						a[5], a[4], a[3], a[2], a[1], a[0]);
+			}
+			len += sprintf(buf+len, "    WWN = %08X%08X:%08X%08X\n",
+					ioc->fc_port_page0[p].WWNN.High,
+					ioc->fc_port_page0[p].WWNN.Low,
+					ioc->fc_port_page0[p].WWPN.High,
+					ioc->fc_port_page0[p].WWPN.Low);
 		}
-		ioc = NULL;
 	}
-	len = out - page;
 
-	PROC_MPT_READ_RETURN(page,start,off,count,eof,len);
+	MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len);
 }
+
 #endif		/* CONFIG_PROC_FS } */
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static void
 mpt_get_fw_exp_ver(char *buf, MPT_ADAPTER *ioc)
 {
-	if ((ioc->facts.FWVersion & 0xF000) == 0xE000)
+	buf[0] ='\0';
+	if ((ioc->facts.FWVersion.Word >> 24) == 0x0E) {
 		sprintf(buf, " (Exp %02d%02d)",
-			(ioc->facts.FWVersion & 0x0F00) >> 8,	/* Month */
-			ioc->facts.FWVersion & 0x001F);		/* Day */
-	else
-		buf[0] ='\0';
+			(ioc->facts.FWVersion.Word >> 16) & 0x00FF,	/* Month */
+			(ioc->facts.FWVersion.Word >> 8) & 0x1F);	/* Day */
 
-	/* insider hack! */
-	if (ioc->facts.FWVersion & 0x0080) {
-		strcat(buf, " [MDBG]");
+		/* insider hack! */
+		if ((ioc->facts.FWVersion.Word >> 8) & 0x80)
+			strcat(buf, " [MDBG]");
 	}
 }
 
@@ -3130,8 +5180,8 @@
  *	@len: Offset at which to start writing in buffer
  *	@showlan: Display LAN stuff?
  *
- * 	This routine writes (english readable) ASCII text, which represents
- * 	a summary of IOC information, to a buffer.
+ *	This routine writes (english readable) ASCII text, which represents
+ *	a summary of IOC information, to a buffer.
  */
 void
 mpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buffer, int *size, int len, int showlan)
@@ -3144,11 +5194,11 @@
 	/*
 	 *  Shorter summary of attached ioc's...
 	 */
-	y = sprintf(buffer+len, "%s: %s, %s%04xh%s, Ports=%d, MaxQ=%d",
+	y = sprintf(buffer+len, "%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d",
 			ioc->name,
 			ioc->prod_name,
 			MPT_FW_REV_MAGIC_ID_STRING,	/* "FwRev=" or somesuch */
-			ioc->facts.FWVersion,
+			ioc->facts.FWVersion.Word,
 			expVer,
 			ioc->facts.NumberOfPorts,
 			ioc->req_depth);
@@ -3159,8 +5209,11 @@
 			a[5], a[4], a[3], a[2], a[1], a[0]);
 	}
 
-	if (ioc->pci_irq < 100)
-		y += sprintf(buffer+len+y, ", IRQ=%d", ioc->pci_irq);
+#ifndef __sparc__
+	y += sprintf(buffer+len+y, ", IRQ=%d", ioc->pci_irq);
+#else
+	y += sprintf(buffer+len+y, ", IRQ=%s", __irq_itoa(ioc->pci_irq));
+#endif
 
 	if (!ioc->active)
 		y += sprintf(buffer+len+y, " (disabled)");
@@ -3171,75 +5224,66 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	Reset Handling
+ */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_print_ioc_facts - Write ASCII summary of IOC facts to a buffer.
+ *	mpt_HardResetHandler - Generic reset handler, issue SCSI Task
+ *	Management call based on input arg values.  If TaskMgmt fails,
+ *	return associated SCSI request.
  *	@ioc: Pointer to MPT_ADAPTER structure
- *	@buffer: Pointer to buffer where IOC facts should be written
- *	@size: Pointer to number of bytes we wrote (set by this routine)
- *	@len: Offset at which to start writing in buffer
+ *	@sleepFlag: Indicates if sleep or schedule must be called.
+ *
+ *	Remark: _HardResetHandler can be invoked from an interrupt thread (timer)
+ *	or a non-interrupt thread.  In the former, must not call schedule().
+ *
+ *	Remark: A return of -1 is a FATAL error case, as it means a
+ *	FW reload/initialization failed.
  *
- * 	This routine writes (english readable) ASCII text, which represents
- * 	a summary of the IOC facts, to a buffer.
+ *	Returns 0 for SUCCESS or -1 if FAILED.
  */
-void
-mpt_print_ioc_facts(MPT_ADAPTER *ioc, char *buffer, int *size, int len)
+int
+mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag)
 {
-	char expVer[32];
-	char iocName[16];
-	int sz;
-	int y;
-	int p;
-
-	mpt_get_fw_exp_ver(expVer, ioc);
+	int		 rc;
+	unsigned long	 flags;
 
-	strcpy(iocName, ioc->name);
-	y = sprintf(buffer+len, "%s:\n", iocName);
+	dprintk((MYIOC_s_INFO_FMT "HardResetHandler Entered!\n", ioc->name));
+#ifdef MFCNT
+	printk(MYIOC_s_INFO_FMT "HardResetHandler Entered!\n", ioc->name);
+	printk("MF count 0x%x !\n", ioc->mfcnt);
+#endif
 
-	y += sprintf(buffer+len+y, "  ProductID = 0x%04x\n", ioc->facts.ProductID);
-	for (p=0; p < ioc->facts.NumberOfPorts; p++) {
-		y += sprintf(buffer+len+y, "  PortNumber = %d (of %d)\n",
-			p+1,
-			ioc->facts.NumberOfPorts);
-		if (ioc->pfacts[p].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {
-			u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
-			y += sprintf(buffer+len+y, "  LanAddr = 0x%02x:%02x:%02x:%02x:%02x:%02x\n",
-				a[5], a[4], a[3], a[2], a[1], a[0]);
-		}
-	}
-	y += sprintf(buffer+len+y, "  FWVersion = 0x%04x%s\n", ioc->facts.FWVersion, expVer);
-	y += sprintf(buffer+len+y, "  MsgVersion = 0x%04x\n", ioc->facts.MsgVersion);
-	y += sprintf(buffer+len+y, "  FirstWhoInit = 0x%02x\n", ioc->FirstWhoInit);
-	y += sprintf(buffer+len+y, "  EventState = 0x%02x\n", ioc->facts.EventState);
-	y += sprintf(buffer+len+y, "  CurrentHostMfaHighAddr = 0x%08x\n",
-		 	ioc->facts.CurrentHostMfaHighAddr);
-	y += sprintf(buffer+len+y, "  CurrentSenseBufferHighAddr = 0x%08x\n",
-			ioc->facts.CurrentSenseBufferHighAddr);
-	y += sprintf(buffer+len+y, "  MaxChainDepth = 0x%02x frames\n", ioc->facts.MaxChainDepth);
-	y += sprintf(buffer+len+y, "  MinBlockSize = 0x%02x bytes\n", 4*ioc->facts.BlockSize);
+	/* Reset the adapter. Prevent more than 1 call to
+	 * mpt_do_ioc_recovery at any instant in time.
+	 */
+	spin_lock_irqsave(&ioc->diagLock, flags);
+	if ((ioc->diagPending) || (ioc->alt_ioc && ioc->alt_ioc->diagPending)){
+		spin_unlock_irqrestore(&ioc->diagLock, flags);
+		return 0;
+	} else {
+		ioc->diagPending = 1;
+	}
+	spin_unlock_irqrestore(&ioc->diagLock, flags);
 
-	y += sprintf(buffer+len+y, "  RequestFrames @ 0x%p (Dma @ 0x%08x)\n",
-					ioc->req_alloc, ioc->req_alloc_dma);
-	/*
-	 *  Rounding UP to nearest 4-kB boundary here...
+	/* FIXME: If do_ioc_recovery fails, repeat....
 	 */
-	sz = (ioc->req_sz * ioc->req_depth) + 128;
-	sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
-	y += sprintf(buffer+len+y, "    {CurReqSz=%d} x {CurReqDepth=%d} = %d bytes ^= 0x%x\n",
-					ioc->req_sz, ioc->req_depth, ioc->req_sz*ioc->req_depth, sz);
-	y += sprintf(buffer+len+y, "    {MaxReqSz=%d}   {MaxReqDepth=%d}\n",
-					4*ioc->facts.RequestFrameSize,
-					ioc->facts.GlobalCredits);
 
-	y += sprintf(buffer+len+y, "  ReplyFrames   @ 0x%p (Dma @ 0x%08x)\n",
-					ioc->reply_alloc, ioc->reply_alloc_dma);
-	sz = (ioc->reply_sz * ioc->reply_depth) + 128;
-	y += sprintf(buffer+len+y, "    {CurRepSz=%d} x {CurRepDepth=%d} = %d bytes ^= 0x%x\n",
-					ioc->reply_sz, ioc->reply_depth, ioc->reply_sz*ioc->reply_depth, sz);
-	y += sprintf(buffer+len+y, "    {MaxRepSz=%d}   {MaxRepDepth=%d}\n",
-					ioc->facts.CurReplyFrameSize,
-					ioc->facts.ReplyQueueDepth);
+	if ((rc = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_RECOVER, sleepFlag)) != 0) {
+		printk(KERN_WARNING MYNAM ": WARNING - (%d) Cannot recover %s\n",
+			rc, ioc->name);
+	}
 
-	*size = y;
+	spin_lock_irqsave(&ioc->diagLock, flags);
+	ioc->diagPending = 0;
+	if (ioc->alt_ioc)
+		ioc->alt_ioc->diagPending = 0;
+	spin_unlock_irqrestore(&ioc->diagLock, flags);
+
+	dprintk((MYIOC_s_INFO_FMT "HardResetHandler rc = %d!\n", ioc->name, rc));
+
+	return rc;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -3268,7 +5312,7 @@
 		ds = "External Bus Reset";
 		break;
 	case MPI_EVENT_RESCAN:
-		ds = "Bus Rescan Event"; 
+		ds = "Bus Rescan Event";
 		/* Ok, do we need to do anything here? As far as
 		   I can tell, this is when a new device gets added
 		   to the loop. */
@@ -3296,6 +5340,9 @@
 		else
 			ds = "Events(OFF) Change";
 		break;
+	case MPI_EVENT_INTEGRATED_RAID:
+		ds = "Integrated Raid";
+		break;
 	/*
 	 *  MPT base "custom" events may be added here...
 	 */
@@ -3307,7 +5354,7 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	ProcessEventNotification - Route a received EventNotificationReply to
  *	all currently regeistered event handlers.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3322,7 +5369,7 @@
 	u16 evDataLen;
 	u32 evData0 = 0;
 //	u32 evCtx;
-	int i;
+	int ii;
 	int r = 0;
 	int handlers = 0;
 	char *evStr;
@@ -3339,15 +5386,15 @@
 	}
 
 	evStr = EventDescriptionStr(event, evData0);
-	dprintk((KERN_INFO MYNAM ": %s: MPT event (%s=%02Xh) detected!\n",
+	dprintk((MYIOC_s_INFO_FMT "MPT event (%s=%02Xh) detected!\n",
 			ioc->name,
 			evStr,
 			event));
 
 #if defined(MPT_DEBUG) || defined(MPT_DEBUG_EVENTS)
 	printk(KERN_INFO MYNAM ": Event data:\n" KERN_INFO);
-	for (i = 0; i < evDataLen; i++)
-		printk(" %08x", le32_to_cpu(pEventReply->Data[i]));
+	for (ii = 0; ii < evDataLen; ii++)
+		printk(" %08x", le32_to_cpu(pEventReply->Data[ii]));
 	printk("\n");
 #endif
 
@@ -3365,6 +5412,8 @@
 	case MPI_EVENT_LINK_STATUS_CHANGE:	/* 07 */
 	case MPI_EVENT_LOOP_STATE_CHANGE:	/* 08 */
 	case MPI_EVENT_LOGOUT:			/* 09 */
+	case MPI_EVENT_INTEGRATED_RAID:		/* 0B */
+	case MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE:	/* 0C */
 	default:
 		break;
 	case MPI_EVENT_EVENT_CHANGE:		/* 0A */
@@ -3382,13 +5431,36 @@
 	}
 
 	/*
+	 * Should this event be logged? Events are written sequentially.
+	 * When buffer is full, start again at the top.
+	 */
+	if (ioc->events && (ioc->eventTypes & ( 1 << event))) {
+		int idx;
+
+		idx = ioc->eventContext % ioc->eventLogSize;
+
+		ioc->events[idx].event = event;
+		ioc->events[idx].eventContext = ioc->eventContext;
+
+		for (ii = 0; ii < 2; ii++) {
+			if (ii < evDataLen)
+				ioc->events[idx].data[ii] = le32_to_cpu(pEventReply->Data[ii]);
+			else
+				ioc->events[idx].data[ii] =  0;
+		}
+
+		ioc->eventContext++;
+	}
+
+
+	/*
 	 *  Call each currently registered protocol event handler.
 	 */
-	for (i=MPT_MAX_PROTOCOL_DRIVERS-1; i; i--) {
-		if (MptEvHandlers[i]) {
-			dprintk((KERN_INFO MYNAM ": %s: Routing Event to event handler #%d\n",
-					ioc->name, i));
-			r += (*(MptEvHandlers[i]))(ioc, pEventReply);
+	for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+		if (MptEvHandlers[ii]) {
+			dprintk((MYIOC_s_INFO_FMT "Routing Event to event handler #%d\n",
+					ioc->name, ii));
+			r += (*(MptEvHandlers[ii]))(ioc, pEventReply);
 			handlers++;
 		}
 	}
@@ -3398,7 +5470,9 @@
 	 *  If needed, send (a single) EventAck.
 	 */
 	if (pEventReply->AckRequired == MPI_EVENT_NOTIFICATION_ACK_REQUIRED) {
-		if ((i = SendEventAck(ioc, pEventReply)) != 0) {
+		if ((ii = SendEventAck(ioc, pEventReply)) != 0) {
+			printk(MYIOC_s_WARN_FMT "SendEventAck returned %d\n",
+					ioc->name, ii);
 		}
 	}
 
@@ -3427,7 +5501,7 @@
 
 	switch(log_info) {
 /* FCP Initiator */
-    	case MPI_IOCLOGINFO_FC_INIT_ERROR_OUT_OF_ORDER_FRAME:
+	case MPI_IOCLOGINFO_FC_INIT_ERROR_OUT_OF_ORDER_FRAME:
 		desc = "Received an out of order frame - unsupported";
 		break;
 	case MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_START_OF_FRAME:
@@ -3483,7 +5557,7 @@
 		desc = "Not sent because login to remote node not validated";
 		break;
 	case MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND:
-		desc = "Cleared from the outbound after a logout";
+		desc = "Cleared from the outbound queue after a logout";
 		break;
 	case MPI_IOCLOGINFO_FC_TARGET_WAITING_FOR_DATA_IN:
 		desc = "Cleared waiting for data after a logout";
@@ -3516,7 +5590,7 @@
 		break;
 	}
 
-	printk(KERN_INFO MYNAM ": %s: LogInfo(0x%08x): SubCl={%s}",
+	printk(MYIOC_s_INFO_FMT "LogInfo(0x%08x): SubCl={%s}",
 			ioc->name, log_info, subcl_str[subcl]);
 	if (SubCl == MPI_IOCLOGINFO_FC_INVALID_FIELD_BYTE_OFFSET)
 		printk(", byte_offset=%d\n", log_info & MPI_IOCLOGINFO_FC_INVALID_FIELD_MAX_OFFSET);
@@ -3539,7 +5613,7 @@
 mpt_sp_log_info(MPT_ADAPTER *ioc, u32 log_info)
 {
 	/* FIXME! */
-	printk(KERN_INFO MYNAM ": %s: LogInfo(0x%08x)\n", ioc->name, log_info);
+	printk(MYIOC_s_INFO_FMT "LogInfo(0x%08x)\n", ioc->name, log_info);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -3553,7 +5627,7 @@
  *	Specialized driver registration routine for the isense driver.
  */
 int
-mpt_register_ascqops_strings(/*ASCQ_Table_t*/void *ascqTable, int ascqtbl_sz, const char **opsTable)
+mpt_register_ascqops_strings(void *ascqTable, int ascqtbl_sz, const char **opsTable)
 {
 	int r = 0;
 
@@ -3562,6 +5636,7 @@
 		mpt_ASCQ_TableSz = ascqtbl_sz;
 		mpt_ScsiOpcodesPtr = opsTable;
 		printk(KERN_INFO MYNAM ": English readable SCSI-3 strings enabled:-)\n");
+		isense_idx = last_drv_idx;
 		r = 1;
 	}
 	MOD_INC_USE_COUNT;
@@ -3582,11 +5657,15 @@
 	mpt_ASCQ_TableSz = 0;
 	mpt_ScsiOpcodesPtr = NULL;
 	printk(KERN_INFO MYNAM ": English readable SCSI-3 strings disabled)-:\n");
+	isense_idx = -1;
 	MOD_DEC_USE_COUNT;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
+EXPORT_SYMBOL(mpt_adapters);
+EXPORT_SYMBOL(mpt_proc_root_dir);
+EXPORT_SYMBOL(DmpService);
 EXPORT_SYMBOL(mpt_register);
 EXPORT_SYMBOL(mpt_deregister);
 EXPORT_SYMBOL(mpt_event_register);
@@ -3596,13 +5675,21 @@
 EXPORT_SYMBOL(mpt_get_msg_frame);
 EXPORT_SYMBOL(mpt_put_msg_frame);
 EXPORT_SYMBOL(mpt_free_msg_frame);
+EXPORT_SYMBOL(mpt_add_sge);
+EXPORT_SYMBOL(mpt_add_chain);
 EXPORT_SYMBOL(mpt_send_handshake_request);
+EXPORT_SYMBOL(mpt_handshake_req_reply_wait);
 EXPORT_SYMBOL(mpt_adapter_find_first);
 EXPORT_SYMBOL(mpt_adapter_find_next);
 EXPORT_SYMBOL(mpt_verify_adapter);
+EXPORT_SYMBOL(mpt_GetIocState);
 EXPORT_SYMBOL(mpt_print_ioc_summary);
 EXPORT_SYMBOL(mpt_lan_index);
 EXPORT_SYMBOL(mpt_stm_index);
+EXPORT_SYMBOL(mpt_HardResetHandler);
+EXPORT_SYMBOL(mpt_config);
+EXPORT_SYMBOL(mpt_alloc_fw_memory);
+EXPORT_SYMBOL(mpt_free_fw_memory);
 
 EXPORT_SYMBOL(mpt_register_ascqops_strings);
 EXPORT_SYMBOL(mpt_deregister_ascqops_strings);
@@ -3611,12 +5698,13 @@
 EXPORT_SYMBOL(mpt_ScsiOpcodesPtr);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	fusion_init - Fusion MPT base driver initialization routine.
  *
  *	Returns 0 for success, non-zero for failure.
  */
-int __init fusion_init(void)
+int __init
+fusion_init(void)
 {
 	int i;
 
@@ -3636,12 +5724,22 @@
 		MptResetHandlers[i] = NULL;
 	}
 
+	DmpService = NULL;
+
 	/* NEW!  20010120 -sralston
 	 *  Register ourselves (mptbase) in order to facilitate
 	 *  EventNotification handling.
 	 */
 	mpt_base_index = mpt_register(mpt_base_reply, MPTBASE_DRIVER);
 
+	/* Register for hard reset handling callbacks.
+	 */
+	if (mpt_reset_register(mpt_base_index, mpt_ioc_reset) == 0) {
+		dprintk((KERN_INFO MYNAM ": Register for IOC reset notification\n"));
+	} else {
+		/* FIXME! */
+	}
+
 	if ((i = mpt_pci_scan()) < 0)
 		return i;
 
@@ -3649,13 +5747,14 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	fusion_exit - Perform driver unload cleanup.
  *
  *	This routine frees all resources associated with each MPT adapter
  *	and removes all %MPT_PROCFS_MPTBASEDIR entries.
  */
-static void fusion_exit(void)
+static void
+fusion_exit(void)
 {
 	MPT_ADAPTER *this;
 
@@ -3665,7 +5764,7 @@
 	 *  Moved this *above* removal of all MptAdapters!
 	 */
 #ifdef CONFIG_PROC_FS
-	procmpt_destroy();
+	(void) procmpt_destroy();
 #endif
 
 	while (! Q_IS_EMPTY(&MptAdapters)) {
@@ -3673,6 +5772,8 @@
 		Q_DEL_ITEM(this);
 		mpt_adapter_dispose(this);
 	}
+
+	mpt_reset_deregister(mpt_base_index);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
diff -Nru a/drivers/message/fusion/mptbase.h b/drivers/message/fusion/mptbase.h
--- a/drivers/message/fusion/mptbase.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/mptbase.h	Thu Jun 20 15:54:00 2002
@@ -8,11 +8,12 @@
  *  Credits:
  *     (see mptbase.c)
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id$
+ *  $Id$
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -55,6 +56,7 @@
 /*{-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 #include "linux_compat.h"	/* linux-2.2.x (vs. -2.4.x) tweaks */
+#include "scsi3.h"		/* SCSI defines */
 
 #include "lsi/mpi_type.h"
 #include "lsi/mpi.h"		/* Fusion MPI(nterface) basic defs */
@@ -62,6 +64,7 @@
 #include "lsi/mpi_cnfg.h"	/* IOC configuration support */
 #include "lsi/mpi_init.h"	/* SCSI Host (initiator) protocol support */
 #include "lsi/mpi_lan.h"	/* LAN over FC protocol support */
+#include "lsi/mpi_raid.h"	/* Integrated Mirroring support */
 
 #include "lsi/mpi_fc.h"		/* Fibre Channel (lowlevel) support */
 #include "lsi/mpi_targ.h"	/* SCSI/FCP Target protcol support */
@@ -74,11 +77,11 @@
 #endif
 
 #ifndef COPYRIGHT
-#define COPYRIGHT	"Copyright (c) 1999-2001 " MODULEAUTHOR
+#define COPYRIGHT	"Copyright (c) 1999-2002 " MODULEAUTHOR
 #endif
 
-#define MPT_LINUX_VERSION_COMMON	"1.02.02"
-#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-1.02.02"
+#define MPT_LINUX_VERSION_COMMON	"2.01.06"
+#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-2.01.06"
 #define WHAT_MAGIC_STRING		"@" "(" "#" ")"
 
 #define show_mptmod_ver(s,ver)  \
@@ -89,39 +92,77 @@
  *  Fusion MPT(linux) driver configurable stuff...
  */
 #define MPT_MAX_ADAPTERS		16
-#define MPT_MAX_PROTOCOL_DRIVERS	8
+#define MPT_MAX_PROTOCOL_DRIVERS	16
+#define MPT_MAX_BUS			1
 #define MPT_MAX_FC_DEVICES		255
+#define MPT_MAX_SCSI_DEVICES		16
+#define MPT_LAST_LUN			31
+#define MPT_SENSE_BUFFER_ALLOC		64
+	/* allow for 256 max sense alloc, but only 255 max request */
+#if MPT_SENSE_BUFFER_ALLOC >= 256
+#	undef MPT_SENSE_BUFFER_ALLOC
+#	define MPT_SENSE_BUFFER_ALLOC	256
+#	define MPT_SENSE_BUFFER_SIZE	255
+#else
+#	define MPT_SENSE_BUFFER_SIZE	MPT_SENSE_BUFFER_ALLOC
+#endif
 
-#define MPT_MISCDEV_BASENAME		"mptctl"
-#define MPT_MISCDEV_PATHNAME		"/dev/" MPT_MISCDEV_BASENAME
+#define MPT_NAME_LENGTH			32
 
 #define MPT_PROCFS_MPTBASEDIR		"mpt"
 						/* chg it to "driver/fusion" ? */
-#define MPT_PROCFS_SUMMARY_NODE		MPT_PROCFS_MPTBASEDIR "/summary"
-#define MPT_PROCFS_SUMMARY_PATHNAME	"/proc/" MPT_PROCFS_SUMMARY_NODE
-#define MPT_FW_REV_MAGIC_ID_STRING	"FwRev="
+#define MPT_PROCFS_SUMMARY_ALL_NODE		MPT_PROCFS_MPTBASEDIR "/summary"
+#define MPT_PROCFS_SUMMARY_ALL_PATHNAME		"/proc/" MPT_PROCFS_SUMMARY_ALL_NODE
+#define MPT_FW_REV_MAGIC_ID_STRING		"FwRev="
 
-#ifdef __KERNEL__	/* { */
 #define  MPT_MAX_REQ_DEPTH		1023
-#define  MPT_REQ_DEPTH			256
+#define  MPT_DEFAULT_REQ_DEPTH		256
 #define  MPT_MIN_REQ_DEPTH		128
 
 #define  MPT_MAX_REPLY_DEPTH		MPT_MAX_REQ_DEPTH
-#define  MPT_REPLY_DEPTH		128
+#define  MPT_DEFAULT_REPLY_DEPTH	128
 #define  MPT_MIN_REPLY_DEPTH		8
 #define  MPT_MAX_REPLIES_PER_ISR	32
 
 #define  MPT_MAX_FRAME_SIZE		128
-#define  MPT_REQ_SIZE			128
-#define  MPT_REPLY_SIZE			128
+#define  MPT_DEFAULT_FRAME_SIZE		128
 
-#define  MPT_SG_BUCKETS_PER_HUNK	1
+#define  MPT_SG_REQ_128_SCALE		1
+#define  MPT_SG_REQ_96_SCALE		2
+#define  MPT_SG_REQ_64_SCALE		4
 
-#ifdef MODULE
-#define  MPT_REQ_DEPTH_RANGE_STR	__MODULE_STRING(MPT_MIN_REQ_DEPTH) "-" __MODULE_STRING(MPT_MAX_REQ_DEPTH)
-#define  MPT_REPLY_DEPTH_RANGE_STR	__MODULE_STRING(MPT_MIN_REPLY_DEPTH) "-" __MODULE_STRING(MPT_MAX_REPLY_DEPTH)
-#define  MPT_REPLY_SIZE_RANGE_STR	__MODULE_STRING(MPT_MIN_REPLY_SIZE) "-" __MODULE_STRING(MPT_MAX_FRAME_SIZE)
-#endif
+#define	 CAN_SLEEP			1
+#define  NO_SLEEP			0
+
+/* 
+ * SCSI transfer rate defines. 
+ */
+#define MPT_ULTRA320			0x08
+#define MPT_ULTRA160			0x09
+#define MPT_ULTRA2			0x0A
+#define MPT_ULTRA			0x0C
+#define MPT_FAST			0x19
+#define MPT_SCSI			0x32
+#define MPT_ASYNC			0xFF
+
+#define MPT_NARROW			0
+#define MPT_WIDE			1
+
+#ifdef __KERNEL__	/* { */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#include <linux/proc_fs.h>
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Attempt semi-consistent error & warning msgs across
+ * MPT drivers.  NOTE: Users of these macro defs must
+ * themselves define their own MYNAM.
+ */
+#define MYIOC_s_INFO_FMT		KERN_INFO MYNAM ": %s: "
+#define MYIOC_s_NOTE_FMT		KERN_NOTICE MYNAM ": %s: "
+#define MYIOC_s_WARN_FMT		KERN_WARNING MYNAM ": %s: WARNING - "
+#define MYIOC_s_ERR_FMT			KERN_ERR MYNAM ": %s: ERROR - "
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -133,6 +174,7 @@
 	MPTSCSIH_DRIVER,	/* MPT SCSI host (initiator) class */
 	MPTLAN_DRIVER,		/* MPT LAN class */
 	MPTSTM_DRIVER,		/* MPT SCSI target mode class */
+	MPTDMP_DRIVER,		/* MPT Dynamic Multi-pathing class */
 	MPTUNKNOWN_DRIVER
 } MPT_DRIVER_CLASS;
 
@@ -145,10 +187,21 @@
 		struct _MPT_FRAME_HDR	*forw;
 		struct _MPT_FRAME_HDR	*back;
 		u32			 arg1;
+		u32			 pad;
 		void			*argp1;
+#ifndef MPT_SCSI_USE_NEW_EH
+		void			*argp2;
+#endif
 	} linkage;
 	/*
-	 * NOTE: On non-32-bit systems, where pointers are LARGE,
+	 * NOTE: When request frames are free, on the linkage structure
+	 * contets are valid.  All other values are invalid.
+	 * In particular, do NOT reply on offset [2]
+	 * (in words) being the * message context.
+	 * The message context must be reset (computed via base address
+	 * + an offset) prior to issuing any command.
+	 *
+	 * NOTE2: On non-32-bit systems, where pointers are LARGE,
 	 * using the linkage pointers destroys our sacred MsgContext
 	 * field contents.  But we don't care anymore because these
 	 * are now reset in mpt_put_msg_frame() just prior to sending
@@ -169,6 +222,12 @@
 			} fld;
 		} msgctxu;
 	} hwhdr;
+	/*
+	 * Remark: 32 bit identifier:
+	 *  31-24: reserved
+	 *  23-16: call back index
+	 *  15-0 : request index
+	 */
 } MPT_FRAME_TRACKER;
 
 /*
@@ -189,6 +248,11 @@
 	} u;
 } MPT_FRAME_HDR;
 
+#define MPT_REQ_MSGFLAGS_DROPME		0x80
+
+/* Used for tracking the free request frames
+ * and free reply frames.
+ */
 typedef struct _MPT_Q_TRACKER {
 	MPT_FRAME_HDR	*head;
 	MPT_FRAME_HDR	*tail;
@@ -214,12 +278,25 @@
 	struct _Q_ITEM	*tail;
 } Q_TRACKER;
 
+typedef struct _MPT_DONE_Q {
+	struct _MPT_DONE_Q	*forw;
+	struct _MPT_DONE_Q	*back;
+	void			*argp;
+} MPT_DONE_Q;
+
+typedef struct _DONE_Q_TRACKER {
+	MPT_DONE_Q	*head;
+	MPT_DONE_Q	*tail;
+} DONE_Q_TRACKER;
 
 /*
- *  Chip-specific stuff...
+ *  Chip-specific stuff... FC929 delineates break between
+ *  FC and Parallel SCSI parts. Do NOT re-order.
  */
 
 typedef enum {
+	FC919X = 0x0819,
+	FC929X = 0x0829,
 	FC909 = 0x0909,
 	FC919 = 0x0919,
 	FC929 = 0x0929,
@@ -237,7 +314,9 @@
 	u32	WriteSequence;	/* 04     Write Sequence register    */
 	u32	Diagnostic;	/* 08     Diagnostic register        */
 	u32	TestBase;	/* 0C     Test Base Address          */
-	u32	Reserved1[8];	/* 10-2F  reserved for future use    */
+	u32	DiagRwData;	/* 10     Read Write Data (fw download)   */
+	u32	DiagRwAddress;	/* 14     Read Write Address (fw download)*/
+	u32	Reserved1[6];	/* 18-2F  reserved for future use    */
 	u32	IntStatus;	/* 30     Interrupt Status           */
 	u32	IntMask;	/* 34     Interrupt Mask             */
 	u32	Reserved2[2];	/* 38-3F  reserved for future use    */
@@ -256,60 +335,294 @@
  */
 
 
+/*
+ *	Dynamic Multi-Pathing specific stuff...
+ */
+#define DMP_MAX_PATHS	8
+
+typedef struct _PathInfo {
+	u8		 ioc;
+	u8		 target;
+	u8		 pad;
+	u8		 pflags;
+} PathInfo;
+
+#define PATHINFO_FLAGS_OWNED		0x01
+#define PATHINFO_FLAGS_EXISTS		0x02
+#define PATHINFO_FLAGS_AVAILABLE	0x04
+#define PATHINFO_FLAGS_SECONDARY	0x08
+
+#define PFLAGS_EXISTS_AND_AVAIL		(PATHINFO_FLAGS_EXISTS|PATHINFO_FLAGS_AVAILABLE)
+#define PFLAGS_AVAIL_AND_OWNED		(PATHINFO_FLAGS_AVAILABLE|PATHINFO_FLAGS_OWNED)
+
+typedef struct _ScsiCmndTracker {
+	void			*head;
+	void			*tail;
+} ScsiCmndTracker;
+
+
+/*
+ *	VirtDevice - FC LUN device or SCSI target device
+ *	(used to be FCSCSI_TARGET)
+ */
+typedef struct _VirtDevice {
+	struct _VirtDevice	*forw;
+	struct _VirtDevice	*back;
+	rwlock_t		 VdevLock;
+	int			 ref_cnt;
+	u8			 tflags;
+	u8			 ioc_id;
+	u8			 target_id;
+	u8			 bus_id;
+	u8			 minSyncFactor;	/* 0xFF is async */
+	u8			 maxOffset;	/* 0 if async */
+	u8			 maxWidth;	/* 0 if narrow, 1 if wide*/
+	u8			 negoFlags;	/* bit field, 0 if WDTR/SDTR/QAS allowed */
+	u8			 raidVolume;	/* set, if RAID Volume */
+	u8			 rsvd;
+	u16			 rsvd1raid;
+	int			 npaths;
+	u16			 fc_phys_lun;
+	u16			 fc_xlat_lun;
+	int			 stall_detected;
+	PathInfo		 path[DMP_MAX_PATHS];
+	struct timer_list	 stall_timer;
+	struct timer_list	 retry_timer;
+	struct timer_list	 gone_timer;
+	ScsiCmndTracker		 WaitQ;
+	ScsiCmndTracker		 SentQ;
+	ScsiCmndTracker		 DoneQ;
+//--- LUN split here?
+	u8			 sense[SCSI_STD_SENSE_BYTES];		/* 18 */
+	u8			 rsvd2[2];	/* alignment */
+	u32			 luns;		/* Max LUNs is 32 */
+	u8			 inq_data[SCSI_STD_INQUIRY_BYTES];	/* 36 */
+	u8			 pad0[4];
+	u8			 inq00_data[20];
+	u8			 pad1[4];
+		/* IEEE Registered Extended Identifier
+		   obtained via INQUIRY VPD page 0x83 */
+		/* NOTE: Do not separate uniq_prepad and uniq_data
+		   as they are treateed as a single entity in the code */
+	u8			 uniq_prepad[8];
+	u8			 uniq_data[20];
+	u8			 pad2[4];
+	u8			 inqC3_data[12];
+	u8			 pad3[4];
+	u8			 inqC9_data[12];
+	u8			 pad4[4];
+	u8			 dev_vol_name[64];
+} VirtDevice;
+
+/*
+ *  Fibre Channel (SCSI) target device and associated defines...
+ */
+#define MPT_TARGET_DEFAULT_DV_STATUS	0
+#define MPT_TARGET_FLAGS_VALID_NEGO	0x01
+#define MPT_TARGET_FLAGS_VALID_INQUIRY	0x02
+#define MPT_TARGET_FLAGS_VALID_SENSE	0x04
+#define MPT_TARGET_FLAGS_Q_YES		0x08
+
+#define MPT_TARGET_NO_NEGO_WIDE		0x01
+#define MPT_TARGET_NO_NEGO_SYNC		0x02
+#define MPT_TARGET_NO_NEGO_QAS		0x04
+
+typedef struct _VirtDevTracker {
+	struct _VirtDevice	*head;
+	struct _VirtDevice	*tail;
+	rwlock_t		 VlistLock;
+	int			 pad;
+} VirtDevTracker;
+
+
+/*
+ *	/proc/mpt interface
+ */
+typedef struct {
+	const char	*name;
+	mode_t		 mode;
+	int		 pad;
+	read_proc_t	*read_proc;
+	write_proc_t	*write_proc;
+} mpt_proc_entry_t;
+
+#define MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len) \
+do { \
+	len -= offset;			\
+	if (len < request) {		\
+		*eof = 1;		\
+		if (len <= 0)		\
+			return 0;	\
+	} else				\
+		len = request;		\
+	*start = buf + offset;		\
+	return len;			\
+} while (0)
+
+
+/*
+ *	IOCTL structure and associated defines
+ */
+
+#define MPT_IOCTL_STATUS_DID_IOCRESET	0x01	/* IOC Reset occurred on the current*/
+#define MPT_IOCTL_STATUS_RF_VALID	0x02	/* The Reply Frame is VALID */
+#define MPT_IOCTL_STATUS_TIMER_ACTIVE	0x04	/* The timer is running */
+#define MPT_IOCTL_STATUS_SENSE_VALID	0x08	/* Sense data is valid */
+#define MPT_IOCTL_STATUS_COMMAND_GOOD	0x10	/* Command Status GOOD */
+#define MPT_IOCTL_STATUS_TMTIMER_ACTIVE	0x20	/* The TM timer is running */
+#define MPT_IOCTL_STATUS_TM_FAILED	0x40	/* User TM request failed */
+
+#define MPTCTL_RESET_OK			0x01	/* Issue Bus Reset */
+
+typedef struct _MPT_IOCTL {
+	struct _MPT_ADAPTER	*ioc;
+	struct timer_list	 timer;		/* timer function for this adapter */
+	u8			 ReplyFrame[MPT_DEFAULT_FRAME_SIZE];	/* reply frame data */
+	u8			 sense[MPT_SENSE_BUFFER_ALLOC];
+	int			 wait_done;	/* wake-up value for this ioc */
+	u8			 rsvd;
+	u8			 status;	/* current command status */
+	u8			 reset;		/* 1 if bus reset allowed */
+	u8			 target;	/* target for reset */
+	void 			*tmPtr;
+	struct timer_list	 TMtimer;	/* timer function for this adapter */
+} MPT_IOCTL;
+
+/*
+ *  Event Structure and define
+ */
+#define MPTCTL_EVENT_LOG_SIZE		(0x0000000A)
+typedef struct _mpt_ioctl_events {
+	u32	event;		/* Specified by define above */
+	u32	eventContext;	/* Index or counter */
+	int	data[2];	/* First 8 bytes of Event Data */
+} MPT_IOCTL_EVENTS;
+
+/*
+ * CONFIGPARM status  defines
+ */
+#define MPT_CONFIG_GOOD		MPI_IOCSTATUS_SUCCESS
+#define MPT_CONFIG_ERROR	0x002F
+
+/*
+ *	Substructure to store SCSI specific configuration page data
+ */
+						/* dvStatus defines: */
+#define MPT_SCSICFG_NEGOTIATE		0x01	/* Negotiate on next IO */
+#define MPT_SCSICFG_NEED_DV		0x02	/* Schedule DV */
+#define MPT_SCSICFG_DV_PENDING		0x04	/* DV on this physical id pending */
+#define MPT_SCSICFG_DV_DONE		0x08	/* DV on this physical id complete */
+#define MPT_SCSICFG_BLK_NEGO		0x10	/* WriteSDP1 with WDTR and SDTR disabled */
+
+						/* Args passed to writeSDP1: */
+#define MPT_SCSICFG_USE_NVRAM		0x01	/* WriteSDP1 using NVRAM */
+#define MPT_SCSICFG_ALL_IDS		0x02	/* WriteSDP1 to all IDS */
+/* #define MPT_SCSICFG_BLK_NEGO		0x10	   WriteSDP1 with WDTR and SDTR disabled */
+
+typedef	struct _ScsiCfgData {
+	int		*nvram;			/* table of device NVRAM values */
+	IOCPage3_t	*pIocPg3;		/* table of physical disks */
+	u8		 dvStatus[MPT_MAX_SCSI_DEVICES];
+	int		 isRaid;		/* bit field, 1 if RAID */
+	u8		 minSyncFactor;		/* 0xFF if async */
+	u8		 maxSyncOffset;		/* 0 if async */
+	u8		 maxBusWidth;		/* 0 if narrow, 1 if wide */
+	u8		 busType;		/* SE, LVD, HD */
+	u8		 sdp1version;		/* SDP1 version */
+	u8		 sdp1length;		/* SDP1 length  */
+	u8		 sdp0version;		/* SDP0 version */
+	u8		 sdp0length;		/* SDP0 length  */
+	u8		 dvScheduled;		/* 1 if scheduled */
+	u8		 forceDv;		/* 1 to force DV scheduling */
+	u8		 noQas;			/* Disable QAS for this adapter */
+	u8		 rsvd[2];
+} ScsiCfgData;
+
+typedef struct _fw_image {
+	char		*fw;
+	dma_addr_t	 fw_dma;
+	u32		 size;
+	u32		 rsvd;
+} fw_image_t;
+
+/*
+ *  Adapter Structure - pci_dev specific. Maximum: MPT_MAX_ADAPTERS
+ */
 typedef struct _MPT_ADAPTER
 {
 	struct _MPT_ADAPTER	*forw;
 	struct _MPT_ADAPTER	*back;
-	int			 id;		/* Unique adapter id {0,1,2,...} */
-	int			 pci_irq;
-	char			 name[32];	/* "iocN"             */
+	int			 id;		/* Unique adapter id N {0,1,2,...} */
+	int			 pci_irq;	/* This irq           */
+	char			 name[MPT_NAME_LENGTH];	/* "iocN"             */
 	char			*prod_name;	/* "LSIFC9x9"         */
-	u32			 mem_phys;	/* == f4020000 (mmap) */
 	volatile SYSIF_REGS	*chip;		/* == c8817000 (mmap) */
-	CHIP_TYPE		 chip_type;
-	int			 mem_size;
+	volatile SYSIF_REGS	*pio_chip;	/* Programmed IO (downloadboot) */
+	u32			 mem_phys;	/* == f4020000 (mmap) */
+	u32			 pio_mem_phys;	/* Programmed IO (downloadboot) */
+	int			 mem_size;	/* mmap memory size */
 	int			 alloc_total;
 	u32			 last_state;
 	int			 active;
-	int			 sod_reset;
-	unsigned long		 last_kickstart;
-	u8			*reply_alloc;		/* Reply frames alloc ptr */
+	u8			*reply_alloc;	/* Reply frames alloc ptr */
 	dma_addr_t		 reply_alloc_dma;
-	MPT_FRAME_HDR		*reply_frames;		/* Reply frames - rounded up! */
+	MPT_FRAME_HDR		*reply_frames;	/* Reply msg frames - rounded up! */
 	dma_addr_t		 reply_frames_dma;
-	int			 reply_depth;
-	int			 reply_sz;
+	u32			 reply_frames_low_dma;
+	int			 reply_depth;	/* Num Allocated reply frames */
+	int			 reply_sz;	/* Reply frame size */
+	CHIP_TYPE		 chip_type;
 		/* We (host driver) get to manage our own RequestQueue! */
-	u8			*req_alloc;		/* Request frames alloc ptr */
+	u8			*req_alloc;	/* Request frames alloc ptr */
 	dma_addr_t		 req_alloc_dma;
-	MPT_FRAME_HDR		*req_frames;		/* Request msg frames for PULL mode! */
+	MPT_FRAME_HDR		*req_frames;	/* Request msg frames - rounded up! */
 	dma_addr_t		 req_frames_dma;
-	int			 req_depth;
-	int			 req_sz;
-	MPT_Q_TRACKER		 FreeQ;
+	u32			 req_frames_low_dma;
+	int			 req_depth;	/* Number of request frames */
+	int			 req_sz;	/* Request frame size (bytes) */
 	spinlock_t		 FreeQlock;
+	MPT_Q_TRACKER		 FreeQ;
 		/* Pool of SCSI sense buffers for commands coming from
 		 * the SCSI mid-layer.  We have one 256 byte sense buffer
 		 * for each REQ entry.
 		 */
 	u8			*sense_buf_pool;
 	dma_addr_t		 sense_buf_pool_dma;
-	struct pci_dev		*pcidev;
-/*	atomic_t		 userCnt;	*/
-	u8			*memmap;
+	u32			 sense_buf_low_dma;
 	int			 mtrr_reg;
-	struct Scsi_Host	*sh;
+	void			*pcidev;	/* struct pci_dev pointer */
+	u8			*memmap;	/* mmap address */
+	struct Scsi_Host	*sh;		/* Scsi Host pointer */
+	ScsiCfgData		spi_data;	/* Scsi config. data */
+	MPT_IOCTL		*ioctl;		/* ioctl data pointer */
 	struct proc_dir_entry	*ioc_dentry;
-	struct _MPT_ADAPTER	*alt_ioc;
+	struct _MPT_ADAPTER	*alt_ioc;	/* ptr to 929 bound adapter port */
+	spinlock_t		 diagLock;	/* diagnostic reset lock */
+	int			 diagPending;
+	u32			 biosVersion;	/* BIOS version from IO Unit Page 2 */
+	int			 eventTypes;	/* Event logging parameters */
+	int			 eventContext;	/* Next event context */
+	int			 eventLogSize;	/* Max number of cached events */
+	struct _mpt_ioctl_events *events;	/* pointer to event log */
+	fw_image_t		**cached_fw;	/* Pointer to FW SG List */
+	Q_TRACKER		 configQ;	/* linked list of config. requests */
+	int			 num_fw_frags;	/* Number of SGE in FW SG List */
 	int			 hs_reply_idx;
+#ifndef MFCNT
+	u32			 pad0;
+#else
+	u32			 mfcnt;
+#endif
 	u32			 hs_req[MPT_MAX_FRAME_SIZE/sizeof(u32)];
 	u16			 hs_reply[MPT_MAX_FRAME_SIZE/sizeof(u16)];
 	IOCFactsReply_t		 facts;
 	PortFactsReply_t	 pfacts[2];
+	FCPortPage0_t		 fc_port_page0[2];
 	LANPage0_t		 lan_cnfg_page0;
 	LANPage1_t		 lan_cnfg_page1;
 	u8			 FirstWhoInit;
-	u8			 pad1[3];
+	u8			 upload_fw;	/* If set, do a fw upload */
+	u8			 pad1[6];
 } MPT_ADAPTER;
 
 
@@ -324,7 +637,6 @@
  *    0 = not Ok ...
  */
 typedef int (*MPT_CALLBACK)(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply);
-
 typedef int (*MPT_EVHANDLER)(MPT_ADAPTER *ioc, EventNotificationReply_t *evReply);
 typedef int (*MPT_RESETHANDLER)(MPT_ADAPTER *ioc, int reset_phase);
 /* reset_phase defs */
@@ -344,6 +656,22 @@
 #define MPT_HOSTEVENT_IOC_BRINGUP	0x91
 #define MPT_HOSTEVENT_IOC_RECOVER	0x92
 
+/* Define the generic types based on the size
+ * of the dma_addr_t type.
+ */
+typedef struct _mpt_sge {
+	u32		FlagsLength;
+	dma_addr_t	Address;
+} MptSge_t;
+
+#define mpt_addr_size() \
+	((sizeof(dma_addr_t) == sizeof(u64)) ? MPI_SGE_FLAGS_64_BIT_ADDRESSING : \
+		MPI_SGE_FLAGS_32_BIT_ADDRESSING)
+
+#define mpt_msg_flags() \
+	((sizeof(dma_addr_t) == sizeof(u64)) ? MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_64 : \
+		MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_32)
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Funky (private) macros...
@@ -360,7 +688,8 @@
 #define dhsprintk(x)
 #endif
 
-#if defined(MPT_DEBUG) || defined(MPT_DEBUG_MSG_FRAME)
+//#if defined(MPT_DEBUG) || defined(MPT_DEBUG_MSG_FRAME)
+#if defined(MPT_DEBUG_MSG_FRAME)
 #define dmfprintk(x)  printk x
 #else
 #define dmfprintk(x)
@@ -372,24 +701,41 @@
 #define dirqprintk(x)
 #endif
 
-#ifdef MPT_DEBUG_EVENTS
-#define deventprintk(x)  printk x
+#ifdef MPT_DEBUG_SG
+#define dsgprintk(x)  printk x
+#else
+#define dsgprintk(x)
+#endif
+
+#ifdef MPT_DEBUG_DV
+#define ddvprintk(x)  printk x
 #else
-#define deventprintk(x)
+#define ddvprintk(x)
 #endif
 
-#ifdef MPT_DEBUG_SPINLOCK
-#define dslprintk(x)  printk x
+#if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
+#define ddvtprintk(x)  printk x
 #else
-#define dslprintk(x)
+#define ddvtprintk(x)
 #endif
 
-#ifdef MPT_DEBUG_SG
-#define dsgprintk(x)  printk x
+#ifdef MPT_DEBUG_IOCTL
+#define dctlprintk(x) printk x
 #else
-#define dsgprintk(x)
+#define dctlprintk(x)
 #endif
 
+#ifdef MPT_DEBUG_RESET
+#define dtmprintk(x) printk x
+#else
+#define dtmprintk(x)
+#endif
+
+#ifdef MPT_DEBUG_NEH
+#define nehprintk(x) printk x
+#else
+#define nehprintk(x)
+#endif
 
 #define MPT_INDEX_2_MFPTR(ioc,idx) \
 	(MPT_FRAME_HDR*)( (u8*)(ioc)->req_frames + (ioc)->req_sz * (idx) )
@@ -397,6 +743,9 @@
 #define MFPTR_2_MPT_INDEX(ioc,mf) \
 	(int)( ((u8*)mf - (u8*)(ioc)->req_frames) / (ioc)->req_sz )
 
+#define MPT_INDEX_2_RFPTR(ioc,idx) \
+	(MPT_FRAME_HDR*)( (u8*)(ioc)->reply_frames + (ioc)->req_sz * (idx) )
+
 #define Q_INIT(q,type)  (q)->head = (q)->tail = (type*)(q)
 #define Q_IS_EMPTY(q)   ((Q_ITEM*)(q)->head == (Q_ITEM*)(q))
 
@@ -425,7 +774,6 @@
 	_forw->back = _back; \
 }
 
-
 #define SWAB4(value) \
 	(u32)(   (((value) & 0x000000ff) << 24) \
 	       | (((value) & 0x0000ff00) << 8)  \
@@ -457,64 +805,157 @@
 
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-#endif		/* } __KERNEL__ */
 
+/*
+ * MPT_SCSI_HOST defines - Used by the IOCTL and the SCSI drivers
+ * Private to the driver.
+ */
+/* LOCAL structure and fields used when processing
+ * internally generated commands. These include:
+ * bus scan, dv and config requests.
+ */
+typedef struct _MPT_LOCAL_REPLY {
+	ConfigPageHeader_t header;
+	int	completion;
+	u8	sense[SCSI_STD_SENSE_BYTES];
+	u8	scsiStatus;
+	u8	skip;
+	u32	pad;
+} MPT_LOCAL_REPLY;
+
+#define MPT_HOST_BUS_UNKNOWN		(0xFF)
+#define MPT_HOST_TOO_MANY_TM		(0x05)
+#define MPT_HOST_NVRAM_INVALID		(0xFFFFFFFF)
+#define MPT_HOST_NO_CHAIN		(0xFFFFFFFF)
+#define MPT_NVRAM_MASK_TIMEOUT		(0x000000FF)
+#define MPT_NVRAM_SYNC_MASK		(0x0000FF00)
+#define MPT_NVRAM_SYNC_SHIFT		(8)
+#define MPT_NVRAM_DISCONNECT_ENABLE	(0x00010000)
+#define MPT_NVRAM_ID_SCAN_ENABLE	(0x00020000)
+#define MPT_NVRAM_LUN_SCAN_ENABLE	(0x00040000)
+#define MPT_NVRAM_TAG_QUEUE_ENABLE	(0x00080000)
+#define MPT_NVRAM_WIDE_DISABLE		(0x00100000)
+#define MPT_NVRAM_BOOT_CHOICE		(0x00200000)
+
+#ifdef MPT_SCSI_USE_NEW_EH
+/* The TM_STATE variable is used to provide strict single threading of TM
+ * requests as well as communicate TM error conditions.
+ */
+#define TM_STATE_NONE          (0)
+#define	TM_STATE_IN_PROGRESS   (1)
+#define	TM_STATE_ERROR	       (2)
+#endif
+
+typedef struct _MPT_SCSI_HOST {
+	MPT_ADAPTER		 *ioc;
+	int			  port;
+	u32			  pad0;
+	struct scsi_cmnd	**ScsiLookup;
+		/* Pool of buffers for chaining. ReqToChain
+		 * and ChainToChain track index of chain buffers.
+		 * ChainBuffer (DMA) virt/phys addresses.
+		 * FreeChainQ (lock) locking mechanisms.
+		 */
+	int			 *ReqToChain;
+	int			 *ChainToChain;
+	u8			 *ChainBuffer;
+	dma_addr_t		  ChainBufferDMA;
+	MPT_Q_TRACKER		  FreeChainQ;
+	spinlock_t		  FreeChainQlock;
+	u32			  qtag_tick;
+	VirtDevice		**Targets;
+	MPT_LOCAL_REPLY		 *pLocal;		/* used for internal commands */
+	struct timer_list	  timer;
+	struct timer_list	  TMtimer;		/* Timer for TM commands ONLY */
+		/* Pool of memory for holding SCpnts before doing
+		 * OS callbacks. freeQ is the free pool.
+		 */
+	u8			 *memQ;
+	DONE_Q_TRACKER		  freeQ;
+	DONE_Q_TRACKER		  doneQ;		/* Holds Linux formmatted requests */
+	DONE_Q_TRACKER		  pendingQ;		/* Holds MPI formmatted requests */
+	MPT_Q_TRACKER		  taskQ;		/* TM request Q */
+	spinlock_t		  freedoneQlock;
+	int			  taskQcnt;
+	u8			  numTMrequests;
+	u8			  tmPending;
+	u8			  resetPending;
+	u8			  is_spi;		/* Parallel SCSI i/f */
+	u8			  negoNvram;		/* DV disabled, nego NVRAM */
+	u8			  is_multipath;		/* Multi-path compatible */
+#ifdef MPT_SCSI_USE_NEW_EH
+	u8                        tmState;
+	u8			  rsvd[1];
+#else
+	u8			  rsvd[2];
+#endif
+	MPT_FRAME_HDR		 *tmPtr;		/* Ptr to TM request*/
+	MPT_FRAME_HDR		 *cmdPtr;		/* Ptr to nonOS request */
+	struct scsi_cmnd	 *abortSCpnt;
+	MPT_LOCAL_REPLY		  localReply;		/* internal cmd reply struct */
+} MPT_SCSI_HOST;
+
+/*
+ *	Structure for overlaying onto scsi_cmnd->SCp area
+ *	NOTE: SCp area is 36 bytes min, 44 bytes max?
+ */
+typedef struct _scPrivate {
+	struct scsi_cmnd	*forw;
+	struct scsi_cmnd	*back;
+	void			*p1;
+	void			*p2;
+	u8			 io_path_id;	/* DMP */
+	u8			 pad[7];
+} scPrivate;
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	More Dynamic Multi-Pathing stuff...
+ */
+
+/* Forward decl, a strange C thing, to prevent gcc compiler warnings */
+struct scsi_cmnd;
 
 /*
- *  MPT Control IOCTLs and structures
+ *	DMP service layer structure / API interface
  */
-#define MPT_MAGIC_NUMBER	'm'
-#define MPTRWPERF		_IOWR(MPT_MAGIC_NUMBER,0,struct mpt_raw_r_w)
-#define MPTRWPERF_CHK		_IOR(MPT_MAGIC_NUMBER,13,struct mpt_raw_r_w)
-#define MPTRWPERF_RESET		_IOR(MPT_MAGIC_NUMBER,14,struct mpt_raw_r_w)
-#define MPTFWDOWNLOAD		_IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer)
-#define MPTSCSICMD		_IOWR(MPT_MAGIC_NUMBER,16,struct mpt_scsi_cmd)
-
-/*
- *  Define something *vague* enough that caller doesn't
- *  really need to know anything about device parameters
- *  (blk_size, capacity, etc.)
- */
-struct mpt_raw_r_w {
-	unsigned int	 iocnum;	/* IOC unit number */
-	unsigned int	 port;		/* IOC port number */
-	unsigned int	 target;	/* SCSI Target */
-	unsigned int	 lun;		/* SCSI LUN */
-	unsigned int	 iters;		/* N iterations */
-	unsigned short	 nblks;		/* number of blocks per IO */
-	unsigned short	 qdepth;	/* max Q depth on this device */
-	unsigned char	 range;		/* 0-100% of FULL disk capacity, 0=use (nblks X iters) */
-	unsigned char	 skip;		/* % of disk to skip */
-	unsigned char	 rdwr;		/* 0-100%, 0=pure ReaDs, 100=pure WRites */
-	unsigned char	 seqran;	/* 0-100%, 0=pure SEQential, 100=pure RANdom */
-	unsigned int	 cache_sz;	/* In Kb!  Optimize hits to N Kb cache size */
-};
-
-struct mpt_fw_xfer {
-	unsigned int	 iocnum;	/* IOC unit number */
-/*	u8		 flags;*/	/* Message flags - bit field */
-	unsigned int	 fwlen;
-	void		*bufp;		/* Pointer to firmware buffer */
-};
-
-struct mpt_scsi_cmd {
-	unsigned int	 iocnum;	/* IOC unit number */
-	unsigned int	 port;		/* IOC port number */
-	unsigned int	 target;	/* SCSI Target */
-	unsigned int	 lun;		/* SCSI LUN */
-	SCSIIORequest_t	 scsi_req;
-	SCSIIOReply_t	 scsi_reply;
-};
-
-struct mpt_ioctl_sanity {
-	unsigned int	 iocnum;
-};
+typedef struct _DmpServices {
+	VirtDevTracker	  VdevList;
+	struct semaphore *Daemon;
+	int		(*ScsiPathSelect)
+				(struct scsi_cmnd *, MPT_SCSI_HOST **hd, int *target, int *lun);
+	int		(*DmpIoDoneChk)
+				(MPT_SCSI_HOST *, struct scsi_cmnd *,
+				 SCSIIORequest_t *,
+				 SCSIIOReply_t *);
+	void		(*mptscsih_scanVlist)
+				(MPT_SCSI_HOST *, int portnum);
+	int		(*ScsiAbort)
+				(struct scsi_cmnd *);
+	int		(*ScsiBusReset)
+				(struct scsi_cmnd *);
+} DmpServices_t;
 
-#ifdef __KERNEL__	/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Generic structure passed to the base mpt_config function.
+ */
+typedef struct _x_config_parms {
+	Q_ITEM			 linkage;	/* linked list */
+	struct timer_list	 timer;		/* timer function for this request  */
+	ConfigPageHeader_t	*hdr;
+	dma_addr_t		 physAddr;
+	int			 wait_done;	/* wait for this request */
+	u32			 pageAddr;	/* properly formatted */
+	u8			 action;
+	u8			 dir;
+	u8			 timeout;	/* seconds */
+	u8			 pad1;
+	u16			 status;
+	u16			 pad2;
+} CONFIGPARMS;
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Public entry points...
  */
@@ -524,21 +965,33 @@
 extern void	 mpt_event_deregister(int cb_idx);
 extern int	 mpt_reset_register(int cb_idx, MPT_RESETHANDLER reset_func);
 extern void	 mpt_reset_deregister(int cb_idx);
-extern int	 mpt_register_ascqops_strings(/*ASCQ_Table_t*/void *ascqTable, int ascqtbl_sz, const char **opsTable);
+extern int	 mpt_register_ascqops_strings(void *ascqTable, int ascqtbl_sz, const char **opsTable);
 extern void	 mpt_deregister_ascqops_strings(void);
 extern MPT_FRAME_HDR	*mpt_get_msg_frame(int handle, int iocid);
 extern void	 mpt_free_msg_frame(int handle, int iocid, MPT_FRAME_HDR *mf);
 extern void	 mpt_put_msg_frame(int handle, int iocid, MPT_FRAME_HDR *mf);
-extern int	 mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req);
+extern void	 mpt_add_sge(char *pAddr, u32 flagslength, dma_addr_t dma_addr);
+extern void	 mpt_add_chain(char *pAddr, u8 next, u16 length, dma_addr_t dma_addr);
+
+extern int	 mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req, int sleepFlag);
+extern int	 mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req, int replyBytes, u16 *u16reply, int maxwait, int sleepFlag);
 extern int	 mpt_verify_adapter(int iocid, MPT_ADAPTER **iocpp);
 extern MPT_ADAPTER	*mpt_adapter_find_first(void);
 extern MPT_ADAPTER	*mpt_adapter_find_next(MPT_ADAPTER *prev);
+extern u32	 mpt_GetIocState(MPT_ADAPTER *ioc, int cooked);
 extern void	 mpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buf, int *size, int len, int showlan);
-extern void	 mpt_print_ioc_facts(MPT_ADAPTER *ioc, char *buf, int *size, int len);
+extern int	 mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag);
+extern int	 mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *cfg);
+extern void	*mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size, int *frags, int *alloc_sz);
+extern void	 mpt_free_fw_memory(MPT_ADAPTER *ioc, fw_image_t **alt_img);
 
 /*
  *  Public data decl's...
  */
+extern MPT_ADAPTER	 	*mpt_adapters[MPT_MAX_ADAPTERS];
+extern struct proc_dir_entry	*mpt_proc_root_dir;
+extern DmpServices_t		*DmpService;
+
 extern int		  mpt_lan_index;	/* needed by mptlan.c */
 extern int		  mpt_stm_index;	/* needed by mptstm.c */
 
@@ -563,7 +1016,7 @@
 #define offsetof(t, m)	((size_t) (&((t *)0)->m))
 #endif
 
-#if defined(__alpha__) || defined(__sparc_v9__)
+#if defined(__alpha__) || defined(__sparc_v9__) || defined(__ia64__)
 #define CAST_U32_TO_PTR(x)	((void *)(u64)x)
 #define CAST_PTR_TO_U32(x)	((u32)(u64)x)
 #else
@@ -576,6 +1029,40 @@
 	((pflags) & MPI_PORTFACTS_PROTOCOL_TARGET)	? 'T' : 't',	\
 	((pflags) & MPI_PORTFACTS_PROTOCOL_LAN)		? 'L' : 'l',	\
 	((pflags) & MPI_PORTFACTS_PROTOCOL_LOGBUSADDR)	? 'B' : 'b'
+
+/*
+ *  Shifted SGE Defines - Use in SGE with FlagsLength member.
+ *  Otherwise, use MPI_xxx defines (refer to "lsi/mpi.h" header).
+ *  Defaults: 32 bit SGE, SYSTEM_ADDRESS if direction bit is 0, read
+ */
+#define MPT_TRANSFER_IOC_TO_HOST		(0x00000000)
+#define MPT_TRANSFER_HOST_TO_IOC		(0x04000000)
+#define MPT_SGE_FLAGS_LAST_ELEMENT		(0x80000000)
+#define MPT_SGE_FLAGS_END_OF_BUFFER		(0x40000000)
+#define MPT_SGE_FLAGS_LOCAL_ADDRESS		(0x08000000)
+#define MPT_SGE_FLAGS_DIRECTION			(0x04000000)
+#define MPT_SGE_FLAGS_ADDRESSING		(mpt_addr_size() << MPI_SGE_FLAGS_SHIFT)
+#define MPT_SGE_FLAGS_END_OF_LIST		(0x01000000)
+
+#define MPT_SGE_FLAGS_TRANSACTION_ELEMENT	(0x00000000)
+#define MPT_SGE_FLAGS_SIMPLE_ELEMENT		(0x10000000)
+#define MPT_SGE_FLAGS_CHAIN_ELEMENT		(0x30000000)
+#define MPT_SGE_FLAGS_ELEMENT_MASK		(0x30000000)
+
+#define MPT_SGE_FLAGS_SSIMPLE_READ \
+	(MPT_SGE_FLAGS_LAST_ELEMENT |	\
+	 MPT_SGE_FLAGS_END_OF_BUFFER |	\
+	 MPT_SGE_FLAGS_END_OF_LIST |	\
+	 MPT_SGE_FLAGS_SIMPLE_ELEMENT |	\
+	 MPT_SGE_FLAGS_ADDRESSING | \
+	 MPT_TRANSFER_IOC_TO_HOST)
+#define MPT_SGE_FLAGS_SSIMPLE_WRITE \
+	(MPT_SGE_FLAGS_LAST_ELEMENT |	\
+	 MPT_SGE_FLAGS_END_OF_BUFFER |	\
+	 MPT_SGE_FLAGS_END_OF_LIST |	\
+	 MPT_SGE_FLAGS_SIMPLE_ELEMENT |	\
+	 MPT_SGE_FLAGS_ADDRESSING | \
+	 MPT_TRANSFER_HOST_TO_IOC)
 
 /*}-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #endif
diff -Nru a/drivers/message/fusion/mptctl.c b/drivers/message/fusion/mptctl.c
--- a/drivers/message/fusion/mptctl.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/mptctl.c	Thu Jun 20 15:54:00 2002
@@ -9,6 +9,12 @@
  *      This driver would not exist if not for Alan Cox's development
  *      of the linux i2o driver.
  *
+ *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
+ *      and countless enhancements while adding support for the 1030
+ *      chip family.  Pam has been instrumental in the development of
+ *      of the 2.xx.xx series fusion drivers, and her contributions are
+ *      far too numerous to hope to list in one place.
+ *
  *      A huge debt of gratitude is owed to David S. Miller (DaveM)
  *      for fixing much of the stupid and broken stuff in the early
  *      driver while porting to sparc64 platform.  THANK YOU!
@@ -18,16 +24,17 @@
  *      (plus Eddie's other helpful hints and insights)
  *
  *      Thanks to Arnaldo Carvalho de Melo for finding and patching
- *      a potential memory leak in mpt_ioctl_do_fw_download(),
+ *      a potential memory leak in mptctl_do_fw_download(),
  *      and for some kmalloc insight:-)
  *
  *      (see also mptbase.c)
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston, Noah Romer
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id$
+ *  $Id$
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -69,7 +76,6 @@
 #include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/major.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -80,36 +86,83 @@
 #include <asm/io.h>
 #include <asm/uaccess.h>
 
-#include <linux/proc_fs.h>
+#include <linux/kdev_t.h>	/* needed for access to Scsi_Host struct */
+#include <linux/blkdev.h>
+#include <linux/blk.h>          /* for io_request_lock (spinlock) decl */
+#include "../../scsi/scsi.h"
+#include "../../scsi/hosts.h"
 
 #define COPYRIGHT	"Copyright (c) 1999-2001 LSI Logic Corporation"
-#define MODULEAUTHOR	"Steven J. Ralston, Noah Romer"
+#define MODULEAUTHOR	"Steven J. Ralston, Noah Romer, Pamela Delaney"
 #include "mptbase.h"
+#include "mptctl.h"
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #define my_NAME		"Fusion MPT misc device (ioctl) driver"
 #define my_VERSION	MPT_LINUX_VERSION_COMMON
 #define MYNAM		"mptctl"
 
+EXPORT_NO_SYMBOLS;
 MODULE_AUTHOR(MODULEAUTHOR);
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
 
-
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 static int mptctl_id = -1;
-static int rwperf_reset = 0;
 static struct semaphore mptctl_syscall_sem_ioc[MPT_MAX_ADAPTERS];
 
+static DECLARE_WAIT_QUEUE_HEAD ( mptctl_wait );
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-static int mpt_ioctl_rwperf(unsigned long arg);
-static int mpt_ioctl_rwperf_status(unsigned long arg);
-static int mpt_ioctl_rwperf_reset(unsigned long arg);
-static int mpt_ioctl_fw_download(unsigned long arg);
-static int mpt_ioctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen);
-static int mpt_ioctl_scsi_cmd(unsigned long arg);
+struct buflist {
+	u8	*kptr;
+	int	 len;
+};
+
+/*
+ * Function prototypes. Called from OS entry point mptctl_ioctl.
+ * arg contents specific to function.
+ */
+static int mptctl_fw_download(unsigned long arg);
+static int mptctl_getiocinfo (unsigned long arg, unsigned int cmd);
+static int mptctl_gettargetinfo (unsigned long arg);
+static int mptctl_readtest (unsigned long arg);
+static int mptctl_mpt_command (unsigned long arg);
+static int mptctl_eventquery (unsigned long arg);
+static int mptctl_eventenable (unsigned long arg);
+static int mptctl_eventreport (unsigned long arg);
+static int mptctl_replace_fw (unsigned long arg);
+
+static int mptctl_do_reset(unsigned long arg);
+
+static int mptctl_compaq_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+static int mptctl_cpq_getpciinfo(unsigned long arg);
+static int mptctl_cpq_getdriver(unsigned long arg);
+static int mptctl_cpq_ctlr_status(unsigned long arg);
+static int mptctl_cpq_target_address(unsigned long arg);
+static int mptctl_cpq_passthru(unsigned long arg);
+static int mptctl_compaq_scsiio(VENDOR_IOCTL_REQ *pVenReq, cpqfc_passthru_t *pPass);
+
+/*
+ * Private function calls.
+ */
+static int mptctl_do_mpt_command (struct mpt_ioctl_command karg, char *mfPtr, int local);
+static int mptctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen);
+static MptSge_t *kbuf_alloc_2_sgl( int bytes, u32 dir, int sge_offset, int *frags,
+		struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc);
+static void kfree_sgl( MptSge_t *sgl, dma_addr_t sgl_dma,
+		struct buflist *buflist, MPT_ADAPTER *ioc);
+static void mptctl_timer_expired (unsigned long data);
+static int  mptctl_bus_reset(MPT_IOCTL *ioctl);
+static int mptctl_set_tm_flags(MPT_SCSI_HOST *hd);
+static void mptctl_free_tm_flags(MPT_ADAPTER *ioc);
+
+/*
+ * Reset Handler cleanup function
+ */
+static int  mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -132,34 +185,18 @@
 /* linux only seems to ever give 128kB MAX contiguous (GFP_USER) mem bytes */
 #define MAX_KMALLOC_SZ		(128*1024)
 
-struct buflist {
-	u8	*kptr;
-	int	 len;
-};
-
-#define myMAX_TARGETS	(1<<4)
-#define myMAX_LUNS	(1<<3)
-#define myMAX_T_MASK	(myMAX_TARGETS-1)
-#define myMAX_L_MASK	(myMAX_LUNS-1)
-static u8  DevInUse[myMAX_TARGETS][myMAX_LUNS] = {{0,0}};
-static u32 DevIosCount[myMAX_TARGETS][myMAX_LUNS] = {{0,0}};
+#define MPT_IOCTL_DEFAULT_TIMEOUT 10	/* Default timeout value (seconds) */
 
 static u32 fwReplyBuffer[16];
 static pMPIDefaultReply_t ReplyMsg = NULL;
 
-/* some private forw protos */
-static SGESimple32_t *kbuf_alloc_2_sgl( int bytes, u32 dir, int *frags,
-		struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc);
-static void kfree_sgl( SGESimple32_t *sgl, dma_addr_t sgl_dma,
-		struct buflist *buflist, MPT_ADAPTER *ioc);
-
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptctl_syscall_down - Down the MPT adapter syscall semaphore.
  *	@ioc: Pointer to MPT adapter
  *	@nonblock: boolean, non-zero if O_NONBLOCK is set
  *
- *	All of the mptctl commands can potentially sleep, which is illegal
+ *	All of the ioctl commands can potentially sleep, which is illegal
  *	with a spinlock held, thus we perform mutual exclusion here.
  *
  *	Returns negative errno on error, or zero for success.
@@ -167,16 +204,32 @@
 static inline int
 mptctl_syscall_down(MPT_ADAPTER *ioc, int nonblock)
 {
-	dprintk((KERN_INFO MYNAM "::mpt_syscall_down(%p,%d) called\n", ioc, nonblock));
+	int rc = 0;
+	dctlprintk((KERN_INFO MYNAM "::mptctl_syscall_down(%p,%d) called\n", ioc, nonblock));
 
+	if (ioc->ioctl->tmPtr != NULL) {
+		dctlprintk((KERN_INFO MYNAM "::mptctl_syscall_down BUSY\n"));
+		return -EBUSY;
+	}
+
+#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+	if (!nonblock) {
+		if (down_interruptible(&mptctl_syscall_sem_ioc[ioc->id]))
+			rc = -ERESTARTSYS;
+	} else {
+		rc = -EPERM;
+	}
+#else
 	if (nonblock) {
 		if (down_trylock(&mptctl_syscall_sem_ioc[ioc->id]))
-			return -EAGAIN;
+			rc = -EAGAIN;
 	} else {
 		if (down_interruptible(&mptctl_syscall_sem_ioc[ioc->id]))
-			return -ERESTARTSYS;
+			rc = -ERESTARTSYS;
 	}
-	return 0;
+#endif
+	dctlprintk((KERN_INFO MYNAM "::mptctl_syscall_down return %d\n", rc));
+	return rc;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -189,18 +242,323 @@
 static int
 mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)
 {
-	u8 targ;
+	char *sense_data;
+	int sz, req_index;
+	u16 iocStatus;
+	u8 cmd;
+
+	dctlprintk((MYIOC_s_INFO_FMT ": mptctl_reply()!\n", ioc->name));
+	if (req)
+		 cmd = req->u.hdr.Function;
+	else
+		return 1;
+
+	if (ioc->ioctl) {
+		/* If timer is not running, then an error occurred.
+		 * A timeout will call the reset routine to reload the messaging
+		 * queues.
+		 * Main callback will free message and reply frames.
+		 */
+		if (reply && (cmd == MPI_FUNCTION_SCSI_TASK_MGMT) &&
+		    (ioc->ioctl->status & MPT_IOCTL_STATUS_TMTIMER_ACTIVE)) {
+			/* This is internally generated TM
+			 */
+			del_timer (&ioc->ioctl->TMtimer);
+			ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TMTIMER_ACTIVE;
+
+			mptctl_free_tm_flags(ioc);
+
+			/* If TM failed, reset the timer on the existing command,
+			 * will trigger an adapter reset.
+			 */
+			iocStatus = reply->u.reply.IOCStatus & MPI_IOCSTATUS_MASK;
+			if (iocStatus == MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED) {
+				if (ioc->ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE) {
+					del_timer (&ioc->ioctl->timer);
+					ioc->ioctl->timer.expires = jiffies + HZ;
+					add_timer(&ioc->ioctl->timer);
+				}
+			}
+			ioc->ioctl->tmPtr = NULL;
+
+		} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE) {
+			/* Delete this timer
+			 */
+			del_timer (&ioc->ioctl->timer);
+			ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TIMER_ACTIVE;
+
+			/* Set the overall status byte.  Good if:
+			 * IOC status is good OR if no reply and a SCSI IO request
+			 */
+			if (reply) {
+				/* Copy the reply frame (which much exist
+				 * for non-SCSI I/O) to the IOC structure.
+				 */
+				dctlprintk((MYIOC_s_INFO_FMT ": Copying Reply Frame @%p to IOC!\n",
+						ioc->name, reply));
+				memcpy(ioc->ioctl->ReplyFrame, reply,
+					MIN(ioc->reply_sz, 4*reply->u.reply.MsgLength));
+				ioc->ioctl->status |= MPT_IOCTL_STATUS_RF_VALID;
+
+				/* Set the command status to GOOD if IOC Status is GOOD
+				 * OR if SCSI I/O cmd and data underrun or recovered error.
+				 */
+				iocStatus = reply->u.reply.IOCStatus & MPI_IOCSTATUS_MASK;
+				if (iocStatus  == MPI_IOCSTATUS_SUCCESS)
+					ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
+
+				if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||
+					(cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
+					ioc->ioctl->reset &= ~MPTCTL_RESET_OK;
+
+					if ((iocStatus == MPI_IOCSTATUS_SCSI_DATA_UNDERRUN) ||
+						(iocStatus == MPI_IOCSTATUS_SCSI_RECOVERED_ERROR)) {
+						ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
+					}
+				}
+
+				/* Copy the sense data - if present
+				 */
+				if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) &&
+					(reply->u.sreply.SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID)){
+
+					sz = req->u.scsireq.SenseBufferLength;
+					req_index = le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);
+					sense_data = ((u8 *)ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));
+					memcpy(ioc->ioctl->sense, sense_data, sz);
+					ioc->ioctl->status |= MPT_IOCTL_STATUS_SENSE_VALID;
+				}
+
+				if (cmd == MPI_FUNCTION_SCSI_TASK_MGMT)
+					mptctl_free_tm_flags(ioc);
+
+
+			} else if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||
+					(cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
+				ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
+				ioc->ioctl->reset &= ~MPTCTL_RESET_OK;
+			}
+
+			/* We are done, issue wake up
+			 */
+			ioc->ioctl->wait_done = 1;
+			wake_up (&mptctl_wait);
+		} else if (reply && cmd == MPI_FUNCTION_FW_DOWNLOAD) {
+			/* Two paths to FW DOWNLOAD! */
+			// NOTE: Expects/requires non-Turbo reply!
+			dctlprintk((MYIOC_s_INFO_FMT ":Caching MPI_FUNCTION_FW_DOWNLOAD reply!\n",
+				ioc->name));
+			memcpy(fwReplyBuffer, reply, MIN(sizeof(fwReplyBuffer), 4*reply->u.reply.MsgLength));
+			ReplyMsg = (pMPIDefaultReply_t) fwReplyBuffer;
+		}
+	}
+	return 1;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_timer_expired
+ *
+ * Call back for timer process. Used only for ioctl functionality.
+ *
+ */
+static void mptctl_timer_expired (unsigned long data)
+{
+	MPT_IOCTL *ioctl = (MPT_IOCTL *) data;
+	int rc = 1;
+
+	dctlprintk((KERN_NOTICE MYNAM ": Timer Expired! Host %d\n",
+				ioctl->ioc->id));
+	if (ioctl == NULL)
+		return;
+
+	if (ioctl->reset & MPTCTL_RESET_OK)
+		rc = mptctl_bus_reset(ioctl);
+
+	if (rc) {
+		/* Issue a reset for this device.
+		 * The IOC is not responding.
+		 */
+		mpt_HardResetHandler(ioctl->ioc, NO_SLEEP);
+	}
+	return;
+
+}
+
+/* mptctl_bus_reset
+ *
+ * Bus reset code.
+ *
+ */
+static int mptctl_bus_reset(MPT_IOCTL *ioctl)
+{
+	MPT_FRAME_HDR	*mf;
+	SCSITaskMgmt_t	*pScsiTm;
+	MPT_SCSI_HOST	*hd;
+	int		 ii;
+	int		 retval;
+
+
+	ioctl->reset &= ~MPTCTL_RESET_OK;
+
+	if (ioctl->ioc->sh == NULL)
+		return -EPERM;
+	
+	hd = (MPT_SCSI_HOST *) ioctl->ioc->sh->hostdata;
+	if (hd == NULL)
+		return -EPERM;
+
+	/* Single threading ....
+	 */
+	if (mptctl_set_tm_flags(hd) != 0)
+		return -EPERM;
+
+	/* Send request
+	 */
+	if ((mf = mpt_get_msg_frame(mptctl_id, ioctl->ioc->id)) == NULL) {
+		dtmprintk((MYIOC_s_WARN_FMT "IssueTaskMgmt, no msg frames!!\n",
+				ioctl->ioc->name));
+
+		mptctl_free_tm_flags(ioctl->ioc);
+		return -ENOMEM;
+	}
+
+	dtmprintk((MYIOC_s_INFO_FMT "IssueTaskMgmt request @ %p\n",
+			ioctl->ioc->name, mf));
+
+	pScsiTm = (SCSITaskMgmt_t *) mf;
+	pScsiTm->TargetID = ioctl->target;
+	pScsiTm->Bus = hd->port;	/* 0 */
+	pScsiTm->ChainOffset = 0;
+	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+	pScsiTm->Reserved = 0;
+	pScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
+	pScsiTm->Reserved1 = 0;
+	pScsiTm->MsgFlags = MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION;
+
+	for (ii= 0; ii < 8; ii++)
+		pScsiTm->LUN[ii] = 0;
+
+	for (ii=0; ii < 7; ii++)
+		pScsiTm->Reserved2[ii] = 0;
+
+	pScsiTm->TaskMsgContext = 0;
+	dtmprintk((MYIOC_s_INFO_FMT "mptctl_bus_reset: issued.\n", ioctl->ioc->name));
+
+	ioctl->tmPtr = mf;
+	ioctl->TMtimer.expires = jiffies + HZ * 20;	/* 20 seconds */
+	ioctl->status |= MPT_IOCTL_STATUS_TMTIMER_ACTIVE;
+	add_timer(&ioctl->TMtimer);
+
+	retval = mpt_send_handshake_request(mptctl_id, ioctl->ioc->id,
+			sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, NO_SLEEP);
+
+	if (retval != 0) {
+		dtmprintk((MYIOC_s_WARN_FMT "_send_handshake FAILED!"
+			" (hd %p, ioc %p, mf %p) \n", ioctl->ioc->name, hd, hd->ioc, mf));
+
+		mptctl_free_tm_flags(ioctl->ioc);
+		del_timer(&ioctl->TMtimer);
+		mpt_free_msg_frame(mptctl_id, ioctl->ioc->id, mf);
+		ioctl->tmPtr = NULL;
+	}
+
+	return retval;
+}
+
+static int
+mptctl_set_tm_flags(MPT_SCSI_HOST *hd) {
+	unsigned long flags;
+
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+#ifdef MPT_SCSI_USE_NEW_EH
+	if (hd->tmState == TM_STATE_NONE) {
+		hd->tmState = TM_STATE_IN_PROGRESS;
+		hd->tmPending = 1;
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+	} else {
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		return -EBUSY;
+	}
+#else
+	if (hd->tmPending) {
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		return -EBUSY;
+	} else {
+		hd->tmPending = 1;
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+	}
+#endif
+	return 0;
+}
+
+static void
+mptctl_free_tm_flags(MPT_ADAPTER *ioc)
+{
+	MPT_SCSI_HOST * hd;
+	unsigned long flags;
+
+	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+	if (hd == NULL)
+		return;
+
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+#ifdef MPT_SCSI_USE_NEW_EH
+	hd->tmState = TM_STATE_ERROR;
+	hd->tmPending = 0;
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+#else
+	hd->tmPending = 0;
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+#endif
 
-	//dprintk((KERN_DEBUG MYNAM ": Got mptctl_reply()!\n"));
+	return;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_ioc_reset
+ *
+ * Clean-up functionality. Used only if there has been a
+ * reload of the FW due.
+ *
+ */
+static int
+mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
+{
+	MPT_IOCTL *ioctl = ioc->ioctl;
+	dctlprintk((KERN_INFO MYNAM ": IOC %s_reset routed to IOCTL driver!\n",
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+
+	if (reset_phase == MPT_IOC_PRE_RESET){
+
+		/* Someone has called the reset handler to
+		 * do a hard reset. No more replies from the FW.
+		 * Delete the timer. TM flags cleaned up by SCSI driver.
+		 * Do not need to free msg frame, as re-initialized
+		 */
+		if (ioctl && (ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE)){
+			del_timer(&ioctl->timer);
+		}
+		if (ioctl && (ioctl->status & MPT_IOCTL_STATUS_TMTIMER_ACTIVE)){
+			ioctl->status &= ~MPT_IOCTL_STATUS_TMTIMER_ACTIVE;
+			del_timer(&ioctl->TMtimer);
+			mpt_free_msg_frame(mptctl_id, ioc->id, ioctl->tmPtr);
+		}
 
-	if (req && req->u.hdr.Function == MPI_FUNCTION_SCSI_IO_REQUEST) {
-		targ = req->u.scsireq.TargetID & myMAX_T_MASK;
-		DevIosCount[targ][0]--;
-	} else if (reply && req && req->u.hdr.Function == MPI_FUNCTION_FW_DOWNLOAD) {
-		// NOTE: Expects/requires non-Turbo reply!
-		dprintk((KERN_INFO MYNAM ": Caching MPI_FUNCTION_FW_DOWNLOAD reply!\n"));
-		memcpy(fwReplyBuffer, reply, MIN(sizeof(fwReplyBuffer), 4*reply->u.reply.MsgLength));
-		ReplyMsg = (pMPIDefaultReply_t) fwReplyBuffer;
+	} else {
+		/* Set the status and continue IOCTL
+		 * processing. All memory will be free'd
+		 * by originating thread after wake_up is
+		 * called.
+		 */
+		if (ioctl && (ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE)){
+			ioctl->status = MPT_IOCTL_STATUS_DID_IOCRESET;
+
+			/* Wake up the calling process
+			 */
+			ioctl->wait_done = 1;
+			wake_up(&mptctl_wait);
+		}
 	}
 
 	return 1;
@@ -208,7 +566,7 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *  struct file_operations functionality. 
+ *  struct file_operations functionality.
  *  Members:
  *	llseek, write, read, ioctl, open, release
  */
@@ -234,63 +592,96 @@
 static ssize_t
 mptctl_read(struct file *file, char *buf, size_t count, loff_t *ptr)
 {
+	printk(KERN_ERR MYNAM ": ioctl READ not yet supported\n");
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  MPT ioctl handler
+ *  cmd - specify the particular IOCTL command to be issued
+ *  arg - data specific to the command. Must not be null.
  */
 static int
-mpt_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+mptctl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct mpt_ioctl_sanity	*usanity = (struct mpt_ioctl_sanity *) arg;
-	struct mpt_ioctl_sanity	 ksanity;
+	mpt_ioctl_header	*uhdr = (mpt_ioctl_header *) arg;
+	mpt_ioctl_header	 khdr;
 	int iocnum;
 	unsigned iocnumX;
 	int nonblock = (file->f_flags & O_NONBLOCK);
 	int ret;
 	MPT_ADAPTER *iocp = NULL;
 
-	dprintk((KERN_INFO MYNAM "::mpt_ioctl() called\n"));
+	dctlprintk(("mptctl_ioctl() called\n"));
 
-	if (copy_from_user(&ksanity, usanity, sizeof(ksanity))) {
-		printk(KERN_ERR "%s::mpt_ioctl() @%d - "
-				"Unable to copy mpt_ioctl_sanity data @ %p\n",
-				__FILE__, __LINE__, (void*)usanity);
+	if (copy_from_user(&khdr, uhdr, sizeof(khdr))) {
+		printk(KERN_ERR "%s::mptctl_ioctl() @%d - "
+				"Unable to copy mpt_ioctl_header data @ %p\n",
+				__FILE__, __LINE__, (void*)uhdr);
 		return -EFAULT;
 	}
 	ret = -ENXIO;				/* (-6) No such device or address */
 
-	/* Verify intended MPT adapter */
-	iocnumX = ksanity.iocnum & 0xFF;
+
+	/* Test for Compaq-specific IOCTL's.
+	 */
+	if ((cmd == CPQFCTS_GETPCIINFO) || (cmd == CPQFCTS_CTLR_STATUS) ||
+		(cmd == CPQFCTS_GETDRIVER) || (cmd == CPQFCTS_SCSI_PASSTHRU) ||
+		(cmd == CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS))
+		return mptctl_compaq_ioctl(file, cmd, arg);
+
+	/* Verify intended MPT adapter - set iocnum and the adapter
+	 * pointer (iocp)
+	 */
+	iocnumX = khdr.iocnum & 0xFF;
 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
 	    (iocp == NULL)) {
-		printk(KERN_ERR "%s::mpt_ioctl() @%d - ioc%d not found!\n",
+		printk(KERN_ERR "%s::mptctl_ioctl() @%d - ioc%d not found!\n",
 				__FILE__, __LINE__, iocnumX);
 		return -ENODEV;
 	}
 
+
+
+	/* Handle those commands that are just returning
+	 * information stored in the driver.
+	 * These commands should never time out and are unaffected
+	 * by TM and FW reloads.
+	 */
+	if ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {
+		return mptctl_getiocinfo(arg, _IOC_SIZE(cmd));
+	} else if (cmd == MPTTARGETINFO) {
+		return mptctl_gettargetinfo(arg);
+	} else if (cmd == MPTTEST) {
+		return mptctl_readtest(arg);
+	} else if (cmd == MPTEVENTQUERY) {
+		return mptctl_eventquery(arg);
+	} else if (cmd == MPTEVENTENABLE) {
+		return mptctl_eventenable(arg);
+	} else if (cmd == MPTEVENTREPORT) {
+		return mptctl_eventreport(arg);
+	} else if (cmd == MPTFWREPLACE) {
+		return mptctl_replace_fw(arg);
+	}
+
+	/* All of these commands require an interrupt or
+	 * are unknown/illegal.
+	 */
 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
 		return ret;
 
-	dprintk((KERN_INFO MYNAM "::mpt_ioctl() - Using %s\n", iocp->name));
+	dctlprintk((MYIOC_s_INFO_FMT ": mptctl_ioctl()\n", iocp->name));
 
 	switch(cmd) {
-	case MPTRWPERF:
-		ret = mpt_ioctl_rwperf(arg);
-		break;
-	case MPTRWPERF_CHK:
-		ret = mpt_ioctl_rwperf_status(arg);
-		break;
-	case MPTRWPERF_RESET:
-		ret = mpt_ioctl_rwperf_reset(arg);
-		break;
 	case MPTFWDOWNLOAD:
-		ret = mpt_ioctl_fw_download(arg);
+		ret = mptctl_fw_download(arg);
+		break;
+	case MPTCOMMAND:
+		ret = mptctl_mpt_command(arg);
 		break;
-	case MPTSCSICMD:
-		ret = mpt_ioctl_scsi_cmd(arg);
+	case MPTHARDRESET:
+		ret = mptctl_do_reset(arg);
 		break;
 	default:
 		ret = -EINVAL;
@@ -301,6 +692,36 @@
 	return ret;
 }
 
+static int mptctl_do_reset(unsigned long arg)
+{
+	struct mpt_ioctl_diag_reset *urinfo = (struct mpt_ioctl_diag_reset *) arg;
+	struct mpt_ioctl_diag_reset krinfo;
+	MPT_ADAPTER		*iocp;
+
+	dctlprintk((KERN_INFO "mptctl_do_reset called.\n"));
+
+	if (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {
+		printk(KERN_ERR "%s@%d::mptctl_do_reset - "
+				"Unable to copy mpt_ioctl_diag_reset struct @ %p\n",
+				__FILE__, __LINE__, (void*)urinfo);
+		return -EFAULT;
+	}
+
+	if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {
+		printk(KERN_ERR "%s@%d::mptctl_do_reset - ioc%d not found!\n",
+				__FILE__, __LINE__, krinfo.hdr.iocnum);
+		return -ENXIO; /* (-6) No such device or address */
+	}
+
+	if (mpt_HardResetHandler(iocp, NO_SLEEP) != 0) {
+		printk (KERN_ERR "%s@%d::mptctl_do_reset - reset failed.\n",
+			__FILE__, __LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static int mptctl_open(struct inode *inode, struct file *file)
 {
@@ -317,13 +738,29 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * MPT FW download function.  Cast the arg into the mpt_fw_xfer structure.
+ * This structure contains: iocnum, firmware length (bytes),
+ *      pointer to user space memory where the fw image is stored.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENXIO  if no such device
+ *		-EAGAIN if resource problem
+ *		-ENOMEM if no memory for SGE
+ *		-EMLINK if too many chain buffers required
+ *		-EBADRQC if adapter does not support FW download
+ *		-EBUSY if adapter is busy
+ *		-ENOMSG if FW upload returned bad status
+ */
 static int
-mpt_ioctl_fw_download(unsigned long arg)
+mptctl_fw_download(unsigned long arg)
 {
 	struct mpt_fw_xfer	*ufwdl = (struct mpt_fw_xfer *) arg;
 	struct mpt_fw_xfer	 kfwdl;
 
-	dprintk((KERN_INFO "mpt_ioctl_fwdl called. mptctl_id = %xh\n", mptctl_id)); //tc
+	dctlprintk((KERN_INFO "mptctl_fwdl called. mptctl_id = %xh\n", mptctl_id)); //tc
 	if (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {
 		printk(KERN_ERR "%s@%d::_ioctl_fwdl - "
 				"Unable to copy mpt_fw_xfer struct @ %p\n",
@@ -331,44 +768,52 @@
 		return -EFAULT;
 	}
 
-	return mpt_ioctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);
+	return mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- * MPT FW Download
+ * FW Download engine.
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENXIO  if no such device
+ *		-EAGAIN if resource problem
+ *		-ENOMEM if no memory for SGE
+ *		-EMLINK if too many chain buffers required
+ *		-EBADRQC if adapter does not support FW download
+ *		-EBUSY if adapter is busy
+ *		-ENOMSG if FW upload returned bad status
  */
 static int
-mpt_ioctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen)
+mptctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen)
 {
 	FWDownload_t		*dlmsg;
 	MPT_FRAME_HDR		*mf;
 	MPT_ADAPTER		*iocp;
-//	char			*fwbuf;
-//	dma_addr_t		 fwbuf_dma;
-	FWDownloadTCSGE_t	*fwVoodoo;
-//	SGEAllUnion_t		*fwSgl;
+	FWDownloadTCSGE_t	*ptsge;
+	MptSge_t		*sgl, *sgIn;
+	char			*sgOut;
+	struct buflist		*buflist;
+	struct buflist		*bl;
+	dma_addr_t		 sgl_dma;
 	int			 ret;
-
-	SGESimple32_t	*sgl;
-	SGESimple32_t	*sgOut, *sgIn;
-	dma_addr_t	 sgl_dma;
-	struct buflist	*buflist = NULL;
-	struct buflist	*bl = NULL;
-	int		 numfrags = 0;
-	int		 maxfrags;
-	int		 n = 0;
-	u32		 sgdir;
-	u32		 nib;
-	int		 fw_bytes_copied = 0;
-	u16		 iocstat;
-	int		 i;
-
-	dprintk((KERN_INFO "mpt_ioctl_do_fwdl called. mptctl_id = %xh.\n", mptctl_id));
-
-	dprintk((KERN_INFO "DbG: kfwdl.bufp  = %p\n", ufwbuf));
-	dprintk((KERN_INFO "DbG: kfwdl.fwlen = %d\n", (int)fwlen));
-	dprintk((KERN_INFO "DbG: kfwdl.ioc   = %04xh\n", ioc));
+	int			 numfrags = 0;
+	int			 maxfrags;
+	int			 n = 0;
+	u32			 sgdir;
+	u32			 nib;
+	int			 fw_bytes_copied = 0;
+	int			 i;
+	int			 cntdn;
+	int			 sge_offset = 0;
+	u16			 iocstat;
+
+	dctlprintk((KERN_INFO "mptctl_do_fwdl called. mptctl_id = %xh.\n", mptctl_id));
+
+	dctlprintk((KERN_INFO "DbG: kfwdl.bufp  = %p\n", ufwbuf));
+	dctlprintk((KERN_INFO "DbG: kfwdl.fwlen = %d\n", (int)fwlen));
+	dctlprintk((KERN_INFO "DbG: kfwdl.ioc   = %04xh\n", ioc));
 
 	if ((ioc = mpt_verify_adapter(ioc, &iocp)) < 0) {
 		printk("%s@%d::_ioctl_fwdl - ioc%d not found!\n",
@@ -376,11 +821,13 @@
 		return -ENXIO; /* (-6) No such device or address */
 	}
 
+	/*  Valid device. Get a message frame and construct the FW download message.
+	 */
 	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)
 		return -EAGAIN;
 	dlmsg = (FWDownload_t*) mf;
-	fwVoodoo = (FWDownloadTCSGE_t *) &dlmsg->SGL;
-	sgOut = (SGESimple32_t *) (fwVoodoo + 1);
+	ptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;
+	sgOut = (char *) (ptsge + 1);
 
 	/*
 	 * Construct f/w download request
@@ -392,27 +839,36 @@
 	dlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;
 	dlmsg->MsgFlags = 0;
 
-	fwVoodoo->Reserved = 0;
-	fwVoodoo->ContextSize = 0;
-	fwVoodoo->DetailsLength = 12;
-	fwVoodoo->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
-	fwVoodoo->Reserved1 = 0;
-	fwVoodoo->ImageOffset = 0;
-	fwVoodoo->ImageSize = cpu_to_le32(fwlen);
+	/* Set up the Transaction SGE.
+	 */
+	ptsge->Reserved = 0;
+	ptsge->ContextSize = 0;
+	ptsge->DetailsLength = 12;
+	ptsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
+	ptsge->Reserved_0100_Checksum = 0;
+	ptsge->ImageOffset = 0;
+	ptsge->ImageSize = cpu_to_le32(fwlen);
+
+	/* Add the SGL
+	 */
 
 	/*
 	 * Need to kmalloc area(s) for holding firmware image bytes.
 	 * But we need to do it piece meal, using a proper
 	 * scatter gather list (with 128kB MAX hunks).
-	 * 
+	 *
 	 * A practical limit here might be # of sg hunks that fit into
 	 * a single IOC request frame; 12 or 8 (see below), so:
 	 * For FC9xx: 12 x 128kB == 1.5 mB (max)
 	 * For C1030:  8 x 128kB == 1   mB (max)
 	 * We could support chaining, but things get ugly(ier:)
+	 *
+	 * Set the sge_offset to the start of the sgl (bytes).
 	 */
 	sgdir = 0x04000000;		/* IOC will READ from sys mem */
-	if ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, &numfrags, &buflist, &sgl_dma, iocp)) == NULL)
+	sge_offset = sizeof(MPIHeader_t) + sizeof(FWDownloadTCSGE_t);
+	if ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, sge_offset,
+				    &numfrags, &buflist, &sgl_dma, iocp)) == NULL)
 		return -ENOMEM;
 
 	/*
@@ -420,16 +876,20 @@
 	 * for FC9xx f/w image, but calculate max number of sge hunks
 	 * we can fit into a request frame, and limit ourselves to that.
 	 * (currently no chain support)
-	 * For FC9xx: (128-12-16)/8 = 12.5 = 12
-	 * For C1030:  (96-12-16)/8 =  8.5 =  8
+	 * maxfrags = (Request Size - FWdownload Size ) / Size of 32 bit SGE
+	 *	Request		maxfrags
+	 *	128		12
+	 *	96		8
+	 *	64		4
 	 */
-	maxfrags = (iocp->req_sz - sizeof(MPIHeader_t) - sizeof(FWDownloadTCSGE_t)) / sizeof(SGESimple32_t);
+	maxfrags = (iocp->req_sz - sizeof(MPIHeader_t) - sizeof(FWDownloadTCSGE_t)) 
+			/ (sizeof(dma_addr_t) + sizeof(u32));
 	if (numfrags > maxfrags) {
 		ret = -EMLINK;
 		goto fwdl_out;
 	}
 
-	dprintk((KERN_INFO "DbG: sgl buffer  = %p, sgfrags = %d\n", sgl, numfrags));
+	dctlprintk((KERN_INFO "DbG: sgl buffer  = %p, sgfrags = %d\n", sgl, numfrags));
 
 	/*
 	 * Parse SG list, copying sgl itself,
@@ -439,12 +899,18 @@
 	sgIn = sgl;
 	bl = buflist;
 	for (i=0; i < numfrags; i++) {
-		nib = (le32_to_cpu(sgIn->FlagsLength) & 0xF0000000) >> 28;
-		/* skip ignore/chain. */
+
+		/* Get the SGE type: 0 - TCSGE, 3 - Chain, 1 - Simple SGE
+		 * Skip everything but Simple. If simple, copy from
+		 *	user space into kernel space.
+		 * Note: we should not have anything but Simple as
+		 *	Chain SGE are illegal.
+		 */
+		nib = (sgIn->FlagsLength & 0x30000000) >> 28;
 		if (nib == 0 || nib == 3) {
 			;
 		} else if (sgIn->Address) {
-			*sgOut = *sgIn;
+			mpt_add_sge(sgOut, sgIn->FlagsLength, sgIn->Address);
 			n++;
 			if (copy_from_user(bl->kptr, ufwbuf+fw_bytes_copied, bl->len)) {
 				printk(KERN_ERR "%s@%d::_ioctl_fwdl - "
@@ -456,7 +922,7 @@
 		}
 		sgIn++;
 		bl++;
-		sgOut++;
+		sgOut += (sizeof(dma_addr_t) + sizeof(u32));
 	}
 
 #ifdef MPT_DEBUG
@@ -478,26 +944,24 @@
 	/*
 	 *  Wait until the reply has been received
 	 */
-	{
-		int	 foo = 0;
-
-		while (ReplyMsg == NULL) {
-			if (!(foo%1000000)) {
-				dprintk((KERN_INFO "DbG::_do_fwdl: "
-					   "In ReplyMsg loop - iteration %d\n",
-					   foo)); //tc
-			}
+	for (cntdn=HZ*60, i=1; ReplyMsg == NULL; cntdn--, i++) {
+		if (!cntdn) {
 			ret = -ETIME;
-			if (++foo > 60000000)
-				goto fwdl_out;
-			mb();
-			schedule();
-			barrier();
+			goto fwdl_out;
+		}
+
+		if (!(i%HZ)) {
+			dctlprintk((KERN_INFO "DbG::_do_fwdl: "
+				   "In ReplyMsg loop - iteration %d\n",
+				   i));
 		}
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
 	}
 
 	if (sgl)
-        	kfree_sgl(sgl, sgl_dma, buflist, iocp);
+		kfree_sgl(sgl, sgl_dma, buflist, iocp);
 
 	iocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;
 	if (iocstat == MPI_IOCSTATUS_SUCCESS) {
@@ -527,32 +991,43 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *  NEW rwperf (read/write performance) stuff starts here...
+ * SGE Allocation routine
+ *
+ * Inputs:	bytes - number of bytes to be transferred
+ *		sgdir - data direction
+ *		sge_offset - offset (in bytes) from the start of the request
+ *			frame to the first SGE
+ *		ioc - pointer to the mptadapter
+ * Outputs:	frags - number of scatter gather elements
+ *		blp - point to the buflist pointer
+ *		sglbuf_dma - pointer to the (dma) sgl
+ * Returns:	Null if failes
+ *		pointer to the (virtual) sgl if successful.
  */
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static SGESimple32_t *
-kbuf_alloc_2_sgl(int bytes, u32 sgdir, int *frags,
+static MptSge_t *
+kbuf_alloc_2_sgl(int bytes, u32 sgdir, int sge_offset, int *frags,
 		 struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc)
 {
-	SGESimple32_t	*sglbuf = NULL;
-	struct buflist	*buflist = NULL;
+	MptSge_t	*sglbuf = NULL;		/* pointer to array of SGE */
+						/* and chain buffers */
+	struct buflist	*buflist = NULL;	/* kernel routine */
+	MptSge_t	*sgl;
 	int		 numfrags = 0;
 	int		 fragcnt = 0;
 	int		 alloc_sz = MIN(bytes,MAX_KMALLOC_SZ);	// avoid kernel warning msg!
 	int		 bytes_allocd = 0;
 	int		 this_alloc;
-	SGESimple32_t	*sgl;
-	u32		 pa;					// phys addr
-	SGEChain32_t	*last_chain = NULL;
-	SGEChain32_t	*old_chain = NULL;
-	int		 chaincnt = 0;
+	dma_addr_t	 pa;					// phys addr
 	int		 i, buflist_ent;
 	int		 sg_spill = MAX_FRAGS_SPILL1;
 	int		 dir;
-
+	/* initialization */
 	*frags = 0;
 	*blp = NULL;
+
+	/* Allocate and initialize an array of kernel
+	 * structures for the SG elements.
+	 */
 	i = MAX_SGL_BYTES / 8;
 	buflist = kmalloc(i, GFP_USER);
 	if (buflist == NULL)
@@ -560,6 +1035,11 @@
 	memset(buflist, 0, i);
 	buflist_ent = 0;
 
+	/* Allocate a single block of memory to store the sg elements and
+	 * the chain buffers.  The calling routine is responsible for
+	 * copying the data in this array into the correct place in the
+	 * request and chain buffers.
+	 */
 	sglbuf = pci_alloc_consistent(ioc->pcidev, MAX_SGL_BYTES, sglbuf_dma);
 	if (sglbuf == NULL)
 		goto free_and_fail;
@@ -569,7 +1049,15 @@
 	else
 		dir = PCI_DMA_FROMDEVICE;
 
+	/* At start:
+	 *	sgl = sglbuf = point to beginning of sg buffer
+	 *	buflist_ent = 0 = first kernel structure
+	 *	sg_spill = number of SGE that can be written before the first
+	 *		chain element.
+	 *
+	 */
 	sgl = sglbuf;
+	sg_spill = ((ioc->req_sz - sge_offset)/(sizeof(dma_addr_t) + sizeof(u32))) - 1;
 	while (bytes_allocd < bytes) {
 		this_alloc = MIN(alloc_sz, bytes-bytes_allocd);
 		buflist[buflist_ent].len = this_alloc;
@@ -590,11 +1078,9 @@
 			dma_addr_t dma_addr;
 
 			bytes_allocd += this_alloc;
-
-			/* Write one SIMPLE sge */
-			sgl->FlagsLength = cpu_to_le32(0x10000000|sgdir|this_alloc);
+			sgl->FlagsLength = (0x10000000|MPT_SGE_FLAGS_ADDRESSING|sgdir|this_alloc);
 			dma_addr = pci_map_single(ioc->pcidev, buflist[buflist_ent].kptr, this_alloc, dir);
-			sgl->Address = cpu_to_le32(dma_addr);
+			sgl->Address = dma_addr;
 
 			fragcnt++;
 			numfrags++;
@@ -607,33 +1093,13 @@
 
 		/* Need to chain? */
 		if (fragcnt == sg_spill) {
-			dma_addr_t chain_link;
-
-			if (last_chain != NULL)
-				last_chain->NextChainOffset = 0x1E;
-
-			fragcnt = 0;
-			sg_spill = MAX_FRAGS_SPILL2;
-
-			/* fixup previous SIMPLE sge */
-			sgl[-1].FlagsLength |= cpu_to_le32(0x80000000);
-
-			chain_link = (*sglbuf_dma) +
-				((u8 *)(sgl+1) - (u8 *)sglbuf);
-
-			/* Write one CHAIN sge */
-			sgl->FlagsLength = cpu_to_le32(0x30000080);
-			sgl->Address = cpu_to_le32(chain_link);
-
-			old_chain = last_chain;
-			last_chain = (SGEChain32_t*)sgl;
-			chaincnt++;
-			numfrags++;
-			sgl++;
+			printk(KERN_WARNING MYNAM "-SG: No can do - " "Chain required!   :-(\n");
+			printk(KERN_WARNING MYNAM "(freeing %d frags)\n", numfrags);
+			goto free_and_fail;
 		}
 
 		/* overflow check... */
-		if (numfrags*8 > MAX_SGL_BYTES) {
+		if (numfrags*8 > MAX_SGL_BYTES){
 			/* GRRRRR... */
 			printk(KERN_WARNING MYNAM "-SG: No can do - "
 					    "too many SG frags!   :-(\n");
@@ -644,20 +1110,16 @@
 	}
 
 	/* Last sge fixup: set LE+eol+eob bits */
-	sgl[-1].FlagsLength |= cpu_to_le32(0xC1000000);
-
-	/* Chain fixup needed? */
-	if (last_chain != NULL && fragcnt < 16)
-		last_chain->Length = cpu_to_le16(fragcnt * 8);
+	sgl[-1].FlagsLength |= 0xC1000000;
 
 	*frags = numfrags;
 	*blp = buflist;
 
-	dprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
-			   "%d SG frags generated!  (%d CHAIN%s)\n",
-			   numfrags, chaincnt, chaincnt>1?"s":""));
+	dctlprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
+			   "%d SG frags generated!\n",
+			   numfrags));
 
-	dprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
+	dctlprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
 			   "last (big) alloc_sz=%d\n",
 			   alloc_sz));
 
@@ -672,10 +1134,10 @@
 			u8 *kptr;
 			int len;
 
-			if ((le32_to_cpu(sglbuf[i].FlagsLength) >> 24) == 0x30)
+			if ((sglbuf[i].FlagsLength >> 24) == 0x30)
 				continue;
 
-			dma_addr = le32_to_cpu(sglbuf[i].Address);
+			dma_addr = sglbuf[i].Address;
 			kptr = buflist[i].kptr;
 			len = buflist[i].len;
 
@@ -688,21 +1150,24 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Routine to free the SGL elements.
+ */
 static void
-kfree_sgl(SGESimple32_t *sgl, dma_addr_t sgl_dma, struct buflist *buflist, MPT_ADAPTER *ioc)
+kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma, struct buflist *buflist, MPT_ADAPTER *ioc)
 {
-	SGESimple32_t	*sg = sgl;
+	MptSge_t	*sg = sgl;
 	struct buflist	*bl = buflist;
 	u32		 nib;
 	int		 dir;
 	int		 n = 0;
 
-	if (le32_to_cpu(sg->FlagsLength) & 0x04000000)
+	if (sg->FlagsLength & 0x04000000)
 		dir = PCI_DMA_TODEVICE;
 	else
 		dir = PCI_DMA_FROMDEVICE;
 
-	nib = (le32_to_cpu(sg->FlagsLength) & 0xF0000000) >> 28;
+	nib = (sg->FlagsLength & 0xF0000000) >> 28;
 	while (! (nib & 0x4)) { /* eob */
 		/* skip ignore/chain. */
 		if (nib == 0 || nib == 3) {
@@ -712,7 +1177,7 @@
 			void *kptr;
 			int len;
 
-			dma_addr = le32_to_cpu(sg->Address);
+			dma_addr = sg->Address;
 			kptr = bl->kptr;
 			len = bl->len;
 			pci_unmap_single(ioc->pcidev, dma_addr, len, dir);
@@ -730,7 +1195,7 @@
 		void *kptr;
 		int len;
 
-		dma_addr = le32_to_cpu(sg->Address);
+		dma_addr = sg->Address;
 		kptr = bl->kptr;
 		len = bl->len;
 		pci_unmap_single(ioc->pcidev, dma_addr, len, dir);
@@ -740,363 +1205,1711 @@
 
 	pci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sgl, sgl_dma);
 	kfree(buflist);
-	dprintk((KERN_INFO MYNAM "-SG: Free'd 1 SGL buf + %d kbufs!\n", n));
+	dctlprintk((KERN_INFO MYNAM "-SG: Free'd 1 SGL buf + %d kbufs!\n", n));
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptctl_getiocinfo - Query the host adapter for IOC information.
+ *	@arg: User space argument
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV  if no such device/adapter
+ */
 static int
-mpt_ioctl_rwperf_init(struct mpt_raw_r_w *dest, unsigned long src,
-		      char *caller, MPT_ADAPTER **iocpp)
+mptctl_getiocinfo (unsigned long arg, unsigned int data_size)
 {
-	char	*myname = "_rwperf_init()";
-	int	 ioc;
+	struct mpt_ioctl_iocinfo *uarg = (struct mpt_ioctl_iocinfo *) arg;
+	struct mpt_ioctl_iocinfo karg;
+	MPT_ADAPTER		*ioc;
+	struct pci_dev		*pdev;
+	struct Scsi_Host	*sh;
+	MPT_SCSI_HOST		*hd;
+	int			iocnum;
+	int			numDevices = 0;
+	unsigned int		max_id;
+	int			ii;
+	int			port;
+	int			cim_rev;
+	u8			revision;
+
+	dctlprintk((": mptctl_getiocinfo called.\n"));
+	if (data_size == sizeof(struct mpt_ioctl_iocinfo))
+		cim_rev = 1;
+	else if (data_size == (sizeof(struct mpt_ioctl_iocinfo) - sizeof(struct mpt_ioctl_pci_info)))
+		cim_rev = 0;
+	else
+		return -EFAULT;
 
-	/* get copy of structure passed from user space */
-	if (copy_from_user(dest, (void*)src, sizeof(*dest))) {
-		printk(KERN_ERR MYNAM "::%s() @%d - Can't copy mpt_raw_r_w data @ %p\n",
-				myname, __LINE__, (void*)src);
-		return -EFAULT;				/* (-14) Bad address */
-	} else {
-		dprintk((KERN_INFO MYNAM "-perf: PerfInfo.{ioc,targ,qd,iters,nblks}"
-				   ": %d %d %d %d %d\n",
-				   dest->iocnum, dest->target,
-				   (int)dest->qdepth, dest->iters, dest->nblks ));
-		dprintk((KERN_INFO MYNAM "-perf: PerfInfo.{cache,skip,range,rdwr,seqran}"
-				   ": %d %d %d %d %d\n",
-				   dest->cache_sz, dest->skip, dest->range,
-				   dest->rdwr, dest->seqran ));
-
-		/* Get the MPT adapter id. */
-		if ((ioc = mpt_verify_adapter(dest->iocnum, iocpp)) < 0) {
-			printk(KERN_ERR MYNAM "::%s() @%d - ioc%d not found!\n",
-					myname, __LINE__, dest->iocnum);
-			return -ENXIO;			/* (-6) No such device or address */
-		} else {
-			dprintk((MYNAM "-perf: %s using mpt/ioc%x, target %02xh\n",
-					caller, dest->iocnum, dest->target));
+	if (copy_from_user(&karg, uarg, data_size)) {
+		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
+			"Unable to read in mpt_ioctl_iocinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_getiocinfo() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	/* Verify the data transfer size is correct.
+	 * Ignore the port setting.
+	 */
+	if (karg.hdr.maxDataSize != data_size) {
+		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
+			"Structure size mismatch. Command not completed.\n",
+				__FILE__, __LINE__);
+		return -EFAULT;
+	}
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+	if (ioc->chip_type == C1030)
+		karg.adapterType = MPT_IOCTL_INTERFACE_SCSI;
+	else
+		karg.adapterType = MPT_IOCTL_INTERFACE_FC;
+
+	port = karg.hdr.port;
+
+	karg.port = port;
+	pdev = (struct pci_dev *) ioc->pcidev;
+
+	karg.pciId = pdev->device;
+	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
+	karg.hwRev = revision;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	karg.subSystemDevice = pdev->subsystem_device;
+	karg.subSystemVendor = pdev->subsystem_vendor;
+#endif
+
+	if (cim_rev == 1) {
+		/* Get the PCI bus, device, and function numbers for the IOC
+		 */
+		karg.pciInfo.u.bits.busNumber = pdev->bus->number;
+		karg.pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
+		karg.pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
+	}
+
+	/* Get number of devices
+         */
+	if ((sh = ioc->sh) != NULL) {
+		 /* sh->max_id = maximum target ID + 1
+		 */
+		max_id = sh->max_id - 1;
+		hd = (MPT_SCSI_HOST *) sh->hostdata;
+
+		/* Check all of the target structures and
+		 * keep a counter.
+		 */
+		if (hd && hd->Targets) {
+			for (ii = 0; ii <= max_id; ii++) {
+				if (hd->Targets[ii])
+					numDevices++;
+			}
 		}
 	}
+	karg.numDevices = numDevices;
+
+	/* Set the BIOS and FW Version
+	 */
+	karg.FWVersion = ioc->facts.FWVersion.Word;
+	karg.BIOSVersion = ioc->biosVersion;
+
+	/* Set the Version Strings.
+	 */
+	strncpy (karg.driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);
+
+	karg.busChangeEvent = 0;
+	karg.hostId = ioc->pfacts[port].PortSCSIID;
+	karg.rsvd[0] = karg.rsvd[1] = 0;
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg, data_size)) {
+		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
+			"Unable to write out mpt_ioctl_iocinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
-	return ioc;
+	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptctl_gettargetinfo - Query the host adapter for target information.
+ *	@arg: User space argument
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV  if no such device/adapter
+ */
+static int
+mptctl_gettargetinfo (unsigned long arg)
+{
+	struct mpt_ioctl_targetinfo *uarg = (struct mpt_ioctl_targetinfo *) arg;
+	struct mpt_ioctl_targetinfo karg;
+	MPT_ADAPTER		*ioc;
+	struct Scsi_Host	*sh;
+	MPT_SCSI_HOST		*hd;
+	char			*pmem;
+	int			*pdata;
+	int			iocnum;
+	int			numDevices = 0;
+	unsigned int		max_id;
+	int			ii, jj, lun;
+	int			maxWordsLeft;
+	int			numBytes;
+	u8			port;
+
+	dctlprintk(("mptctl_gettargetinfo called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {
+		printk(KERN_ERR "%s@%d::mptctl_gettargetinfo - "
+			"Unable to read in mpt_ioctl_targetinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_gettargetinfo() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	/* Get the port number and set the maximum number of bytes
+	 * in the returned structure.
+	 * Ignore the port setting.
+	 */
+	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
+	maxWordsLeft = numBytes/sizeof(int);
+	port = karg.hdr.port;
+
+	if (maxWordsLeft <= 0) {
+		printk(KERN_ERR "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
+				__FILE__, __LINE__);
+		return -ENOMEM;
+	}
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+
+	/* struct mpt_ioctl_targetinfo does not contain sufficient space
+	 * for the target structures so when the IOCTL is called, there is
+	 * not sufficient stack space for the structure. Allocate memory,
+	 * populate the memory, copy back to the user, then free memory.
+	 * targetInfo format:
+	 * bits 31-24: reserved
+	 *      23-16: LUN
+	 *      15- 8: Bus Number
+	 *       7- 0: Target ID
+	 */
+	pmem = kmalloc(numBytes, GFP_KERNEL);
+	if (pmem == NULL) {
+		printk(KERN_ERR "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
+				__FILE__, __LINE__);
+		return -ENOMEM;
+	}
+	memset(pmem, 0, numBytes);
+	pdata =  (int *) pmem;
+
+	/* Get number of devices
+         */
+	if ( (sh = ioc->sh) != NULL) {
+
+		max_id = sh->max_id - 1;
+		hd = (MPT_SCSI_HOST *) sh->hostdata;
+
+		/* Check all of the target structures.
+		 * Save the Id and increment the counter,
+		 * if ptr non-null.
+		 * sh->max_id = maximum target ID + 1
+		 */
+		if (hd && hd->Targets) {
+			ii = 0;
+			while (ii <= max_id) {
+				if (hd->Targets[ii]) {
+					for (jj = 0; jj <= MPT_LAST_LUN; jj++) {
+						lun = (1 << jj);
+						if (hd->Targets[ii]->luns & lun) {
+							numDevices++;
+							*pdata = (jj << 16) | ii;
+							--maxWordsLeft;
+
+							pdata++;
+
+							if (maxWordsLeft <= 0) {
+								break;
+							}
+						}
+					}
+				}
+				ii++;
+			}
+		}
+	}
+	karg.numDevices = numDevices;
+
+	/* Copy part of the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(struct mpt_ioctl_targetinfo))) {
+		printk(KERN_ERR "%s@%d::mptctl_gettargetinfo - "
+			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		kfree(pmem);
+		return -EFAULT;
+	}
+
+	/* Copy the remaining data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *) uarg->targetInfo, pmem, numBytes)) {
+		printk(KERN_ERR "%s@%d::mptctl_gettargetinfo - "
+			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)pdata);
+		kfree(pmem);
+		return -EFAULT;
+	}
+
+	kfree(pmem);
 
-/*  Treat first N blocks of disk as sacred!  */
-#define SACRED_BLOCKS	100
+	return 0;
+}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* MPT IOCTL Test function.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV  if no such device/adapter
+ */
 static int
-mpt_ioctl_rwperf(unsigned long arg)
+mptctl_readtest (unsigned long arg)
 {
-	struct mpt_raw_r_w	 kPerfInfo;
-				/* NOTE: local copy, on stack==KERNEL_SPACE! */
-	u8		 target, targetM;
-	u8		 lun, lunM;
-	u8		 scsiop;
-	int		 qdepth;
-	int		 iters;
-	int		 cache_sz;
-	u32		 xferbytes;
-	u32		 scsidir;
-	u32		 qtag;
-	u32		 scsictl;
-	u32		 sgdir;
-	u32		 blkno;
-	u32		 sbphys;
-	SGESimple32_t	*sgl;
-	dma_addr_t	 sgl_dma;
-	struct buflist	*buflist;
-	SGESimple32_t	*sgOut, *sgIn;
-	int		 numfrags;
-	u32		*msg;
-	int		 i;
-	int		 ioc;
-	MPT_FRAME_HDR	*mf;
-	MPT_ADAPTER	*iocp;
-	int		 sgfragcpycnt;
-	int		 blklo, blkhi;
-	u8		 nextchainoffset;
-	u8		*SenseBuf;
-	dma_addr_t	 SenseBufDMA;
-	char		*myname = "_rwperf()";
-
-    dprintk((KERN_INFO "%s - starting...\n", myname));
-
-    /* Validate target device */
-    if ((ioc = mpt_ioctl_rwperf_init(&kPerfInfo, arg, myname, &iocp)) < 0)
-        return ioc;
-
-    /* Allocate DMA'able memory for the sense buffer. */
-    SenseBuf = pci_alloc_consistent(iocp->pcidev, 256, &SenseBufDMA);
-
-    /* set perf parameters from input */
-    target = kPerfInfo.target & 0x0FF;
-    targetM = target & myMAX_T_MASK;
-    lun = kPerfInfo.lun & 0x1F;			// LUN=31 max
-    lunM = lun & myMAX_L_MASK;
-    qdepth = kPerfInfo.qdepth;
-    iters = kPerfInfo.iters;
-    xferbytes = ((u32)kPerfInfo.nblks)<<9;
-
-    DevInUse[targetM][lunM] = 1;
-    DevIosCount[targetM][lunM] = 0;
-
-    cache_sz = kPerfInfo.cache_sz * 1024;	// CacheSz in kB!
-
-    /* ToDo: */
-    /* get capacity (?) */
-
-
-    // pre-build, one time, everything we can for speed in the loops below...
-
-    scsiop = 0x28;				// default to SCSI READ!
-    scsidir = MPI_SCSIIO_CONTROL_READ;		// DATA IN  (host<--ioc<--dev)
-						// 02000000
-    qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;		// 00000000
-
-    if (xferbytes == 0) {
-        // Do 0-byte READ!!!
-        //  IMPORTANT!  Need to set no SCSI DIR for this!
-        scsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
-    }
-
-    scsictl = scsidir | qtag;
-
-    /*
-     *  Set sgdir for DMA transfer.
-     */
-//    sgdir   = 0x04000000;		// SCSI WRITE
-    sgdir = 0x00000000;			// SCSI READ
-
-    if ((sgl = kbuf_alloc_2_sgl(MAX(512,xferbytes), sgdir, &numfrags, &buflist, &sgl_dma, iocp)) == NULL)
-        return -ENOMEM;
-
-    sgfragcpycnt = MIN(10,numfrags);
-    nextchainoffset = 0;
-    if (numfrags > 10)
-        nextchainoffset = 0x1E;
-
-    sbphys = SenseBufDMA;
-
-    rwperf_reset = 0;
-
-//    do {	// target-loop
-
-        blkno = SACRED_BLOCKS;		// Treat first N blocks as sacred!
-					// FIXME!  Skip option
-        blklo = blkno;
-        blkhi = blkno;
-
-        do {    // inner-loop
-
-            while ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
-                mb();
-                schedule();
-                barrier();
-            }
-            msg = (u32*)mf;
-
-            /* Start piecing the SCSIIORequest together */
-            msg[0] = 0x00000000 | nextchainoffset<<16 | target;
-            msg[1] = 0x0000FF0A;				// 255 sense bytes, 10-byte CDB!
-            msg[3] = lun << 8;
-            msg[4] = 0;
-            msg[5] = scsictl;
-
-            // 16 bytes of CDB @ msg[6,7,8,9] are below...
-
-            msg[6] = (   ((blkno & 0xFF000000) >> 8)
-                       | ((blkno & 0x00FF0000) << 8)
-                       | scsiop );
-            msg[7] = (   (((u32)kPerfInfo.nblks & 0x0000FF00) << 16)
-                       | ((blkno & 0x000000FF) << 8)
-                       | ((blkno & 0x0000FF00) >> 8) );
-            msg[8] = (kPerfInfo.nblks & 0x00FF);
-            msg[9] = 0;
-
-            msg[10] = xferbytes;
-
-//            msg[11] = 0xD0000100;
-//            msg[12] = sbphys;
-//            msg[13] = 0;
-            msg[11] = sbphys;
-
-            // Copy the SGL...
-            if (xferbytes) {
-                sgOut = (SGESimple32_t*)&msg[12];
-                sgIn  = sgl;
-                for (i=0; i < sgfragcpycnt; i++)
-                    *sgOut++ = *sgIn++;
-            }
-
-            // fubar!  QueueDepth issue!!!
-            while (    !rwperf_reset
-                    && (DevIosCount[targetM][lunM] >= MIN(qdepth,64)) )
-            {
-                mb();
-                schedule();
-                barrier();
-            }
-
-//            blkno += kPerfInfo.nblks;
-// EXP Stuff!
-// Try optimizing to certain cache size for the target!
-// by keeping blkno within cache range if at all possible
-#if 0
-            if (    cache_sz
-                 && ((2 * kPerfInfo.nblks) <= (cache_sz>>9))
-                 && ((blkno + kPerfInfo.nblks) > ((cache_sz>>9) + SACRED_BLOCKS)) )
-                blkno = SACRED_BLOCKS;
-            else
-                blkno += kPerfInfo.nblks;
+	struct mpt_ioctl_test	*uarg = (struct mpt_ioctl_test *) arg;
+	struct mpt_ioctl_test	 karg;
+	MPT_ADAPTER *ioc;
+	int iocnum;
+
+	dctlprintk(("mptctl_readtest called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {
+		printk(KERN_ERR "%s@%d::mptctl_readtest - "
+			"Unable to read in mpt_ioctl_test struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_readtest() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+
+#ifdef MFCNT
+	karg.chip_type = ioc->mfcnt;
+#else
+	karg.chip_type = ioc->chip_type;
 #endif
-// Ok, cheat!
-            if (cache_sz && ((blkno + kPerfInfo.nblks) > ((cache_sz>>9) + SACRED_BLOCKS)) )
-                   blkno = SACRED_BLOCKS;
-            else
-                blkno += kPerfInfo.nblks;
+	strncpy (karg.name, ioc->name, MPT_MAX_NAME);
+	strncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg, sizeof(struct mpt_ioctl_test))) {
+		printk(KERN_ERR "%s@%d::mptctl_readtest - "
+			"Unable to write out mpt_ioctl_test struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptctl_eventquery - Query the host adapter for the event types
+ *	that are being logged.
+ *	@arg: User space argument
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV  if no such device/adapter
+ */
+static int
+mptctl_eventquery (unsigned long arg)
+{
+	struct mpt_ioctl_eventquery	*uarg = (struct mpt_ioctl_eventquery *) arg;
+	struct mpt_ioctl_eventquery	 karg;
+	MPT_ADAPTER *ioc;
+	int iocnum;
+
+	dctlprintk(("mptctl_eventquery called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventquery - "
+			"Unable to read in mpt_ioctl_eventquery struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
-            if (blkno > blkhi)
-                blkhi = blkno;
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_eventquery() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
 
-            DevIosCount[targetM][lunM]++;
+	karg.eventEntries = ioc->eventLogSize;
+	karg.eventTypes = ioc->eventTypes;
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventquery - "
+			"Unable to write out mpt_ioctl_eventquery struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+	return 0;
+}
 
-            /*
-             *  Finally, post the request
-             */
-            mpt_put_msg_frame(mptctl_id, ioc, mf);
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+mptctl_eventenable (unsigned long arg)
+{
+	struct mpt_ioctl_eventenable	*uarg = (struct mpt_ioctl_eventenable *) arg;
+	struct mpt_ioctl_eventenable	 karg;
+	MPT_ADAPTER *ioc;
+	int iocnum;
 
+	dctlprintk(("mptctl_eventenable called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventenable - "
+			"Unable to read in mpt_ioctl_eventenable struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
-            /* let linux breath! */
-            mb();
-            schedule();
-            barrier();
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_eventenable() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
 
-            //dprintk((KERN_DEBUG MYNAM "-perf: inner-loop, cnt=%d\n", iters));
+	if (ioc->events == NULL) {
+		/* Have not yet allocated memory - do so now.
+		 */
+		int sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
+		ioc->events = kmalloc(sz, GFP_KERNEL);
+		if (ioc->events == NULL) {
+			printk(KERN_ERR MYNAM ": ERROR - Insufficient memory to add adapter!\n");
+			return -ENOMEM;
+		}
+		memset(ioc->events, 0, sz);
+		ioc->alloc_total += sz;
 
-        } while ((--iters > 0) && !rwperf_reset);
+		ioc->eventLogSize = MPTCTL_EVENT_LOG_SIZE;
+		ioc->eventContext = 0;
+        }
 
-        dprintk((KERN_INFO MYNAM "-perf: DbG: blklo=%d, blkhi=%d\n", blklo, blkhi));
-        dprintk((KERN_INFO MYNAM "-perf: target-loop, thisTarget=%d\n", target));
+	/* Update the IOC event logging flag.
+	 */
+	ioc->eventTypes = karg.eventTypes;
 
-//        //  TEMPORARY!
-//        target = 0;
+	return 0;
+}
 
-//    } while (target);
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+mptctl_eventreport (unsigned long arg)
+{
+	struct mpt_ioctl_eventreport	*uarg = (struct mpt_ioctl_eventreport *) arg;
+	struct mpt_ioctl_eventreport	 karg;
+	MPT_ADAPTER		 *ioc;
+	int			 iocnum;
+	int			 numBytes, maxEvents, max;
+
+	dctlprintk(("mptctl_eventreport called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventreport - "
+			"Unable to read in mpt_ioctl_eventreport struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_eventreport() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
 
-    if (DevIosCount[targetM][lunM]) {
-        dprintk((KERN_INFO "  DbG: DevIosCount[%d][%d]=%d\n",
-                targetM, lunM, DevIosCount[targetM][lunM]));
-    }
+	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
+	maxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);
 
-    while (DevIosCount[targetM][lunM]) {
-        //dprintk((KERN_DEBUG "  DbG: Waiting... DevIosCount[%d][%d]=%d\n",
-        //        targetM, lunM, DevIosCount[targetM][lunM]));
-        mb();
-        schedule();
-        barrier();
-    }
-    DevInUse[targetM][lunM] = 0;
 
-    pci_free_consistent(iocp->pcidev, 256, SenseBuf, SenseBufDMA);
+	max = ioc->eventLogSize < maxEvents ? ioc->eventLogSize : maxEvents;
 
-    if (sgl)
-        kfree_sgl(sgl, sgl_dma, buflist, iocp);
+	/* If fewer than 1 event is requested, there must have
+	 * been some type of error.
+	 */
+	if ((max < 1) || !ioc->events)
+		return -ENODATA;
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	numBytes = max * sizeof(MPT_IOCTL_EVENTS);
+	if (copy_to_user((char *) uarg->eventData, ioc->events, numBytes)) {
+		printk(KERN_ERR "%s@%d::mptctl_eventreport - "
+			"Unable to write out mpt_ioctl_eventreport struct @ %p\n",
+				__FILE__, __LINE__, (void*)ioc->events);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+mptctl_replace_fw (unsigned long arg)
+{
+	struct mpt_ioctl_replace_fw	*uarg = (struct mpt_ioctl_replace_fw *) arg;
+	struct mpt_ioctl_replace_fw	 karg;
+	MPT_ADAPTER		 *ioc;
+	fw_image_t		 **fwmem = NULL;
+	int			 iocnum;
+	int			 newFwSize;
+	int			 num_frags, alloc_sz;
+	int			 ii;
+	u32			 offset;
+
+	dctlprintk(("mptctl_replace_fw called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {
+		printk(KERN_ERR "%s@%d::mptctl_replace_fw - "
+			"Unable to read in mpt_ioctl_replace_fw struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_replace_fw() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	/* If not caching FW, return 0
+	 */
+	if ((ioc->cached_fw == NULL) && (ioc->alt_ioc) && (ioc->alt_ioc->cached_fw == NULL))
+		return 0;
+
+	/* Allocate memory for the new FW image
+	 */
+	newFwSize = karg.newImageSize;
+	fwmem = mpt_alloc_fw_memory(ioc, newFwSize, &num_frags, &alloc_sz); 
+	if (fwmem == NULL)
+		return -ENOMEM;
+
+	offset = 0;
+	for (ii = 0; ii < num_frags; ii++) {
+		/* Copy the data from user memory to kernel space
+		 */
+		if (copy_from_user(fwmem[ii]->fw, uarg->newImage + offset, fwmem[ii]->size)) {
+			printk(KERN_ERR "%s@%d::mptctl_replace_fw - "
+				"Unable to read in mpt_ioctl_replace_fw image @ %p\n",
+					__FILE__, __LINE__, (void*)uarg);
+
+			mpt_free_fw_memory(ioc, fwmem);
+			return -EFAULT;
+		}
+		offset += fwmem[ii]->size;
+	}
+
+
+	/* Free the old FW image 
+	 */
+	if (ioc->cached_fw) {
+		mpt_free_fw_memory(ioc, 0);
+		ioc->cached_fw = fwmem;
+		ioc->alloc_total += alloc_sz;
+	} else if ((ioc->alt_ioc) && (ioc->alt_ioc->cached_fw)) {
+		mpt_free_fw_memory(ioc->alt_ioc, 0);
+		ioc->alt_ioc->cached_fw = fwmem;
+		ioc->alt_ioc->alloc_total += alloc_sz;
+	}
+
+	/* Update IOCFactsReply
+	 */
+	ioc->facts.FWImageSize = newFwSize;
+	if (ioc->alt_ioc)
+		ioc->alt_ioc->facts.FWImageSize = newFwSize;
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* MPT IOCTL MPTCOMMAND function.
+ * Cast the arg into the mpt_ioctl_mpt_command structure.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_mpt_command (unsigned long arg)
+{
+	struct mpt_ioctl_command *uarg = (struct mpt_ioctl_command *) arg;
+	struct mpt_ioctl_command  karg;
+	MPT_ADAPTER	*ioc;
+	int		iocnum;
+	int		rc;
+
+	dctlprintk(("mptctl_command called.\n"));
+
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {
+		printk(KERN_ERR "%s@%d::mptctl_mpt_command - "
+			"Unable to read in mpt_ioctl_command struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_mpt_command() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	rc = mptctl_do_mpt_command (karg, (char *) &uarg->MF, 0);
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Worker routine for the IOCTL MPTCOMMAND and MPTCOMMAND32 (sparc) commands.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ *		-EPERM if SCSI I/O and target is untagged
+ */
+static int
+mptctl_do_mpt_command (struct mpt_ioctl_command karg, char *mfPtr, int local)
+{
+	MPT_ADAPTER	*ioc;
+	MPT_FRAME_HDR	*mf = NULL;
+	MPIHeader_t	*hdr;
+	char		*psge;
+	MptSge_t	*this_sge = NULL;
+	MptSge_t	*sglbuf = NULL;
+	struct buflist	bufIn;	/* data In buffer */
+	struct buflist	bufOut; /* data Out buffer */
+	dma_addr_t	sglbuf_dma;
+	dma_addr_t	dma_addr;
+	int		dir;	/* PCI data direction */
+	int		sgSize = 0;	/* Num SG elements */
+	int		this_alloc;
+	int		 iocnum, flagsLength;
+	int		 sz, rc = 0;
+	int		 msgContext;
+	int		tm_flags_set = 0;
+	u16		req_idx;
+
+	dctlprintk(("mptctl_do_mpt_command called.\n"));
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_do_mpt_command() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+	if (!ioc->ioctl) {
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"No memory available during driver init.\n",
+				__FILE__, __LINE__);
+		return -ENOMEM;
+	} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_DID_IOCRESET) {
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"Busy with IOC Reset \n", __FILE__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Verify that the final request frame will not be too large.
+	 */
+	sz = karg.dataSgeOffset * 4;
+	if (karg.dataInSize > 0)
+		sz += sizeof(dma_addr_t) + sizeof(u32);
+	if (karg.dataOutSize > 0)
+		sz += sizeof(dma_addr_t) + sizeof(u32);
+
+	if ( sz > ioc->req_sz) {
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"Request frame too large (%d) maximum (%d)\n",
+				__FILE__, __LINE__, sz, ioc->req_sz);
+		return -EFAULT;
+	}
+
+	/* Get a free request frame and save the message context.
+	 */
+        if ((mf = mpt_get_msg_frame(mptctl_id, ioc->id)) == NULL)
+                return -EAGAIN;
+
+	hdr = (MPIHeader_t *) mf;
+	msgContext = le32_to_cpu(hdr->MsgContext);
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+
+	/* Copy the request frame
+	 * Reset the saved message context.
+	 */
+        if (local) {
+		/* Request frame in kernel space
+		 */
+		memcpy((char *)mf, (char *) mfPtr, karg.dataSgeOffset * 4);
+        } else {
+		/* Request frame in user space
+		 */
+		if (copy_from_user((char *)mf, (char *) mfPtr,
+					karg.dataSgeOffset * 4)){
+			printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+				"Unable to read MF from mpt_ioctl_command struct @ %p\n",
+				__FILE__, __LINE__, (void*)mfPtr);
+			rc = -EFAULT;
+			goto done_free_mem;
+		}
+        }
+	hdr->MsgContext = cpu_to_le32(msgContext);
+
+
+	/* Verify that this request is allowed.
+	 */
+	switch (hdr->Function) {
+	case MPI_FUNCTION_IOC_FACTS:
+	case MPI_FUNCTION_PORT_FACTS:
+	case MPI_FUNCTION_CONFIG:
+	case MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:
+	case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:
+	case MPI_FUNCTION_FW_UPLOAD:
+	case MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:
+	case MPI_FUNCTION_FW_DOWNLOAD:
+		break;
+
+	case MPI_FUNCTION_SCSI_IO_REQUEST:
+		if (ioc->sh) {
+			SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
+			VirtDevice	*pTarget = NULL;
+			MPT_SCSI_HOST	*hd = NULL;
+			int qtag = MPI_SCSIIO_CONTROL_UNTAGGED;
+			int scsidir = 0;
+			int target = (int) pScsiReq->TargetID;
+			int dataSize;
+
+			pScsiReq->MsgFlags = mpt_msg_flags();
+
+			/* verify that app has not requested
+			 *	more sense data than driver
+			 *	can provide, if so, reset this parameter
+			 * set the sense buffer pointer low address
+			 * update the control field to specify Q type
+			 */
+			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
+				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+
+			pScsiReq->SenseBufferLowAddr =
+				cpu_to_le32(ioc->sense_buf_low_dma
+				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
+
+			if ( (hd = (MPT_SCSI_HOST *) ioc->sh->hostdata)) {
+				if (hd->Targets)
+					pTarget = hd->Targets[target];
+			}
+
+			if (pTarget &&(pTarget->tflags & MPT_TARGET_FLAGS_Q_YES))
+				qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
+			else {
+				rc = -EPERM;
+				goto done_free_mem;
+			}
+
+			/* Have the IOCTL driver set the direction based
+			 * on the dataOutSize (ordering issue with Sparc).
+			 */
+			if (karg.dataOutSize > 0 ) {
+				scsidir = MPI_SCSIIO_CONTROL_WRITE;
+				dataSize = karg.dataOutSize;
+			}
+			else {
+				scsidir = MPI_SCSIIO_CONTROL_READ;
+				dataSize = karg.dataInSize;
+			}
+
+			pScsiReq->Control = cpu_to_le32(scsidir | qtag);
+			pScsiReq->DataLength = cpu_to_le32(dataSize);
+
+			ioc->ioctl->reset = MPTCTL_RESET_OK;
+			ioc->ioctl->target = target;
+
+		} else {
+			printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+				"SCSI driver is not loaded. \n",
+					__FILE__, __LINE__);
+			rc = -EFAULT;
+			goto done_free_mem;
+		}
+		break;
+
+	case MPI_FUNCTION_RAID_ACTION:
+		/* Just add a SGE
+		 */
+		break;
+
+	case MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:
+		if (ioc->sh) {
+			SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
+			int qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
+			int scsidir = MPI_SCSIIO_CONTROL_READ;
+			int dataSize;
+
+			pScsiReq->MsgFlags = mpt_msg_flags();
+
+			/* verify that app has not requested
+			 *	more sense data than driver
+			 *	can provide, if so, reset this parameter
+			 * set the sense buffer pointer low address
+			 * update the control field to specify Q type
+			 */
+			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
+				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+
+			pScsiReq->SenseBufferLowAddr =
+				cpu_to_le32(ioc->sense_buf_low_dma
+				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
+
+			/* All commands to physical devices are tagged
+			 */
+
+			/* Have the IOCTL driver set the direction based
+			 * on the dataOutSize (ordering issue with Sparc).
+			 */
+			if (karg.dataOutSize > 0 ) {
+				scsidir = MPI_SCSIIO_CONTROL_WRITE;
+				dataSize = karg.dataOutSize;
+			}
+			else {
+				scsidir = MPI_SCSIIO_CONTROL_READ;
+				dataSize = karg.dataInSize;
+			}
+
+			pScsiReq->Control = cpu_to_le32(scsidir | qtag);
+			pScsiReq->DataLength = cpu_to_le32(dataSize);
+
+			ioc->ioctl->reset = MPTCTL_RESET_OK;
+			ioc->ioctl->target = pScsiReq->TargetID;
+		} else {
+			printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+				"SCSI driver is not loaded. \n",
+					__FILE__, __LINE__);
+			rc = -EFAULT;
+			goto done_free_mem;
+		}
+		break;
+
+	case MPI_FUNCTION_SCSI_TASK_MGMT:
+		{ 
+			MPT_SCSI_HOST *hd = NULL;
+			if ((ioc->sh == NULL) || ((hd = (MPT_SCSI_HOST *)ioc->sh->hostdata) == NULL)) {
+				printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					"SCSI driver not loaded or SCSI host not found. \n",
+					__FILE__, __LINE__);
+				rc = -EFAULT;
+				goto done_free_mem;
+			}  else if (mptctl_set_tm_flags(hd) != 0) {
+				rc = -EPERM;
+				goto done_free_mem;
+			}
+			tm_flags_set = 1;
+		}
+		break;
+
+	default:
+		/*
+		 * MPI_FUNCTION_IOC_INIT
+		 * MPI_FUNCTION_PORT_ENABLE
+		 * MPI_FUNCTION_TARGET_CMD_BUFFER_POST
+		 * MPI_FUNCTION_TARGET_ASSIST
+		 * MPI_FUNCTION_TARGET_STATUS_SEND
+		 * MPI_FUNCTION_TARGET_MODE_ABORT
+		 * MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET
+		 * MPI_FUNCTION_IO_UNIT_RESET
+		 * MPI_FUNCTION_HANDSHAKE
+		 * MPI_FUNCTION_REPLY_FRAME_REMOVAL
+		 * MPI_FUNCTION_EVENT_NOTIFICATION
+		 *  (driver handles event notification)
+		 * MPI_FUNCTION_EVENT_ACK
+		 */
+
+		/*  What to do with these???  CHECK ME!!!
+			MPI_FUNCTION_FC_LINK_SRVC_BUF_POST
+			MPI_FUNCTION_FC_LINK_SRVC_RSP
+			MPI_FUNCTION_FC_ABORT
+			MPI_FUNCTION_FC_PRIMITIVE_SEND
+			MPI_FUNCTION_LAN_SEND
+			MPI_FUNCTION_LAN_RECEIVE
+		 	MPI_FUNCTION_LAN_RESET
+		*/
+
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"Illegal request (function 0x%x) \n",
+			__FILE__, __LINE__, hdr->Function);
+		rc = -EFAULT;
+		goto done_free_mem;
+	}
+
+	/* Add the SGL ( at most one data in SGE and one data out SGE )
+	 * In the case of two SGE's - the data out (write) will always
+	 * preceede the data in (read) SGE. psgList is used to free the
+	 * allocated memory.
+	 */
+	psge = (char *) ( ((int *) mf) + karg.dataSgeOffset);
+	flagsLength = 0;
+
+	/* bufIn and bufOut are used for user to kernel space transfers
+	 */
+	bufIn.kptr = bufOut.kptr = NULL;
+	bufIn.len = bufOut.len = 0;
+
+	if (karg.dataOutSize > 0 )
+		sgSize ++;
+
+	if (karg.dataInSize > 0 )
+		sgSize ++;
+
+	if (sgSize > 0) {
+
+		/* Allocate memory for the SGL.
+		 * Used to free kernel memory once
+		 * the MF is freed.
+		 */
+		sglbuf = pci_alloc_consistent (ioc->pcidev,
+			sgSize*sizeof(MptSge_t), &sglbuf_dma);
+		if (sglbuf == NULL) {
+			rc = -ENOMEM;
+			goto done_free_mem;
+		}
+		this_sge = sglbuf;
+
+		/* Set up the dataOut memory allocation */
+		if (karg.dataOutSize > 0) {
+			dir = PCI_DMA_TODEVICE;
+			if (karg.dataInSize > 0 ) {
+				flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+						MPI_SGE_FLAGS_DIRECTION |
+						mpt_addr_size() )
+						<< MPI_SGE_FLAGS_SHIFT;
+			} else {
+				flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
+			}
+			flagsLength |= karg.dataOutSize;
+
+			this_alloc = karg.dataOutSize;
+			bufOut.len = this_alloc;
+			bufOut.kptr = pci_alloc_consistent(
+					ioc->pcidev, this_alloc, &dma_addr);
+
+			if (bufOut.kptr == NULL) {
+				rc = -ENOMEM;
+				goto done_free_mem;
+			} else {
+				/* Copy user data to kernel space.
+				 */
+				if (copy_from_user(bufOut.kptr,
+						karg.dataOutBufPtr,
+						bufOut.len)) {
+
+					printk(KERN_ERR
+						"%s@%d::mptctl_do_mpt_command - Unable "
+						"to read user data "
+						"struct @ %p\n",
+						__FILE__, __LINE__,(void*)karg.dataOutBufPtr);
+					rc =  -EFAULT;
+					goto done_free_mem;
+				}
+
+				/* Set up this SGE.
+				 * Copy to MF and to sglbuf
+				 */
+				mpt_add_sge(psge, flagsLength, dma_addr);
+				psge += (sizeof(u32) + sizeof(dma_addr_t));
+
+				this_sge->FlagsLength = flagsLength;
+				this_sge->Address = dma_addr;
+				this_sge++;
+			}
+		}
+
+		if (karg.dataInSize > 0) {
+			dir = PCI_DMA_FROMDEVICE;
+			flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
+			flagsLength |= karg.dataInSize;
+
+			this_alloc = karg.dataInSize;
+			bufIn.len = this_alloc;
+			bufIn.kptr = pci_alloc_consistent(ioc->pcidev,
+							this_alloc, &dma_addr);
+			if (bufIn.kptr == NULL) {
+				rc = -ENOMEM;
+				goto done_free_mem;
+			} else {
+				/* Set up this SGE
+				 * Copy to MF and to sglbuf
+				 */
+				mpt_add_sge(psge, flagsLength, dma_addr);
+
+				this_sge->FlagsLength = flagsLength;
+				this_sge->Address = dma_addr;
+				this_sge++;
+			}
+		}
+	} else  {
+		/* Add a NULL SGE
+		 */
+		mpt_add_sge(psge, flagsLength, (dma_addr_t) -1);
+	}
+
+	/* The request is complete. Set the timer parameters
+	 * and issue the request.
+	 */
+	if (karg.timeout > 0) {
+		ioc->ioctl->timer.expires = jiffies + HZ*karg.timeout;
+	} else {
+		ioc->ioctl->timer.expires = jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT;
+	}
+
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+
+	if (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {
+		rc = mpt_send_handshake_request(mptctl_id, ioc->id,
+				sizeof(SCSITaskMgmt_t), (u32*)mf, NO_SLEEP);
+		if (rc == 0) {
+			wait_event(mptctl_wait, ioc->ioctl->wait_done);
+		} else {
+			mptctl_free_tm_flags(ioc);
+			tm_flags_set= 0;
+			del_timer(&ioc->ioctl->timer);
+			ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TIMER_ACTIVE;
+			ioc->ioctl->status = MPT_IOCTL_STATUS_TM_FAILED;
+		}
+	} else {
+		mpt_put_msg_frame(mptctl_id, ioc->id, mf);
+		wait_event(mptctl_wait, ioc->ioctl->wait_done);
+	}
+
+	/* The command is complete.  * Return data to the user.
+	 *
+	 * If command completed,  mf has been freed so cannot
+	 * use this memory.
+	 *
+	 * If timeout, a recovery  mechanism has been called.
+	 * Need to free the mf.
+	 */
+	if (ioc->ioctl->status & MPT_IOCTL_STATUS_DID_IOCRESET) {
+
+		/* A timeout - there is no data to return to the
+		 * the user other than an error.
+		 * The timer callback deleted the
+		 * timer and reset the adapter queues.
+		 */
+		printk(KERN_WARNING "%s@%d::mptctl_do_mpt_command - "
+			"Timeout Occurred on IOCTL! Reset IOC.\n", __FILE__, __LINE__);
+		tm_flags_set= 0;
+		rc = -ETIME;
+
+		/* Free memory and return to the calling function
+		 */
+		goto done_free_mem;
+	} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_TM_FAILED) {
+		/* User TM request failed!
+		 */
+		rc = -ENODATA;
+	} else {
+		/* Callback freed request frame.
+		 */
+		mf = NULL;
+
+		/* If a valid reply frame, copy to the user.
+		 * Offset 2: reply length in U32's
+		 */
+		if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
+			if (karg.maxReplyBytes < ioc->reply_sz) {
+				 sz = MIN(karg.maxReplyBytes, 4*ioc->ioctl->ReplyFrame[2]);
+			} else {
+				 sz = MIN(ioc->reply_sz, 4*ioc->ioctl->ReplyFrame[2]);
+			}
+
+			if (sz > 0) {
+				if (copy_to_user((char *)karg.replyFrameBufPtr,
+					 &ioc->ioctl->ReplyFrame, sz)){
+
+					 printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					 "Unable to write out reply frame %p\n",
+					 __FILE__, __LINE__, (void*)karg.replyFrameBufPtr);
+					 rc =  -ENODATA;
+					 goto done_free_mem;
+				}
+			}
+		}
+
+		/* If valid sense data, copy to user.
+		 */
+		if (ioc->ioctl->status & MPT_IOCTL_STATUS_SENSE_VALID) {
+			sz = MIN(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
+			if (sz > 0) {
+				if (copy_to_user((char *)karg.senseDataPtr, ioc->ioctl->sense, sz)) {
+					printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					"Unable to write sense data to user %p\n",
+					__FILE__, __LINE__,
+					(void*)karg.senseDataPtr);
+					rc =  -ENODATA;
+					goto done_free_mem;
+				}
+			}
+		}
+
+		/* If the overall status is _GOOD and data in, copy data
+		 * to user.
+		 */
+		if ((ioc->ioctl->status & MPT_IOCTL_STATUS_COMMAND_GOOD) &&
+					(karg.dataInSize > 0) && (bufIn.kptr)) {
+
+			if (copy_to_user((char *)karg.dataInBufPtr,
+					 bufIn.kptr, karg.dataInSize)) {
+				printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					"Unable to write data to user %p\n",
+					__FILE__, __LINE__,
+					(void*)karg.dataInBufPtr);
+				rc =  -ENODATA;
+			}
+		}
+	}
+
+done_free_mem:
+	/* Clear status bits.
+	 */
+	ioc->ioctl->status = 0;
+
+	if (tm_flags_set)
+		mptctl_free_tm_flags(ioc);
+
+	if (sglbuf) {
+		this_sge = sglbuf;
+
+		/* Free the allocated memory.
+		 */
+		 if (bufOut.kptr != NULL ) {
+			dma_addr = this_sge->Address;
+			this_sge++;	/* go to next structure */
+			this_alloc = bufOut.len;
+			pci_free_consistent(ioc->pcidev,
+				this_alloc, (void *) &bufOut, dma_addr);
+		}
+
+		if (bufIn.kptr != NULL ) {
+			dma_addr = this_sge->Address;
+			this_alloc = bufIn.len;
+
+			pci_free_consistent(ioc->pcidev,
+					this_alloc, (void *) &bufIn, dma_addr);
+		}
+
+		this_alloc = sgSize * sizeof(MptSge_t);
+		pci_free_consistent(ioc->pcidev,
+				this_alloc, (void *) sglbuf, sglbuf_dma);
+
+	}
 
-    dprintk((KERN_INFO "  *** done ***\n"));
+	/* mf will be null if allocation failed OR
+	 * if command completed OK (callback freed)
+	 */
+	if (mf)
+		mpt_free_msg_frame(mptctl_id, ioc->id, mf);
 
-    return 0;
+	return rc;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Routine for the Compaq IOCTL commands.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
 static int
-mpt_ioctl_rwperf_status(unsigned long arg)
+mptctl_compaq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct mpt_raw_r_w	 kPerfInfo;
-				/* NOTE: local copy, on stack==KERNEL_SPACE! */
-	MPT_ADAPTER	*iocp;
-	int		 ioc;
-//	u8		 targ;
-//	u8		 lun;
-	int		 T, L;
-	char		*myname = "_rwperf_status()";
+	int iocnum = 0;
+	unsigned iocnumX = 0;
+	int ret;
+	int nonblock = (file->f_flags & O_NONBLOCK);
+	MPT_ADAPTER *iocp = NULL;
+
+	if (cmd == CPQFCTS_SCSI_PASSTHRU) {
+		/* Update the iocnum */
+		if (copy_from_user(&iocnumX, (int *)arg, sizeof(int))) {
+			printk(KERN_ERR "%s::mptctl_compaq_ioctl() @%d - "
+				"Unable to read controller number @ %p\n",
+				__FILE__, __LINE__, (void*)arg);
+			return -EFAULT;
+		}
+		iocnumX &= 0xFF;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
+	    (iocp == NULL)) {
+		printk(KERN_ERR "%s::mptctl_compaq_ioctl() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnumX);
+		return -ENODEV;
+	}
+
+	/* All of these commands require an interrupt or
+	 * are unknown/illegal.
+	 */
+	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
+		return ret;
+
+	dctlprintk((MYIOC_s_INFO_FMT ": mptctl_compaq_ioctl()\n", iocp->name));
+
+	switch(cmd) {
+	case CPQFCTS_GETPCIINFO:
+		ret = mptctl_cpq_getpciinfo(arg);
+		break;
+	case CPQFCTS_GETDRIVER:
+		ret = mptctl_cpq_getdriver(arg);
+		break;
+	case CPQFCTS_CTLR_STATUS:
+		ret = mptctl_cpq_ctlr_status(arg);
+		break;
+	case CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS:
+		ret = mptctl_cpq_target_address(arg);
+		break;
+	case CPQFCTS_SCSI_PASSTHRU:
+		ret = mptctl_cpq_passthru(arg);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	up(&mptctl_syscall_sem_ioc[iocp->id]);
 
+	return ret;
 
-	dprintk((KERN_INFO "%s - starting...\n", myname));
+}
 
-	/* Get a pointer to the MPT adapter. */
-	if ((ioc = mpt_ioctl_rwperf_init(&kPerfInfo, arg, myname, &iocp)) < 0)
-		return ioc;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_getpciinfo - Get PCI Information in format desired by Compaq
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ */
+static int
+mptctl_cpq_getpciinfo(unsigned long arg)
+{
+	cpqfc_pci_info_struct *uarg = (cpqfc_pci_info_struct *) arg;
+	cpqfc_pci_info_struct karg;
+	MPT_ADAPTER		*ioc;
+	struct pci_dev		*pdev;
+	CONFIGPARMS		cfg;
+	ConfigPageHeader_t	hdr;
+	int			iocnum = 0, iocnumX = 0;
+	dma_addr_t		buf_dma;
+	u8			*pbuf = NULL;
+	int			failed;
+
+	dctlprintk((": mptctl_cpq_pciinfo called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(cpqfc_pci_info_struct))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_pciinfo - "
+			"Unable to read in cpqfc_pci_info_struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EINVAL;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_pciinfo() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
 
-	/* set perf parameters from input */
-//	targ = kPerfInfo.target & 0xFF;
-//	lun = kPerfInfo.lun & 0x1F;
+	pdev = (struct pci_dev *) ioc->pcidev;
+
+	/* Populate the structure. */
+	karg.bus = pdev->bus->number;
+	karg.bus_type = 1;	/* 1 = PCI; 4 = unknown */
+	karg.device_fn = PCI_FUNC(pdev->devfn);
+	karg.slot_number = PCI_SLOT(pdev->devfn);
+	karg.vendor_id = pdev->vendor;
+	karg.device_id = pdev->device;
+	karg.board_id = (karg.device_id | (karg.vendor_id << 16));
+	karg.class_code = pdev->class;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	karg.sub_vendor_id = pdev->subsystem_vendor;
+	karg.sub_device_id = pdev->subsystem_device;
+#endif
 
-	for (T=0; T < myMAX_TARGETS; T++)
-		for (L=0; L < myMAX_LUNS; L++)
-			if (DevIosCount[T][L]) {
-				printk(KERN_INFO "%s: ioc%d->00:%02x:%02x"
-						 ", IosCnt=%d\n",
-						 myname, ioc, T, L, DevIosCount[T][L] );
+	/* Issue a config request to get the device serial number
+	 */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	failed = 1;
+
+	if (mpt_config(ioc, &cfg) == 0) {
+		if (cfg.hdr->PageLength > 0) {
+			/* Issue the second config page request */
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+			pbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);
+			if (pbuf) {
+				cfg.physAddr = buf_dma;
+				if (mpt_config(ioc, &cfg) == 0) {
+					ManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;
+					strncpy(karg.serial_number, pdata->BoardTracerNumber, 17);
+					failed = 0;
+				}
+				pci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);
+				pbuf = NULL;
 			}
+		}
+	}
+	if (failed)
+		strncpy(karg.serial_number, " ", 17);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(cpqfc_pci_info_struct))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_pciinfo - "
+			"Unable to write out cpqfc_pci_info_struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_getdriver - Get Driver Version in format desired by Compaq
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_cpq_getdriver(unsigned long arg)
+{
+	int		*uarg = (int *)arg;
+	int		karg;
+	MPT_ADAPTER	*ioc = NULL;
+	int		iocnum = 0, iocnumX = 0;
+	int		ii, jj;
+	char		version[10];
+	char		val;
+	char		*vptr = NULL;
+	char		*pptr = NULL;
+
+	dctlprintk((": mptctl_cpq_getdriver called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(int))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_getdriver - "
+			"Unable to read in struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_cpq_getdriver() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	strncpy(version, MPT_LINUX_VERSION_COMMON, 8);
+
+	karg = 0;
+	vptr = version;
+	ii = 3;
+	while (ii > 0) {
+		pptr = strchr(vptr, '.');
+		if (pptr) {
+			*pptr = '\0';
+			val = 0;
+			for (jj=0; vptr[jj]>='0' && vptr[jj]<='9'; jj++)
+				val = 10 * val + (vptr[jj] - '0');
+			karg |= (val << (8*ii));
+			pptr++;
+			vptr = pptr;
+		} else
+			break;
+		ii--;
+	}
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(int))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_getdriver - "
+			"Unable to write out stuct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_ctlr_status - Get controller status in format desired by Compaq
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_cpq_ctlr_status(unsigned long arg)
+{
+	cpqfc_ctlr_status *uarg = (cpqfc_ctlr_status *) arg;
+	cpqfc_ctlr_status karg;
+	MPT_ADAPTER		*ioc;
+	int			iocnum = 0, iocnumX = 0;
+
+	dctlprintk((": mptctl_cpq_pciinfo called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(cpqfc_ctlr_status))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_ctlr_status - "
+			"Unable to read in cpqfc_ctlr_status @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_cpq_ctlr_status() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	karg.status = ioc->last_state;
+	karg.offline_reason = 0;
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(cpqfc_ctlr_status))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_ctlr_status - "
+			"Unable to write out cpqfc_ctlr_status @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_target_address - Get WWN Information in format desired by Compaq
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ */
 static int
-mpt_ioctl_rwperf_reset(unsigned long arg)
+mptctl_cpq_target_address(unsigned long arg)
 {
-	struct mpt_raw_r_w	 kPerfInfo;
-				/* NOTE: local copy, on stack==KERNEL_SPACE! */
-	MPT_ADAPTER	*iocp;
-	int		 ioc;
-//	u8		 targ;
-//	u8		 lun;
-	int		 T, L;
-	int		 i;
-	char		*myname = "_rwperf_reset()";
-
-	dprintk((KERN_INFO "%s - starting...\n", myname));
-
-	/* Get MPT adapter id. */
-	if ((ioc = mpt_ioctl_rwperf_init(&kPerfInfo, arg, myname, &iocp)) < 0)
-		return ioc;
-
-	/* set perf parameters from input */
-//	targ = kPerfInfo.target & 0xFF;
-//	lun = kPerfInfo.lun & 0x1F;
-
-	rwperf_reset = 1;
-	for (i=0; i < 1000000; i++) {
-		mb();
-		schedule();
-		barrier();
-	}
-	rwperf_reset = 0;
-
-	for (T=0; T < myMAX_TARGETS; T++)
-		for (L=0; L < myMAX_LUNS; L++)
-			if (DevIosCount[T][L]) {
-				printk(KERN_INFO "%s: ioc%d->00:%02x:%02x, "
-						 "IosCnt RESET! (from %d to 0)\n",
-						 myname, ioc, T, L, DevIosCount[T][L] );
-				DevIosCount[T][L] = 0;
-				DevInUse[T][L] = 0;
+	Scsi_FCTargAddress *uarg = (Scsi_FCTargAddress *) arg;
+	Scsi_FCTargAddress karg;
+	MPT_ADAPTER		*ioc;
+	int			iocnum = 0, iocnumX = 0;
+	CONFIGPARMS		cfg;
+	ConfigPageHeader_t	hdr;
+	dma_addr_t		buf_dma;
+	u8			*pbuf = NULL;
+	FCPortPage0_t		*ppp0;
+	int			ii, failed;
+	u32			low, high;
+
+	dctlprintk((": mptctl_cpq_target_address called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(Scsi_FCTargAddress))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_target_address - "
+			"Unable to read in Scsi_FCTargAddress @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_cpq_target_address() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	karg.host_port_id = 0;
+
+	/* Issue a config request to get the device wwn
+	 */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	failed = 1;
+
+	if (mpt_config(ioc, &cfg) == 0) {
+		if (cfg.hdr->PageLength > 0) {
+			/* Issue the second config page request */
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+			pbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);
+			if (pbuf) {
+				cfg.physAddr = buf_dma;
+				if (mpt_config(ioc, &cfg) == 0) {
+					ppp0 = (FCPortPage0_t *) pbuf;
+
+					low = le32_to_cpu(ppp0->WWNN.Low);
+					high = le32_to_cpu(ppp0->WWNN.High);
+
+					for (ii = 0; ii < 4; ii++) {
+						karg.host_wwn[7-ii] = low & 0xFF;
+						karg.host_wwn[3-ii] = high & 0xFF;
+						low = (low >> 8);
+						high = (high >> 8);
+					}
+					failed = 0;
+				}
+				pci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);
+				pbuf = NULL;
 			}
+		}
+	}
+
+	if (failed) {
+		for (ii = 7; ii >= 0; ii--)
+			karg.host_wwn[ii] = 0;
+	}
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(Scsi_FCTargAddress))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_target_address - "
+			"Unable to write out Scsi_FCTargAddress @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_passthru - Construct and issue a SCSI IO Passthru
+ *
+ * Requires the SCSI host driver to be loaded.
+ * I386 version.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ */
+static int
+mptctl_cpq_passthru(unsigned long arg)
+{
+	VENDOR_IOCTL_REQ	*uarg = (VENDOR_IOCTL_REQ *) arg;
+	VENDOR_IOCTL_REQ	karg;
+	cpqfc_passthru_t	kpass;
+	MPT_ADAPTER		*ioc;
+	int			iocnum = 0, iocnumX = 0;
+	int			rc;
+
+	dctlprintk((": mptctl_cpq_passthru called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(VENDOR_IOCTL_REQ))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_passthru - "
+			"Unable to read in VENDOR_IOCTL_REQ @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	/* Set the IOC number */
+	iocnumX = karg.lc & 0xFF;
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_cpq_passthru() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	if (ioc->sh == NULL) {
+		printk(KERN_ERR "%s::mptctl_cpq_passthru() @%d - SCSI Host driver not loaded!\n",
+				__FILE__, __LINE__);
+		return -EFAULT;
+	}
+
+	/* Read in the second buffer */
+	if (copy_from_user(&kpass, uarg->argp, sizeof(cpqfc_passthru_t))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_passthru - "
+			"Unable to read in cpqfc_passthru_t @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+
+	/* Generate the SCSI IO command and issue */
+	rc = mptctl_compaq_scsiio(&karg, &kpass);
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_compaq_scsiio - Reformat Compaq structures into driver structures
+ * Call the generic _do_mpt_command function.
+ *
+ * Requires the SCSI host driver to be loaded.
+ * I386 version.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ */
 static int
-mpt_ioctl_scsi_cmd(unsigned long arg)
+mptctl_compaq_scsiio(VENDOR_IOCTL_REQ *pVenReq, cpqfc_passthru_t *pPass)
 {
-	return -ENOSYS;
+	struct mpt_ioctl_command karg;
+	SCSIIORequest_t		 request ;
+	SCSIIORequest_t		 *pMf;
+	int			 ii, rc;
+	u8			 opcode;
+
+	/* Fill in parameters to karg */
+	karg.hdr.iocnum = pVenReq->lc;
+	karg.hdr.port = 0;
+	karg.hdr.maxDataSize = 0;	/* not used */
+	karg.timeout = 0;		/* use default */
+
+	karg.replyFrameBufPtr = NULL;	/* no reply data */
+	karg.maxReplyBytes = 0;
+
+	karg.senseDataPtr = pPass->sense_data;
+	karg.maxSenseBytes = pPass->sense_len;	/* max is 40 */
+
+	if (pPass->rw_flag == MPT_COMPAQ_WRITE) {
+		karg.dataOutBufPtr = pPass->bufp;
+		karg.dataOutSize = pPass->len;
+		karg.dataInBufPtr = NULL;
+		karg.dataInSize = 0;
+	} else {
+		karg.dataInBufPtr = pPass->bufp;
+		karg.dataInSize = pPass->len;
+		karg.dataOutBufPtr = NULL;
+		karg.dataOutSize = 0;
+	}
+
+	karg.dataSgeOffset = (sizeof(SCSIIORequest_t) - sizeof(SGE_IO_UNION))/4;
+
+	/* Construct the Message frame */
+	pMf = &request;
+
+	pMf->TargetID =	(u8) pVenReq->ld;			/* ???? FIXME */
+	pMf->Bus = (u8) pPass->bus;
+	pMf->ChainOffset = 0;
+	pMf->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
+
+	/* May need some tweaking here */
+	opcode = (u8) pPass->cdb[0];
+	if (opcode < 0x20)
+		pMf->CDBLength = 6;
+	else if (opcode < 0x60)
+		pMf->CDBLength = 10;
+	else if ((opcode < 0xC0) && (opcode >= 0xA0))
+		pMf->CDBLength = 12;
+	else
+		pMf->CDBLength = 16;
+
+	pMf->SenseBufferLength = karg.maxSenseBytes;	/* max is 40 */
+	pMf->Reserved = 0;
+	pMf->MsgFlags = 0;				/* set later */
+	pMf->MsgContext = 0;				/* set later */
+
+	for (ii = 0; ii < 8; ii++)
+		pMf->LUN[ii] = 0;
+	pMf->LUN[1] = 0;				/* ???? FIXME */
+
+	/* Tag values set by _do_mpt_command */
+	if (pPass->rw_flag == MPT_COMPAQ_WRITE)
+		pMf->Control = MPI_SCSIIO_CONTROL_WRITE;
+	else
+		pMf->Control = MPI_SCSIIO_CONTROL_READ;
+
+	for (ii = 0; ii < 16; ii++)
+		pMf->CDB[ii] = pPass->cdb[ii];
+
+	pMf->DataLength = pPass->len;
+
+	/* All remaining fields are set by the next function
+	 */
+	rc = mptctl_do_mpt_command (karg, (char *)pMf, 1);
+	return rc;
 }
 
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,51)
@@ -1110,7 +2923,7 @@
 	llseek:		no_llseek,
 	read:		mptctl_read,
 	write:		mptctl_write,
-	ioctl:		mpt_ioctl,
+	ioctl:		mptctl_ioctl,
 	open:		mptctl_open,
 	release:	mptctl_release,
 };
@@ -1133,18 +2946,15 @@
 						      unsigned long,
 						      struct file *));
 int unregister_ioctl32_conversion(unsigned int cmd);
-
-struct mpt_fw_xfer32 {
-	unsigned int iocnum;
-	unsigned int fwlen;
-	u32 bufp;
-};
-
-#define MPTFWDOWNLOAD32     _IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer32)
-
 extern asmlinkage int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* sparc32_XXX functions are used to provide a conversion between
+ * pointers and u32's. If the arg does not contain any pointers, then
+ * a specialized function (sparc32_XXX) is not needed. If the arg
+ * does contain pointer(s), then the specialized function is used
+ * to ensure the structure contents is properly processed by mptctl.
+ */
 static int
 sparc32_mptfwxfer_ioctl(unsigned int fd, unsigned int cmd,
 			unsigned long arg, struct file *filp)
@@ -1156,7 +2966,7 @@
 	int nonblock = (filp->f_flags & O_NONBLOCK);
 	int ret;
 
-	dprintk((KERN_INFO MYNAM "::sparc32_mptfwxfer_ioctl() called\n"));
+	dctlprintk((KERN_INFO MYNAM "::sparc32_mptfwxfer_ioctl() called\n"));
 
 	if (copy_from_user(&kfw32, (char *)arg, sizeof(kfw32)))
 		return -EFAULT;
@@ -1177,13 +2987,131 @@
 	kfw.fwlen = kfw32.fwlen;
 	kfw.bufp = (void *)(unsigned long)kfw32.bufp;
 
-	ret = mpt_ioctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);
+	ret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);
+
+	up(&mptctl_syscall_sem_ioc[iocp->id]);
+
+	return ret;
+}
+
+static int
+sparc32_mpt_command(unsigned int fd, unsigned int cmd,
+			unsigned long arg, struct file *filp)
+{
+	struct mpt_ioctl_command32 karg32;
+	struct mpt_ioctl_command32 *uarg = (struct mpt_ioctl_command32 *) arg;
+	struct mpt_ioctl_command karg;
+	MPT_ADAPTER *iocp = NULL;
+	int iocnum, iocnumX;
+	int nonblock = (filp->f_flags & O_NONBLOCK);
+	int ret;
+
+	dctlprintk((KERN_INFO MYNAM "::sparc32_mpt_command() called\n"));
+
+	if (copy_from_user(&karg32, (char *)arg, sizeof(karg32)))
+		return -EFAULT;
+
+	/* Verify intended MPT adapter */
+	iocnumX = karg32.hdr.iocnum & 0xFF;
+	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
+	    (iocp == NULL)) {
+		printk(KERN_ERR MYNAM "::sparc32_mpt_command @%d - ioc%d not found!\n",
+				__LINE__, iocnumX);
+		return -ENODEV;
+	}
+
+	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
+		return ret;
+
+	/* Copy data to karg */
+	karg.hdr.iocnum = karg32.hdr.iocnum;
+	karg.hdr.port = karg32.hdr.port;
+	karg.timeout = karg32.timeout;
+	karg.maxReplyBytes = karg32.maxReplyBytes;
+
+	karg.dataInSize = karg32.dataInSize;
+	karg.dataOutSize = karg32.dataOutSize;
+	karg.maxSenseBytes = karg32.maxSenseBytes;
+	karg.dataSgeOffset = karg32.dataSgeOffset;
+
+	karg.replyFrameBufPtr = (char *)(unsigned long)karg32.replyFrameBufPtr;
+	karg.dataInBufPtr = (char *)(unsigned long)karg32.dataInBufPtr;
+	karg.dataOutBufPtr = (char *)(unsigned long)karg32.dataOutBufPtr;
+	karg.senseDataPtr = (char *)(unsigned long)karg32.senseDataPtr;
+
+	/* Pass new structure to do_mpt_command
+	 */
+	ret = mptctl_do_mpt_command (karg, (char *) &uarg->MF, 0);
 
 	up(&mptctl_syscall_sem_ioc[iocp->id]);
 
 	return ret;
 }
 
+static int
+sparc32_mptctl_cpq_passthru(unsigned int fd, unsigned int cmd,
+			unsigned long arg, struct file *filp)
+{
+	VENDOR_IOCTL_REQ32	*uarg = (VENDOR_IOCTL_REQ32 *) arg;
+	VENDOR_IOCTL_REQ32	karg32;
+	VENDOR_IOCTL_REQ	karg;
+	cpqfc_passthru32_t	kpass32;
+	cpqfc_passthru_t	kpass;
+	MPT_ADAPTER		*ioc;
+	int			nonblock = (filp->f_flags & O_NONBLOCK);
+	int			iocnum = 0, iocnumX = 0;
+	int			rc;
+	int			ii;
+
+	dctlprintk((KERN_INFO MYNAM "::sparc32_mptctl_cpq_passthru() called\n"));
+
+	if (copy_from_user(&karg32, (char *)arg, sizeof(karg32)))
+		return -EFAULT;
+
+	/* Verify intended MPT adapter */
+	iocnumX = karg32.lc & 0xFF;
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR MYNAM "::sparc32_mpt_command @%d - ioc%d not found!\n",
+				__LINE__, iocnumX);
+		return -ENODEV;
+	}
+
+	if ((rc = mptctl_syscall_down(ioc, nonblock)) != 0)
+		return rc;
+
+	/* Copy data to karg */
+	karg.ld = karg32.ld;
+	karg.node = karg32.node;
+	karg.lc = karg32.lc;
+	karg.nexus = karg32.nexus;
+	karg.argp = (void *)(unsigned long)karg32.argp;
+
+	/* Read in the second buffer */
+	if (copy_from_user(&kpass32, karg.argp, sizeof(cpqfc_passthru32_t))) {
+		printk(KERN_ERR "%s@%d::sparc32_mptctl_cpq_passthru - "
+			"Unable to read in cpqfc_passthru_t @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	/* Copy the 32bit buffer to kpass */
+	for (ii = 0; ii < 16; ii++)
+		kpass.cdb[ii] = kpass32.cdb[ii];
+	kpass.bus = kpass32.bus;
+	kpass.pdrive = kpass32.pdrive;
+	kpass.len = kpass32.len;
+	kpass.sense_len = kpass32.sense_len;
+	kpass.bufp = (void *)(unsigned long)kpass32.bufp;
+	kpass.rw_flag = kpass32.rw_flag;
+
+	/* Generate the SCSI IO command and issue */
+	rc = mptctl_compaq_scsiio(&karg, &kpass);
+
+	up(&mptctl_syscall_sem_ioc[ioc->id]);
+	return rc;
+}
+
 #endif		/*} linux >= 2.3.x */
 #endif		/*} sparc */
 
@@ -1193,26 +3121,79 @@
 	int err;
 	int i;
 	int where = 1;
+	int sz;
+	u8 *mem;
+	MPT_ADAPTER *ioc = NULL;
+	int iocnum;
 
 	show_mptmod_ver(my_NAME, my_VERSION);
 
 	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
 		sema_init(&mptctl_syscall_sem_ioc[i], 1);
+
+		ioc = NULL;
+		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
+		    (ioc == NULL)) {
+			continue;
+		}
+		else {
+			/* This adapter instance is found.
+			 * Allocate and inite a MPT_IOCTL structure
+			 */
+			sz = sizeof (MPT_IOCTL);
+			mem = kmalloc(sz, GFP_KERNEL);
+			if (mem == NULL) {
+				err = -ENOMEM;
+				goto out_fail;
+			}
+
+			memset(mem, 0, sz);
+			ioc->ioctl = (MPT_IOCTL *) mem;
+			ioc->ioctl->ioc = ioc;
+			init_timer (&ioc->ioctl->timer);
+			ioc->ioctl->timer.data = (unsigned long) ioc->ioctl;
+			ioc->ioctl->timer.function = mptctl_timer_expired;
+			init_timer (&ioc->ioctl->TMtimer);
+			ioc->ioctl->TMtimer.data = (unsigned long) ioc->ioctl;
+			ioc->ioctl->TMtimer.function = mptctl_timer_expired;
+		}
 	}
 
 #if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
-	err = register_ioctl32_conversion(MPTRWPERF, NULL);
+	err = register_ioctl32_conversion(MPTIOCINFO, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTTARGETINFO, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTTEST, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTEVENTQUERY, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTEVENTENABLE, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTEVENTREPORT, NULL);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTRWPERF_CHK, NULL);
+	err = register_ioctl32_conversion(MPTHARDRESET, NULL);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTRWPERF_RESET, NULL);
+	err = register_ioctl32_conversion(MPTCOMMAND32, sparc32_mpt_command);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTFWDOWNLOAD32, sparc32_mptfwxfer_ioctl);
+	err = register_ioctl32_conversion(MPTFWDOWNLOAD32,
+					  sparc32_mptfwxfer_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CPQFCTS_GETPCIINFO, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CPQFCTS_CTLR_STATUS, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CPQFCTS_GETDRIVER, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CPQFCTS_SCSI_PASSTHRU32, sparc32_mptctl_cpq_passthru);
 	if (++where && err) goto out_fail;
 #endif		/*} linux >= 2.3.x */
 #endif		/*} sparc */
 
+	/* Register this device */
 	if (misc_register(&mptctl_miscdev) == -1) {
 		printk(KERN_ERR MYNAM ": Can't register misc device [minor=%d].\n", MPT_MINOR);
 		err = -EBUSY;
@@ -1226,13 +3207,19 @@
 	 *  Install our handler
 	 */
 	++where;
-	if ((mptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER)) <= 0) {
+	if ((mptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER)) < 0) {
 		printk(KERN_ERR MYNAM ": ERROR: Failed to register with Fusion MPT base driver\n");
 		misc_deregister(&mptctl_miscdev);
 		err = -EBUSY;
 		goto out_fail;
 	}
 
+	if (mpt_reset_register(mptctl_id, mptctl_ioc_reset) == 0) {
+		dprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
+	} else {
+		/* FIXME! */
+	}
+
 	return 0;
 
 out_fail:
@@ -1241,35 +3228,72 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
 	printk(KERN_ERR MYNAM ": ERROR: Failed to register ioctl32_conversion!"
 			" (%d:err=%d)\n", where, err);
-	unregister_ioctl32_conversion(MPTRWPERF);
-	unregister_ioctl32_conversion(MPTRWPERF_CHK);
-	unregister_ioctl32_conversion(MPTRWPERF_RESET);
+	unregister_ioctl32_conversion(MPTIOCINFO);
+	unregister_ioctl32_conversion(MPTTARGETINFO);
+	unregister_ioctl32_conversion(MPTTEST);
+	unregister_ioctl32_conversion(MPTEVENTQUERY);
+	unregister_ioctl32_conversion(MPTEVENTENABLE);
+	unregister_ioctl32_conversion(MPTEVENTREPORT);
+	unregister_ioctl32_conversion(MPTHARDRESET);
+	unregister_ioctl32_conversion(MPTCOMMAND32);
 	unregister_ioctl32_conversion(MPTFWDOWNLOAD32);
+	unregister_ioctl32_conversion(CPQFCTS_GETPCIINFO);
+	unregister_ioctl32_conversion(CPQFCTS_GETDRIVER);
+	unregister_ioctl32_conversion(CPQFCTS_CTLR_STATUS);
+	unregister_ioctl32_conversion(CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS);
+	unregister_ioctl32_conversion(CPQFCTS_SCSI_PASSTHRU32);
 #endif		/*} linux >= 2.3.x */
 #endif		/*} sparc */
 
+	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
+		ioc = NULL;
+		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
+		    (ioc == NULL)) {
+			continue;
+		}
+		else {
+			if (ioc->ioctl) {
+				kfree ( ioc->ioctl );
+				ioc->ioctl = NULL;
+			}
+		}
+	}
 	return err;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 void mptctl_exit(void)
 {
-
-#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
-	unregister_ioctl32_conversion(MPTRWPERF);
-	unregister_ioctl32_conversion(MPTRWPERF_CHK);
-	unregister_ioctl32_conversion(MPTRWPERF_RESET);
-	unregister_ioctl32_conversion(MPTFWDOWNLOAD32);
-#endif		/*} linux >= 2.3.x */
-#endif		/*} sparc */
+	int i;
+	MPT_ADAPTER *ioc;
+	int iocnum;
 
 	misc_deregister(&mptctl_miscdev);
-	printk(KERN_INFO MYNAM ": /dev/%s @ (major,minor=%d,%d)\n",
+	printk(KERN_INFO MYNAM ": Deregistered /dev/%s @ (major,minor=%d,%d)\n",
 			 mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);
-	printk(KERN_INFO MYNAM ": Deregistered from Fusion MPT base driver\n");
 
+	/* De-register reset handler from base module */
+	mpt_reset_deregister(mptctl_id);
+	dprintk((KERN_INFO MYNAM ": Deregistered for IOC reset notifications\n"));
+
+	/* De-register callback handler from base module */
 	mpt_deregister(mptctl_id);
+	printk(KERN_INFO MYNAM ": Deregistered from Fusion MPT base driver\n");
+
+	/* Free allocated memory */
+	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
+		ioc = NULL;
+		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
+		    (ioc == NULL)) {
+			continue;
+		}
+		else {
+			if (ioc->ioctl) {
+				kfree ( ioc->ioctl );
+				ioc->ioctl = NULL;
+			}
+		}
+	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
diff -Nru a/drivers/message/fusion/mptctl.h b/drivers/message/fusion/mptctl.h
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/message/fusion/mptctl.h	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,409 @@
+/*
+ *  linux/drivers/message/fusion/mptioctl.h
+ *      Fusion MPT misc device (ioctl) driver.
+ *      For use with PCI chip/adapter(s):
+ *          LSIFC9xx/LSI409xx Fibre Channel
+ *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
+ *
+ *  Credits:
+ *      This driver would not exist if not for Alan Cox's development
+ *      of the linux i2o driver.
+ *
+ *      A huge debt of gratitude is owed to David S. Miller (DaveM)
+ *      for fixing much of the stupid and broken stuff in the early
+ *      driver while porting to sparc64 platform.  THANK YOU!
+ *
+ *      (see also mptbase.c)
+ *
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
+ *  Originally By: Steven J. Ralston
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
+ *
+ *  $Id$
+ */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    NO WARRANTY
+    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
+    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
+    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
+    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
+    solely responsible for determining the appropriateness of using and
+    distributing the Program and assumes all risks associated with its
+    exercise of rights under this Agreement, including but not limited to
+    the risks and costs of program errors, damage to or loss of data,
+    programs or equipment, and unavailability or interruption of operations.
+
+    DISCLAIMER OF LIABILITY
+    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
+    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
+    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef MPTCTL_H_INCLUDED
+#define MPTCTL_H_INCLUDED
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#include "linux/version.h"
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *
+ */
+#define MPT_MISCDEV_BASENAME            "mptctl"
+#define MPT_MISCDEV_PATHNAME            "/dev/" MPT_MISCDEV_BASENAME
+
+#define MPT_PRODUCT_LENGTH              12
+
+/*
+ *  Generic MPT Control IOCTLs and structures
+ */
+#define MPT_MAGIC_NUMBER	'm'
+
+#define MPTRWPERF		_IOWR(MPT_MAGIC_NUMBER,0,struct mpt_raw_r_w)
+
+#define MPTFWDOWNLOAD		_IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer)
+#define MPTCOMMAND		_IOWR(MPT_MAGIC_NUMBER,20,struct mpt_ioctl_command)
+
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+#define MPTFWDOWNLOAD32		_IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer32)
+#define MPTCOMMAND32		_IOWR(MPT_MAGIC_NUMBER,20,struct mpt_ioctl_command32)
+#endif	/*}*/
+
+#define MPTIOCINFO		_IOWR(MPT_MAGIC_NUMBER,17,struct mpt_ioctl_iocinfo)
+#define MPTTARGETINFO		_IOWR(MPT_MAGIC_NUMBER,18,struct mpt_ioctl_targetinfo)
+#define MPTTEST			_IOWR(MPT_MAGIC_NUMBER,19,struct mpt_ioctl_test)
+#define MPTEVENTQUERY		_IOWR(MPT_MAGIC_NUMBER,21,struct mpt_ioctl_eventquery)
+#define MPTEVENTENABLE		_IOWR(MPT_MAGIC_NUMBER,22,struct mpt_ioctl_eventenable)
+#define MPTEVENTREPORT		_IOWR(MPT_MAGIC_NUMBER,23,struct mpt_ioctl_eventreport)
+#define MPTHARDRESET		_IOWR(MPT_MAGIC_NUMBER,24,struct mpt_ioctl_diag_reset)
+#define MPTFWREPLACE		_IOWR(MPT_MAGIC_NUMBER,25,struct mpt_ioctl_replace_fw)
+
+/*
+ * SPARC PLATFORM REMARK:
+ * IOCTL data structures that contain pointers
+ * will have different sizes in the driver and applications
+ * (as the app. will not use 8-byte pointers).
+ * Apps should use MPTFWDOWNLOAD and MPTCOMMAND.
+ * The driver will convert data from
+ * mpt_fw_xfer32 (mpt_ioctl_command32) to mpt_fw_xfer (mpt_ioctl_command)
+ * internally.
+ */
+struct mpt_fw_xfer {
+	unsigned int	 iocnum;	/* IOC unit number */
+	unsigned int	 fwlen;
+	void		*bufp;		/* Pointer to firmware buffer */
+};
+
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+struct mpt_fw_xfer32 {
+	unsigned int iocnum;
+	unsigned int fwlen;
+	u32 bufp;
+};
+#endif	/*}*/
+
+/*
+ *  IOCTL header structure.
+ *  iocnum - must be defined.
+ *  port - must be defined for all IOCTL commands other than MPTIOCINFO
+ *  maxDataSize - ignored on MPTCOMMAND commands
+ *		- ignored on MPTFWREPLACE commands
+ *		- on query commands, reports the maximum number of bytes to be returned
+ *		  to the host driver (count includes the header).
+ *		  That is, set to sizeof(struct mpt_ioctl_iocinfo) for fixed sized commands.
+ *		  Set to sizeof(struct mpt_ioctl_targetinfo) + datasize for variable
+ *			sized commands. (MPTTARGETINFO, MPTEVENTREPORT)
+ */
+typedef struct _mpt_ioctl_header {
+	unsigned int	 iocnum;	/* IOC unit number */
+	unsigned int	 port;		/* IOC port number */
+	int		 maxDataSize;	/* Maximum Num. bytes to transfer on read */
+} mpt_ioctl_header;
+
+/*
+ * Issue a diagnostic reset
+ */
+struct mpt_ioctl_diag_reset {
+	mpt_ioctl_header hdr;
+};
+
+
+/*
+ *  PCI bus/device/function information structure.
+ */
+struct mpt_ioctl_pci_info {
+	union {
+		struct {
+			unsigned long  deviceNumber   :  5;
+			unsigned long  functionNumber :  3;
+			unsigned long  busNumber      : 24;
+		} bits;
+		unsigned long  asUlong;
+	} u;
+};
+
+/*
+ *  Adapter Information Page
+ *  Read only.
+ *  Data starts at offset 0xC
+ */
+#define MPT_IOCTL_INTERFACE_FC		(0x01)
+#define MPT_IOCTL_INTERFACE_SCSI	(0x00)
+#define MPT_IOCTL_VERSION_LENGTH	(32)
+
+struct mpt_ioctl_iocinfo {
+	mpt_ioctl_header hdr;
+	int		 adapterType;	/* SCSI or FCP */
+	int		 port;		/* port number */
+	int		 pciId;		/* PCI Id. */
+	int		 hwRev;		/* hardware revision */
+	int		 subSystemDevice;	/* PCI subsystem Device ID */
+	int		 subSystemVendor;	/* PCI subsystem Vendor ID */
+	int		 numDevices;		/* number of devices */
+	int		 FWVersion;		/* FW Version (integer) */
+	int		 BIOSVersion;		/* BIOS Version (integer) */
+	char		 driverVersion[MPT_IOCTL_VERSION_LENGTH];	/* Driver Version (string) */
+	char		 busChangeEvent;
+	char		 hostId;
+	char		 rsvd[2];
+	struct mpt_ioctl_pci_info  pciInfo; /* Added Rev 1 */
+};
+
+/*
+ * Device Information Page
+ * Report the number of, and ids of, all targets
+ * on this IOC.  The ids array is a packed structure
+ * of the known targetInfo.
+ * bits 31-24: reserved
+ *      23-16: LUN
+ *      15- 8: Bus Number
+ *       7- 0: Target ID
+ */
+struct mpt_ioctl_targetinfo {
+	mpt_ioctl_header hdr;
+	int		 numDevices;	/* Num targets on this ioc */
+	int		 targetInfo[1];
+};
+
+
+/*
+ * Event reporting IOCTL's.  These IOCTL's will
+ * use the following defines:
+ */
+struct mpt_ioctl_eventquery {
+	mpt_ioctl_header hdr;
+	unsigned short	 eventEntries;
+	unsigned short	 reserved;
+	unsigned int	 eventTypes;
+};
+
+struct mpt_ioctl_eventenable {
+	mpt_ioctl_header hdr;
+	unsigned int	 eventTypes;
+};
+
+#ifndef __KERNEL__
+typedef struct {
+	uint	event;
+	uint	eventContext;
+	uint	data[2];
+} MPT_IOCTL_EVENTS;
+#endif
+
+struct mpt_ioctl_eventreport {
+	mpt_ioctl_header	hdr;
+	MPT_IOCTL_EVENTS	eventData[1];
+};
+
+#define MPT_MAX_NAME	32
+struct mpt_ioctl_test {
+	mpt_ioctl_header hdr;
+	u8		 name[MPT_MAX_NAME];
+	int		 chip_type;
+	u8		 product [MPT_PRODUCT_LENGTH];
+};
+
+/* Replace the FW image cached in host driver memory
+ * newImageSize - image size in bytes
+ * newImage - first byte of the new image
+ */
+typedef struct mpt_ioctl_replace_fw {
+	mpt_ioctl_header hdr;
+	int		 newImageSize;
+	u8		 newImage[1];
+} mpt_ioctl_replace_fw_t;
+
+/* General MPT Pass through data strucutre
+ *
+ * iocnum
+ * timeout - in seconds, command timeout. If 0, set by driver to
+ *		default value.
+ * replyFrameBufPtr - reply location
+ * dataInBufPtr - destination for read
+ * dataOutBufPtr - data source for write
+ * senseDataPtr - sense data location
+ * maxReplyBytes - maximum number of reply bytes to be sent to app.
+ * dataInSize - num bytes for data transfer in (read)
+ * dataOutSize - num bytes for data transfer out (write)
+ * dataSgeOffset - offset in words from the start of the request message
+ *		to the first SGL
+ * MF[1];
+ *
+ * Remark:  Some config pages have bi-directional transfer,
+ * both a read and a write. The basic structure allows for
+ * a bidirectional set up. Normal messages will have one or
+ * both of these buffers NULL.
+ */
+struct mpt_ioctl_command {
+	mpt_ioctl_header hdr;
+	int		timeout;	/* optional (seconds) */
+	char		*replyFrameBufPtr;
+	char		*dataInBufPtr;
+	char		*dataOutBufPtr;
+	char		*senseDataPtr;
+	int		maxReplyBytes;
+	int		dataInSize;
+	int		dataOutSize;
+	int		maxSenseBytes;
+	int		dataSgeOffset;
+	char		MF[1];
+};
+
+/*
+ * SPARC PLATFORM: See earlier remark.
+ */
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+struct mpt_ioctl_command32 {
+	mpt_ioctl_header hdr;
+	int	timeout;
+	u32	replyFrameBufPtr;
+	u32	dataInBufPtr;
+	u32	dataOutBufPtr;
+	u32	senseDataPtr;
+	int	maxReplyBytes;
+	int	dataInSize;
+	int	dataOutSize;
+	int	maxSenseBytes;
+	int	dataSgeOffset;
+	char	MF[1];
+};
+#endif	/*}*/
+
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+ /*
+  *	COMPAQ Specific IOCTL Defines and Structures
+  */
+
+#define CPQFCTS_IOC_MAGIC 'Z'
+
+#define CPQFCTS_GETPCIINFO		_IOR(CPQFCTS_IOC_MAGIC, 1, cpqfc_pci_info_struct)
+#define CPQFCTS_GETDRIVER		_IOR(CPQFCTS_IOC_MAGIC, 2, int)
+#define CPQFCTS_CTLR_STATUS		_IOR(CPQFCTS_IOC_MAGIC, 3, struct _cpqfc_ctlr_status)
+#define CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS	_IOR(CPQFCTS_IOC_MAGIC, 4, struct scsi_fctargaddress)
+#define CPQFCTS_SCSI_PASSTHRU		_IOWR(CPQFCTS_IOC_MAGIC, 5, VENDOR_IOCTL_REQ)
+#if defined(__sparc__) && defined(__sparc_v9__)
+#define CPQFCTS_SCSI_PASSTHRU32		_IOWR(CPQFCTS_IOC_MAGIC, 5, VENDOR_IOCTL_REQ32)
+#endif
+
+typedef struct {
+	unsigned short bus;
+	unsigned short bus_type;
+	unsigned short device_fn;
+	u32 board_id;
+	u32 slot_number;
+	unsigned short vendor_id;
+	unsigned short device_id;
+	unsigned short class_code;
+	unsigned short sub_vendor_id;
+	unsigned short sub_device_id;
+	u8 serial_number[81];
+} cpqfc_pci_info_struct;
+
+
+typedef struct scsi_fctargaddress {
+	unsigned int host_port_id;
+	u8 host_wwn[8];	/* WW Network Name */
+} Scsi_FCTargAddress;
+
+typedef struct _cpqfc_ctlr_status {
+	u32 status;
+	u32 offline_reason;
+} cpqfc_ctlr_status;
+
+
+/* Compaq SCSI I/O Passthru structures.
+ */
+#define MPT_COMPAQ_READ		0x26
+#define MPT_COMPAQ_WRITE	0x27
+
+typedef struct {
+	int lc;		/* controller number */
+	int node;	/* node number */
+	int ld;		/* target logical id */
+	u32 nexus;
+	void *argp;
+} VENDOR_IOCTL_REQ;
+
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+typedef struct {
+	int lc;		/* controller number */
+	int node;	/* node number */
+	int ld;		/* target logical id */
+	u32 nexus;
+	u32 argp;
+} VENDOR_IOCTL_REQ32;
+#endif
+
+typedef struct {
+	char cdb[16];		/* cdb */
+	unsigned short bus;	/* bus number */
+	unsigned short pdrive;	/* physical drive */
+	int len;		/* data area size */
+	int sense_len;		/* sense size */
+	char sense_data[40];	/* sense buffer */
+	void *bufp;		/* data buffer pointer */
+	char rw_flag;
+} cpqfc_passthru_t;
+
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+typedef struct {
+	char cdb[16];		/* cdb */
+	unsigned short bus;	/* bus number */
+	unsigned short pdrive;	/* physical drive */
+	int len;		/* data area size */
+	int sense_len;		/* sense size */
+	char sense_data[40];	/* sense buffer */
+	u32 bufp;		/* data buffer pointer */
+	char rw_flag;
+} cpqfc_passthru32_t;
+#endif
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#endif
+
diff -Nru a/drivers/message/fusion/mptlan.c b/drivers/message/fusion/mptlan.c
--- a/drivers/message/fusion/mptlan.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/message/fusion/mptlan.c	Thu Jun 20 15:54:01 2002
@@ -23,10 +23,10 @@
  *
  *      (see also mptbase.c)
  *
- *  Copyright (c) 2000-2001 LSI Logic Corporation
+ *  Copyright (c) 2000-2002 LSI Logic Corporation
  *  Originally By: Noah Romer
  *
- *  $Id$
+ *  $Id$
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -79,6 +79,8 @@
 
 #define MYNAM		"mptlan"
 
+MODULE_LICENSE("GPL");
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  * MPT LAN message sizes without variable part.
@@ -109,8 +111,8 @@
 	MPT_ADAPTER *mpt_dev;
 	u8 pnum; /* Port number in the IOC. This is not a Unix network port! */
 
-	atomic_t buckets_out;	  	/* number of unused buckets on IOC */
-	int bucketthresh;		/* Send more when this many used */
+	atomic_t buckets_out;		/* number of unused buckets on IOC */
+	int bucketthresh;		/* Send more when this many left */
 
 	int *mpt_txfidx; /* Free Tx Context list */
 	int mpt_txfidx_tail;
@@ -123,8 +125,8 @@
 	struct BufferControl *RcvCtl;	/* Receive BufferControl structs */
 	struct BufferControl *SendCtl;	/* Send BufferControl structs */
 
-	int max_buckets_out;	   	/* Max buckets to send to IOC */
-	int tx_max_out;		   	/* IOC's Tx queue len */
+	int max_buckets_out;		/* Max buckets to send to IOC */
+	int tx_max_out;			/* IOC's Tx queue len */
 
 	u32 total_posted;
 	u32 total_received;
@@ -152,7 +154,8 @@
 static int  mpt_lan_reset(struct net_device *dev);
 static int  mpt_lan_close(struct net_device *dev);
 static void mpt_lan_post_receive_buckets(void *dev_id);
-static void mpt_lan_wake_post_buckets_task(struct net_device *dev);
+static void mpt_lan_wake_post_buckets_task(struct net_device *dev, 
+					   int priority);
 static int  mpt_lan_receive_post_turbo(struct net_device *dev, u32 tmsg);
 static int  mpt_lan_receive_post_reply(struct net_device *dev,
 				       LANReceivePostReply_t *pRecvRep);
@@ -175,8 +178,10 @@
 
 static struct net_device *mpt_landev[MPT_MAX_ADAPTERS+1];
 
+#ifdef QLOGIC_NAA_WORKAROUND
 static struct NAA_Hosed *mpt_bad_naa = NULL;
 rwlock_t bad_naa_lock;
+#endif
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -229,7 +234,7 @@
 		case LAN_REPLY_FORM_SEND_SINGLE:
 //			dioprintk((MYNAM "/lan_reply: "
 //				  "calling mpt_lan_send_reply (turbo)\n"));
-  
+
 			// Potential BUG here?  -sralston
 			//	FreeReqFrame = mpt_lan_send_turbo(dev, tmsg);
 			//  If/when mpt_lan_send_turbo would return 1 here,
@@ -333,7 +338,7 @@
 	struct net_device *dev = mpt_landev[ioc->id];
 	struct mpt_lan_priv *priv = (struct mpt_lan_priv *) dev->priv;
 
-	dprintk((KERN_INFO MYNAM ": IOC %s_reset routed to LAN driver!\n",
+	dlprintk((KERN_INFO MYNAM ": IOC %s_reset routed to LAN driver!\n",
 			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
 
 	if (priv->mpt_rxfidx == NULL)
@@ -342,9 +347,11 @@
 	if (reset_phase == MPT_IOC_PRE_RESET) {
 		int i;
 		unsigned long flags;
-		
+
 		netif_stop_queue(dev);
 
+		dlprintk ((KERN_INFO "mptlan/ioc_reset: called netif_stop_queue for %s.\n", dev->name));
+
 		atomic_set(&priv->buckets_out, 0);
 
 		/* Reset Rx Free Tail index and re-populate the queue. */
@@ -365,7 +372,7 @@
 static int
 mpt_lan_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)
 {
-	dprintk((KERN_INFO MYNAM ": MPT event routed to LAN driver!\n"));
+	dlprintk((KERN_INFO MYNAM ": MPT event routed to LAN driver!\n"));
 
 	switch (le32_to_cpu(pEvReply->Event)) {
 	case MPI_EVENT_NONE:				/* 00 */
@@ -403,9 +410,9 @@
 
 	if (mpt_lan_reset(dev) != 0) {
 		MPT_ADAPTER *mpt_dev = priv->mpt_dev;
-		
+
 		printk (KERN_WARNING MYNAM "/lan_open: lan_reset failed.");
-		
+
 		if (mpt_dev->active)
 			printk ("The ioc is active. Perhaps it needs to be"
 				" reset?\n");
@@ -429,7 +436,7 @@
 		priv->mpt_txfidx[++priv->mpt_txfidx_tail] = i;
 	}
 
-	dprintk((KERN_INFO MYNAM "@lo: Finished initializing SendCtl\n"));
+	dlprintk((KERN_INFO MYNAM "@lo: Finished initializing SendCtl\n"));
 
 	priv->mpt_rxfidx = kmalloc(priv->max_buckets_out * sizeof(int),
 				   GFP_KERNEL);
@@ -447,12 +454,12 @@
 		priv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = i;
 	}
 
-/**/	dprintk((KERN_INFO MYNAM "/lo: txfidx contains - "));
+/**/	dlprintk((KERN_INFO MYNAM "/lo: txfidx contains - "));
 /**/	for (i = 0; i < priv->tx_max_out; i++)
-/**/		dprintk((" %xh", priv->mpt_txfidx[i]));
-/**/	dprintk(("\n"));
+/**/		dlprintk((" %xh", priv->mpt_txfidx[i]));
+/**/	dlprintk(("\n"));
 
-	dprintk((KERN_INFO MYNAM "/lo: Finished initializing RcvCtl\n"));
+	dlprintk((KERN_INFO MYNAM "/lo: Finished initializing RcvCtl\n"));
 
 	mpt_lan_post_receive_buckets(dev);
 	printk(KERN_INFO MYNAM ": %s/%s: interface up & active\n",
@@ -466,7 +473,7 @@
 	}
 
 	netif_start_queue(dev);
-	dprintk((KERN_INFO MYNAM "/lo: Done.\n"));
+	dlprintk((KERN_INFO MYNAM "/lo: Done.\n"));
 
 	return 0;
 out_mpt_rxfidx:
@@ -494,7 +501,7 @@
 	mf = mpt_get_msg_frame(LanCtx, priv->mpt_dev->id);
 
 	if (mf == NULL) {
-/*		dprintk((KERN_ERR MYNAM "/reset: Evil funkiness abounds! "
+/*		dlprintk((KERN_ERR MYNAM "/reset: Evil funkiness abounds! "
 		"Unable to allocate a request frame.\n"));
 */
 		return -1;
@@ -523,11 +530,11 @@
 	unsigned int timeout;
 	int i;
 
-	dprintk((KERN_INFO MYNAM ": mpt_lan_close called\n"));
+	dlprintk((KERN_INFO MYNAM ": mpt_lan_close called\n"));
 
 	mpt_event_deregister(LanCtx);
 
-	dprintk((KERN_INFO MYNAM ":lan_close: Posted %d buckets "
+	dlprintk((KERN_INFO MYNAM ":lan_close: Posted %d buckets "
 		  "since driver was loaded, %d still out\n",
 		  priv->total_posted,atomic_read(&priv->buckets_out)));
 
@@ -537,18 +544,18 @@
 
 	timeout = 2 * HZ;
 	while (atomic_read(&priv->buckets_out) && --timeout) {
-		current->state = TASK_INTERRUPTIBLE;
+		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(1);
 	}
 
 	for (i = 0; i < priv->max_buckets_out; i++) {
 		if (priv->RcvCtl[i].skb != NULL) {
-/**/			dprintk((KERN_INFO MYNAM "/lan_close: bucket %05x "
+/**/			dlprintk((KERN_INFO MYNAM "/lan_close: bucket %05x "
 /**/				  "is still out\n", i));
 			pci_unmap_single(mpt_dev->pcidev, priv->RcvCtl[i].dma,
-				 	 priv->RcvCtl[i].len,
+					 priv->RcvCtl[i].len,
 					 PCI_DMA_FROMDEVICE);
- 			dev_kfree_skb(priv->RcvCtl[i].skb);
+			dev_kfree_skb(priv->RcvCtl[i].skb);
 		}
 	}
 
@@ -556,11 +563,11 @@
 	kfree (priv->mpt_rxfidx);
 
 	for (i = 0; i < priv->tx_max_out; i++) {
- 		if (priv->SendCtl[i].skb != NULL) {
+		if (priv->SendCtl[i].skb != NULL) {
 			pci_unmap_single(mpt_dev->pcidev, priv->SendCtl[i].dma,
 					 priv->SendCtl[i].len,
 					 PCI_DMA_TODEVICE);
- 			dev_kfree_skb(priv->SendCtl[i].skb);
+			dev_kfree_skb(priv->SendCtl[i].skb);
 		}
 	}
 
@@ -599,7 +606,13 @@
 static void
 mpt_lan_tx_timeout(struct net_device *dev)
 {
-	netif_wake_queue(dev);  
+	struct mpt_lan_priv *priv = (struct mpt_lan_priv *) dev->priv;
+	MPT_ADAPTER *mpt_dev = priv->mpt_dev;
+
+	if (mpt_dev->active) {
+		dlprintk (("mptlan/tx_timeout: calling netif_wake_queue for %s.\n", dev->name));
+		netif_wake_queue(dev);
+	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -656,7 +669,7 @@
 
 	/* Add check for Loginfo Flag in IOCStatus */
 
-	switch (le16_to_cpu(pSendRep->IOCStatus)) {
+	switch (le16_to_cpu(pSendRep->IOCStatus) & MPI_IOCSTATUS_MASK) {
 	case MPI_IOCSTATUS_SUCCESS:
 		priv->stats.tx_packets += count;
 		break;
@@ -722,7 +735,6 @@
 	dma_addr_t dma;
 	unsigned long flags;
 	int ctx;
-	struct NAA_Hosed *nh;
 	u16 cur_naa = 0x1000;
 
 	dioprintk((KERN_INFO MYNAM ": %s called, skb_addr = %p\n",
@@ -741,7 +753,6 @@
 	mf = mpt_get_msg_frame(LanCtx, mpt_dev->id);
 	if (mf == NULL) {
 		netif_stop_queue(dev);
-		dev_kfree_skb(skb);
 		spin_unlock_irqrestore(&priv->txfidx_lock, flags);
 
 		printk (KERN_ERR "%s: Unable to alloc request frame\n",
@@ -791,6 +802,10 @@
 //			IOC_AND_NETDEV_NAMES_s_s(dev),
 //			ctx, skb, skb->data));
 
+#ifdef QLOGIC_NAA_WORKAROUND
+{
+	struct NAA_Hosed *nh;
+
 	/* Munge the NAA for Tx packets to QLogic boards, which don't follow
 	   RFC 2625. The longer I look at this, the more my opinion of Qlogic
 	   drops. */
@@ -803,12 +818,14 @@
 		    (nh->ieee[4] == skb->mac.raw[4]) &&
 		    (nh->ieee[5] == skb->mac.raw[5])) {
 			cur_naa = nh->NAA;
-			dprintk ((KERN_INFO "mptlan/sdu_send: using NAA value "
+			dlprintk ((KERN_INFO "mptlan/sdu_send: using NAA value "
 				  "= %04x.\n", cur_naa));
 			break;
 		}
 	}
 	read_unlock_irq(&bad_naa_lock);
+}
+#endif
 
 	pTrans->TransactionDetails[0] = cpu_to_le32((cur_naa         << 16) |
 						    (skb->mac.raw[0] <<  8) |
@@ -821,10 +838,10 @@
 	pSimple = (SGESimple64_t *) &pTrans->TransactionDetails[2];
 
 	/* If we ever decide to send more than one Simple SGE per LANSend, then
-	   we will need to make sure that LAST_ELEMENT only gets set on the 
+	   we will need to make sure that LAST_ELEMENT only gets set on the
 	   last one. Otherwise, bad voodoo and evil funkiness will commence. */
 	pSimple->FlagsLength = cpu_to_le32(
-			((MPI_SGE_FLAGS_LAST_ELEMENT | 
+			((MPI_SGE_FLAGS_LAST_ELEMENT |
 			  MPI_SGE_FLAGS_END_OF_BUFFER |
 			  MPI_SGE_FLAGS_SIMPLE_ELEMENT |
 			  MPI_SGE_FLAGS_SYSTEM_ADDRESS |
@@ -842,23 +859,32 @@
 	dev->trans_start = jiffies;
 
 	dioprintk((KERN_INFO MYNAM ": %s/%s: Sending packet. FlagsLength = %08x.\n",
-		 	IOC_AND_NETDEV_NAMES_s_s(dev),
-		       	le32_to_cpu(pSimple->FlagsLength)));
+			IOC_AND_NETDEV_NAMES_s_s(dev),
+			le32_to_cpu(pSimple->FlagsLength)));
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static inline void
-mpt_lan_wake_post_buckets_task(struct net_device *dev)
+mpt_lan_wake_post_buckets_task(struct net_device *dev, int priority)
+/* 
+ * @priority: 0 = put it on the timer queue, 1 = put it on the immediate queue
+ */
 {
 	struct mpt_lan_priv *priv = dev->priv;
-
+	
 	if (test_and_set_bit(0, &priv->post_buckets_active) == 0) {
-		queue_task(&priv->post_buckets_task, &tq_immediate);
-		mark_bh(IMMEDIATE_BH);
-		dioprintk((KERN_INFO MYNAM ": %s/%s: Queued post_buckets task.\n",
-				IOC_AND_NETDEV_NAMES_s_s(dev) ));
+		if (priority) {
+			queue_task(&priv->post_buckets_task, &tq_immediate);
+			mark_bh(IMMEDIATE_BH);
+		} else {
+			queue_task(&priv->post_buckets_task, &tq_timer);
+			dioprintk((KERN_INFO MYNAM ": post_buckets queued on "
+				   "timer.\n"));
+		}
+	        dioprintk((KERN_INFO MYNAM ": %s/%s: Queued post_buckets task.\n",
+			   IOC_AND_NETDEV_NAMES_s_s(dev) ));
 	}
 }
 
@@ -870,7 +896,7 @@
 
 	skb->protocol = mpt_lan_type_trans(skb, dev);
 
-	dioprintk((KERN_INFO MYNAM ": %s/%s: Incoming packet (%d bytes) " 
+	dioprintk((KERN_INFO MYNAM ": %s/%s: Incoming packet (%d bytes) "
 		 "delivered to upper level.\n",
 			IOC_AND_NETDEV_NAMES_s_s(dev), skb->len));
 
@@ -884,7 +910,7 @@
 		 atomic_read(&priv->buckets_out)));
 
 	if (atomic_read(&priv->buckets_out) < priv->bucketthresh)
-		mpt_lan_wake_post_buckets_task(dev);
+		mpt_lan_wake_post_buckets_task(dev, 1);
 
 	dioprintk((KERN_INFO MYNAM "/receive_post_reply: %d buckets "
 		  "remaining, %d received back since sod\n",
@@ -956,12 +982,12 @@
 	unsigned long flags;
 	struct sk_buff *skb;
 	u32 ctx;
-	u8 count;
+	int count;
 	int i;
 
 	count = pRecvRep->NumberOfContexts;
 
-/**/	dprintk((KERN_INFO MYNAM "/receive_post_reply: "
+/**/	dlprintk((KERN_INFO MYNAM "/receive_post_reply: "
 		  "IOC returned %d buckets, freeing them...\n", count));
 
 	spin_lock_irqsave(&priv->rxfidx_lock, flags);
@@ -970,11 +996,11 @@
 
 		skb = priv->RcvCtl[ctx].skb;
 
-//		dprintk((KERN_INFO MYNAM ": %s: dev_name = %s\n",
+//		dlprintk((KERN_INFO MYNAM ": %s: dev_name = %s\n",
 //				IOC_AND_NETDEV_NAMES_s_s(dev)));
-//		dprintk((KERN_INFO MYNAM "@rpr[2], priv = %p, buckets_out addr = %p",
-//			  	priv, &(priv->buckets_out)));
-//		dprintk((KERN_INFO MYNAM "@rpr[2] TC + 3\n"));
+//		dlprintk((KERN_INFO MYNAM "@rpr[2], priv = %p, buckets_out addr = %p",
+//				priv, &(priv->buckets_out)));
+//		dlprintk((KERN_INFO MYNAM "@rpr[2] TC + 3\n"));
 
 		priv->RcvCtl[ctx].skb = NULL;
 		pci_unmap_single(mpt_dev->pcidev, priv->RcvCtl[ctx].dma,
@@ -989,13 +1015,13 @@
 
 //	for (i = 0; i < priv->max_buckets_out; i++)
 //		if (priv->RcvCtl[i].skb != NULL)
-//			dprintk((KERN_INFO MYNAM "@rpr: bucket %03x "
+//			dlprintk((KERN_INFO MYNAM "@rpr: bucket %03x "
 //				  "is still out\n", i));
 
-/*	dprintk((KERN_INFO MYNAM "/receive_post_reply: freed %d buckets\n",
+/*	dlprintk((KERN_INFO MYNAM "/receive_post_reply: freed %d buckets\n",
 		  count));
 */
-/**/	dprintk((KERN_INFO MYNAM "@receive_post_reply: %d buckets "
+/**/	dlprintk((KERN_INFO MYNAM "@receive_post_reply: %d buckets "
 /**/		  "remaining, %d received back since sod.\n",
 /**/		  atomic_read(&priv->buckets_out), priv->total_received));
 	return 0;
@@ -1010,16 +1036,17 @@
 	MPT_ADAPTER *mpt_dev = priv->mpt_dev;
 	struct sk_buff *skb, *old_skb;
 	unsigned long flags;
-	u32 len, ctx;
-	u32 offset;
-	u8 count;
+	u32 len, ctx, offset;
+	u32 remaining = le32_to_cpu(pRecvRep->BucketsRemaining);
+	int count;
 	int i, l;
 
 	dioprintk((KERN_INFO MYNAM ": mpt_lan_receive_post_reply called\n"));
 	dioprintk((KERN_INFO MYNAM ": receive_post_reply: IOCStatus: %04x\n",
 		 le16_to_cpu(pRecvRep->IOCStatus)));
 
-	if (le16_to_cpu(pRecvRep->IOCStatus) & MPI_IOCSTATUS_LAN_CANCELED)
+	if ((le16_to_cpu(pRecvRep->IOCStatus) & MPI_IOCSTATUS_MASK) ==
+						MPI_IOCSTATUS_LAN_CANCELED)
 		return mpt_lan_receive_post_free(dev, pRecvRep);
 
 	len = le32_to_cpu(pRecvRep->PacketLength);
@@ -1059,7 +1086,7 @@
 		if (!skb) {
 			printk (KERN_ERR MYNAM ": %s/%s: ERROR - Can't allocate skb! (%s@%d)\n",
 					IOC_AND_NETDEV_NAMES_s_s(dev),
-			       		__FILE__, __LINE__);
+					__FILE__, __LINE__);
 			return -ENOMEM;
 		}
 
@@ -1096,7 +1123,7 @@
 		if (!skb) {
 			printk (KERN_ERR MYNAM ": %s/%s: ERROR - Can't allocate skb! (%s@%d)\n",
 					IOC_AND_NETDEV_NAMES_s_s(dev),
-			       		__FILE__, __LINE__);
+					__FILE__, __LINE__);
 			return -ENOMEM;
 		}
 
@@ -1140,25 +1167,32 @@
 				"Arrgghh! We've done it again!\n");
 	}
 
-#if 0
-	{
-		u32 remaining = le32_to_cpu(pRecvRep->BucketsRemaining);
-		if (remaining < priv->bucketthresh)
-			mpt_lan_wake_post_buckets_task(dev);
-
-		if (remaining == 0)
-			printk (KERN_WARNING MYNAM ": %s/%s: WARNING - IOC out of buckets! "
-				"(priv->buckets_out = %d)\n",
-					IOC_AND_NETDEV_NAMES_s_s(dev),
-					atomic_read(&priv->buckets_out));
-		else
-			printk (KERN_INFO MYNAM ": %s/%s: IOC says %d buckets left. "
-				"(priv->buckets_out = %d)\n",
-					IOC_AND_NETDEV_NAMES_s_s(dev),
-					remaining, atomic_read(&priv->buckets_out));
+	if (remaining == 0)
+		printk (KERN_WARNING MYNAM ": %s/%s: WARNING - IOC out of buckets! "
+			"(priv->buckets_out = %d)\n",
+			IOC_AND_NETDEV_NAMES_s_s(dev),
+			atomic_read(&priv->buckets_out));
+	else if (remaining < 10)
+		printk (KERN_INFO MYNAM ": %s/%s: IOC says %d buckets left. "
+			"(priv->buckets_out = %d)\n",
+			IOC_AND_NETDEV_NAMES_s_s(dev),
+			remaining, atomic_read(&priv->buckets_out));
+	
+	if ((remaining < priv->bucketthresh) &&
+	    ((atomic_read(&priv->buckets_out) - remaining) > 
+	     MPT_LAN_BUCKETS_REMAIN_MISMATCH_THRESH)) {
+		
+		printk (KERN_WARNING MYNAM " Mismatch between driver's "
+			"buckets_out count and fw's BucketsRemaining "
+			"count has crossed the threshold, issuing a "
+			"LanReset to clear the fw's hashtable. You may "
+			"want to check your /var/log/messages for \"CRC "
+			"error\" event notifications.\n");
+		
+		mpt_lan_reset(dev);
+		mpt_lan_wake_post_buckets_task(dev, 0);
 	}
-#endif
-
+	
 	return mpt_lan_receive_skb(dev, skb);
 }
 
@@ -1242,15 +1276,15 @@
 			if (skb == NULL) {
 				skb = dev_alloc_skb(len);
 				if (skb == NULL) {
-/**/					printk (KERN_WARNING
-/**/						MYNAM "/%s: Can't alloc skb\n",
-/**/						__FUNCTION__);
+					printk (KERN_WARNING
+						MYNAM "/%s: Can't alloc skb\n",
+						__FUNCTION__);
 					priv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;
 					spin_unlock_irqrestore(&priv->rxfidx_lock, flags);
 					break;
 				}
 
-		    		dma = pci_map_single(mpt_dev->pcidev, skb->data,
+				dma = pci_map_single(mpt_dev->pcidev, skb->data,
 						     len, PCI_DMA_FROMDEVICE);
 
 				priv->RcvCtl[ctx].skb = skb;
@@ -1308,7 +1342,7 @@
 	dioprintk((KERN_INFO MYNAM "/%s: End_buckets = %u, priv->buckets_out = %u\n",
 		  __FUNCTION__, buckets, atomic_read(&priv->buckets_out)));
 	dioprintk((KERN_INFO MYNAM "/%s: Posted %u buckets and received %u back\n",
-	__FUNCTION__, priv->total_posted, priv->total_received)); 
+	__FUNCTION__, priv->total_posted, priv->total_received));
 
 	clear_bit(0, &priv->post_buckets_active);
 }
@@ -1336,7 +1370,7 @@
 	priv->post_buckets_task.data = dev;
 	priv->post_buckets_active = 0;
 
-	dprintk((KERN_INFO MYNAM "@%d: bucketlen = %d\n",
+	dlprintk((KERN_INFO MYNAM "@%d: bucketlen = %d\n",
 			__LINE__, dev->mtu + dev->hard_header_len + 4));
 
 	atomic_set(&priv->buckets_out, 0);
@@ -1346,7 +1380,7 @@
 	if (mpt_dev->pfacts[0].MaxLanBuckets < max_buckets_out)
 		priv->max_buckets_out = mpt_dev->pfacts[0].MaxLanBuckets;
 
-	dprintk((KERN_INFO MYNAM "@%d: MaxLanBuckets=%d, max_buckets_out/priv=%d/%d\n",
+	dlprintk((KERN_INFO MYNAM "@%d: MaxLanBuckets=%d, max_buckets_out/priv=%d/%d\n",
 			__LINE__,
 			mpt_dev->pfacts[0].MaxLanBuckets,
 			max_buckets_out,
@@ -1389,7 +1423,7 @@
 	dev->tx_timeout = mpt_lan_tx_timeout;
 	dev->watchdog_timeo = MPT_LAN_TX_TIMEOUT;
 
-	dprintk((KERN_INFO MYNAM ": Finished registering dev "
+	dlprintk((KERN_INFO MYNAM ": Finished registering dev "
 		"and setting initial values\n"));
 
 	SET_MODULE_OWNER(dev);
@@ -1403,13 +1437,15 @@
 {
 	struct net_device *dev;
 	MPT_ADAPTER *curadapter;
-	int i = 0, j;
+	int i, j;
 
 	show_mptmod_ver(LANAME, LANVER);
 
-	/* Init the global r/w lock for the bad_naa list. We want to do this 
+#ifdef QLOGIC_NAA_WORKAROUND
+	/* Init the global r/w lock for the bad_naa list. We want to do this
 	   before any boards are initialized and may be used. */
 	rwlock_init(&bad_naa_lock);
+#endif
 
 	if ((LanCtx = mpt_register(lan_reply, MPTLAN_DRIVER)) <= 0) {
 		printk (KERN_ERR MYNAM ": Failed to register with MPT base driver\n");
@@ -1419,10 +1455,10 @@
 	/* Set the callback index to be used by driver core for turbo replies */
 	mpt_lan_index = LanCtx;
 
-	dprintk((KERN_INFO MYNAM ": assigned context of %d\n", LanCtx));
+	dlprintk((KERN_INFO MYNAM ": assigned context of %d\n", LanCtx));
 
 	if (mpt_reset_register(LanCtx, mpt_lan_ioc_reset) == 0) {
-		dprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
+		dlprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
 	} else {
 		printk(KERN_ERR MYNAM ": Eieee! unable to register a reset "
 		       "handler with mptbase! The world is at an end! "
@@ -1433,7 +1469,6 @@
 	for (j = 0; j < MPT_MAX_ADAPTERS; j++) {
 		mpt_landev[j] = NULL;
 	}
-	j = 0;
 
 	curadapter = mpt_adapter_find_first();
 	while (curadapter != NULL) {
@@ -1457,11 +1492,11 @@
 //					printk (KERN_INFO MYNAM ": %s/%s: Max_TX_outstanding = %d\n",
 //							IOC_AND_NETDEV_NAMES_s_s(dev),
 //							NETDEV_TO_LANPRIV_PTR(dev)->tx_max_out);
+					j = curadapter->id;
 					mpt_landev[j] = dev;
-					dprintk((KERN_INFO MYNAM "/init: dev_addr=%p, mpt_landev[%d]=%p\n",
+					dlprintk((KERN_INFO MYNAM "/init: dev_addr=%p, mpt_landev[%d]=%p\n",
 							dev, j,  mpt_landev[j]));
 
-					j++;
 				} else {
 					printk (KERN_ERR MYNAM ": %s: Unable to register port%d as a LAN device\n",
 							curadapter->name,
@@ -1508,18 +1543,15 @@
 MODULE_PARM(tx_max_out_p, "i");
 MODULE_PARM(max_buckets_out, "i"); // Debug stuff. FIXME!
 
-MODULE_LICENSE("GPL");
-
 module_init(mpt_lan_init);
 module_exit(mpt_lan_exit);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static unsigned short
-mpt_lan_type_trans(struct sk_buff *skb, struct net_device *dev) 
+mpt_lan_type_trans(struct sk_buff *skb, struct net_device *dev)
 {
 	struct mpt_lan_ohdr *fch = (struct mpt_lan_ohdr *)skb->data;
 	struct fcllc *fcllc;
-	u16 source_naa = fch->stype, found = 0;
 
 	skb->mac.raw = skb->data;
 	skb_pull(skb, sizeof(struct mpt_lan_ohdr));
@@ -1535,7 +1567,7 @@
 		printk (KERN_WARNING MYNAM ": %s: WARNING - Broadcast swap F/W bug detected!\n",
 				NETDEV_PTR_TO_IOC_NAME_s(dev));
 		printk (KERN_WARNING MYNAM ": Please update sender @ MAC_addr = %02x:%02x:%02x:%02x:%02x:%02x\n",
-		       		fch->saddr[0], fch->saddr[1], fch->saddr[2],
+				fch->saddr[0], fch->saddr[1], fch->saddr[2],
 				fch->saddr[3], fch->saddr[4], fch->saddr[5]);
 	}
 
@@ -1555,6 +1587,10 @@
 
 	fcllc = (struct fcllc *)skb->data;
 
+#ifdef QLOGIC_NAA_WORKAROUND
+{
+	u16 source_naa = fch->stype, found = 0;
+
 	/* Workaround for QLogic not following RFC 2625 in regards to the NAA
 	   value. */
 
@@ -1562,15 +1598,15 @@
 		source_naa = swab16(source_naa);
 
 	if (fcllc->ethertype == htons(ETH_P_ARP))
-	    dprintk ((KERN_INFO "mptlan/type_trans: got arp req/rep w/ naa of "
+	    dlprintk ((KERN_INFO "mptlan/type_trans: got arp req/rep w/ naa of "
 		      "%04x.\n", source_naa));
 
-	if ((fcllc->ethertype == htons(ETH_P_ARP)) && 
+	if ((fcllc->ethertype == htons(ETH_P_ARP)) &&
 	   ((source_naa >> 12) !=  MPT_LAN_NAA_RFC2625)){
 		struct NAA_Hosed *nh, *prevnh;
 		int i;
 
-		dprintk ((KERN_INFO "mptlan/type_trans: ARP Req/Rep from "
+		dlprintk ((KERN_INFO "mptlan/type_trans: ARP Req/Rep from "
 			  "system with non-RFC 2625 NAA value (%04x).\n",
 			  source_naa));
 
@@ -1584,17 +1620,17 @@
 			    (nh->ieee[4] == fch->saddr[4]) &&
 			    (nh->ieee[5] == fch->saddr[5])) {
 				found = 1;
-				dprintk ((KERN_INFO "mptlan/type_trans: ARP Re"
+				dlprintk ((KERN_INFO "mptlan/type_trans: ARP Re"
 					 "q/Rep w/ bad NAA from system already"
 					 " in DB.\n"));
 				break;
 			}
 		}
-		
+
 		if ((!found) && (nh == NULL)) {
 
 			nh = kmalloc(sizeof(struct NAA_Hosed), GFP_KERNEL);
-			dprintk ((KERN_INFO "mptlan/type_trans: ARP Req/Rep w/"
+			dlprintk ((KERN_INFO "mptlan/type_trans: ARP Req/Rep w/"
 				 " bad NAA from system not yet in DB.\n"));
 
 			if (nh != NULL) {
@@ -1603,11 +1639,11 @@
 					mpt_bad_naa = nh;
 				if (prevnh)
 					prevnh->next = nh;
-				
+
 				nh->NAA = source_naa; /* Set the S_NAA value. */
 				for (i = 0; i < FC_ALEN; i++)
 					nh->ieee[i] = fch->saddr[i];
-				dprintk ((KERN_INFO "Got ARP from %02x:%02x:%02x:%02x:"
+				dlprintk ((KERN_INFO "Got ARP from %02x:%02x:%02x:%02x:"
 					  "%02x:%02x with non-compliant S_NAA value.\n",
 					  fch->saddr[0], fch->saddr[1], fch->saddr[2],
 					  fch->saddr[3], fch->saddr[4],fch->saddr[5]));
@@ -1622,9 +1658,10 @@
 		}
 		write_unlock_irq(&bad_naa_lock);
 	}
-		
+}
+#endif
 
-	/* Strip the SNAP header from ARP packets since we don't 
+	/* Strip the SNAP header from ARP packets since we don't
 	 * pass them through to the 802.2/SNAP layers.
 	 */
 	if (fcllc->dsap == EXTENDED_SAP &&
diff -Nru a/drivers/message/fusion/mptlan.h b/drivers/message/fusion/mptlan.h
--- a/drivers/message/fusion/mptlan.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/mptlan.h	Thu Jun 20 15:54:00 2002
@@ -21,6 +21,7 @@
 #include <linux/miscdevice.h>
 #include <linux/spinlock.h>
 #include <linux/tqueue.h>
+#include <linux/delay.h>
 // #include <linux/trdevice.h>
 
 #include <asm/uaccess.h>
@@ -43,13 +44,15 @@
 
 #define MPT_LAN_MAX_BUCKETS_OUT 256
 #define MPT_LAN_BUCKET_THRESH	18 /* 9 buckets in one message */
+#define MPT_LAN_BUCKETS_REMAIN_MISMATCH_THRESH 10
 #define MPT_LAN_RX_COPYBREAK	200
-#define MPT_LAN_TX_TIMEOUT 	(1*HZ)
+#define MPT_LAN_TX_TIMEOUT	(1*HZ)
 #define MPT_TX_MAX_OUT_LIM      127
 
 #define MPT_LAN_MIN_MTU		96		/* RFC2625 */
 #define MPT_LAN_MAX_MTU		65280		/* RFC2625 */
-#define MPT_LAN_MTU             16128		/* be nice to slab allocator */
+#define MPT_LAN_MTU             13312		/* Max perf range + lower mem
+						   usage than 16128 */
 
 #define MPT_LAN_NAA_RFC2625     0x1
 #define MPT_LAN_NAA_QLOGIC      0x2
@@ -64,6 +67,12 @@
 #define dioprintk(x)  printk x
 #else
 #define dioprintk(x)
+#endif
+
+#ifdef MPT_LAN_DEBUG
+#define dlprintk(x)  printk x
+#else
+#define dlprintk(x)
 #endif
 
 #define NETDEV_TO_LANPRIV_PTR(d)	((struct mpt_lan_priv *)(d)->priv)
diff -Nru a/drivers/message/fusion/mptscsih.c b/drivers/message/fusion/mptscsih.c
--- a/drivers/message/fusion/mptscsih.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/message/fusion/mptscsih.c	Thu Jun 20 15:54:01 2002
@@ -9,17 +9,24 @@
  *      This driver would not exist if not for Alan Cox's development
  *      of the linux i2o driver.
  *
+ *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
+ *      and countless enhancements while adding support for the 1030
+ *      chip family.  Pam has been instrumental in the development of
+ *      of the 2.xx.xx series fusion drivers, and her contributions are
+ *      far too numerous to hope to list in one place.
+ *
  *      A huge debt of gratitude is owed to David S. Miller (DaveM)
  *      for fixing much of the stupid and broken stuff in the early
  *      driver while porting to sparc64 platform.  THANK YOU!
  *
  *      (see mptbase.c)
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Original author: Steven J. Ralston
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id$
+ *  $Id$
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -65,7 +72,10 @@
 #include <linux/errno.h>
 #include <linux/kdev_t.h>
 #include <linux/blkdev.h>
-#include <linux/blk.h>
+#include <linux/blk.h>		/* for io_request_lock (spinlock) decl */
+#include <linux/delay.h>	/* for mdelay */
+#include <linux/interrupt.h>	/* needed for in_interrupt() proto */
+#include <linux/reboot.h>	/* notifier code */
 #include "../../scsi/scsi.h"
 #include "../../scsi/hosts.h"
 #include "../../scsi/sd.h"
@@ -83,52 +93,135 @@
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
 
+/* Set string for command line args from insmod */
+#ifdef MODULE
+char *mptscsih = 0;
+MODULE_PARM(mptscsih, "s");
+#endif
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 typedef struct _BIG_SENSE_BUF {
-	u8		data[256];
+	u8		data[MPT_SENSE_BUFFER_ALLOC];
 } BIG_SENSE_BUF;
 
-typedef struct _MPT_SCSI_HOST {
-	MPT_ADAPTER		 *ioc;
-	int			  port;
-	struct scsi_cmnd	**ScsiLookup;
-	u8			 *SgHunks;
-	dma_addr_t		  SgHunksDMA;
-	u32			  qtag_tick;
-} MPT_SCSI_HOST;
-
-typedef struct _MPT_SCSI_DEV {
-	struct _MPT_SCSI_DEV	 *forw;
-	struct _MPT_SCSI_DEV	 *back;
-	MPT_ADAPTER		 *ioc;
-	int			  sense_sz;
-	BIG_SENSE_BUF		  CachedSense;
-	unsigned long		  io_cnt;
-	unsigned long		  read_cnt;
-} MPT_SCSI_DEV;
+#define MPT_SCANDV_GOOD			(0x00000000) /* must be 0 */
+#define MPT_SCANDV_DID_RESET		(0x00000001)
+#define MPT_SCANDV_SENSE		(0x00000002)
+#define MPT_SCANDV_SOME_ERROR		(0x00000004)
+#define MPT_SCANDV_SELECTION_TIMEOUT	(0x00000008)
+
+#define MPT_SCANDV_MAX_RETRIES		(10)
+
+#define MPT_ICFLAG_BUF_CAP	0x01	/* ReadBuffer Read Capacity format */
+#define MPT_ICFLAG_ECHO		0x02	/* ReadBuffer Echo buffer format */
+#define MPT_ICFLAG_PHYS_DISK	0x04	/* Any SCSI IO but do Phys Disk Format */
+#define MPT_ICFLAG_TAGGED_CMD	0x08	/* Do tagged IO */
+#define MPT_ICFLAG_DID_RESET	0x20	/* Bus Reset occured with this command */
+#define MPT_ICFLAG_RESERVED	0x40	/* Reserved has been issued */
+
+typedef struct _internal_cmd {
+	char		*data;		/* data pointer */
+	dma_addr_t	data_dma;	/* data dma address */
+	int		size;		/* transfer size */
+	u8		cmd;		/* SCSI Op Code */
+	u8		bus;		/* bus number */
+	u8		id;		/* SCSI ID (virtual) */
+	u8		lun;
+	u8		flags;		/* Bit Field - See above */
+	u8		physDiskNum;	/* Phys disk number, -1 else */
+	u8		rsvd2;
+	u8		rsvd;
+} INTERNAL_CMD;
+
+typedef struct _negoparms {
+	u8 width;
+	u8 offset;
+	u8 factor;
+	u8 flags;
+} NEGOPARMS;
+
+typedef struct _dv_parameters {
+	NEGOPARMS	 max;
+	NEGOPARMS	 now;
+	u8		 cmd;
+	u8		 id;
+	u16		 pad1;
+} DVPARAMETERS;
+
 
 /*
  *  Other private/forward protos...
  */
-
 static int	mptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
 static void	mptscsih_report_queue_full(Scsi_Cmnd *sc, SCSIIOReply_t *pScsiReply, SCSIIORequest_t *pScsiReq);
 static int	mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
 static int	mptscsih_io_direction(Scsi_Cmnd *cmd);
+
+static int	mptscsih_AddSGE(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt,
+				 SCSIIORequest_t *pReq, int req_idx);
+static int	mptscsih_getFreeChainBuffer(MPT_SCSI_HOST *hd, int *retIndex);
+static void	mptscsih_freeChainBuffers(MPT_SCSI_HOST *hd, int req_idx);
+static int	mptscsih_initChainBuffers (MPT_SCSI_HOST *hd, int init);
+
 static void	copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply);
-static u32	SCPNT_TO_MSGCTX(Scsi_Cmnd *sc);
+#ifndef MPT_SCSI_USE_NEW_EH
+static void	search_taskQ_for_cmd(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd);
+#else
+static int	mptscsih_tm_pending_wait(MPT_SCSI_HOST * hd);
+#endif
+static u32	SCPNT_TO_LOOKUP_IDX(Scsi_Cmnd *sc);
+static MPT_FRAME_HDR *mptscsih_search_pendingQ(MPT_SCSI_HOST *hd, int scpnt_idx);
+static void	post_pendingQ_commands(MPT_SCSI_HOST *hd);
+
+static int	mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag);
+static int	mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag);
 
 static int	mptscsih_ioc_reset(MPT_ADAPTER *ioc, int post_reset);
 static int	mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);
 
+static VirtDevice	*mptscsih_initTarget(MPT_SCSI_HOST *hd, int bus_id, int target_id, u8 lun, char *data, int dlen);
+void		mptscsih_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtDevice *target, char byte56);
+static void	clear_sense_flag(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq);
+static void	mptscsih_set_dvflags(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq, char *data);
+static void	mptscsih_setDevicePage1Flags (u8 width, u8 factor, u8 offset, int *requestedPtr, int *configurationPtr, u8 flags);
+static void	mptscsih_no_negotiate(MPT_SCSI_HOST *hd, int target_id);
+static int	mptscsih_writeSDP1(MPT_SCSI_HOST *hd, int portnum, int target, int flags);
+static int	mptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
+static void	mptscsih_timer_expired(unsigned long data);
+static void	mptscsih_taskmgmt_timeout(unsigned long data);
+static int	mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *iocmd);
+static int	mptscsih_synchronize_cache(MPT_SCSI_HOST *hd, int portnum);
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+static int	mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 action, INTERNAL_CMD *io);
+static void	mptscsih_domainValidation(void *hd);
+static int	mptscsih_is_phys_disk(MPT_ADAPTER *ioc, int id);
+static void	mptscsih_qas_check(MPT_SCSI_HOST *hd);
+static void	mptscsih_doDv(MPT_SCSI_HOST *hd, int portnum, int target);
+static void	mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVPARAMETERS *dv,void *pPage);
+static void	mptscsih_fillbuf(char *buffer, int size, int index, int width);
+#endif
+static int	mptscsih_setup(char *str);
+static int	mptscsih_halt(struct notifier_block *nb, ulong event, void *buf);
+
+/*
+ *	Reboot Notification
+ */
+static struct notifier_block mptscsih_notifier = {
+	mptscsih_halt, NULL, 0
+};
+
+/*
+ *	Private data...
+ */
 
 static int	mpt_scsi_hosts = 0;
 static atomic_t	queue_depth;
 
 static int	ScsiDoneCtx = -1;
 static int	ScsiTaskCtx = -1;
+static int	ScsiScanDvCtx = -1; /* Used only for bus scan and dv */
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,28)
 static struct proc_dir_entry proc_mpt_scsihost =
@@ -141,23 +234,40 @@
 };
 #endif
 
-#define SNS_LEN(scp)  sizeof((scp)->sense_buffer)
+#define SNS_LEN(scp)	sizeof((scp)->sense_buffer)
 
 #ifndef MPT_SCSI_USE_NEW_EH
 /*
  *  Stuff to handle single-threading SCSI TaskMgmt
  *  (abort/reset) requests...
  */
-static spinlock_t mpt_scsih_taskQ_lock = SPIN_LOCK_UNLOCKED;
-static MPT_Q_TRACKER mpt_scsih_taskQ = {
-	(MPT_FRAME_HDR*) &mpt_scsih_taskQ,
-	(MPT_FRAME_HDR*) &mpt_scsih_taskQ
-};
-static int mpt_scsih_taskQ_cnt = 0;
-static int mpt_scsih_taskQ_bh_active = 0;
-static MPT_FRAME_HDR *mpt_scsih_active_taskmgmt_mf = NULL;
+static spinlock_t mytaskQ_lock = SPIN_LOCK_UNLOCKED;
+static int mytaskQ_bh_active = 0;
+static struct tq_struct	mptscsih_ptaskfoo;
+static atomic_t	mpt_taskQdepth;
+#endif
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+/*
+ * Domain Validation task structure
+ */
+static spinlock_t dvtaskQ_lock = SPIN_LOCK_UNLOCKED;
+static int dvtaskQ_active = 0;
+static int dvtaskQ_release = 0;
+static struct tq_struct	mptscsih_dvTask;
 #endif
 
+/*
+ * Wait Queue setup
+ */
+static DECLARE_WAIT_QUEUE_HEAD (scandv_waitq);
+static int scandv_wait_done = 1;
+
+/* Driver default setup
+ */
+static struct mptscsih_driver_setup
+	driver_setup = MPTSCSIH_DRIVER_SETUP;
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	mptscsih_io_done - Main SCSI IO callback routine registered to
@@ -174,123 +284,111 @@
  *	Returns 1 indicating alloc'd request frame ptr should be freed.
  */
 static int
-mptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r)
+mptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)
 {
 	Scsi_Cmnd	*sc;
 	MPT_SCSI_HOST	*hd;
-	MPT_SCSI_DEV	*mpt_sdev = NULL;
+	SCSIIORequest_t	*pScsiReq;
+	SCSIIOReply_t	*pScsiReply;
+#ifndef MPT_SCSI_USE_NEW_EH
+	unsigned long	 flags;
+#endif
 	u16		 req_idx;
 
+	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+
 	if ((mf == NULL) ||
 	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
-		printk(KERN_ERR MYNAM ": ERROR! NULL or BAD req frame ptr (=%p)!\n", mf);
-		return 1;
+		printk(MYIOC_s_ERR_FMT "%s req frame ptr! (=%p)!\n",
+				ioc->name, mf?"BAD":"NULL", (void *) mf);
+		/* return 1; CHECKME SteveR. Don't free. */
+		return 0;
 	}
 
-	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
 	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 	sc = hd->ScsiLookup[req_idx];
-	hd->ScsiLookup[req_idx] = NULL;
+	if (sc == NULL) {
+		MPIHeader_t *hdr = (MPIHeader_t *)mf;
 
-	dmfprintk((KERN_INFO MYNAM ": ScsiDone (req:sc:reply=%p:%p:%p)\n", mf, sc, r));
+		atomic_dec(&queue_depth);
 
-	atomic_dec(&queue_depth);
+		/* writeSDP1 will use the ScsiDoneCtx
+		 * There is no processing for the reply.
+		 * Just return to the calling function.
+		 */
+		if (hdr->Function == MPI_FUNCTION_SCSI_IO_REQUEST)
+			printk(MYIOC_s_ERR_FMT "NULL ScsiCmd ptr!\n", ioc->name);
 
-	/*
-	 *  Check for {1st} {IO} completion to "new" device.
-	 *  How do we know it's a new device?
-	 *  If we haven't set SDpnt->hostdata I guess...
-	 */
-	if (sc && sc->device) {
-		mpt_sdev = (MPT_SCSI_DEV*)sc->device->hostdata;
-		if (!mpt_sdev) {
-			dprintk((KERN_INFO MYNAM ": *NEW* SCSI device (%d:%d:%d)!\n",
-					   sc->device->id, sc->device->lun, sc->device->channel));
-			if ((sc->device->hostdata = kmalloc(sizeof(MPT_SCSI_DEV), GFP_ATOMIC)) == NULL) {
-				printk(KERN_ERR MYNAM ": ERROR - kmalloc(%d) FAILED!\n", (int)sizeof(MPT_SCSI_DEV));
-			} else {
-				memset(sc->device->hostdata, 0, sizeof(MPT_SCSI_DEV));
-				mpt_sdev = (MPT_SCSI_DEV *) sc->device->hostdata;
-				mpt_sdev->ioc = ioc;
-			}
-		} else {
-			if (++mpt_sdev->io_cnt && mptscsih_io_direction(sc) < 0) {
-				if (++mpt_sdev->read_cnt == 3) {
-					dprintk((KERN_INFO MYNAM ": 3rd DATA_IN, CDB[0]=%02x\n",
-							sc->cmnd[0]));
-				}
-			}
-#if 0
-			if (mpt_sdev->sense_sz) {
-				/*
-				 *  Completion of first IO down this path
-				 *  *should* invalidate device SenseData...
-				 */
-				mpt_sdev->sense_sz = 0;
-			}
-#endif
-		}
+		mptscsih_freeChainBuffers(hd, req_idx);
+		return 1;
 	}
 
-#if 0
-{
-	MPT_FRAME_HDR	*mf_chk;
+	dmfprintk((MYIOC_s_INFO_FMT "ScsiDone (mf=%p,mr=%p,sc=%p)\n",
+			ioc->name, mf, mr, sc));
 
-	/* This, I imagine, is a costly check, but...
-	 *  If abort/reset active, check to see if this is a IO
-	 *  that completed while ABORT/RESET for it is waiting
-	 *  on our taskQ!
-	 */
-	if (! Q_IS_EMPTY(&mpt_scsih_taskQ)) {
-		/* If ABORT for this IO is queued, zap it! */
-		mf_chk = search_taskQ(1,sc,MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
-		if (mf_chk != NULL) {
-			sc->result = DID_ABORT << 16;
-			spin_lock_irqsave(sc->host->host_lock, flags);
-			sc->scsi_done(sc);
-			spin_unlock_irqrestore(sc->host->host_lock, flags);
-			return 1;
-		}
-	}
-}
-#endif
+	atomic_dec(&queue_depth);
 
-	if (r != NULL && sc != NULL) {
-		SCSIIOReply_t	*pScsiReply;
-		SCSIIORequest_t *pScsiReq;
-		u16		 status;
+	sc->result = DID_OK << 16;		/* Set default reply as OK */
+	pScsiReq = (SCSIIORequest_t *) mf;
+	pScsiReply = (SCSIIOReply_t *) mr;
 
-		pScsiReply = (SCSIIOReply_t *) r;
-		pScsiReq = (SCSIIORequest_t *) mf;
+	if (pScsiReply == NULL) {
+		/* special context reply handling */
+
+		/* If regular Inquiry cmd - save inquiry data
+		 */
+		if (pScsiReq->CDB[0] == INQUIRY && !(pScsiReq->CDB[1] & 0x3)) {
+			int	 dlen;
+
+			dlen = le32_to_cpu(pScsiReq->DataLength);
+			if (dlen >= SCSI_STD_INQUIRY_BYTES) {
+				mptscsih_initTarget(hd,
+						hd->port,
+						sc->target,
+						pScsiReq->LUN[1],
+						sc->buffer,
+						dlen);
+			}
+		}
+		clear_sense_flag(hd, pScsiReq);
+
+		if (hd->is_spi)
+			mptscsih_set_dvflags(hd, pScsiReq, sc->buffer);
+	} else {
+		u32	 xfer_cnt;
+		u16	 status;
+		u8	 scsi_state;
 
 		status = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+		scsi_state = pScsiReply->SCSIState;
 
-		dprintk((KERN_NOTICE MYNAM ": Uh-Oh!  (req:sc:reply=%p:%p:%p)\n", mf, sc, r));
+		dprintk((KERN_NOTICE "  Uh-Oh! (%d:%d:%d) mf=%p, mr=%p, sc=%p\n",
+				ioc->id, pScsiReq->TargetID, pScsiReq->LUN[1],
+				mf, mr, sc));
 		dprintk((KERN_NOTICE "  IOCStatus=%04xh, SCSIState=%02xh"
-				     ", SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
-				     status, pScsiReply->SCSIState, pScsiReply->SCSIStatus,
-				     le32_to_cpu(pScsiReply->IOCLogInfo)));
+				", SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
+				status, scsi_state, pScsiReply->SCSIStatus,
+				le32_to_cpu(pScsiReply->IOCLogInfo)));
+
+		if (scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID)
+			copy_sense_data(sc, hd, mf, pScsiReply);
 
 		/*
 		 *  Look for + dump FCP ResponseInfo[]!
 		 */
-		if (pScsiReply->SCSIState & MPI_SCSI_STATE_RESPONSE_INFO_VALID) {
+		if (scsi_state & MPI_SCSI_STATE_RESPONSE_INFO_VALID) {
 			dprintk((KERN_NOTICE "  FCP_ResponseInfo=%08xh\n",
 					     le32_to_cpu(pScsiReply->ResponseInfo)));
 		}
 
 		switch(status) {
 		case MPI_IOCSTATUS_BUSY:			/* 0x0002 */
-			/*sc->result = DID_BUS_BUSY << 16;*/		/* YIKES! - Seems to
-									 * kill linux interrupt
-									 * handler
-									 */
-			sc->result = STS_BUSY;				/* Try SCSI BUSY! */
-			break;
-
-		case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:	/* 0x0040 */
-			/*  Not real sure here...  */
-			sc->result = DID_OK << 16;
+			/* CHECKME!
+			 * Maybe: DRIVER_BUSY | SUGGEST_RETRY | DID_SOFT_ERROR (retry)
+			 * But not: DID_BUS_BUSY lest one risk
+			 * killing interrupt handler:-(
+			 */
+			sc->result = STS_BUSY;
 			break;
 
 		case MPI_IOCSTATUS_SCSI_INVALID_BUS:		/* 0x0041 */
@@ -299,10 +397,37 @@
 			break;
 
 		case MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:	/* 0x0043 */
-			/*  Spoof to SCSI Selection Timeout!  */
+			/* Spoof to SCSI Selection Timeout! */
 			sc->result = DID_NO_CONNECT << 16;
 			break;
 
+		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
+#ifndef MPT_SCSI_USE_NEW_EH
+			search_taskQ_for_cmd(sc, hd);
+#endif
+			/* Linux handles an unsolicited DID_RESET better 
+			 * than an unsolicited DID_ABORT.
+			 */
+			sc->result = DID_RESET << 16;
+
+			/* GEM Workaround. */ 
+			if (hd->is_spi)
+				mptscsih_no_negotiate(hd, sc->target);
+			break;
+
+		case MPI_IOCSTATUS_SCSI_IOC_TERMINATED:		/* 0x004B */
+		case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:		/* 0x004C */
+#ifndef MPT_SCSI_USE_NEW_EH
+			search_taskQ_for_cmd(sc, hd);
+#endif
+			sc->result = DID_RESET << 16;
+
+			/* GEM Workaround. */ 
+			if (hd->is_spi)
+				mptscsih_no_negotiate(hd, sc->target);
+			break;
+
+		case MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:	/* 0x0049 */
 		case MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:		/* 0x0045 */
 			/*
 			 *  YIKES!  I just discovered that SCSI IO which
@@ -312,78 +437,148 @@
 			 *  Do upfront check for valid SenseData and give it
 			 *  precedence!
 			 */
+			sc->result = (DID_OK << 16) | pScsiReply->SCSIStatus;
+			clear_sense_flag(hd, pScsiReq);
 			if (pScsiReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
-				copy_sense_data(sc, hd, mf, pScsiReply);
-				sc->result = pScsiReply->SCSIStatus;
-				break;
+				/* Have already saved the status and sense data
+				 */
+				;
+			} else if (pScsiReply->SCSIState & (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)) {
+				/* What to do?
+				 */
+				sc->result = DID_SOFT_ERROR << 16;
+			}
+			else if (pScsiReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
+				/*  Not real sure here either...  */
+				sc->result = DID_RESET << 16;
 			}
 
-			dprintk((KERN_NOTICE MYNAM ": sc->underflow={report ERR if < %02xh bytes xfer'd}\n", sc->underflow));
-			dprintk((KERN_NOTICE MYNAM ": ActBytesXferd=%02xh\n", le32_to_cpu(pScsiReply->TransferCount)));
+			/* Give report and update residual count.
+			 */
+			xfer_cnt = le32_to_cpu(pScsiReply->TransferCount);
+			dprintk((KERN_NOTICE "  sc->underflow={report ERR if < %02xh bytes xfer'd}\n",
+					sc->underflow));
+			dprintk((KERN_NOTICE "  ActBytesXferd=%02xh\n", xfer_cnt));
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-			sc->resid = sc->request_bufflen - le32_to_cpu(pScsiReply->TransferCount);
-			dprintk((KERN_NOTICE MYNAM ": SET sc->resid=%02xh\n", sc->resid));
+			sc->resid = sc->request_bufflen - xfer_cnt;
+			dprintk((KERN_NOTICE "  SET sc->resid=%02xh\n", sc->resid));
 #endif
 
-			if (pScsiReq->CDB[0] == INQUIRY) {
-				sc->result = (DID_OK << 16);
-				break;
-			}
+			/* Report Queue Full
+			 */
+			if (sc->result == MPI_SCSI_STATUS_TASK_SET_FULL)
+				mptscsih_report_queue_full(sc, pScsiReply, pScsiReq);
 
-			/* workaround attempts... */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-			if (sc->resid >= 0x200) {
-				/* GRRRRR...
-				 *   //sc->result = DID_SOFT_ERROR << 16;
-				 * Try spoofing to BUSY
-				 */
-				sc->result = STS_BUSY;
-			} else {
-				sc->result = 0;
+			/* If regular Inquiry cmd and some data was transferred,
+			 * save inquiry data
+			 */
+			if (    pScsiReq->CDB[0] == INQUIRY
+			     && !(pScsiReq->CDB[1] & 0x3)
+			     && xfer_cnt >= SCSI_STD_INQUIRY_BYTES
+			   ) {
+				mptscsih_initTarget(hd,
+						hd->port,
+						sc->target,
+						pScsiReq->LUN[1],
+						sc->buffer,
+						xfer_cnt);
 			}
-#else
-			sc->result = 0;
-#endif
-			break;
 
-		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
-			sc->result = DID_ABORT << 16;
-			break;
-
-		case MPI_IOCSTATUS_SCSI_IOC_TERMINATED:		/* 0x004B */
-		case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:		/* 0x004C */
-			sc->result = DID_RESET << 16;
+			if (hd->is_spi)
+				mptscsih_set_dvflags(hd, pScsiReq, sc->buffer);
 			break;
 
+		case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:	/* 0x0040 */
 		case MPI_IOCSTATUS_SUCCESS:			/* 0x0000 */
-			sc->result = pScsiReply->SCSIStatus;
+			sc->result = (DID_OK << 16) | pScsiReply->SCSIStatus;
+			clear_sense_flag(hd, pScsiReq);
 
 			if (pScsiReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
-				copy_sense_data(sc, hd, mf, pScsiReply);
-
-				/*  If running agains circa 200003dd 909 MPT f/w,
-				 *  may get this (AUTOSENSE_VALID) for actual TASK_SET_FULL
-				 *  (QUEUE_FULL) returned from device!	--> get 0x0000?128
-				 *  and with SenseBytes set to 0.
+				/*
+				 * If running agains circa 200003dd 909 MPT f/w,
+				 * may get this (AUTOSENSE_VALID) for actual TASK_SET_FULL
+				 * (QUEUE_FULL) returned from device! --> get 0x0000?128
+				 * and with SenseBytes set to 0.
 				 */
 				if (pScsiReply->SCSIStatus == MPI_SCSI_STATUS_TASK_SET_FULL)
 					mptscsih_report_queue_full(sc, pScsiReply, pScsiReq);
+
+#ifndef MPT_SCSI_USE_NEW_EH
+				/* ADDED 20011120 -sralston
+				 * Scsi mid-layer (old_eh) doesn't seem to like it
+				 * when RAID returns SCSIStatus=02 (CHECK CONDITION),
+				 * SenseKey=01 (RECOVERED ERROR), ASC/ASCQ=95/01.
+				 * Seems to be * treating this as a IO error:-(
+				 *
+				 * So just lie about it altogether here.
+				 *
+				 * NOTE: It still gets reported to syslog via
+				 * mpt_ScsiHost_ErrorReport from copy_sense_data
+				 * call far above.
+				 */
+				if (    pScsiReply->SCSIStatus == STS_CHECK_CONDITION
+				     && SD_Sense_Key(sc->sense_buffer) == SK_RECOVERED_ERROR
+				   ) {
+					sc->result = 0;
+				}
+#endif
+
 			}
-			else if (pScsiReply->SCSIState & (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)) {
+			else if (pScsiReply->SCSIState &
+			         (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)
+			   ) {
 				/*
-				 *  What to do?
+				 * What to do?
 				 */
 				sc->result = DID_SOFT_ERROR << 16;
 			}
 			else if (pScsiReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
 				/*  Not real sure here either...  */
-				sc->result = DID_ABORT << 16;
+				sc->result = DID_RESET << 16;
+			}
+			else if (pScsiReply->SCSIState & MPI_SCSI_STATE_QUEUE_TAG_REJECTED) {
+				/* Device Inq. data indicates that it supports
+				 * QTags, but rejects QTag messages.
+				 * This command completed OK.
+				 *
+				 * Not real sure here either so do nothing...  */
 			}
 
 			if (sc->result == MPI_SCSI_STATUS_TASK_SET_FULL)
 				mptscsih_report_queue_full(sc, pScsiReply, pScsiReq);
 
+			/* Add handling of:
+			 * Reservation Conflict, Busy,
+			 * Command Terminated, CHECK
+			 */
+
+			/* If regular Inquiry cmd - save inquiry data
+			 */
+			xfer_cnt = le32_to_cpu(pScsiReply->TransferCount);
+			if (    sc->result == (DID_OK << 16)
+			     && pScsiReq->CDB[0] == INQUIRY
+			     && !(pScsiReq->CDB[1] & 0x3)
+			     && xfer_cnt >= SCSI_STD_INQUIRY_BYTES
+			   ) {
+				mptscsih_initTarget(hd,
+						hd->port,
+						sc->target,
+						pScsiReq->LUN[1],
+						sc->buffer,
+						xfer_cnt);
+			}
+
+			if (hd->is_spi)
+				mptscsih_set_dvflags(hd, pScsiReq, sc->buffer);
+			break;
+
+		case MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:		/* 0x0047 */
+			if (pScsiReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
+				/*  Not real sure here either...  */
+				sc->result = DID_RESET << 16;
+			} else
+				sc->result = DID_SOFT_ERROR << 16;
 			break;
 
 		case MPI_IOCSTATUS_INVALID_FUNCTION:		/* 0x0001 */
@@ -395,50 +590,50 @@
 		case MPI_IOCSTATUS_INVALID_STATE:		/* 0x0008 */
 		case MPI_IOCSTATUS_SCSI_DATA_OVERRUN:		/* 0x0044 */
 		case MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:		/* 0x0046 */
-		case MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:		/* 0x0047 */
-		case MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:	/* 0x0049 */
 		case MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:	/* 0x004A */
 		default:
 			/*
-			 *  What to do?
+			 * What to do?
 			 */
 			sc->result = DID_SOFT_ERROR << 16;
 			break;
 
 		}	/* switch(status) */
 
-		dprintk((KERN_NOTICE MYNAM ": sc->result set to %08xh\n", sc->result));
+		dprintk((KERN_NOTICE "  sc->result set to %08xh\n", sc->result));
+	} /* end of address reply case */
+
+	/* Unmap the DMA buffers, if any. */
+	if (sc->use_sg) {
+		pci_unmap_sg(ioc->pcidev, (struct scatterlist *) sc->request_buffer,
+			    sc->use_sg, scsi_to_pci_dma_dir(sc->sc_data_direction));
+	} else if (sc->request_bufflen) {
+		scPrivate	*my_priv;
+
+		my_priv = (scPrivate *) &sc->SCp;
+		pci_unmap_single(ioc->pcidev, (dma_addr_t)(ulong)my_priv->p1,
+			   sc->request_bufflen,
+			   scsi_to_pci_dma_dir(sc->sc_data_direction));
 	}
 
-	if (sc != NULL) {
-		unsigned long flags;
+	hd->ScsiLookup[req_idx] = NULL;
+
+	sc->host_scribble = NULL;	/* CHECKME! - Do we need to clear this??? */
 
-		/* Unmap the DMA buffers, if any. */
-		if (sc->use_sg) {
-			pci_unmap_sg(ioc->pcidev,
-				     (struct scatterlist *) sc->request_buffer,
-				     sc->use_sg,
-				     scsi_to_pci_dma_dir(sc->sc_data_direction));
-		} else if (sc->request_bufflen) {
-			pci_unmap_single(ioc->pcidev,
-					 (dma_addr_t)((long)sc->SCp.ptr),
-					 sc->request_bufflen,
-					 scsi_to_pci_dma_dir(sc->sc_data_direction));
-		}
-
-		spin_lock_irqsave(sc->host->host_lock, flags);
-		sc->scsi_done(sc);
-		spin_unlock_irqrestore(sc->host->host_lock, flags);
-	}
+        MPT_HOST_LOCK(flags);
+	sc->scsi_done(sc);		/* Issue the command callback */
+        MPT_HOST_UNLOCK(flags);
 
+	/* Free Chain buffers */
+	mptscsih_freeChainBuffers(hd, req_idx);
 	return 1;
 }
 
-#ifndef MPT_SCSI_USE_NEW_EH
+#ifndef MPT_SCSI_USE_NEW_EH	/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	search_taskQ - Search SCSI task mgmt request queue for specific
- *			request type
+ *	request type.
  *	@remove: (Boolean) Should request be removed if found?
  *	@sc: Pointer to Scsi_Cmnd structure
  *	@task_type: Task type to search for
@@ -447,42 +642,55 @@
  *	was not found.
  */
 static MPT_FRAME_HDR *
-search_taskQ(int remove, Scsi_Cmnd *sc, u8 task_type)
+search_taskQ(int remove, Scsi_Cmnd *sc, MPT_SCSI_HOST *hd, u8 task_type)
 {
 	MPT_FRAME_HDR *mf = NULL;
 	unsigned long flags;
 	int count = 0;
 	int list_sz;
 
-	dslprintk((KERN_INFO MYNAM ": spinlock#1\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	list_sz = mpt_scsih_taskQ_cnt;
-	if (! Q_IS_EMPTY(&mpt_scsih_taskQ)) {
-		mf = mpt_scsih_taskQ.head;
+	dprintk((KERN_INFO MYNAM ": search_taskQ(%d,sc=%p,%d) called\n",
+			remove, sc, task_type));
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	list_sz = hd->taskQcnt;
+	if (! Q_IS_EMPTY(&hd->taskQ)) {
+		mf = hd->taskQ.head;
 		do {
 			count++;
 			if (mf->u.frame.linkage.argp1 == sc &&
 			    mf->u.frame.linkage.arg1 == task_type) {
 				if (remove) {
 					Q_DEL_ITEM(&mf->u.frame.linkage);
-					mpt_scsih_taskQ_cnt--;
+					hd->taskQcnt--;
+					atomic_dec(&mpt_taskQdepth);
+
+					/* Don't save mf into nextmf because
+					 * exit after command has been deleted.
+					 */
+
+					/* Place the MF back on the FreeQ */
+					Q_ADD_TAIL(&hd->ioc->FreeQ,
+						&mf->u.frame.linkage,
+						MPT_FRAME_HDR);
+#ifdef MFCNT
+					hd->ioc->mfcnt--;
+#endif
 				}
 				break;
 			}
-		} while ((mf = mf->u.frame.linkage.forw) != (MPT_FRAME_HDR*)&mpt_scsih_taskQ);
-		if (mf == (MPT_FRAME_HDR*)&mpt_scsih_taskQ) {
+		} while ((mf = mf->u.frame.linkage.forw) != (MPT_FRAME_HDR*)&hd->taskQ);
+		if (mf == (MPT_FRAME_HDR*)&hd->taskQ) {
 			mf = NULL;
 		}
 	}
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
 	if (list_sz) {
-		dprintk((KERN_INFO MYNAM ": search_taskQ(%d,%p,%d) results=%p (%sFOUND%s)!\n",
-				   remove, sc, task_type,
+		dprintk((KERN_INFO "  Results=%p (%sFOUND%s)!\n",
 				   mf,
 				   mf ? "" : "NOT_",
 				   (mf && remove) ? "+REMOVED" : "" ));
-		dprintk((KERN_INFO MYNAM ": (searched thru %d of %d items on taskQ)\n",
+		dprintk((KERN_INFO "  (searched thru %d of %d items on taskQ)\n",
 				   count,
 				   list_sz ));
 	}
@@ -490,12 +698,340 @@
 	return mf;
 }
 
+/*
+ *	clean_taskQ - Clean the  SCSI task mgmt request for
+ *			this SCSI host instance.
+ *	@hd: MPT_SCSI_HOST pointer
+ *
+ *	Returns: None.
+ */
+static void
+clean_taskQ(MPT_SCSI_HOST *hd)
+{
+	MPT_FRAME_HDR *mf = NULL;
+	MPT_FRAME_HDR *nextmf = NULL;
+	MPT_ADAPTER *ioc = hd->ioc;
+	unsigned long flags;
+
+	dprintk((KERN_INFO MYNAM ": clean_taskQ called\n"));
+
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	if (! Q_IS_EMPTY(&hd->taskQ)) {
+		mf = hd->taskQ.head;
+		do {
+			Q_DEL_ITEM(&mf->u.frame.linkage);
+			hd->taskQcnt--;
+			atomic_dec(&mpt_taskQdepth);
+
+			nextmf = mf->u.frame.linkage.forw;
+
+			/* Place the MF back on the FreeQ */
+			Q_ADD_TAIL(&ioc->FreeQ, &mf->u.frame.linkage,
+				MPT_FRAME_HDR);
+#ifdef MFCNT
+			hd->ioc->mfcnt--;
+#endif
+		} while ((mf = nextmf) != (MPT_FRAME_HDR*)&hd->taskQ);
+	}
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+	return;
+}
+
+/*
+ *	search_taskQ_for_cmd - Search the  SCSI task mgmt request queue for
+ *			the specified command. If found, delete
+ *	@hd: MPT_SCSI_HOST pointer
+ *
+ *	Returns: None.
+ */
+static void
+search_taskQ_for_cmd(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd)
+{
+	MPT_FRAME_HDR *mf = NULL;
+	unsigned long flags;
+	int count = 0;
+
+	dprintk((KERN_INFO MYNAM ": search_taskQ_for_cmd(sc=%p) called\n", sc));
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	if (! Q_IS_EMPTY(&hd->taskQ)) {
+		mf = hd->taskQ.head;
+		do {
+			count++;
+			if (mf->u.frame.linkage.argp1 == sc) {
+				Q_DEL_ITEM(&mf->u.frame.linkage);
+				hd->taskQcnt--;
+				atomic_dec(&mpt_taskQdepth);
+				dprintk((KERN_INFO MYNAM
+					": Cmd %p found! Deleting.\n", sc));
+
+				/* Don't save mf into nextmf because
+				 * exit after command has been deleted.
+				 */
+
+				/* Place the MF back on the FreeQ */
+				Q_ADD_TAIL(&hd->ioc->FreeQ,
+					&mf->u.frame.linkage,
+					MPT_FRAME_HDR);
+#ifdef MFCNT
+				hd->ioc->mfcnt--;
 #endif
+				break;
+			}
+		} while ((mf = mf->u.frame.linkage.forw) != (MPT_FRAME_HDR*)&hd->taskQ);
+	}
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	return;
+}
+
+#endif		/* } MPT_SCSI_USE_NEW_EH */
+
+
+/*
+ * Flush all commands on the doneQ.
+ * Lock Q when deleting/adding members
+ * Lock io_request_lock for OS callback.
+ */
+static void
+flush_doneQ(MPT_SCSI_HOST *hd)
+{
+	MPT_DONE_Q	*buffer;
+	Scsi_Cmnd	*SCpnt;
+	unsigned long	 flags;
+
+	/* Flush the doneQ.
+	 */
+	dprintk((KERN_INFO MYNAM ": flush_doneQ called\n"));
+	while (1) {
+		spin_lock_irqsave(&hd->freedoneQlock, flags);
+		if (Q_IS_EMPTY(&hd->doneQ)) {
+			spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			break;
+		}
+
+		buffer = hd->doneQ.head;
+		/* Delete from Q
+		 */
+		Q_DEL_ITEM(buffer);
+
+		/* Set the Scsi_Cmnd pointer
+		 */
+		SCpnt = (Scsi_Cmnd *) buffer->argp;
+		buffer->argp = NULL;
+
+		/* Add to the freeQ
+		 */
+		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+
+		/* Do the OS callback.
+		 */
+                MPT_HOST_LOCK(flags);
+		SCpnt->scsi_done(SCpnt);
+                MPT_HOST_UNLOCK(flags);
+	}
+
+	return;
+}
+
+/*
+ * Search the doneQ for a specific command. If found, delete from Q.
+ * Calling function will finish processing.
+ */
+static void
+search_doneQ_for_cmd(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt)
+{
+	unsigned long	 flags;
+	MPT_DONE_Q	*buffer;
+
+	spin_lock_irqsave(&hd->freedoneQlock, flags);
+	if (!Q_IS_EMPTY(&hd->doneQ)) {
+		buffer = hd->doneQ.head;
+		do {
+			Scsi_Cmnd *sc = (Scsi_Cmnd *) buffer->argp;
+			if (SCpnt == sc) {
+				Q_DEL_ITEM(buffer);
+				SCpnt->result = sc->result;
+
+				/* Set the Scsi_Cmnd pointer
+				 */
+				buffer->argp = NULL;
+
+				/* Add to the freeQ
+				 */
+				Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+				break;
+			}
+		} while ((buffer = buffer->forw) != (MPT_DONE_Q *) &hd->doneQ);
+	}
+	spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+	return;
+}
+
+/*
+ *	mptscsih_flush_running_cmds - For each command found, search
+ *		Scsi_Host instance taskQ and reply to OS.
+ *		Called only if recovering from a FW reload.
+ *	@hd: Pointer to a SCSI HOST structure
+ *
+ *	Returns: None.
+ *
+ *	Must be called while new I/Os are being queued.
+ */
+static void
+mptscsih_flush_running_cmds(MPT_SCSI_HOST *hd)
+{
+	Scsi_Cmnd	*SCpnt = NULL;
+	MPT_FRAME_HDR	*mf = NULL;
+	int		 ii;
+	int		 max = hd->ioc->req_depth;
+
+#ifndef MPT_SCSI_USE_NEW_EH
+	unsigned long	 flags;
+#endif
+
+	dprintk((KERN_INFO MYNAM ": flush_ScsiLookup called\n"));
+	for (ii= 0; ii < max; ii++) {
+		if ((SCpnt = hd->ScsiLookup[ii]) != NULL) {
+
+			/* Command found.
+			 */
+
+#ifndef MPT_SCSI_USE_NEW_EH
+			/* Search taskQ, if found, delete.
+			 */
+			search_taskQ_for_cmd(SCpnt, hd);
+#endif
+
+			/* Search pendingQ, if found, 
+			 * delete from Q. If found, do not decrement
+			 * queue_depth, command never posted.
+			 */
+			if (mptscsih_search_pendingQ(hd, ii) == NULL)
+				atomic_dec(&queue_depth);
+
+			/* Null ScsiLookup index
+			 */
+			hd->ScsiLookup[ii] = NULL;
+
+			mf = MPT_INDEX_2_MFPTR(hd->ioc, ii);
+			dmfprintk(( "flush: ScsiDone (mf=%p,sc=%p)\n",
+					mf, SCpnt));
+
+			/* Set status
+			 * Do OS callback
+			 * Free chain buffers
+			 * Free message frame
+			 */
+			SCpnt->result = DID_RESET << 16;
+			SCpnt->host_scribble = NULL;
+                        MPT_HOST_LOCK(flags);
+			SCpnt->scsi_done(SCpnt);	/* Issue the command callback */
+                        MPT_HOST_UNLOCK(flags);
+
+			/* Free Chain buffers */
+			mptscsih_freeChainBuffers(hd, ii);
+
+			/* Free Message frames */
+			mpt_free_msg_frame(ScsiDoneCtx, hd->ioc->id, mf);
+		}
+	}
+	return;
+}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_initChainBuffers - Allocate memory for and initialize
+ *	chain buffers, chain buffer control arrays and spinlock.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@init: If set, initialize the spin lock.
+ */
+static int
+mptscsih_initChainBuffers (MPT_SCSI_HOST *hd, int init)
+{
+	MPT_FRAME_HDR	*chain;
+	u8		*mem;
+	unsigned long	flags;
+	int		sz, ii, numChain;
+
+
+        /* Chain buffer allocations
+	 * Allocate and initialize tracker structures
+	 */
+	if (hd->ioc->req_sz <= 64)
+		numChain = MPT_SG_REQ_64_SCALE * hd->ioc->req_depth;
+	else if (hd->ioc->req_sz <= 96)
+		numChain = MPT_SG_REQ_96_SCALE * hd->ioc->req_depth;
+	else
+		numChain = MPT_SG_REQ_128_SCALE * hd->ioc->req_depth;
+
+	sz = numChain * sizeof(int);
+
+	if (hd->ReqToChain == NULL) {
+		mem = kmalloc(sz, GFP_ATOMIC);
+		if (mem == NULL)
+			return -1;
+
+		hd->ReqToChain = (int *) mem;
+	} else {
+		mem = (u8 *) hd->ReqToChain;
+	}
+	memset(mem, 0xFF, sz);
+
+	if (hd->ChainToChain == NULL) {
+		mem = kmalloc(sz, GFP_ATOMIC);
+		if (mem == NULL)
+			return -1;
+
+		hd->ChainToChain = (int *) mem;
+	} else {
+		mem = (u8 *) hd->ChainToChain;
+	}
+	memset(mem, 0xFF, sz);
+
+	if (hd->ChainBuffer == NULL) {
+		/* Allocate free chain buffer pool
+		 */
+		sz = numChain * hd->ioc->req_sz;
+		mem = pci_alloc_consistent(hd->ioc->pcidev, sz, &hd->ChainBufferDMA);
+		if (mem == NULL)
+			return -1;
+
+		hd->ChainBuffer = (u8*)mem;
+	} else {
+		mem = (u8 *) hd->ChainBuffer;
+	}
+	memset(mem, 0, sz);
+
+	dprintk((KERN_INFO "  ChainBuffer    @ %p(%p), sz=%d\n",
+		 hd->ChainBuffer, (void *)(ulong)hd->ChainBufferDMA, sz));
+
+	/* Initialize the free chain Q.
+	 */
+	if (init) {
+		spin_lock_init(&hd->FreeChainQlock);
+	}
+
+	spin_lock_irqsave (&hd->FreeChainQlock, flags);
+	Q_INIT(&hd->FreeChainQ, MPT_FRAME_HDR);
+
+	/* Post the chain buffers to the FreeChainQ.
+	 */
+	mem = (u8 *)hd->ChainBuffer;
+	for (ii=0; ii < numChain; ii++) {
+		chain = (MPT_FRAME_HDR *) mem;
+		Q_ADD_TAIL(&hd->FreeChainQ.head, &chain->u.frame.linkage, MPT_FRAME_HDR);
+		mem += hd->ioc->req_sz;
+	}
+	spin_unlock_irqrestore(&hd->FreeChainQlock, flags);
 
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *  Hack!  I'd like to report if a device is returning QUEUE_FULL
+ *  Hack! It might be nice to report if a device is returning QUEUE_FULL
  *  but maybe not each and every time...
  */
 static long last_queue_full = 0;
@@ -518,8 +1054,12 @@
 	long time = jiffies;
 
 	if (time - last_queue_full > 10 * HZ) {
-		printk(KERN_WARNING MYNAM ": Device reported QUEUE_FULL!  SCSI bus:target:lun = %d:%d:%d\n",
-				0, sc->target, sc->lun);
+		char *ioc_str = "ioc?";
+
+		if (sc->host != NULL && sc->host->hostdata != NULL)
+			ioc_str = ((MPT_SCSI_HOST *)sc->host->hostdata)->ioc->name;
+		printk(MYIOC_s_WARN_FMT "Device (%d:%d:%d) reported QUEUE_FULL!\n",
+				ioc_str, 0, sc->target, sc->lun);
 		last_queue_full = time;
 	}
 }
@@ -527,7 +1067,7 @@
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static int BeenHereDoneThat = 0;
 
-/*  SCSI fops start here...  */
+/*  SCSI host fops start here...  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptscsih_detect - Register MPT adapter(s) as SCSI host(s) with
@@ -546,25 +1086,22 @@
 	struct Scsi_Host	*sh = NULL;
 	MPT_SCSI_HOST		*hd = NULL;
 	MPT_ADAPTER		*this;
+	MPT_DONE_Q		*freedoneQ;
 	unsigned long		 flags;
-	int			 sz;
+	int			 sz, ii;
+	int			 numSGE = 0;
+	int			 scale;
 	u8			*mem;
 
 	if (! BeenHereDoneThat++) {
 		show_mptmod_ver(my_NAME, my_VERSION);
 
-		if ((ScsiDoneCtx = mpt_register(mptscsih_io_done, MPTSCSIH_DRIVER)) <= 0) {
-			printk(KERN_ERR MYNAM ": Failed to register callback1 with MPT base driver\n");
-			return mpt_scsi_hosts;
-		}
-		if ((ScsiTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSCSIH_DRIVER)) <= 0) {
-			printk(KERN_ERR MYNAM ": Failed to register callback2 with MPT base driver\n");
-			return mpt_scsi_hosts;
-		}
+		ScsiDoneCtx = mpt_register(mptscsih_io_done, MPTSCSIH_DRIVER);
+		ScsiTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSCSIH_DRIVER);
+		ScsiScanDvCtx = mpt_register(mptscsih_scandv_complete, MPTSCSIH_DRIVER);
 
 #ifndef MPT_SCSI_USE_NEW_EH
-		Q_INIT(&mpt_scsih_taskQ, MPT_FRAME_HDR);
-		spin_lock_init(&mpt_scsih_taskQ_lock);
+		spin_lock_init(&mytaskQ_lock);
 #endif
 
 		if (mpt_event_register(ScsiDoneCtx, mptscsih_event_process) == 0) {
@@ -579,106 +1116,270 @@
 			/* FIXME! */
 		}
 	}
-
 	dprintk((KERN_INFO MYNAM ": mpt_scsih_detect()\n"));
 
+#ifdef MODULE
+	/* Evaluate the command line arguments, if any */
+	if (mptscsih)
+		mptscsih_setup(mptscsih);
+#endif
+#ifndef MPT_SCSI_USE_NEW_EH
+	atomic_set(&mpt_taskQdepth, 0);
+#endif
+
 	this = mpt_adapter_find_first();
 	while (this != NULL) {
-		/* FIXME!  Multi-port (aka FC929) support...
-		 * for (i = 0; i < this->facts.NumberOfPorts; i++)
-		 */
+		int	 portnum;
+		for (portnum=0; portnum < this->facts.NumberOfPorts; portnum++) {
 
-		/* 20010215 -sralston
-		 *  Added sanity check on SCSI Initiator-mode enabled
-		 *  for this MPT adapter.
-		 */
-		if (!(this->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_INITIATOR)) {
-			printk(KERN_ERR MYNAM ": Skipping %s because SCSI Initiator mode is NOT enabled!\n",
-					this->name);
-			this = mpt_adapter_find_next(this);
-			continue;
-		}
+			/* 20010215 -sralston
+			 *  Added sanity check on SCSI Initiator-mode enabled
+			 *  for this MPT adapter.
+			 */
+			if (!(this->pfacts[portnum].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_INITIATOR)) {
+				printk(MYIOC_s_WARN_FMT "Skipping because SCSI Initiator mode is NOT enabled!\n",
+						this->name);
+				continue;
+			}
 
-		/* 20010202 -sralston
-		 *  Added sanity check on readiness of the MPT adapter.
-		 */
-		if (this->last_state != MPI_IOC_STATE_OPERATIONAL) {
-			printk(KERN_ERR MYNAM ": ERROR - Skipping %s because it's not operational!\n",
-					this->name);
-			this = mpt_adapter_find_next(this);
-			continue;
-		}
+			/* 20010202 -sralston
+			 *  Added sanity check on readiness of the MPT adapter.
+			 */
+			if (this->last_state != MPI_IOC_STATE_OPERATIONAL) {
+				printk(MYIOC_s_WARN_FMT "Skipping because it's not operational!\n",
+						this->name);
+				continue;
+			}
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-		tpnt->proc_dir = &proc_mpt_scsihost;
+			tpnt->proc_dir = &proc_mpt_scsihost;
 #endif
-		sh = scsi_register(tpnt, sizeof(MPT_SCSI_HOST));
-		if (sh != NULL) {
-			save_flags(flags);
-			cli();
-			sh->io_port = 0;
-			sh->n_io_port = 0;
-			sh->irq = 0;
-
-			/* Yikes!  This is important!
-			 * Otherwise, by default, linux only scans target IDs 0-7!
-			 *
-			 * BUG FIX!  20010618 -sralston & pdelaney
-			 * FC919 testing was encountering "duplicate" FC devices,
-			 * as it turns out because the 919 was returning 512
-			 * for PortFacts.MaxDevices, causing a wraparound effect
-			 * in SCSI IO requests.  So instead of using:
-			 *     sh->max_id = this->pfacts[0].MaxDevices - 1
-			 * we'll use a definitive max here.
-			 */
-			sh->max_id = MPT_MAX_FC_DEVICES;
-
-			sh->this_id = this->pfacts[0].PortSCSIID;
-
-			restore_flags(flags);
-
-			hd = (MPT_SCSI_HOST *) sh->hostdata;
-			hd->ioc = this;
-			hd->port = 0;		/* FIXME! */
-
-			/* SCSI needs Scsi_Cmnd lookup table!
-			 * (with size equal to req_depth*PtrSz!)
-			 */
-			sz = hd->ioc->req_depth * sizeof(void *);
-			mem = kmalloc(sz, GFP_KERNEL);
-			if (mem == NULL)
-				return mpt_scsi_hosts;
-
-			memset(mem, 0, sz);
-			hd->ScsiLookup = (struct scsi_cmnd **) mem;
-
-			dprintk((KERN_INFO MYNAM ": ScsiLookup @ %p, sz=%d\n",
-				 hd->ScsiLookup, sz));
-
-			/* SCSI also needs SG buckets/hunk management!
-			 * (with size equal to N * req_sz * req_depth!)
-			 * (where N is number of SG buckets per hunk)
-			 */
-			sz = MPT_SG_BUCKETS_PER_HUNK * hd->ioc->req_sz * hd->ioc->req_depth;
-			mem = pci_alloc_consistent(hd->ioc->pcidev, sz,
-						   &hd->SgHunksDMA);
-			if (mem == NULL)
-				return mpt_scsi_hosts;
+			sh = scsi_register(tpnt, sizeof(MPT_SCSI_HOST));
+			if (sh != NULL) {
+				save_flags(flags);
+				cli();
+				sh->io_port = 0;
+				sh->n_io_port = 0;
+				sh->irq = 0;
+
+				/* Yikes!  This is important!
+				 * Otherwise, by default, linux
+				 * only scans target IDs 0-7!
+				 * pfactsN->MaxDevices unreliable
+				 * (not supported in early
+				 *	versions of the FW).
+				 * max_id = 1 + actual max id,
+				 * max_lun = 1 + actual last lun,
+				 *	see hosts.h :o(
+				 */
+				if ((int)this->chip_type > (int)FC929)
+					sh->max_id = MPT_MAX_SCSI_DEVICES;
+				else {
+					/* For FC, increase the queue depth
+					 * from MPT_SCSI_CAN_QUEUE (31)
+					 * to MPT_FC_CAN_QUEUE (63).
+					 */
+					sh->can_queue = MPT_FC_CAN_QUEUE;
+					sh->max_id = MPT_MAX_FC_DEVICES<256 ? MPT_MAX_FC_DEVICES : 255;
+				}
+				sh->max_lun = MPT_LAST_LUN + 1;
 
-			memset(mem, 0, sz);
-			hd->SgHunks = (u8*)mem;
+				sh->this_id = this->pfacts[portnum].PortSCSIID;
 
-			dprintk((KERN_INFO MYNAM ": SgHunks    @ %p(%08x), sz=%d\n",
-				 hd->SgHunks, hd->SgHunksDMA, sz));
+				/* OS entry to allow host drivers to force
+				 * a queue depth on a per device basis.
+				 */
+				sh->select_queue_depths = mptscsih_select_queue_depths;
 
-			hd->qtag_tick = jiffies;
+				/* Verify that we won't exceed the maximum
+				 * number of chain buffers
+				 * We can optimize:  ZZ = req_sz/sizeof(SGE)
+				 * For 32bit SGE's:
+				 *  numSGE = 1 + (ZZ-1)*(maxChain -1) + ZZ
+				 *               + (req_sz - 64)/sizeof(SGE)
+				 * A slightly different algorithm is required for
+				 * 64bit SGEs.
+				 */
+				scale = this->req_sz/(sizeof(dma_addr_t) + sizeof(u32));
+				if (sizeof(dma_addr_t) == sizeof(u64)) {
+					numSGE = (scale - 1) * (this->facts.MaxChainDepth-1) + scale +
+						(this->req_sz - 60) / (sizeof(dma_addr_t) + sizeof(u32));
+				} else {
+					numSGE = 1 + (scale - 1) * (this->facts.MaxChainDepth-1) + scale +
+						(this->req_sz - 64) / (sizeof(dma_addr_t) + sizeof(u32));
+				} 
+
+				if (numSGE < sh->sg_tablesize) {
+					/* Reset this value */
+					dprintk((MYIOC_s_INFO_FMT
+						 "Resetting sg_tablesize to %d from %d\n",
+						 this->name, numSGE, sh->sg_tablesize));
+					sh->sg_tablesize = numSGE;
+				}
+
+				/* Set the pci device pointer in Scsi_Host structure.
+				 */
+				scsi_set_pci_device(sh, this->pcidev);
+
+				restore_flags(flags);
+
+				hd = (MPT_SCSI_HOST *) sh->hostdata;
+				hd->ioc = this;
+
+				if ((int)this->chip_type > (int)FC929)
+					hd->is_spi = 1;
+
+				if (DmpService &&
+				    (this->chip_type == FC919 || this->chip_type == FC929))
+					hd->is_multipath = 1;
+
+				hd->port = 0;		/* FIXME! */
+
+				/* SCSI needs Scsi_Cmnd lookup table!
+				 * (with size equal to req_depth*PtrSz!)
+				 */
+				sz = hd->ioc->req_depth * sizeof(void *);
+				mem = kmalloc(sz, GFP_ATOMIC);
+				if (mem == NULL)
+					goto done;
+
+				memset(mem, 0, sz);
+				hd->ScsiLookup = (struct scsi_cmnd **) mem;
+
+				dprintk((MYIOC_s_INFO_FMT "ScsiLookup @ %p, sz=%d\n",
+					 this->name, hd->ScsiLookup, sz));
+
+				if (mptscsih_initChainBuffers(hd, 1) < 0)
+					goto done;
+
+				/* Allocate memory for free and doneQ's
+				 */
+				sz = sh->can_queue * sizeof(MPT_DONE_Q);
+				mem = kmalloc(sz, GFP_ATOMIC);
+				if (mem == NULL)
+					goto done;
+
+				memset(mem, 0xFF, sz);
+				hd->memQ = mem;
+
+				/* Initialize the free, done and pending Qs.
+				 */
+				Q_INIT(&hd->freeQ, MPT_DONE_Q);
+				Q_INIT(&hd->doneQ, MPT_DONE_Q);
+				Q_INIT(&hd->pendingQ, MPT_DONE_Q);
+				spin_lock_init(&hd->freedoneQlock);
+
+				mem = hd->memQ;
+				for (ii=0; ii < sh->can_queue; ii++) {
+					freedoneQ = (MPT_DONE_Q *) mem;
+					Q_ADD_TAIL(&hd->freeQ.head, freedoneQ, MPT_DONE_Q);
+					mem += sizeof(MPT_DONE_Q);
+				}
+
+				/* Initialize this Scsi_Host
+				 * internal task Q.
+				 */
+				Q_INIT(&hd->taskQ, MPT_FRAME_HDR);
+				hd->taskQcnt = 0;
+
+				/* Allocate memory for the device structures.
+				 * A non-Null pointer at an offset
+				 * indicates a device exists.
+				 * max_id = 1 + maximum id (hosts.h)
+				 */
+				sz = sh->max_id * sizeof(void *);
+				mem = kmalloc(sz, GFP_ATOMIC);
+				if (mem == NULL)
+					goto done;
+
+				memset(mem, 0, sz);
+				hd->Targets = (VirtDevice **) mem;
+
+				dprintk((KERN_INFO "  Targets @ %p, sz=%d\n", hd->Targets, sz));
+
+
+				/* Clear the TM flags
+				 */
+				hd->tmPending = 0;
+#ifdef MPT_SCSI_USE_NEW_EH
+				hd->tmState = TM_STATE_NONE;
+#endif
+				hd->resetPending = 0;
+				hd->abortSCpnt = NULL;
+				hd->tmPtr = NULL;
+				hd->numTMrequests = 0;
+
+				/* Clear the pointer used to store
+				 * single-threaded commands, i.e., those
+				 * issued during a bus scan, dv and
+				 * configuration pages.
+				 */
+				hd->cmdPtr = NULL;
+
+				/* Attach the SCSI Host to the IOC structure
+				 */
+				this->sh = sh;
+
+				/* Initialize this SCSI Hosts' timers
+				 * To use, set the timer expires field
+				 * and add_timer
+				 */
+				init_timer(&hd->timer);
+				hd->timer.data = (unsigned long) hd;
+				hd->timer.function = mptscsih_timer_expired;
+
+				init_timer(&hd->TMtimer);
+				hd->TMtimer.data = (unsigned long) hd;
+				hd->TMtimer.function = mptscsih_taskmgmt_timeout;
+				hd->qtag_tick = jiffies;
+
+				/* Moved Earlier Pam D */
+				/* this->sh = sh;	*/
+
+				if (hd->is_spi) {
+					/* Update with the driver setup
+					 * values.
+					 */
+					if (hd->ioc->spi_data.maxBusWidth > driver_setup.max_width)
+						hd->ioc->spi_data.maxBusWidth = driver_setup.max_width;
+					if (hd->ioc->spi_data.minSyncFactor < driver_setup.min_sync_fac)
+						hd->ioc->spi_data.minSyncFactor = driver_setup.min_sync_fac;
+
+					if (hd->ioc->spi_data.minSyncFactor == MPT_ASYNC)
+						hd->ioc->spi_data.maxSyncOffset = 0;
+
+					hd->negoNvram = 0;
+#ifdef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+					hd->negoNvram = MPT_SCSICFG_USE_NVRAM;
+#endif
+					if (driver_setup.dv == 0)
+						hd->negoNvram = MPT_SCSICFG_USE_NVRAM;
+
+					hd->ioc->spi_data.forceDv = 0;
+					for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++)
+						hd->ioc->spi_data.dvStatus[ii] = MPT_SCSICFG_NEGOTIATE;
+
+
+					ddvprintk((MYIOC_s_INFO_FMT
+						"dv %x width %x factor %x \n",
+						hd->ioc->name, driver_setup.dv,
+						driver_setup.max_width,
+						driver_setup.min_sync_fac));
+
+				}
+
+				mpt_scsi_hosts++;
+			}
+
+		}	/* for each adapter port */
 
-			this->sh = sh;
-			mpt_scsi_hosts++;
-		}
 		this = mpt_adapter_find_next(this);
 	}
 
+done:
+	if (mpt_scsi_hosts > 0)
+		register_reboot_notifier(&mptscsih_notifier);
+
 	return mpt_scsi_hosts;
 }
 
@@ -699,63 +1400,159 @@
 mptscsih_release(struct Scsi_Host *host)
 {
 	MPT_SCSI_HOST	*hd;
-#ifndef MPT_SCSI_USE_NEW_EH
+	int 		 count;
 	unsigned long	 flags;
 
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	if (mpt_scsih_taskQ_bh_active) {
-		int count = 10 * HZ;
+	hd = (MPT_SCSI_HOST *) host->hostdata;
+
+#ifndef MPT_SCSI_USE_NEW_EH
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+	spin_lock_irqsave(&dvtaskQ_lock, flags);
+	dvtaskQ_release = 1;
+	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+#endif
 
+	count = 10 * HZ;
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+	if (mytaskQ_bh_active) {
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 		dprintk((KERN_INFO MYNAM ": Info: Zapping TaskMgmt thread!\n"));
+		clean_taskQ(hd);
 
-		/* Zap the taskQ! */
-		Q_INIT(&mpt_scsih_taskQ, MPT_FRAME_HDR);
-		spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+		while(mytaskQ_bh_active && --count) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		}
+	} else {
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
+	}
+	if (!count)
+		printk(KERN_ERR MYNAM ": ERROR - TaskMgmt thread still active!\n");
+
+#endif
 
-		while(mpt_scsih_taskQ_bh_active && --count) {
-			current->state = TASK_INTERRUPTIBLE;
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+	/* Check DV thread active */
+	count = 10 * HZ;
+	spin_lock_irqsave(&dvtaskQ_lock, flags);
+	if (dvtaskQ_active) {
+		spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+		while(dvtaskQ_active && --count) {
+			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(1);
 		}
-		if (!count)
-			printk(KERN_ERR MYNAM ": ERROR! TaskMgmt thread still active!\n");
+	} else {
+		spin_unlock_irqrestore(&dvtaskQ_lock, flags);
 	}
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	if (!count)
+		printk(KERN_ERR MYNAM ": ERROR - DV thread still active!\n");
+#if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
+	else
+		printk(KERN_ERR MYNAM ": DV thread orig %d, count %d\n", 10 * HZ, count);
+#endif
 #endif
 
-	hd = (MPT_SCSI_HOST *) host->hostdata;
+	unregister_reboot_notifier(&mptscsih_notifier);
+
 	if (hd != NULL) {
-		int sz1, sz2;
+		int sz1, sz2, sz3, sztarget=0;
+		int szchain = 0;
+		int szQ = 0;
+		int scale;
+
+		/* Synchronize disk caches
+		 */
+		(void) mptscsih_synchronize_cache(hd, 0);
+
+		sz1 = sz2 = sz3 = 0;
+
+		if (hd->ioc->req_sz <= 64)
+			scale = MPT_SG_REQ_64_SCALE;
+		else if (hd->ioc->req_sz <= 96)
+			scale = MPT_SG_REQ_96_SCALE;
+		else
+			scale = MPT_SG_REQ_128_SCALE;
 
-		sz1 = sz2 = 0;
 		if (hd->ScsiLookup != NULL) {
 			sz1 = hd->ioc->req_depth * sizeof(void *);
 			kfree(hd->ScsiLookup);
 			hd->ScsiLookup = NULL;
 		}
 
-		if (hd->SgHunks != NULL) {
+		if (hd->ReqToChain != NULL) {
+			szchain += scale * hd->ioc->req_depth * sizeof(int);
+			kfree(hd->ReqToChain);
+			hd->ReqToChain = NULL;
+		}
+
+		if (hd->ChainToChain != NULL) {
+			szchain += scale * hd->ioc->req_depth * sizeof(int);
+			kfree(hd->ChainToChain);
+			hd->ChainToChain = NULL;
+		}
+
+		if (hd->ChainBuffer != NULL) {
+			sz2 = scale * hd->ioc->req_depth * hd->ioc->req_sz;
+			szchain += sz2;
 
-			sz2 = MPT_SG_BUCKETS_PER_HUNK * hd->ioc->req_sz * hd->ioc->req_depth;
 			pci_free_consistent(hd->ioc->pcidev, sz2,
-					    hd->SgHunks, hd->SgHunksDMA);
-			hd->SgHunks = NULL;
+				    hd->ChainBuffer, hd->ChainBufferDMA);
+			hd->ChainBuffer = NULL;
+		}
+
+		if (hd->memQ != NULL) {
+			szQ = host->can_queue * sizeof(MPT_DONE_Q);
+			kfree(hd->memQ);
+			hd->memQ = NULL;
+		}
+
+		if (hd->Targets != NULL) {
+			int max, ii;
+
+			/*
+			 * Free any target structures that were allocated.
+			 */
+			if (hd->is_spi) {
+				max = MPT_MAX_SCSI_DEVICES;
+			} else {
+				max = MPT_MAX_FC_DEVICES;
+			}
+			for (ii=0; ii < max; ii++) {
+				if (hd->Targets[ii]) {
+					kfree(hd->Targets[ii]);
+					hd->Targets[ii] = NULL;
+					sztarget += sizeof(VirtDevice);
+				}
+			}
+
+			/*
+			 * Free pointer array.
+			 */
+			sz3 = max * sizeof(void *);
+			kfree(hd->Targets);
+			hd->Targets = NULL;
 		}
-		dprintk((KERN_INFO MYNAM ": Free'd ScsiLookup (%d) and SgHunks (%d) memory\n", sz1, sz2));
+
+		dprintk((MYIOC_s_INFO_FMT "Free'd ScsiLookup (%d), chain (%d) and Target (%d+%d) memory\n",
+				hd->ioc->name, sz1, szchain, sz3, sztarget));
+		dprintk(("Free'd done and free Q (%d) memory\n", szQ));
 	}
+	/* NULL the Scsi_Host pointer
+	 */
+	hd->ioc->sh = NULL;
+	scsi_unregister(host);
 
 	if (mpt_scsi_hosts) {
 		if (--mpt_scsi_hosts == 0) {
-#if 0
-			mptscsih_flush_pending();
-#endif
 			mpt_reset_deregister(ScsiDoneCtx);
 			dprintk((KERN_INFO MYNAM ": Deregistered for IOC reset notifications\n"));
 
 			mpt_event_deregister(ScsiDoneCtx);
 			dprintk((KERN_INFO MYNAM ": Deregistered for IOC event notifications\n"));
 
-			mpt_deregister(ScsiDoneCtx);
+			mpt_deregister(ScsiScanDvCtx);
 			mpt_deregister(ScsiTaskCtx);
+			mpt_deregister(ScsiDoneCtx);
 
 			if (info_kbuf != NULL)
 				kfree(info_kbuf);
@@ -767,6 +1564,45 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
+ *	mptscsih_halt - Process the reboot notification
+ *	@nb: Pointer to a struct notifier_block (ignored)
+ *	@event: event (SYS_HALT, SYS_RESTART, SYS_POWER_OFF)
+ *	@buf: Pointer to a data buffer (ignored)
+ *
+ *	This routine called if a system shutdown or reboot is to occur.
+ *
+ *	Return NOTIFY_DONE if this is something other than a reboot message.
+ *		NOTIFY_OK if this is a reboot message.
+ */
+static int
+mptscsih_halt(struct notifier_block *nb, ulong event, void *buf)
+{
+	MPT_ADAPTER *ioc = NULL;
+	MPT_SCSI_HOST *hd = NULL;
+
+	/* Ignore all messages other than reboot message
+	 */
+	if ((event != SYS_RESTART) && (event != SYS_HALT)
+		&& (event != SYS_POWER_OFF))
+		return (NOTIFY_DONE);
+
+	for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc =	mpt_adapter_find_next(ioc)) {
+		/* Flush the cache of this adapter
+		 */
+		if (ioc->sh) {
+			hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+			if (hd) {
+				mptscsih_synchronize_cache(hd, 0);
+			}
+		}
+	}
+
+	unregister_reboot_notifier(&mptscsih_notifier);
+	return NOTIFY_OK;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
  *	mptscsih_info - Return information about MPT adapter
  *	@SChost: Pointer to Scsi_Host structure
  *
@@ -794,14 +1630,6 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 	static int max_qd = 1;
-#ifdef MPT_DEBUG
-	static int max_sges = 0;
-	static int max_xfer = 0;
-#endif
-#if 0
-	static int max_num_sges = 0;
-	static int max_sgent_len = 0;
-#endif
 #if 0
 static int index_log[128];
 static int index_ent = 0;
@@ -814,6 +1642,47 @@
 #else
 #define ADD_INDEX_LOG(req_ent)	do { } while(0)
 #endif
+
+#ifdef	DROP_TEST
+#define DROP_IOC	1	/* IOC to force failures */
+#define DROP_TARGET	3	/* Target ID to force failures */
+#define	DROP_THIS_CMD	10000	/* iteration to drop command */
+static int dropCounter = 0;
+static int dropTestOK = 0;	/* num did good */
+static int dropTestBad = 0;	/* num did bad */
+static int dropTestNum = 0;	/* total = good + bad + incomplete */
+static int numTotCmds = 0;
+static MPT_FRAME_HDR *dropMfPtr = NULL;
+static int numTMrequested = 0;
+#endif
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_put_msgframe - Wrapper routine to post message frame to F/W.
+ *	@context: Call back context (ScsiDoneCtx, ScsiScanDvCtx) 
+ *	@id: IOC id number 
+ *	@mf: Pointer to message frame 
+ *
+ *	Handles the call to mptbase for posting request and queue depth 
+ *	tracking.
+ *
+ *	Returns none.
+ */
+static void
+mptscsih_put_msgframe(int context, int id, MPT_FRAME_HDR *mf)
+{
+	/* Main banana... */
+	atomic_inc(&queue_depth);
+	if (atomic_read(&queue_depth) > max_qd) {
+		max_qd = atomic_read(&queue_depth);
+		dprintk((KERN_INFO MYNAM ": Queue depth now %d.\n", max_qd));
+	}
+
+	mpt_put_msg_frame(context, id, mf);
+
+	return;
+}
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptscsih_qcmd - Primary Fusion MPT SCSI initiator IO start routine.
@@ -829,154 +1698,96 @@
 int
 mptscsih_qcmd(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))
 {
-	struct Scsi_Host	*host;
 	MPT_SCSI_HOST		*hd;
 	MPT_FRAME_HDR		*mf;
 	SCSIIORequest_t		*pScsiReq;
+	VirtDevice		*pTarget;
+	MPT_DONE_Q		*buffer = NULL;
+	unsigned long		 flags;
+	int	 target;
+	int	 lun;
 	int	 datadir;
-	u32	 len;
-	u32	 sgdir;
+	u32	 datalen;
 	u32	 scsictl;
 	u32	 scsidir;
 	u32	 qtag;
-	u32	*mptr;
-	int	 sge_spill1;
-	int	 frm_sz;
-	int	 sges_left;
-	u32	 chain_offset;
+	u32	 cmd_len;
 	int	 my_idx;
-	int	 i;
+	int	 ii;
+	int	 rc;
+	int	 did_errcode;
+	int	 issueCmd;
 
-	dmfprintk((KERN_INFO MYNAM "_qcmd: SCpnt=%p, done()=%p\n",
-		    SCpnt, done));
-
-	host = SCpnt->host;
-	hd = (MPT_SCSI_HOST *) host->hostdata;
-	
-#if 0
-	if (host->host_busy >= 60) {
-		MPT_ADAPTER *ioc = hd->ioc;
-		u16 pci_command, pci_status;
-
-		/* The IOC is probably hung, investigate status. */
-		printk("MPI: IOC probably hung IOCSTAT[%08x] INTSTAT[%08x] REPLYFIFO[%08x]\n",
-		       readl(&ioc->chip.fc9xx->DoorbellValue),
-		       readl(&ioc->chip.fc9xx->IntStatus),
-		       readl(&ioc->chip.fc9xx->ReplyFifo));
-		pci_read_config_word(ioc->pcidev, PCI_COMMAND, &pci_command);
-		pci_read_config_word(ioc->pcidev, PCI_STATUS, &pci_status);
-		printk("MPI: PCI command[%04x] status[%04x]\n", pci_command, pci_status);
-		{
-			/* DUMP req index logger. */
-			int begin, end;
+	did_errcode = 0;
+	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
+	target = SCpnt->target;
+	lun = SCpnt->lun;
+	SCpnt->scsi_done = done;
 
-			begin = (index_ent - 65) & (128 - 1);
-			end = index_ent & (128 - 1);
-			printk("MPI: REQ_INDEX_HIST[");
-			while (begin != end) {
-				printk("(%04x)", index_log[begin]);
-				begin = (begin + 1) & (128 - 1);
-			}
-			printk("\n");
-		}
-		sti();
-		while(1)
-			barrier();
-	}
-#endif
+	pTarget = hd->Targets[target];
 
-	SCpnt->scsi_done = done;
+	dmfprintk((MYIOC_s_INFO_FMT "qcmd: SCpnt=%p, done()=%p\n",
+			(hd && hd->ioc) ? hd->ioc->name : "ioc?", SCpnt, done));
 
 	/* 20000617 -sralston
 	 *  GRRRRR...  Shouldn't have to do this but...
 	 *  Do explicit check for REQUEST_SENSE and cached SenseData.
 	 *  If yes, return cached SenseData.
 	 */
-#ifdef MPT_SCSI_CACHE_AUTOSENSE
-	{
-		MPT_SCSI_DEV	*mpt_sdev;
-
-		mpt_sdev = (MPT_SCSI_DEV *) SCpnt->device->hostdata;
-		if (mpt_sdev && SCpnt->cmnd[0] == REQUEST_SENSE) {
-			u8 *dest = NULL;
-
-			if (!SCpnt->use_sg)
+	if (SCpnt->cmnd[0] == REQUEST_SENSE) {
+		u8 *dest = NULL;
+		int sz;
+
+		if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_VALID_SENSE)) {
+			pTarget->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;	//sjr-moved-here
+			if (!SCpnt->use_sg) {
 				dest = SCpnt->request_buffer;
-			else {
+			} else {
 				struct scatterlist *sg = (struct scatterlist *) SCpnt->request_buffer;
 				if (sg)
-					dest = (u8 *) (unsigned long)sg_dma_address(sg);
+					dest = (u8 *)(ulong)sg_dma_address(sg);
 			}
 
-			if (dest && mpt_sdev->sense_sz) {
-				memcpy(dest, mpt_sdev->CachedSense.data, mpt_sdev->sense_sz);
-#ifdef MPT_DEBUG
-				{
-					int  i;
-					u8  *sb;
-
-					sb = mpt_sdev->CachedSense.data;
-					if (sb && ((sb[0] & 0x70) == 0x70)) {
-						printk(KERN_WARNING MYNAM ": Returning last cached SCSI (hex) SenseData:\n");
-						printk(KERN_WARNING " ");
-						for (i = 0; i < (8 + sb[7]); i++)
-							printk("%s%02x", i == 13 ? "-" : " ", sb[i]);
-						printk("\n");
-					}
-				}
+			if (dest) {
+				sz = MIN (SCSI_STD_SENSE_BYTES, SCpnt->request_bufflen);
+				memcpy(dest, pTarget->sense, sz);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+				SCpnt->resid = SCpnt->request_bufflen - sz;
 #endif
+				SCpnt->result = 0;
+				SCpnt->scsi_done(SCpnt);
+
+				//sjr-moved-up//pTarget->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;
+
+				return 0;
 			}
-			SCpnt->resid = SCpnt->request_bufflen - mpt_sdev->sense_sz;
-			SCpnt->result = 0;
-/*			spin_lock(SCpnt->host->host_lock);	*/
-			SCpnt->scsi_done(SCpnt);
-/*			spin_unlock(SCpnt->host->host_lock);	*/
-			return 0;
 		}
 	}
-#endif
 
-	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-/*		return 1;				*/
-		return 0;
-	}
-	pScsiReq = (SCSIIORequest_t *) mf;
-
-	my_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
-
-	ADD_INDEX_LOG(my_idx);
-
-	/* Map the data portion, if any. */
-	sges_left = SCpnt->use_sg;
-	if (sges_left) {
-		sges_left = pci_map_sg(hd->ioc->pcidev,
-				       (struct scatterlist *) SCpnt->request_buffer,
-				       sges_left,
-				       scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
-	} else if (SCpnt->request_bufflen) {
-		dma_addr_t buf_dma_addr;
-
-		buf_dma_addr = pci_map_single(hd->ioc->pcidev,
-					      SCpnt->request_buffer,
-					      SCpnt->request_bufflen,
-					      scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
-
-		/* We hide it here for later unmap. */
-		SCpnt->SCp.ptr = (char *)(unsigned long) buf_dma_addr;
+	if (hd->resetPending) {
+		/* Prevent new commands from being issued
+		 * while reloading the FW.
+		 */
+		did_errcode = 1;
+		goto did_error;
 	}
 
 	/*
 	 *  Put together a MPT SCSI request...
 	 */
+	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, hd->ioc->id)) == NULL) {
+		dprintk((MYIOC_s_WARN_FMT "QueueCmd, no msg frames!!\n",
+				hd->ioc->name));
+		did_errcode = 2;
+		goto did_error;
+	}
+
+	pScsiReq = (SCSIIORequest_t *) mf;
 
-	/* Assume SimpleQ, NO DATA XFER for now */
+	my_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 
-	len = SCpnt->request_bufflen;
-	sgdir = 0x00000000;		/* SGL IN  (host<--ioc) */
-	scsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
+	ADD_INDEX_LOG(my_idx);
 
 	/*
 	 *  The scsi layer should be handling this stuff
@@ -985,25 +1796,27 @@
 
 	/*  BUG FIX!  19991030 -sralston
 	 *    TUR's being issued with scsictl=0x02000000 (DATA_IN)!
-	 *    Seems we may receive a buffer (len>0) even when there
+	 *    Seems we may receive a buffer (datalen>0) even when there
 	 *    will be no data transfer!  GRRRRR...
 	 */
 	datadir = mptscsih_io_direction(SCpnt);
-	if (datadir < 0) {
+	if (datadir == SCSI_DATA_READ) {
+		datalen = SCpnt->request_bufflen;
 		scsidir = MPI_SCSIIO_CONTROL_READ;	/* DATA IN  (host<--ioc<--dev) */
-	} else if (datadir > 0) {
-		sgdir	= 0x04000000;			/* SGL OUT  (host-->ioc) */
+	} else if (datadir == SCSI_DATA_WRITE) {
+		datalen = SCpnt->request_bufflen;
 		scsidir = MPI_SCSIIO_CONTROL_WRITE;	/* DATA OUT (host-->ioc-->dev) */
 	} else {
-		len = 0;
+		datalen = 0;
+		scsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
 	}
 
-	qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
-
-	/*
-	 *  Attach tags to the devices
+	/* Default to untagged. Once a target structure has been allocated,
+	 * use the Inquiry data to determine if device supports tagged.
 	 */
-	if (SCpnt->device->tagged_supported) {
+	qtag = MPI_SCSIIO_CONTROL_UNTAGGED;
+	if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)
+			&& (SCpnt->device->tagged_supported)) {
 		/*
 		 *  Some drives are too stupid to handle fairness issues
 		 *  with tagged queueing. We throw in the odd ordered
@@ -1012,87 +1825,24 @@
 		if ((jiffies - hd->qtag_tick) > (5*HZ)) {
 			qtag = MPI_SCSIIO_CONTROL_ORDEREDQ;
 			hd->qtag_tick = jiffies;
-
-#if 0
-			/* These are ALWAYS zero!
-			 * (Because this is a place for the device driver to dynamically
-			 *  assign tag numbers any way it sees fit.  That's why -DaveM)
-			 */
-			dprintk((KERN_DEBUG MYNAM ": sc->device->current_tag = %08x\n",
-					SCpnt->device->current_tag));
-			dprintk((KERN_DEBUG MYNAM ": sc->tag                 = %08x\n",
-					SCpnt->tag));
-#endif
 		}
-#if 0
-		else {
-			/* Hmmm...  I always see value of 0 here,
-			 *  of which {HEAD_OF, ORDERED, SIMPLE} are NOT!  -sralston
-			 * (Because this is a place for the device driver to dynamically
-			 *  assign tag numbers any way it sees fit.  That's why -DaveM)
-			 *
-			 * if (SCpnt->tag == HEAD_OF_QUEUE_TAG)
-			 */
-			if (SCpnt->device->current_tag == HEAD_OF_QUEUE_TAG)
-				qtag = MPI_SCSIIO_CONTROL_HEADOFQ;
-			else if (SCpnt->tag == ORDERED_QUEUE_TAG)
-				qtag = MPI_SCSIIO_CONTROL_ORDEREDQ;
-		}
-#endif
+		else
+			qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
 	}
-
 	scsictl = scsidir | qtag;
 
-	frm_sz = hd->ioc->req_sz;
-
-	/* Ack!
-	 * sge_spill1 = 9;
+	/* Use the above information to set up the message frame
 	 */
-	sge_spill1 = (frm_sz - (sizeof(SCSIIORequest_t) - sizeof(SGEIOUnion_t) + sizeof(SGEChain32_t))) / 8;
-	/*  spill1: for req_sz == 128 (128-48==80, 80/8==10 SGEs max, first time!), --> use 9
-	 *  spill1: for req_sz ==  96 ( 96-48==48, 48/8== 6 SGEs max, first time!), --> use 5
-	 */
-	dsgprintk((KERN_INFO MYNAM ": SG: %x     spill1 = %d\n",
-		   my_idx, sge_spill1));
-
-#ifdef MPT_DEBUG
-	if (sges_left > max_sges) {
-		max_sges = sges_left;
-		dprintk((KERN_INFO MYNAM ": MPT_MaxSges = %d\n", max_sges));
-	}
-#endif
-#if 0
-	if (sges_left > max_num_sges) {
-		max_num_sges = sges_left;
-		printk(KERN_INFO MYNAM ": MPT_MaxNumSges = %d\n", max_num_sges);
-	}
-#endif
-
-	dsgprintk((KERN_INFO MYNAM ": SG: %x     sges_left = %d (initially)\n",
-		   my_idx, sges_left));
-
-	chain_offset = 0;
-	if (sges_left > (sge_spill1+1)) {
-#if 0
-		chain_offset = 0x1E;
-#endif
-		chain_offset = (frm_sz - 8) / 4;
-	}
-
-	pScsiReq->TargetID = SCpnt->target;
+	pScsiReq->TargetID = target;
 	pScsiReq->Bus = hd->port;
-	pScsiReq->ChainOffset = chain_offset;
+	pScsiReq->ChainOffset = 0;
 	pScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
 	pScsiReq->CDBLength = SCpnt->cmd_len;
-
-/* We have 256 bytes alloc'd per IO; let's use it. */
-/*	pScsiReq->SenseBufferLength = SNS_LEN(SCpnt);	*/
-	pScsiReq->SenseBufferLength = 255;
-
+	pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
 	pScsiReq->Reserved = 0;
-	pScsiReq->MsgFlags = 0;
+	pScsiReq->MsgFlags = mpt_msg_flags();
 	pScsiReq->LUN[0] = 0;
-	pScsiReq->LUN[1] = SCpnt->lun;
+	pScsiReq->LUN[1] = lun;
 	pScsiReq->LUN[2] = 0;
 	pScsiReq->LUN[3] = 0;
 	pScsiReq->LUN[4] = 0;
@@ -1104,169 +1854,708 @@
 	/*
 	 *  Write SCSI CDB into the message
 	 */
-	for (i = 0; i < 12; i++)
-		pScsiReq->CDB[i] = SCpnt->cmnd[i];
-	for (i = 12; i < 16; i++)
-		pScsiReq->CDB[i] = 0;
+	cmd_len = SCpnt->cmd_len;
+	for (ii=0; ii < cmd_len; ii++)
+		pScsiReq->CDB[ii] = SCpnt->cmnd[ii];
+	for (ii=cmd_len; ii < 16; ii++)
+		pScsiReq->CDB[ii] = 0;
 
 	/* DataLength */
-	pScsiReq->DataLength = cpu_to_le32(len);
+	pScsiReq->DataLength = cpu_to_le32(datalen);
 
 	/* SenseBuffer low address */
-	pScsiReq->SenseBufferLowAddr = cpu_to_le32(hd->ioc->sense_buf_pool_dma + (my_idx * 256));
+	pScsiReq->SenseBufferLowAddr = cpu_to_le32(hd->ioc->sense_buf_low_dma
+					   + (my_idx * MPT_SENSE_BUFFER_ALLOC));
 
-	mptr = (u32 *) &pScsiReq->SGL;
+	/* Now add the SG list
+	 * Always have a SGE even if null length.
+	 */
+	rc = SUCCESS;
+	if (datalen == 0) {
+		/* Add a NULL SGE */
+		mpt_add_sge((char *)&pScsiReq->SGL, MPT_SGE_FLAGS_SSIMPLE_READ | 0,
+			(dma_addr_t) -1);
+	} else {
+		/* Add a 32 or 64 bit SGE */
+		rc = mptscsih_AddSGE(hd, SCpnt, pScsiReq, my_idx);
+	}
 
-	/*
-	 *  Now fill in the SGList...
-	 *  NOTES: For 128 byte req_sz, we can hold up to 10 simple SGE's
-	 *  in the remaining request frame.  We -could- do unlimited chains
-	 *  but each chain buffer can only be req_sz bytes in size, and
-	 *  we lose one SGE whenever we chain.
-	 *  For 128 req_sz, we can hold up to 16 SGE's per chain buffer.
-	 *  For practical reasons, limit ourselves to 1 overflow chain buffer;
-	 *  giving us 9 + 16 == 25 SGE's max.
-	 *  At 4 Kb per SGE, that yields 100 Kb max transfer.
-	 *
-	 *  (This code needs to be completely changed when/if 64-bit DMA
-	 *   addressing is used, since we will be able to fit much less than
-	 *   10 embedded SG entries. -DaveM)
-	 */
-	if (sges_left) {
-		struct scatterlist *sg = (struct scatterlist *) SCpnt->request_buffer;
-		u32  v1, v2;
-		int  sge_spill2;
-		int  sge_cur_spill;
-		int  sgCnt;
-		u8  *pSgBucket;
-		int  chain_sz;
-
-		len = 0;
-
-		/*	sge_spill2 = 15;
-		 *  spill2: for req_sz == 128 (128/8==16 SGEs max, first time!), --> use 15
-		 *  spill2: for req_sz ==  96 ( 96/8==12 SGEs max, first time!), --> use 11
-		 */
-		sge_spill2 = frm_sz / 8 - 1;
-		dsgprintk((KERN_INFO MYNAM ": SG: %x     spill2 = %d\n",
-			   my_idx, sge_spill2));
-
-		pSgBucket = NULL;
-		sgCnt = 0;
-		sge_cur_spill = sge_spill1;
-		while (sges_left) {
-#if 0
-			if (sg_dma_len(sg) > max_sgent_len) {
-				max_sgent_len = sg_dma_len(sg);
-				printk(KERN_INFO MYNAM ": MPT_MaxSgentLen = %d\n", max_sgent_len);
-			}
-#endif
-			/* Write one simple SGE */
-			v1 = sgdir | 0x10000000 | sg_dma_len(sg);
-			len += sg_dma_len(sg);
-			v2 = sg_dma_address(sg);
-			dsgprintk((KERN_INFO MYNAM ": SG: %x     Writing SGE @%p: %08x %08x, sges_left=%d\n",
-				   my_idx, mptr, v1, v2, sges_left));
-			*mptr++ = cpu_to_le32(v1);
-			*mptr++ = cpu_to_le32(v2);
-			sg++;
-			sgCnt++;
-
-			if (--sges_left == 0) {
-				/* re-write 1st word of previous SGE with SIMPLE,
-				 * LE, EOB, and EOL bits!
-				 */
-				v1 = 0xD1000000 | sgdir | sg_dma_len(sg-1);
-				dsgprintk((KERN_INFO MYNAM ": SG: %x (re)Writing SGE @%p: %08x (VERY LAST SGE!)\n",
-					   my_idx, mptr-2, v1));
-				*(mptr - 2) = cpu_to_le32(v1);
-			} else {
-				if ((sges_left > 1) && ((sgCnt % sge_cur_spill) == 0)) {
-					dsgprintk((KERN_INFO MYNAM ": SG: %x     SG spill at modulo 0!\n",
-						   my_idx));
-
-					/* Fixup previous SGE with LE bit! */
-					v1 = sgdir | 0x90000000 | sg_dma_len(sg-1);
-					dsgprintk((KERN_INFO MYNAM ": SG: %x (re)Writing SGE @%p: %08x (LAST BUCKET SGE!)\n",
-						   my_idx, mptr-2, v1));
-					*(mptr - 2) = cpu_to_le32(v1);
-
-					chain_offset = 0;
-					/* Going to need another chain? */
-					if (sges_left > (sge_spill2+1)) {
-#if 0
-						chain_offset = 0x1E;
+
+	if (rc == SUCCESS) {
+		hd->ScsiLookup[my_idx] = SCpnt;
+		SCpnt->host_scribble = NULL;
+
+#ifdef	DROP_TEST
+		numTotCmds++;
+		/* If the IOC number and target match, increment
+		 * counter. If counter matches DROP_THIS, do not
+		 * issue command to FW to force a reset.
+		 * Save the MF pointer so we can free resources
+		 * when task mgmt completes.
+		 */
+		if ((hd->ioc->id == DROP_IOC) && (target == DROP_TARGET)) {
+			dropCounter++;
+
+			if (dropCounter == DROP_THIS_CMD) {
+				dropCounter = 0;
+
+				/* If global is set, then we are already
+				 * doing something - so keep issuing commands.
+				 */
+				if (dropMfPtr == NULL) {
+					dropTestNum++;
+					dropMfPtr = mf;
+					atomic_inc(&queue_depth);
+					printk(MYIOC_s_INFO_FMT
+						"Dropped SCSI cmd (%p)\n",
+						hd->ioc->name, SCpnt);
+					printk("mf (%p) req (%4x) tot cmds (%d)\n",
+						mf, my_idx, numTotCmds);
+
+					return 0;
+				}
+			}
+		}
 #endif
-						chain_offset = (frm_sz - 8) / 4;
-						chain_sz = frm_sz;
-					} else {
-						chain_sz = sges_left * 8;
-					}
 
-					/* write chain SGE at mptr. */
-					v1 = 0x30000000 | chain_offset<<16 | chain_sz;
-					if (pSgBucket == NULL) {
-						pSgBucket = hd->SgHunks
-							+ (my_idx * frm_sz * MPT_SG_BUCKETS_PER_HUNK);
+		/* SCSI specific processing */
+		issueCmd = 1;
+		if (hd->is_spi) {
+			int dvStatus = hd->ioc->spi_data.dvStatus[target];
+
+			if (dvStatus || hd->ioc->spi_data.forceDv) {
+
+				/* Write SDP1 on this I/O to this target */
+				if (dvStatus & MPT_SCSICFG_NEGOTIATE) {
+					mptscsih_writeSDP1(hd, 0, target, hd->negoNvram);
+					dvStatus &= ~MPT_SCSICFG_NEGOTIATE;
+					hd->ioc->spi_data.dvStatus[target] =  dvStatus;
+				} else if (dvStatus & MPT_SCSICFG_BLK_NEGO) {
+					mptscsih_writeSDP1(hd, 0, target, MPT_SCSICFG_BLK_NEGO);
+					dvStatus &= ~MPT_SCSICFG_BLK_NEGO;
+					hd->ioc->spi_data.dvStatus[target] =  dvStatus;
+				}
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+				if ((dvStatus & MPT_SCSICFG_NEED_DV) || hd->ioc->spi_data.forceDv) {
+					unsigned long lflags;
+					/* Schedule DV if necessary */
+					spin_lock_irqsave(&dvtaskQ_lock, lflags);
+					if (!dvtaskQ_active) {
+						dvtaskQ_active = 1;
+						spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
+						mptscsih_dvTask.sync = 0;
+						mptscsih_dvTask.routine = mptscsih_domainValidation;
+						mptscsih_dvTask.data = (void *) hd;
+
+						SCHEDULE_TASK(&mptscsih_dvTask);
 					} else {
-						pSgBucket += frm_sz;
+						spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
 					}
-					v2 = (hd->SgHunksDMA +
-					      ((u8 *)pSgBucket - (u8 *)hd->SgHunks));
-					dsgprintk((KERN_INFO MYNAM ": SG: %x     Writing SGE @%p: %08x %08x (CHAIN!)\n",
-						   my_idx, mptr, v1, v2));
-					*(mptr++) = cpu_to_le32(v1);
-					*(mptr) = cpu_to_le32(v2);
+					hd->ioc->spi_data.forceDv = 0;
+				}
 
-					mptr = (u32 *) pSgBucket;
-					sgCnt = 0;
-					sge_cur_spill = sge_spill2;
+				/* Trying to do DV to this target, extend timeout.
+				 * Wait to issue intil flag is clear 
+				 */
+				if (dvStatus & MPT_SCSICFG_DV_PENDING) {
+					mod_timer(&SCpnt->eh_timeout, jiffies + 40 * HZ);
+					issueCmd = 0;
 				}
+#endif
+			}
+		}
+
+		if (issueCmd) {
+			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+			dmfprintk((MYIOC_s_INFO_FMT "Issued SCSI cmd (%p)\n",
+					hd->ioc->name, SCpnt));
+		} else {
+			ddvtprintk((MYIOC_s_INFO_FMT "Pending SCSI cmd (%p)\n",
+					hd->ioc->name, SCpnt));
+			/* Place this command on the pendingQ if possible */
+			spin_lock_irqsave(&hd->freedoneQlock, flags);
+			if (!Q_IS_EMPTY(&hd->freeQ)) {
+				buffer = hd->freeQ.head;
+				Q_DEL_ITEM(buffer);
+
+				/* Save the mf pointer
+				 */
+				buffer->argp = (void *)mf;
+
+				/* Add to the pendingQ
+				 */
+				Q_ADD_TAIL(&hd->pendingQ.head, buffer, MPT_DONE_Q);
+				spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			} else {
+				spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+				SCpnt->result = (DID_BUS_BUSY << 16);
+				SCpnt->scsi_done(SCpnt);
 			}
 		}
 	} else {
-		dsgprintk((KERN_INFO MYNAM ": SG: non-SG for %p, len=%d\n",
-			   SCpnt, SCpnt->request_bufflen));
+		mptscsih_freeChainBuffers(hd, my_idx);
+		mpt_free_msg_frame(ScsiDoneCtx, hd->ioc->id, mf);
+		did_errcode = 3;
+		goto did_error;
+	}
+
+	return 0;
+
+did_error:
+	dprintk((MYIOC_s_WARN_FMT "_qcmd did_errcode=%d (sc=%p)\n",
+			hd->ioc->name, did_errcode, SCpnt));
+	/* Just wish OS to issue a retry */
+	SCpnt->result = (DID_BUS_BUSY << 16);
+	spin_lock_irqsave(&hd->freedoneQlock, flags);
+	if (!Q_IS_EMPTY(&hd->freeQ)) {
+		buffer = hd->freeQ.head;
+		Q_DEL_ITEM(buffer);
+
+		/* Set the Scsi_Cmnd pointer
+		 */
+		buffer->argp = (void *)SCpnt;
+
+		/* Add to the doneQ
+		 */
+		Q_ADD_TAIL(&hd->doneQ.head, buffer, MPT_DONE_Q);
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+	} else {
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+		SCpnt->scsi_done(SCpnt);
+	}
 
-		if (len > 0) {
-			dma_addr_t buf_dma_addr;
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_AddSGE - Add a SGE (plus chain buffers) to the
+ *	SCSIIORequest_t Message Frame.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@SCpnt: Pointer to Scsi_Cmnd structure
+ *	@pReq: Pointer to SCSIIORequest_t structure
+ *
+ *	Returns ...
+ */
+static int
+mptscsih_AddSGE(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt,
+				 SCSIIORequest_t *pReq, int req_idx)
+{
+	char 	*psge;
+	char	*chainSge;
+	struct scatterlist *sg;
+	int	 frm_sz;
+	int	 sges_left, sg_done;
+	int	 chain_idx = MPT_HOST_NO_CHAIN;
+	int	 sgeOffset;
+	int	 numSgeSlots, numSgeThisFrame;
+	u32	 sgflags, sgdir, thisxfer = 0;
+	int	 chain_dma_off = 0;
+	int	 newIndex;
+	int	 ii;
+	dma_addr_t v2;
+
+	sgdir = le32_to_cpu(pReq->Control) & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK;
+	if (sgdir == MPI_SCSIIO_CONTROL_WRITE)  {
+		sgdir = MPT_TRANSFER_HOST_TO_IOC;
+	} else {
+		sgdir = MPT_TRANSFER_IOC_TO_HOST;
+	}
+
+	psge = (char *) &pReq->SGL;
+	frm_sz = hd->ioc->req_sz;
+
+	/* Map the data portion, if any.
+	 * sges_left  = 0 if no data transfer.
+	 */
+	sges_left = SCpnt->use_sg;
+	if (SCpnt->use_sg) {
+		sges_left = pci_map_sg(hd->ioc->pcidev,
+			       (struct scatterlist *) SCpnt->request_buffer,
+			       SCpnt->use_sg,
+			       scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+	} else if (SCpnt->request_bufflen) {
+		dma_addr_t	 buf_dma_addr;
+		scPrivate	*my_priv;
+
+		buf_dma_addr = pci_map_single(hd->ioc->pcidev,
+				      SCpnt->request_buffer,
+				      SCpnt->request_bufflen,
+				      scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+
+		/* We hide it here for later unmap. */
+		my_priv = (scPrivate *) &SCpnt->SCp;
+		my_priv->p1 = (void *)(ulong) buf_dma_addr;
+
+		dsgprintk((MYIOC_s_INFO_FMT "SG: non-SG for %p, len=%d\n",
+				hd->ioc->name, SCpnt, SCpnt->request_bufflen));
+
+		mpt_add_sge((char *) &pReq->SGL,
+			0xD1000000|MPT_SGE_FLAGS_ADDRESSING|sgdir|SCpnt->request_bufflen,
+			buf_dma_addr);
+
+		return SUCCESS;
+	}
+
+	/* Handle the SG case.
+	 */
+	sg = (struct scatterlist *) SCpnt->request_buffer;
+	sg_done  = 0;
+	sgeOffset = sizeof(SCSIIORequest_t) - sizeof(SGE_IO_UNION);
+	chainSge = NULL;
+
+	/* Prior to entering this loop - the following must be set
+	 * current MF:  sgeOffset (bytes)
+	 *              chainSge (Null if original MF is not a chain buffer)
+	 *              sg_done (num SGE done for this MF)
+	 */
+
+nextSGEset:
+	numSgeSlots = ((frm_sz - sgeOffset) / (sizeof(u32) + sizeof(dma_addr_t)) );
+	numSgeThisFrame = (sges_left < numSgeSlots) ? sges_left : numSgeSlots;
+
+	sgflags = MPT_SGE_FLAGS_SIMPLE_ELEMENT | MPT_SGE_FLAGS_ADDRESSING | sgdir;
+
+	/* Get first (num - 1) SG elements
+	 * Skip any SG entries with a length of 0
+	 * NOTE: at finish, sg and psge pointed to NEXT data/location positions
+	 */
+	for (ii=0; ii < (numSgeThisFrame-1); ii++) {
+		thisxfer = sg_dma_len(sg);
+		if (thisxfer == 0) {
+			sg ++; /* Get next SG element from the OS */
+			sg_done++;
+			continue;
+		}
+
+		v2 = sg_dma_address(sg);
+		mpt_add_sge(psge, sgflags | thisxfer, v2);
+
+		sg++;		/* Get next SG element from the OS */
+		psge += (sizeof(u32) + sizeof(dma_addr_t));
+		sgeOffset += (sizeof(u32) + sizeof(dma_addr_t));
+		sg_done++;
+	}
+
+	if (numSgeThisFrame == sges_left) {
+		/* Add last element, end of buffer and end of list flags.
+		 */
+		sgflags |= MPT_SGE_FLAGS_LAST_ELEMENT |
+				MPT_SGE_FLAGS_END_OF_BUFFER |
+				MPT_SGE_FLAGS_END_OF_LIST;
+
+		/* Add last SGE and set termination flags.
+		 * Note: Last SGE may have a length of 0 - which should be ok.
+		 */
+		thisxfer = sg_dma_len(sg);
+
+		v2 = sg_dma_address(sg);
+		mpt_add_sge(psge, sgflags | thisxfer, v2);
+		/*
+		sg++;
+		psge += (sizeof(u32) + sizeof(dma_addr_t));
+		*/
+		sgeOffset += (sizeof(u32) + sizeof(dma_addr_t));
+		sg_done++;
+
+		if (chainSge) {
+			/* The current buffer is a chain buffer,
+			 * but there is not another one.
+			 * Update the chain element
+			 * Offset and Length fields.
+			 */
+			mpt_add_chain((char *)chainSge, 0, sgeOffset, hd->ChainBufferDMA + chain_dma_off);
+		} else {
+			/* The current buffer is the original MF
+			 * and there is no Chain buffer.
+			 */
+			pReq->ChainOffset = 0;
+		}
+	} else {
+		/* At least one chain buffer is needed.
+		 * Complete the first MF
+		 *  - last SGE element, set the LastElement bit
+		 *  - set ChainOffset (words) for orig MF
+		 *             (OR finish previous MF chain buffer)
+		 *  - update MFStructPtr ChainIndex
+		 *  - Populate chain element
+		 * Also
+		 * Loop until done.
+		 */
+
+		dsgprintk((MYIOC_s_INFO_FMT "SG: Chain Required! sg done %d\n",
+				hd->ioc->name, sg_done));
+
+		/* Set LAST_ELEMENT flag for last non-chain element
+		 * in the buffer. Since psge points at the NEXT
+		 * SGE element, go back one SGE element, update the flags
+		 * and reset the pointer. (Note: sgflags & thisxfer are already
+		 * set properly).
+		 */
+		if (sg_done) {
+			u32 *ptmp = (u32 *) (psge - (sizeof(u32) + sizeof(dma_addr_t)));
+			sgflags = le32_to_cpu(*ptmp);
+			sgflags |= MPT_SGE_FLAGS_LAST_ELEMENT;
+			*ptmp = cpu_to_le32(sgflags);
+		}
+
+		if (chainSge) {
+			/* The current buffer is a chain buffer.
+			 * chainSge points to the previous Chain Element.
+			 * Update its chain element Offset and Length (must
+			 * include chain element size) fields.
+			 * Old chain element is now complete.
+			 */
+			u8 nextChain = (u8) (sgeOffset >> 2);
+			sgeOffset += (sizeof(u32) + sizeof(dma_addr_t));
+			mpt_add_chain((char *)chainSge, nextChain, sgeOffset, hd->ChainBufferDMA + chain_dma_off);
+		} else {
+			/* The original MF buffer requires a chain buffer -
+			 * set the offset.
+			 * Last element in this MF is a chain element.
+			 */
+			pReq->ChainOffset = (u8) (sgeOffset >> 2);
+		}
+
+		sges_left -= sg_done;
+
+
+		/* NOTE: psge points to the beginning of the chain element
+		 * in current buffer. Get a chain buffer.
+		 */
+		if ((mptscsih_getFreeChainBuffer(hd, &newIndex)) == FAILED)
+			return FAILED;
 
-			buf_dma_addr = (dma_addr_t) (unsigned long)SCpnt->SCp.ptr;
-			*(mptr++) = cpu_to_le32(0xD1000000|sgdir|SCpnt->request_bufflen);
-			*(mptr++) = cpu_to_le32(buf_dma_addr);
+		/* Update the tracking arrays.
+		 * If chainSge == NULL, update ReqToChain, else ChainToChain
+		 */
+		if (chainSge) {
+			hd->ChainToChain[chain_idx] = newIndex;
+		} else {
+			hd->ReqToChain[req_idx] = newIndex;
 		}
+		chain_idx = newIndex;
+		chain_dma_off = hd->ioc->req_sz * chain_idx;
+
+		/* Populate the chainSGE for the current buffer.
+		 * - Set chain buffer pointer to psge and fill
+		 *   out the Address and Flags fields.
+		 */
+		chainSge = (char *) psge;
+		dsgprintk((KERN_INFO "  Current buff @ %p (index 0x%x)",
+				psge, req_idx));
+
+		/* Start the SGE for the next buffer
+		 */
+		psge = (char *) (hd->ChainBuffer + chain_dma_off);
+		sgeOffset = 0;
+		sg_done = 0;
+
+		dsgprintk((KERN_INFO "  Chain buff @ %p (index 0x%x)\n",
+				psge, chain_idx));
+
+		/* Start the SGE for the next buffer
+		 */
+
+		goto nextSGEset;
+	}
+
+	return SUCCESS;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_getFreeChainBuffes - Function to get a free chain
+ *	from the MPT_SCSI_HOST FreeChainQ.
+ *	@hd: Pointer to the MPT_SCSI_HOST instance
+ *	@req_idx: Index of the SCSI IO request frame. (output)
+ *
+ *	return SUCCESS or FAILED
+ */
+static int
+mptscsih_getFreeChainBuffer(MPT_SCSI_HOST *hd, int *retIndex)
+{
+	MPT_FRAME_HDR *chainBuf = NULL;
+	unsigned long flags;
+	int rc = FAILED;
+	int chain_idx = MPT_HOST_NO_CHAIN;
+
+	//spin_lock_irqsave(&hd->FreeChainQlock, flags);
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	if (!Q_IS_EMPTY(&hd->FreeChainQ)) {
+
+		int offset;
+
+		chainBuf = hd->FreeChainQ.head;
+		Q_DEL_ITEM(&chainBuf->u.frame.linkage);
+		offset = (u8 *)chainBuf - (u8 *)hd->ChainBuffer;
+		chain_idx = offset / hd->ioc->req_sz;
+		rc = SUCCESS;
 	}
+	//spin_unlock_irqrestore(&hd->FreeChainQlock, flags);
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+
+	*retIndex = chain_idx;
+
+	dsgprintk((MYIOC_s_INFO_FMT "getFreeChainBuffer (index %d), got buf=%p\n",
+			hd->ioc->name, *retIndex, chainBuf));
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_freeChainBuffers - Function to free chain buffers associated
+ *	with a SCSI IO request
+ *	@hd: Pointer to the MPT_SCSI_HOST instance
+ *	@req_idx: Index of the SCSI IO request frame.
+ *
+ *	Called if SG chain buffer allocation fails and mptscsih callbacks.
+ *	No return.
+ */
+static void
+mptscsih_freeChainBuffers(MPT_SCSI_HOST *hd, int req_idx)
+{
+	MPT_FRAME_HDR *chain = NULL;
+	unsigned long flags;
+	int chain_idx;
+	int next;
+
+	/* Get the first chain index and reset
+	 * tracker state.
+	 */
+	chain_idx = hd->ReqToChain[req_idx];
+	hd->ReqToChain[req_idx] = MPT_HOST_NO_CHAIN;
 
-#ifdef MPT_DEBUG
-	/* if (SCpnt->request_bufflen > max_xfer) */
-	if (len > max_xfer) {
-		max_xfer = len;
-		dprintk((KERN_INFO MYNAM ": MPT_MaxXfer = %d\n", max_xfer));
+	while (chain_idx != MPT_HOST_NO_CHAIN) {
+
+		/* Save the next chain buffer index */
+		next = hd->ChainToChain[chain_idx];
+
+		/* Free this chain buffer and reset
+		 * tracker
+		 */
+		hd->ChainToChain[chain_idx] = MPT_HOST_NO_CHAIN;
+
+		chain = (MPT_FRAME_HDR *) (hd->ChainBuffer
+					+ (chain_idx * hd->ioc->req_sz));
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		Q_ADD_TAIL(&hd->FreeChainQ.head,
+					&chain->u.frame.linkage, MPT_FRAME_HDR);
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+		dmfprintk((MYIOC_s_INFO_FMT "FreeChainBuffers (index %d)\n",
+				hd->ioc->name, chain_idx));
+
+		/* handle next */
+		chain_idx = next;
+	}
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	Reset Handling
+ */
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_TMHandler - Generic handler for SCSI Task Management.
+ *	Fall through to mpt_HardResetHandler if: not operational, too many
+ *	failed TM requests or handshake failure.
+ *
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@type: Task Management type
+ *	@target: Logical Target ID for reset (if appropriate)
+ *	@lun: Logical Unit for reset (if appropriate)
+ *	@ctx2abort: Context for the task to be aborted (if appropriate)
+ *	@sleepFlag: If set, use udelay instead of schedule in handshake code.
+ *
+ *	Remark: Currently invoked from a non-interrupt thread (_bh).
+ *
+ *	Remark: With old EH code, at most 1 SCSI TaskMgmt function per IOC
+ *	will be active.
+ *
+ *	Returns 0 for SUCCESS or -1 if FAILED.
+ */
+static int
+mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag)
+{
+	MPT_ADAPTER	*ioc = NULL;
+	int		 rc = -1;
+	int		 doTask = 1;
+	u32		 ioc_raw_state;
+	unsigned long	 flags;
+
+	/* If FW is being reloaded currently, return success to
+	 * the calling function.
+	 */
+	if (hd == NULL)
+		return 0;
+
+	ioc = hd->ioc;
+	dtmprintk((MYIOC_s_INFO_FMT "TMHandler Entered!\n", ioc->name));
+
+	if (ioc == NULL) {
+		printk(KERN_ERR MYNAM " TMHandler" " NULL ioc!\n");
+		return 0;
+	}
+
+	// SJR - CHECKME - Can we avoid this here?
+	// (mpt_HardResetHandler has this check...)
+	spin_lock_irqsave(&ioc->diagLock, flags);
+	if ((ioc->diagPending) || (ioc->alt_ioc && ioc->alt_ioc->diagPending)) {
+		spin_unlock_irqrestore(&ioc->diagLock, flags);
+		return 0;
+	}
+	spin_unlock_irqrestore(&ioc->diagLock, flags);
+
+	/* Do not do a Task Management if there are
+	 * too many failed TMs on this adapter.
+	 */
+	if (hd->numTMrequests > MPT_HOST_TOO_MANY_TM)
+		doTask = 0;
+
+	/* Is operational?
+	 */
+	ioc_raw_state = mpt_GetIocState(hd->ioc, 0);
+
+#ifdef MPT_DEBUG_RESET
+	if ((ioc_raw_state & MPI_IOC_STATE_MASK) != MPI_IOC_STATE_OPERATIONAL) {
+		printk(MYIOC_s_WARN_FMT 
+			"TM Handler: IOC Not operational! state 0x%x Calling HardResetHandler\n", 
+			hd->ioc->name, ioc_raw_state);
 	}
 #endif
 
-	hd->ScsiLookup[my_idx] = SCpnt;
+	if (doTask && ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_OPERATIONAL)
+				&& !(ioc_raw_state & MPI_DOORBELL_ACTIVE)) {
 
-	/* Main banana... */
-	mpt_put_msg_frame(ScsiDoneCtx, hd->ioc->id, mf);
+		/* Isse the Task Mgmt request.
+		 */
+		rc = mptscsih_IssueTaskMgmt(hd, type, target, lun, ctx2abort, sleepFlag);
+		if (rc) {
+#ifdef MPT_SCSI_USE_NEW_EH
+			hd->tmState = TM_STATE_ERROR;
+#endif
+			printk(MYIOC_s_INFO_FMT "Issue of TaskMgmt failed!\n", hd->ioc->name);
+		} else {
+			printk(MYIOC_s_INFO_FMT "Issue of TaskMgmt Successful!\n", hd->ioc->name);
+		}
+	}
+#ifdef DROP_TEST
+	numTMrequested++;
+	if (numTMrequested > 5) {
+		rc = 0;		/* set to 1 to force a hard reset */
+		numTMrequested = 0;
+	}
+#endif
 
-	atomic_inc(&queue_depth);
-	if (atomic_read(&queue_depth) > max_qd) {
-		max_qd = atomic_read(&queue_depth);
-		dprintk((KERN_INFO MYNAM ": Queue depth now %d.\n", max_qd));
+	if (rc) {
+		dtmprintk((MYIOC_s_INFO_FMT "Falling through to HardReset! \n",
+			 hd->ioc->name));
+		rc = mpt_HardResetHandler(hd->ioc, sleepFlag);
 	}
 
-	dmfprintk((KERN_INFO MYNAM ": Issued SCSI cmd (%p)\n", SCpnt));
+	dtmprintk((MYIOC_s_INFO_FMT "TMHandler rc = %d!\n", hd->ioc->name, rc));
+#ifndef MPT_SCSI_USE_NEW_EH
+	dtmprintk((MYIOC_s_INFO_FMT "TMHandler: _bh_handler state (%d) taskQ count (%d)\n",
+		ioc->name, mytaskQ_bh_active, hd->taskQcnt));
+#endif
 
-	return 0;
+	return rc;
 }
 
-#ifdef MPT_SCSI_USE_NEW_EH		/* { */
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
-    mptscsih_abort
-    Returns: 0=SUCCESS, else FAILED
-*/
+ *	mptscsih_IssueTaskMgmt - Generic send Task Management function.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@type: Task Management type
+ *	@target: Logical Target ID for reset (if appropriate)
+ *	@lun: Logical Unit for reset (if appropriate)
+ *	@ctx2abort: Context for the task to be aborted (if appropriate)
+ *	@sleepFlag: If set, use udelay instead of schedule in handshake code.
+ *
+ *	Remark: _HardResetHandler can be invoked from an interrupt thread (timer)
+ *	or a non-interrupt thread.  In the former, must not call schedule().
+ *
+ *	Not all fields are meaningfull for all task types.
+ *
+ *	Returns 0 for SUCCESS, -999 for "no msg frames",
+ *	else other non-zero value returned.
+ */
+static int
+mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag)
+{
+	MPT_FRAME_HDR	*mf;
+	SCSITaskMgmt_t	*pScsiTm;
+	int		 ii;
+	int		 retval;
+
+	/* Return Fail to calling function if no message frames available.
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
+		dtmprintk((MYIOC_s_WARN_FMT "IssueTaskMgmt, no msg frames!!\n",
+				hd->ioc->name));
+		//return FAILED;
+		return -999;
+	}
+	dtmprintk((MYIOC_s_INFO_FMT "IssueTaskMgmt request @ %p\n",
+			hd->ioc->name, mf));
+
+	/* Format the Request
+	 */
+	pScsiTm = (SCSITaskMgmt_t *) mf;
+	pScsiTm->TargetID = target;
+	pScsiTm->Bus = hd->port;
+	pScsiTm->ChainOffset = 0;
+	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+
+	pScsiTm->Reserved = 0;
+	pScsiTm->TaskType = type;
+	pScsiTm->Reserved1 = 0;
+	pScsiTm->MsgFlags = (type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS)
+	                    ? MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION : 0;
+
+	for (ii= 0; ii < 8; ii++) {
+		pScsiTm->LUN[ii] = 0;
+	}
+	pScsiTm->LUN[1] = lun;
+
+	for (ii=0; ii < 7; ii++)
+		pScsiTm->Reserved2[ii] = 0;
+
+	pScsiTm->TaskMsgContext = ctx2abort;
+	dtmprintk((MYIOC_s_INFO_FMT "IssueTaskMgmt, ctx2abort (0x%08x), type (%d)\n",
+			hd->ioc->name, ctx2abort, type));
+
+	/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
+		mpt_put_msg_frame(hd->ioc->id, mf);
+	* Save the MF pointer in case the request times out.
+	*/
+	hd->tmPtr = mf;
+	hd->numTMrequests++;
+	hd->TMtimer.expires = jiffies + HZ*20;  /* 20 seconds */
+	add_timer(&hd->TMtimer);
+
+	if ((retval = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
+				sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, sleepFlag))
+	!= 0) {
+		dtmprintk((MYIOC_s_WARN_FMT "_send_handshake FAILED!"
+			" (hd %p, ioc %p, mf %p) \n", hd->ioc->name, hd, hd->ioc, mf));
+		hd->numTMrequests--;
+		hd->tmPtr = NULL;
+		del_timer(&hd->TMtimer);
+		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+	}
+
+	return retval;
+}
+
+#ifdef MPT_SCSI_USE_NEW_EH		/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptscsih_abort - Abort linux Scsi_Cmnd routine, new_eh variant
@@ -1274,53 +2563,73 @@
  *
  *	(linux Scsi_Host_Template.eh_abort_handler routine)
  *
- *	Returns SUCCESS or FAILED.  
+ *	Returns SUCCESS or FAILED.
  */
 int
 mptscsih_abort(Scsi_Cmnd * SCpnt)
 {
-	MPT_FRAME_HDR	*mf;
-	SCSITaskMgmt_t	*pScsiTm;
 	MPT_SCSI_HOST	*hd;
-	u32		*msg;
-	u32		 ctx2abort;
-	int		 i;
+	MPT_FRAME_HDR	*mf;
 	unsigned long	 flags;
+	u32		 ctx2abort;
+	int		 scpnt_idx;
 
-	printk(KERN_WARNING MYNAM ": Attempting _ABORT SCSI IO (=%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
-
-	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
-
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
+	/* If we can't locate our host adapter structure, return FAILED status.
+	 */
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
+		SCpnt->result = DID_RESET << 16;
 		SCpnt->scsi_done(SCpnt);
+		nehprintk((KERN_WARNING MYNAM ": mptscsih_abort: "
+			   "Can't locate host! (sc=%p)\n",
+			   SCpnt));
 		return FAILED;
 	}
 
-	pScsiTm = (SCSITaskMgmt_t *) mf;
-	msg = (u32 *) mf;
+	printk(KERN_WARNING MYNAM ": %s: >> Attempting task abort! (sc=%p)\n",
+	       hd->ioc->name, SCpnt);
+	printk(KERN_WARNING MYNAM ": %s: IOs outstanding = %d\n",
+	       hd->ioc->name, atomic_read(&queue_depth));
 
-	pScsiTm->TargetID = SCpnt->target;
-	pScsiTm->Bus = hd->port;
-	pScsiTm->ChainOffset = 0;
-	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+	/* Find this command
+	 */
+	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
+		/* Cmd not found in ScsiLookup. If found in
+		 * doneQ, delete from Q. Do OS callback.
+		 */
+		search_doneQ_for_cmd(hd, SCpnt);
 
-	pScsiTm->Reserved = 0;
-	pScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
-	pScsiTm->Reserved1 = 0;
-	pScsiTm->MsgFlags = 0;
+		SCpnt->result = DID_RESET << 16;
+		SCpnt->scsi_done(SCpnt);
+		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_abort: "
+			   "Command not in the active list! (sc=%p)\n",
+			   hd->ioc->name, SCpnt));
+		return SUCCESS;
+	}
 
-	for (i = 0; i < 8; i++) {
-		u8 val = 0;
-		if (i == 1)
-			val = SCpnt->lun;
-		pScsiTm->LUN[i] = val;
+	/*  Wait a fixed amount of time for the TM pending flag to be cleared.
+	 *  If we time out, then we return a FAILED status to the caller.  This
+	 *  call to mptscsih_tm_pending_wait() will set the pending flag if we are
+	 *  successful.
+	 */
+	if (mptscsih_tm_pending_wait(hd) == FAILED){
+		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_abort: "
+			   "Timed out waiting for previous TM to complete! "
+			   "(sc = %p)\n",
+			   hd->ioc->name, SCpnt));
+		return FAILED;
 	}
 
-	for (i = 0; i < 7; i++)
-		pScsiTm->Reserved2[i] = 0;
+	/* If this command is pended, then timeout/hang occurred
+	 * during DV. Post command and flush pending Q
+	 * and then following up with the reset request.
+	 */
+	if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		post_pendingQ_commands(hd);
+		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_abort: "
+			   "Found command in pending queue! (sc=%p)\n",
+			   hd->ioc->name, SCpnt));
+	}
 
 	/* Most important!  Set TaskMsgContext to SCpnt's MsgContext!
 	 * (the IO to be ABORT'd)
@@ -1329,38 +2638,65 @@
 	 *	 swap it here either.  It is an opaque cookie to
 	 *	 the controller, so it does not matter. -DaveM
 	 */
-	ctx2abort = SCPNT_TO_MSGCTX(SCpnt);
-	if (ctx2abort == -1) {
-		printk(KERN_ERR MYNAM ": ERROR - ScsiLookup fail(#2) for SCpnt=%p\n", SCpnt);
-		SCpnt->result = DID_SOFT_ERROR << 16;
-		spin_lock_irqsave(SCpnt->host->host_lock, flags);
-		SCpnt->scsi_done(SCpnt);
-		spin_unlock_irqrestore(SCpnt->host->host_lock, flags);
-		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-	} else {
-		dprintk((KERN_INFO MYNAM ":DbG: ctx2abort = %08x\n", ctx2abort));
-		pScsiTm->TaskMsgContext = ctx2abort;
+	mf = MPT_INDEX_2_MFPTR(hd->ioc, scpnt_idx);
+	ctx2abort = mf->u.frame.hwhdr.msgctxu.MsgContext;
 
+	hd->abortSCpnt = SCpnt;
 
-		/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
-			mpt_put_msg_frame(hd->ioc->id, mf);
-		*/
-		if ((i = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
-					sizeof(SCSITaskMgmt_t), msg))
-		    != 0) {
-			printk(KERN_WARNING MYNAM
-					": WARNING[2] - IOC error (%d) processing TaskMgmt request (mf=%p:sc=%p)\n",
-					i, mf, SCpnt);
-			SCpnt->result = DID_SOFT_ERROR << 16;
-			spin_lock_irqsave(SCpnt->host->host_lock, flags);
+	if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK,
+	                       SCpnt->target, SCpnt->lun, ctx2abort, CAN_SLEEP) 
+		< 0
+	    || hd->tmState == TM_STATE_ERROR) {
+
+		/* The TM request failed and the subsequent FW-reload failed!
+		 * Fatal error case.
+		 */
+		printk(MYIOC_s_WARN_FMT "Error issuing abort task! (sc=%p)\n",
+		       hd->ioc->name, SCpnt);
+
+		/* If command not found, do not do callback,
+		 *  just return failed.  CHECKME
+		 */
+		if (hd->ScsiLookup[scpnt_idx] != NULL) {
+			SCpnt->result = STS_BUSY;
 			SCpnt->scsi_done(SCpnt);
-			spin_unlock_irqrestore(SCpnt->host->host_lock, flags);
-			mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
 		}
+
+		/* We must clear our pending flag before clearing our state.
+		 */
+		hd->tmPending = 0;
+		hd->tmState = TM_STATE_NONE;
+
+		return FAILED;
+	}
+
+	/* Our task management request will either complete or time out.  So we
+	 * spin until tmPending is != 1. If tmState is set to TM_STATE_ERROR, 
+	 * we encountered an error executing the task management request.
+	 */
+	while (hd->tmPending == 1){
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+	}
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	if (hd->tmState == TM_STATE_ERROR){
+		hd->tmState = TM_STATE_NONE;
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_abort: "
+			   "TM timeout error! (sc=%p)\n",
+			   hd->ioc->name,
+			   SCpnt));
+		return FAILED;
 	}
+	hd->tmState = TM_STATE_NONE;
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_abort: "
+		   "Abort was successful! (sc=%p)\n",
+		   hd->ioc->name,
+		   SCpnt));
 
-	//return SUCCESS;
-	return FAILED;
+	return SUCCESS;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -1375,67 +2711,76 @@
 int
 mptscsih_dev_reset(Scsi_Cmnd * SCpnt)
 {
-	MPT_FRAME_HDR	*mf;
-	SCSITaskMgmt_t	*pScsiTm;
 	MPT_SCSI_HOST	*hd;
-	u32		*msg;
-	int		 i;
 	unsigned long	 flags;
 
-	printk(KERN_WARNING MYNAM ": Attempting _TARGET_RESET (%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
-
-	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
-
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
+	/* If we can't locate our host adapter structure, return FAILED status.
+	 */
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL){
+		nehprintk((KERN_WARNING MYNAM ": mptscsih_dev_reset: "
+			   "Can't locate host! (sc=%p)\n",
+			   SCpnt));
 		return FAILED;
 	}
 
-	pScsiTm = (SCSITaskMgmt_t *) mf;
-	msg = (u32*)mf;
-
-	pScsiTm->TargetID = SCpnt->target;
-	pScsiTm->Bus = hd->port;
-	pScsiTm->ChainOffset = 0;
-	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
-
-	pScsiTm->Reserved = 0;
-	pScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET;
-	pScsiTm->Reserved1 = 0;
-	pScsiTm->MsgFlags = 0;
-
-	/* _TARGET_RESET goes to LUN 0 always! */
-	for (i = 0; i < 8; i++)
-		pScsiTm->LUN[i] = 0;
-
-	/* Control: No data direction, set task mgmt bit? */
-	for (i = 0; i < 7; i++)
-		pScsiTm->Reserved2[i] = 0;
+	printk(KERN_WARNING MYNAM ": %s: >> Attempting target reset! (sc=%p)\n",
+	       hd->ioc->name, SCpnt);
+	printk(KERN_WARNING MYNAM ": %s: IOs outstanding = %d\n",
+	       hd->ioc->name, atomic_read(&queue_depth));
+
+	/*  Wait a fixed amount of time for the TM pending flag to be cleared.
+	 *  If we time out, then we return a FAILED status to the caller.  This
+	 *  call to mptscsih_tm_pending_wait() will set the pending flag if we are
+	 *  successful.
+	 */
+	if (mptscsih_tm_pending_wait(hd) == FAILED) {
+		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_dev_reset: "
+			   "Timed out waiting for previous TM to complete! "
+			   "(sc = %p)\n",
+			   hd->ioc->name, SCpnt));
+		return FAILED;
+	}
 
-	pScsiTm->TaskMsgContext = cpu_to_le32(0);
+	if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,
+	                       SCpnt->target, 0, 0, CAN_SLEEP) 
+		< 0){
+		/* The TM request failed and the subsequent FW-reload failed!
+		 * Fatal error case.
+		 */
+		printk(MYIOC_s_WARN_FMT "Error processing TaskMgmt request (sc=%p)\n",
+		 		hd->ioc->name, SCpnt);
+		hd->tmPending = 0;
+		hd->tmState = TM_STATE_NONE;
+		return FAILED;
+	}
 
-/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
-	mpt_put_msg_frame(hd->ioc->id, mf);
-*/
-/* FIXME!  Check return status! */
-	if ((i = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
-				sizeof(SCSITaskMgmt_t), msg))
-	    != 0) {
-		printk(KERN_WARNING MYNAM
-				": WARNING[3] - IOC error (%d) processing TaskMgmt request (mf=%p:sc=%p)\n",
-				i, mf, SCpnt);
-		SCpnt->result = DID_SOFT_ERROR << 16;
-		spin_lock_irqsave(SCpnt->host->host_lock, flags);
-		SCpnt->scsi_done(SCpnt);
-		spin_unlock_irqrestore(SCpnt->host->host_lock, flags);
-		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+	/* Our task management request will either complete or time out.  So we
+	 * spin until tmPending is != 1. If tmState is set to TM_STATE_ERROR, 
+	 * we encountered an error executing the task management request.
+	 */
+	while (hd->tmPending == 1){
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+	}
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	if (hd->tmState == TM_STATE_ERROR){
+		hd->tmState = TM_STATE_NONE;
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_dev_reset: "
+			   "TM timeout error! (sc=%p)\n",
+			   hd->ioc->name,
+			   SCpnt));
+		return FAILED;
 	}
+	hd->tmState = TM_STATE_NONE;
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
-	//return SUCCESS;
-	return FAILED;
+	nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_dev_reset: "
+		   "Device reset was successful! (sc=%p)\n",
+		   hd->ioc->name,
+		   SCpnt));
+
+	return SUCCESS;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -1450,68 +2795,81 @@
 int
 mptscsih_bus_reset(Scsi_Cmnd * SCpnt)
 {
-	MPT_FRAME_HDR	*mf;
-	SCSITaskMgmt_t	*pScsiTm;
 	MPT_SCSI_HOST	*hd;
-	u32		*msg;
-	int		 i;
 	unsigned long	 flags;
 
-	printk(KERN_WARNING MYNAM ": Attempting _BUS_RESET (%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
-
-	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
-
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
+	/* If we can't locate our host adapter structure, return FAILED status.
+	 */
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL){
+		nehprintk((KERN_WARNING MYNAM ": mptscsih_bus_reset: "
+			   "Can't locate host! (sc=%p)\n",
+			   SCpnt ) );
 		return FAILED;
 	}
 
-	pScsiTm = (SCSITaskMgmt_t *) mf;
-	msg = (u32 *) mf;
-
-	pScsiTm->TargetID = SCpnt->target;
-	pScsiTm->Bus = hd->port;
-	pScsiTm->ChainOffset = 0;
-	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
-
-	pScsiTm->Reserved = 0;
-	pScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
-	pScsiTm->Reserved1 = 0;
-	pScsiTm->MsgFlags = 0;
-
-	for (i = 0; i < 8; i++)
-		pScsiTm->LUN[i] = 0;
+	printk(KERN_WARNING MYNAM ": %s: >> Attempting bus reset! (sc=%p)\n",
+	       hd->ioc->name, SCpnt);
+	printk(KERN_WARNING MYNAM ": %s: IOs outstanding = %d\n",
+	       hd->ioc->name, atomic_read(&queue_depth));
+
+	/*  Wait a fixed amount of time for the TM pending flag to be cleared.
+	 *  If we time out, then we return a FAILED status to the caller.  This
+	 *  call to mptscsih_tm_pending_wait() will set the pending flag if we are
+	 *  successful.
+	 */
+	if (mptscsih_tm_pending_wait(hd) == FAILED) {
+		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_bus_reset: "
+			   "Timed out waiting for previous TM to complete! "
+			   "(sc = %p)\n",
+			   hd->ioc->name, SCpnt ) );
+		return FAILED;
+	}
 
-	/* Control: No data direction, set task mgmt bit? */
-	for (i = 0; i < 7; i++)
-		pScsiTm->Reserved2[i] = 0;
+	/* We are now ready to execute the task management request. */
+	if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,
+	                       0, 0, 0, CAN_SLEEP) 
+	    < 0){
 
-	pScsiTm->TaskMsgContext = cpu_to_le32(0);
+		/* The TM request failed and the subsequent FW-reload failed!
+		 * Fatal error case.
+		 */
+		printk(MYIOC_s_WARN_FMT 
+		       "Error processing TaskMgmt request (sc=%p)\n",
+		       hd->ioc->name, SCpnt);
+		hd->tmPending = 0;
+		hd->tmState = TM_STATE_NONE;
+		return FAILED;
+	}
 
-/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
-	mpt_put_msg_frame(hd->ioc->id, mf);
-*/
-/* FIXME!  Check return status! */
-	if ((i = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
-				sizeof(SCSITaskMgmt_t), msg))
-	    != 0) {
-		printk(KERN_WARNING MYNAM
-				": WARNING[4] - IOC error (%d) processing TaskMgmt request (mf=%p:sc=%p)\n",
-				i, mf, SCpnt);
-		SCpnt->result = DID_SOFT_ERROR << 16;
-		spin_lock_irqsave(SCpnt->host->host_lock, flags);
-		SCpnt->scsi_done(SCpnt);
-		spin_unlock_irqrestore(SCpnt->host->host_lock, flags);
-		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+	/* Our task management request will either complete or time out.  So we
+	 * spin until tmPending is != 1. If tmState is set to TM_STATE_ERROR, 
+	 * we encountered an error executing the task management request.
+	 */
+	while (hd->tmPending == 1){
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+	}
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	if (hd->tmState == TM_STATE_ERROR){
+		hd->tmState = TM_STATE_NONE;
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_bus_reset: "
+			   "TM timeout error! (sc=%p)\n",
+			   hd->ioc->name,
+			   SCpnt));
+		return FAILED;
 	}
+	hd->tmState = TM_STATE_NONE;
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_bus_reset: "
+		   "Bus reset was successful! (sc=%p)\n",
+		   hd->ioc->name,
+		   SCpnt));
 
 	return SUCCESS;
 }
 
-#if 0	/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptscsih_host_reset - Perform a SCSI host adapter RESET!
@@ -1523,11 +2881,77 @@
  *	Returns SUCCESS or FAILED.
  */
 int
-mptscsih_host_reset(Scsi_Cmnd * SCpnt)
+mptscsih_host_reset(Scsi_Cmnd *SCpnt)
 {
-	return FAILED;
+	MPT_SCSI_HOST *  hd;
+	int              status = SUCCESS;
+
+	/*  If we can't locate the host to reset, then we failed. */
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL){
+		nehprintk( ( KERN_WARNING MYNAM ": mptscsih_host_reset: "
+			     "Can't locate host! (sc=%p)\n",
+			     SCpnt ) );
+		return FAILED;
+	}
+
+	printk(KERN_WARNING MYNAM ": %s: >> Attempting host reset! (sc=%p)\n",
+	       hd->ioc->name, SCpnt);
+	printk(KERN_WARNING MYNAM ": %s: IOs outstanding = %d\n",
+	       hd->ioc->name, atomic_read(&queue_depth));
+
+	/*  If our attempts to reset the host failed, then return a failed
+	 *  status.  The host will be taken off line by the SCSI mid-layer.
+	 */
+	if (mpt_HardResetHandler(hd->ioc, CAN_SLEEP) < 0){
+		status = FAILED;
+	} else {
+		/*  Make sure TM pending is cleared and TM state is set to 
+		 *  NONE. 
+		 */
+		hd->tmPending = 0;
+		hd->tmState = TM_STATE_NONE;
+	}
+
+
+	nehprintk( ( KERN_WARNING MYNAM ": mptscsih_host_reset: "
+		     "Status = %s\n",
+		     (status == SUCCESS) ? "SUCCESS" : "FAILED" ) );
+
+	return status;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_tm_pending_wait - wait for pending task management request to 
+ *		complete.
+ *	@hd: Pointer to MPT host structure.
+ *
+ *	Returns {SUCCESS,FAILED}.
+ */
+static int
+mptscsih_tm_pending_wait(MPT_SCSI_HOST * hd)
+{
+	unsigned long  flags;
+	int            loop_count = 60 * 4;  /* Wait 60 seconds */
+	int            status = FAILED;
+
+	do {
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		if (hd->tmState == TM_STATE_NONE) {
+			hd->tmState = TM_STATE_IN_PROGRESS;
+			hd->tmPending = 1;
+			spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+			status = SUCCESS;
+			break;
+		}
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+
+	} while (--loop_count);
+
+	return status;
 }
-#endif	/* } */
 
 #else		/* MPT_SCSI old EH stuff... */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -1546,57 +2970,121 @@
 	MPT_FRAME_HDR		*mf;
 	struct tq_struct	*ptaskfoo;
 	unsigned long		 flags;
+	int			 scpnt_idx;
 
-	printk(KERN_WARNING MYNAM ": Scheduling _ABORT SCSI IO (=%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+	printk(KERN_WARNING MYNAM ": OldAbort scheduling ABORT SCSI IO (sc=%p)\n", (void *) SCpnt);
+	printk(KERN_WARNING "  IOs outstanding = %d\n", atomic_read(&queue_depth));
 
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
-		SCpnt->result = DID_ABORT << 16;
+		printk(KERN_WARNING "  WARNING - OldAbort, NULL hostdata ptr!!\n");
+		SCpnt->result = DID_ERROR << 16;
+		SCpnt->scsi_done(SCpnt);
+		return SCSI_ABORT_NOT_RUNNING;
+	}
+
+	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
+		/* Cmd not found in ScsiLookup.
+		 * If found in doneQ, delete from Q.
+		 * Do OS callback.
+		 */
+		search_doneQ_for_cmd(hd, SCpnt);
+
+		SCpnt->result = DID_RESET << 16;
 		SCpnt->scsi_done(SCpnt);
 		return SCSI_ABORT_SUCCESS;
+	} else {
+		/* If this command is pended, then timeout/hang occurred
+		 * during DV. Force bus reset by posting command to F/W
+		 * and then following up with the reset request.
+		 */
+		if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+			post_pendingQ_commands(hd);
+		}
 	}
 
 	/*
 	 *  Check to see if there's already an ABORT queued for this guy.
 	 */
-	mf = search_taskQ(0,SCpnt,MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
+	mf = search_taskQ(0, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
 	if (mf != NULL) {
+		dtmprintk((MYIOC_s_INFO_FMT "OldAbort:Abort Task PENDING cmd (%p) taskQ depth (%d)\n",
+			hd->ioc->name, SCpnt, hd->taskQcnt));
+		return SCSI_ABORT_PENDING;
+	}
+
+	// SJR - CHECKME - Can we avoid this here?
+	// (mpt_HardResetHandler has this check...)
+	/* If IOC is reloading FW, return PENDING.
+	 */
+	spin_lock_irqsave(&hd->ioc->diagLock, flags);
+	if (hd->ioc->diagPending) {
+		spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
 		return SCSI_ABORT_PENDING;
 	}
+	spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
 
+	/* If there are no message frames what should we do?
+	 */
 	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-		return SCSI_ABORT_BUSY;
+		printk((KERN_WARNING "  WARNING - OldAbort, no msg frames!!\n"));
+		/* We are out of message frames!
+		 * Call the reset handler to do a FW reload.
+		 */
+		printk((KERN_WARNING " Reloading Firmware!!\n"));
+		if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
+			printk((KERN_WARNING " Firmware Reload FAILED!!\n"));
+		}
+		return SCSI_ABORT_PENDING;
 	}
 
 	/*
-	 *  Add ourselves to (end of) mpt_scsih_taskQ.
+	 *  Add ourselves to (end of) taskQ .
 	 *  Check to see if our _bh is running.  If NOT, schedule it.
 	 */
-	dslprintk((KERN_INFO MYNAM ": spinlock#2\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	Q_ADD_TAIL(&mpt_scsih_taskQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
-	mpt_scsih_taskQ_cnt++;
-	/* Yikes - linkage! */
-/*	SCpnt->host_scribble = (unsigned char *)mf;	*/
-	mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	Q_ADD_TAIL(&hd->taskQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+	hd->taskQcnt++;
+	atomic_inc(&mpt_taskQdepth);
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+
+	/* Save the original SCpnt mf pointer
+	 */
+	SCpnt->host_scribble = (u8 *) MPT_INDEX_2_MFPTR (hd->ioc, scpnt_idx);
+
+	/* For the time being, force bus reset on any abort
+	 * requests for the 1030 FW.
+	 */
+	if (hd->is_spi)
+		mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
+	else
+		mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
+
 	mf->u.frame.linkage.argp1 = SCpnt;
-	if (! mpt_scsih_taskQ_bh_active) {
-		mpt_scsih_taskQ_bh_active = 1;
+	mf->u.frame.linkage.argp2 = (void *) hd;
+
+	dtmprintk((MYIOC_s_INFO_FMT "OldAbort:_bh_handler state (%d) taskQ count (%d)\n",
+		hd->ioc->name, mytaskQ_bh_active, hd->taskQcnt));
+
+	if (! mytaskQ_bh_active) {
+		mytaskQ_bh_active = 1;
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
+
 		/*
 		 *  Oh how cute, no alloc/free/mgmt needed if we use
 		 *  (bottom/unused portion of) MPT request frame.
 		 */
-		ptaskfoo = (struct tq_struct *) ((u8*)mf + hd->ioc->req_sz - sizeof(*ptaskfoo));
+		ptaskfoo = (struct tq_struct *) &mptscsih_ptaskfoo;
 		ptaskfoo->sync = 0;
 		ptaskfoo->routine = mptscsih_taskmgmt_bh;
 		ptaskfoo->data = SCpnt;
 
 		SCHEDULE_TASK(ptaskfoo);
+	} else  {
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 	}
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
 
 	return SCSI_ABORT_PENDING;
 }
@@ -1618,9 +3106,10 @@
 	MPT_FRAME_HDR		*mf;
 	struct tq_struct	*ptaskfoo;
 	unsigned long		 flags;
+	int			 scpnt_idx;
 
-	printk(KERN_WARNING MYNAM ": Scheduling _BUS_RESET (=%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+	printk(KERN_WARNING MYNAM ": OldReset scheduling BUS_RESET (sc=%p)\n", (void *) SCpnt);
+	printk(KERN_WARNING "  IOs outstanding = %d\n", atomic_read(&queue_depth));
 
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
 		SCpnt->result = DID_RESET << 16;
@@ -1628,48 +3117,104 @@
 		return SCSI_RESET_SUCCESS;
 	}
 
+	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
+		/* Cmd not found in ScsiLookup.
+		 * If found in doneQ, delete from Q.
+		 * Do OS callback.
+		 */
+		search_doneQ_for_cmd(hd, SCpnt);
+
+		SCpnt->result = DID_RESET << 16;
+		SCpnt->scsi_done(SCpnt);
+		return SCSI_RESET_SUCCESS;
+	} else {
+		/* If this command is pended, then timeout/hang occurred
+		 * during DV. Force bus reset by posting command to F/W
+		 * and then following up with the reset request.
+		 */
+		if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+			post_pendingQ_commands(hd);
+		}
+	}
+
+	/*
+	 *  Check to see if there's an ABORT_TASK queued for this guy.
+	 *  If so, delete.
+	 */
+	search_taskQ(1, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
+
 	/*
 	 *  Check to see if there's already a BUS_RESET queued for this guy.
 	 */
-	mf = search_taskQ(0,SCpnt,MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS);
+	mf = search_taskQ(0, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS);
 	if (mf != NULL) {
+		dtmprintk((MYIOC_s_INFO_FMT "OldReset:Reset Task PENDING cmd (%p) taskQ depth (%d)\n",
+			hd->ioc->name, SCpnt, hd->taskQcnt));
+		return SCSI_RESET_PENDING;
+	}
+
+	// SJR - CHECKME - Can we avoid this here?
+	// (mpt_HardResetHandler has this check...)
+	/* If IOC is reloading FW, return PENDING.
+	 */
+	spin_lock_irqsave(&hd->ioc->diagLock, flags);
+	if (hd->ioc->diagPending) {
+		spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
 		return SCSI_RESET_PENDING;
 	}
+	spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
 
 	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-		return SCSI_RESET_PUNT;
+		/* We are out of message frames!
+		 * Call the reset handler to do a FW reload.
+		 */
+		printk((KERN_WARNING " Reloading Firmware!!\n"));
+		if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
+			printk((KERN_WARNING " Firmware Reload FAILED!!\n"));
+		}
+		return SCSI_RESET_PENDING;
 	}
 
 	/*
-	 *  Add ourselves to (end of) mpt_scsih_taskQ.
+	 *  Add ourselves to (end of) taskQ.
 	 *  Check to see if our _bh is running.  If NOT, schedule it.
 	 */
-	dslprintk((KERN_INFO MYNAM ": spinlock#3\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	Q_ADD_TAIL(&mpt_scsih_taskQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
-	mpt_scsih_taskQ_cnt++;
-	/* Yikes - linkage! */
-/*	SCpnt->host_scribble = (unsigned char *)mf;	*/
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	Q_ADD_TAIL(&hd->taskQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+	hd->taskQcnt++;
+	atomic_inc(&mpt_taskQdepth);
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+
+	dtmprintk((MYIOC_s_INFO_FMT "OldReset: _bh_handler state (%d) taskQ count (%d)\n",
+		hd->ioc->name, mytaskQ_bh_active, hd->taskQcnt));
+
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+	/* Save the original SCpnt mf pointer
+	 */
+	SCpnt->host_scribble = (u8 *) MPT_INDEX_2_MFPTR (hd->ioc, scpnt_idx);
+
 	mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
 	mf->u.frame.linkage.argp1 = SCpnt;
-	if (! mpt_scsih_taskQ_bh_active) {
-		mpt_scsih_taskQ_bh_active = 1;
+	mf->u.frame.linkage.argp2 = (void *) hd;
+
+	if (! mytaskQ_bh_active) {
+		mytaskQ_bh_active = 1;
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 		/*
 		 *  Oh how cute, no alloc/free/mgmt needed if we use
 		 *  (bottom/unused portion of) MPT request frame.
 		 */
-		ptaskfoo = (struct tq_struct *) ((u8*)mf + hd->ioc->req_sz - sizeof(*ptaskfoo));
+		ptaskfoo = (struct tq_struct *) &mptscsih_ptaskfoo;
 		ptaskfoo->sync = 0;
 		ptaskfoo->routine = mptscsih_taskmgmt_bh;
 		ptaskfoo->data = SCpnt;
 
 		SCHEDULE_TASK(ptaskfoo);
+	} else  {
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 	}
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-
 	return SCSI_RESET_PENDING;
 }
 
@@ -1686,147 +3231,170 @@
 void
 mptscsih_taskmgmt_bh(void *sc)
 {
+	MPT_ADAPTER	*ioc;
 	Scsi_Cmnd	*SCpnt;
-	MPT_FRAME_HDR	*mf;
-	SCSITaskMgmt_t	*pScsiTm;
+	MPT_FRAME_HDR	*mf = NULL;
 	MPT_SCSI_HOST	*hd;
 	u32		 ctx2abort = 0;
-	int		 i;
 	unsigned long	 flags;
+	int		 scpnt_idx;
+	int		 did;
 	u8		 task_type;
 
-	dslprintk((KERN_INFO MYNAM ": spinlock#4\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	mpt_scsih_taskQ_bh_active = 1;
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+	mytaskQ_bh_active = 1;
+	spin_unlock_irqrestore(&mytaskQ_lock, flags);
 
-	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ/4);
+		did = 0;
 
-		/*
-		 *  We MUST remove item from taskQ *before* we format the
-		 *  frame as a SCSITaskMgmt request and send it down to the IOC.
-		 */
-		dslprintk((KERN_INFO MYNAM ": spinlock#5\n"));
-		spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-		if (Q_IS_EMPTY(&mpt_scsih_taskQ)) {
-			spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-			break;
-		}
-		mf = mpt_scsih_taskQ.head;
-		Q_DEL_ITEM(&mf->u.frame.linkage);
-		mpt_scsih_taskQ_cnt--;
-		mpt_scsih_active_taskmgmt_mf = mf;
-		spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-
-		SCpnt = (Scsi_Cmnd*)mf->u.frame.linkage.argp1;
-		if (SCpnt == NULL) {
-			printk(KERN_ERR MYNAM ": ERROR - TaskMgmt has NULL SCpnt! (%p:%p)\n", mf, SCpnt);
-			continue;
-		}
-		hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
-		pScsiTm = (SCSITaskMgmt_t *) mf;
+		for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc = mpt_adapter_find_next(ioc)) {
+			if (ioc->sh) {
+				hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+				if (hd == NULL) {
+					printk(KERN_ERR MYNAM
+							": ERROR - TaskMgmt NULL SCSI Host!"
+							"(ioc=%p, sh=%p hd=%p)\n",
+							(void *) ioc, (void *) ioc->sh, (void *) hd);
+					continue;
+				}
 
-		for (i = 0; i < 8; i++) {
-			pScsiTm->LUN[i] = 0;
-		}
+				spin_lock_irqsave(&ioc->FreeQlock, flags);
+				if (Q_IS_EMPTY(&hd->taskQ)) {
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
 
-		task_type = mf->u.frame.linkage.arg1;
-		if (task_type == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {
-			printk(KERN_WARNING MYNAM ": Attempting _ABORT SCSI IO! (mf=%p:sc=%p)\n",
-					mf, SCpnt);
-
-			/* Most important!  Set TaskMsgContext to SCpnt's MsgContext!
-			 * (the IO to be ABORT'd)
-			 *
-			 * NOTE: Since we do not byteswap MsgContext, we do not
-			 *	 swap it here either.  It is an opaque cookie to
-			 *	 the controller, so it does not matter. -DaveM
-			 */
-			ctx2abort = SCPNT_TO_MSGCTX(SCpnt);
-			if (ctx2abort == -1) {
-				printk(KERN_ERR MYNAM ": ERROR - ScsiLookup fail(#1) for SCpnt=%p\n", SCpnt);
-				SCpnt->result = DID_SOFT_ERROR << 16;
-				spin_lock_irqsave(SCpnt->host->host_lock, flags);
-				SCpnt->scsi_done(SCpnt);
-				spin_unlock_irqrestore(SCpnt->host->host_lock, flags);
-				mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-				continue;
-			}
-			pScsiTm->LUN[1] = SCpnt->lun;
-		}
-		else if (task_type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS)
-		{
-			printk(KERN_WARNING MYNAM ": Attempting _BUS_RESET! (against SCSI IO mf=%p:sc=%p)\n", mf, SCpnt);
-		}
-#if 0
-		else if (task_type == MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET) {}
-		else if (task_type == MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET) {}
-#endif
+				/* If we ever find a non-empty queue,
+				 * keep the handler alive
+				 */
+				did++;
 
-		printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+				/* tmPending is SMP lock-protected */
+				if (hd->tmPending || hd->tmPtr) {
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
+				hd->tmPending = 1;
 
-		pScsiTm->TargetID = SCpnt->target;
-		pScsiTm->Bus = hd->port;
-		pScsiTm->ChainOffset = 0;
-		pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+				/* Process this request
+				 */
+                                mf = hd->taskQ.head;
+				Q_DEL_ITEM(&mf->u.frame.linkage);
+				hd->taskQcnt--;
+				atomic_dec(&mpt_taskQdepth);
+				spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+				SCpnt = (Scsi_Cmnd*)mf->u.frame.linkage.argp1;
+				if (SCpnt == NULL) {
+					printk(KERN_ERR MYNAM ": ERROR - TaskMgmt has NULL SCpnt! (mf=%p:sc=%p)\n",
+							(void *) mf, (void *) SCpnt);
+					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					spin_lock_irqsave(&ioc->FreeQlock, flags);
+					hd->tmPending = 0;
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
 
-		pScsiTm->Reserved = 0;
-		pScsiTm->TaskType = task_type;
-		pScsiTm->Reserved1 = 0;
-		pScsiTm->MsgFlags = 0;
+				/* Get the ScsiLookup index pointer
+				 * from the SC pointer.
+				 */
+				if (!SCpnt->host_scribble || ((MPT_SCSI_HOST *)SCpnt->host->hostdata != hd)) {
+					/* The command associated with the
+					 * abort/reset request must have
+					 * completed and this is a stale
+					 * request. We are done.
+					 * Free the current MF and continue.
+					 */
+					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					spin_lock_irqsave(&ioc->FreeQlock, flags);
+					hd->tmPending = 0;
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
 
-		for (i = 0; i < 7; i++)
-			pScsiTm->Reserved2[i] = 0;
+				scpnt_idx = MFPTR_2_MPT_INDEX(hd->ioc, SCpnt->host_scribble);
+				if (scpnt_idx != SCPNT_TO_LOOKUP_IDX(SCpnt)) {
+					/* Error! this should never happen!!
+					 */
+					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					spin_lock_irqsave(&ioc->FreeQlock, flags);
+					hd->tmPending = 0;
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
 
-		dprintk((KERN_INFO MYNAM ":DbG: ctx2abort = %08x\n", ctx2abort));
-		pScsiTm->TaskMsgContext = ctx2abort;
+				task_type = mf->u.frame.linkage.arg1;
+				ctx2abort = 0;
+				if (task_type == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {
+					MPT_FRAME_HDR	*SCpntMf;
+
+					/*
+					 * Most important!  Set TaskMsgContext to SCpnt's MsgContext!
+					 * (the IO to be ABORT'd)
+					 *
+					 * NOTE: Since we do not byteswap MsgContext, we do not
+					 *	 swap it here either.  It is an opaque cookie to
+					 *	 the controller, so it does not matter. -DaveM
+					 */
+					SCpntMf = (MPT_FRAME_HDR *) SCpnt->host_scribble;
+					ctx2abort = SCpntMf->u.frame.hwhdr.msgctxu.MsgContext;
+
+					hd->abortSCpnt = SCpnt;
+					printk(KERN_WARNING MYNAM ": Attempting ABORT SCSI IO! (mf=%p:sc=%p)\n",
+							(void *) mf, (void *) SCpnt);
+				}
 
-		/* Control: No data direction, set task mgmt bit? */
+				/* The TM handler will allocate a new mf,
+				 * so free the current mf.
+				 */
+				mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+				mf = NULL;
 
-		/*
-		 *  As of MPI v0.10 this request can NOT be sent (normally)
-		 *  via FIFOs.	So we can't:
-		 *		mpt_put_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-		 *  SCSITaskMgmt requests MUST be sent ONLY via
-		 *  Doorbell/handshake now.   :-(
-		 */
-		if ((i = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
-					sizeof(SCSITaskMgmt_t), (u32*) mf))
-		    != 0) {
-			printk(KERN_WARNING MYNAM ": WARNING[1] - IOC error (%d) processing TaskMgmt request (mf=%p:sc=%p)\n", i, mf, SCpnt);
-			SCpnt->result = DID_SOFT_ERROR << 16;
-			spin_lock_irqsave(SCpnt->host->host_lock, flags);
-			SCpnt->scsi_done(SCpnt);
-			spin_unlock_irqrestore(SCpnt->host->host_lock, flags);
-			mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-		} else {
-			/* Spin-Wait for TaskMgmt complete!!! */
-			while (mpt_scsih_active_taskmgmt_mf != NULL) {
-				current->state = TASK_INTERRUPTIBLE;
-				schedule_timeout(HZ/4);
+				if (mptscsih_TMHandler(hd, task_type, SCpnt->target, SCpnt->lun, ctx2abort, NO_SLEEP) < 0) {
+
+					/* The TM request failed and the subsequent FW-reload failed!
+					 * Fatal error case.
+					 */
+					printk(KERN_WARNING MYNAM
+						": WARNING[1] - IOC error processing TaskMgmt request (sc=%p)\n", (void *) SCpnt);
+
+					if (hd->ScsiLookup[scpnt_idx] != NULL) {
+						atomic_dec(&queue_depth);
+						SCpnt->result = DID_SOFT_ERROR << 16;
+                                                MPT_HOST_LOCK(flags);
+						SCpnt->scsi_done(SCpnt);
+                                                MPT_HOST_UNLOCK(flags);
+						mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					}
+					spin_lock_irqsave(&ioc->FreeQlock, flags);
+					hd->tmPending = 0;
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					hd->abortSCpnt = NULL;
+				}
 			}
 		}
-	}
+		if (atomic_read(&mpt_taskQdepth) > 0)
+			did++;
 
-	dslprintk((KERN_INFO MYNAM ": spinlock#6\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	mpt_scsih_taskQ_bh_active = 0;
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	} while ( did );
+
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+	mytaskQ_bh_active = 0;
+	spin_unlock_irqrestore(&mytaskQ_lock, flags);
 
 	return;
 }
-
 #endif		/* } */
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mptscsih_taskmgmt_complete - Callback routine, gets registered to
- *	Fusion MPT base	driver
+ *	mptscsih_taskmgmt_complete - Registered with Fusion MPT base driver
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@mf: Pointer to SCSI task mgmt request frame
- *	@r: Pointer to SCSI task mgmt reply frame
+ *	@mr: Pointer to SCSI task mgmt reply frame
  *
  *	This routine is called from mptbase.c::mpt_interrupt() at the completion
  *	of any SCSI task management request.
@@ -1836,73 +3404,168 @@
  *	Returns 1 indicating alloc'd request frame ptr should be freed.
  */
 static int
-mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r)
+mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)
 {
 	SCSITaskMgmtReply_t	*pScsiTmReply;
 	SCSITaskMgmt_t		*pScsiTmReq;
-	u8			 tmType;
-#ifndef MPT_SCSI_USE_NEW_EH
+	MPT_SCSI_HOST		*hd = NULL;
 	unsigned long		 flags;
-#endif
-
-	dprintk((KERN_INFO MYNAM ": SCSI TaskMgmt completed mf=%p, r=%p\n",
-		 mf, r));
+	u8			 tmType = 0;
 
-#ifndef MPT_SCSI_USE_NEW_EH
-	dslprintk((KERN_INFO MYNAM ": spinlock#7\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	/* It better be the active one! */
-	if (mf != mpt_scsih_active_taskmgmt_mf) {
-		printk(KERN_ERR MYNAM ": ERROR! Non-active TaskMgmt (=%p) completed!\n", mf);
-		mpt_scsih_active_taskmgmt_mf = NULL;
-		spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	dtmprintk((MYIOC_s_INFO_FMT "SCSI TaskMgmt completed (mf=%p,r=%p)\n",
+			ioc->name, mf, mr));
+	if (ioc->sh) {
+		/* Depending on the thread, a timer is activated for
+		 * the TM request.  Delete this timer on completion of TM.
+		 * Decrement count of outstanding TM requests.
+		 */
+		hd = (MPT_SCSI_HOST *)ioc->sh->hostdata;
+		if (hd->tmPtr) {
+			del_timer(&hd->TMtimer);
+		}
+		dtmprintk((MYIOC_s_INFO_FMT "taskQcnt (%d)\n",
+			ioc->name, hd->taskQcnt));
+	} else {
+		dtmprintk((MYIOC_s_WARN_FMT "TaskMgmt Complete: NULL Scsi Host Ptr\n",
+			ioc->name));
 		return 1;
 	}
 
-#ifdef MPT_DEBUG
-	if ((mf == NULL) ||
-	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
-		printk(KERN_ERR MYNAM ": ERROR! NULL or BAD TaskMgmt ptr (=%p)!\n", mf);
-		mpt_scsih_active_taskmgmt_mf = NULL;
-		spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	if (mr == NULL) {
+		dtmprintk((MYIOC_s_WARN_FMT "ERROR! TaskMgmt Reply: NULL Request %p\n",
+			ioc->name, mf));
 		return 1;
-	}
-#endif
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-#endif
-
-	if (r != NULL) {
-		pScsiTmReply = (SCSITaskMgmtReply_t*)r;
+	} else {
+		pScsiTmReply = (SCSITaskMgmtReply_t*)mr;
 		pScsiTmReq = (SCSITaskMgmt_t*)mf;
 
 		/* Figure out if this was ABORT_TASK, TARGET_RESET, or BUS_RESET! */
 		tmType = pScsiTmReq->TaskType;
 
-		dprintk((KERN_INFO MYNAM ": TaskType = %d\n", tmType));
-		dprintk((KERN_INFO MYNAM ": TerminationCount = %d\n",
-			 le32_to_cpu(pScsiTmReply->TerminationCount)));
+		dtmprintk((KERN_INFO "  TaskType = %d, TerminationCount=%d\n",
+				tmType, le32_to_cpu(pScsiTmReply->TerminationCount)));
 
 		/* Error?  (anything non-zero?) */
 		if (*(u32 *)&pScsiTmReply->Reserved2[0]) {
-			dprintk((KERN_INFO MYNAM ": SCSI TaskMgmt (%d) - Oops!\n", tmType));
-			dprintk((KERN_INFO MYNAM ": IOCStatus = %04xh\n",
-				 le16_to_cpu(pScsiTmReply->IOCStatus)));
-			dprintk((KERN_INFO MYNAM ": IOCLogInfo = %08xh\n",
+			u16	 iocstatus;
+
+			iocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+			dtmprintk((KERN_INFO "  SCSI TaskMgmt (%d) - Oops!\n", tmType));
+			dtmprintk((KERN_INFO "  IOCStatus = %04xh\n", iocstatus));
+			dtmprintk((KERN_INFO "  IOCLogInfo = %08xh\n",
 				 le32_to_cpu(pScsiTmReply->IOCLogInfo)));
+
+			/* clear flags and continue.
+			 */
+			if (tmType == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK)
+				hd->abortSCpnt = NULL;
+#ifdef	DROP_TEST
+			if (dropMfPtr)
+				dropTestBad++;
+#endif
+			/* If an internal command is present
+			 * or the TM failed - reload the FW.
+			 * FC FW may respond FAILED to an ABORT
+			 */
+			if (tmType == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) {
+				if ((hd->cmdPtr) ||
+				    (iocstatus == MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED)) {
+					if (mpt_HardResetHandler(ioc, NO_SLEEP) < 0) {
+						printk((KERN_WARNING
+							" Firmware Reload FAILED!!\n"));
+					}
+				}
+			}
+#ifdef MPT_SCSI_USE_NEW_EH
+			hd->tmState = TM_STATE_ERROR;
+#endif
 		} else {
-			dprintk((KERN_INFO MYNAM ": SCSI TaskMgmt (%d) SUCCESS!\n", tmType));
+			dtmprintk((KERN_INFO "  SCSI TaskMgmt SUCCESS!\n"));
+
+#ifndef MPT_SCSI_USE_NEW_EH
+			if (tmType == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) {
+				/* clean taskQ - remove tasks associated with
+				 * completed commands.
+				 */
+				clean_taskQ(hd);
+			} else if (tmType == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {
+				/* If taskQ contains another request
+				 * for this SCpnt, delete this request.
+				 */
+				search_taskQ_for_cmd(hd->abortSCpnt, hd);
+			}
+#endif
+			hd->numTMrequests--;
+			hd->abortSCpnt = NULL;
+			flush_doneQ(hd);
+
+#ifdef	DROP_TEST
+			if (dropMfPtr)
+				dropTestOK++;
+#endif
+		}
+	}
+
+#ifdef	DROP_TEST
+	{
+		Scsi_Cmnd	*sc;
+		unsigned long	 flags;
+		u16		 req_idx;
+
+		/* Free resources for the drop test MF and chain buffers.
+		 */
+		if (dropMfPtr) {
+			req_idx = le16_to_cpu(dropMfPtr->u.frame.hwhdr.msgctxu.fld.req_idx);
+			sc = hd->ScsiLookup[req_idx];
+			if (sc == NULL) {
+				printk(MYIOC_s_ERR_FMT
+					"Drop Test: NULL ScsiCmd ptr!\n",
+					ioc->name);
+			} else {
+				sc->host_scribble = NULL;
+				if (tmType == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS)
+					sc->result = DID_RESET << 16;
+				else
+					sc->result = DID_ABORT << 16;
+
+				hd->ScsiLookup[req_idx] = NULL;
+				atomic_dec(&queue_depth);
+                                MPT_HOST_LOCK(flags);
+				sc->scsi_done(sc);	/* Issue callback */
+                                MPT_HOST_UNLOCK(flags);
+
+				mptscsih_freeChainBuffers(hd, req_idx);
+				mpt_free_msg_frame(ScsiDoneCtx, ioc->id, dropMfPtr);
+
+				printk(MYIOC_s_INFO_FMT
+						"Free'd Dropped cmd (%p)\n",
+						hd->ioc->name, sc);
+				printk(MYIOC_s_INFO_FMT
+						"mf (%p) reqidx (%4x)\n",
+						hd->ioc->name, dropMfPtr,
+						req_idx);
+				printk(MYIOC_s_INFO_FMT
+					"Num Tot (%d) Good (%d) Bad (%d) \n",
+					hd->ioc->name, dropTestNum,
+					dropTestOK, dropTestBad);
+			}
+			dropMfPtr = NULL;
 		}
 	}
+#endif
 
 #ifndef MPT_SCSI_USE_NEW_EH
 	/*
 	 *  Signal to _bh thread that we finished.
+	 *  This IOC can now process another TM command.
 	 */
-	dslprintk((KERN_INFO MYNAM ": spinlock#8\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	mpt_scsih_active_taskmgmt_mf = NULL;
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	dtmprintk((MYIOC_s_INFO_FMT "taskmgmt_complete: (=%p) done! Num Failed(%d) Task Count (%d)\n",
+			ioc->name, mf, hd->numTMrequests, hd->taskQcnt));
 #endif
+	hd->tmPtr = NULL;
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	hd->tmPending = 0;
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
 	return 1;
 }
@@ -1930,6 +3593,45 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
+ *	OS entry point to adjust the queue_depths on a per-device basis.
+ *	Called once per device the bus scan. Use it to force the queue_depth
+ *	member to 1 if a device does not support Q tags.
+ */
+void
+mptscsih_select_queue_depths(struct Scsi_Host *sh, Scsi_Device *sdList)
+{
+	struct scsi_device	*device;
+	VirtDevice		*pTarget;
+	MPT_SCSI_HOST		*hd;
+	int			 ii, max;
+
+	for (device = sdList; device != NULL; device = device->next) {
+
+		if (device->host != sh)
+			continue;
+
+		hd = (MPT_SCSI_HOST *) sh->hostdata;
+		if (hd == NULL)
+			continue;
+
+		if (hd->Targets != NULL) {
+			if (hd->is_spi)
+				max = MPT_MAX_SCSI_DEVICES;
+			else
+				max = MPT_MAX_FC_DEVICES;
+
+			for (ii=0; ii < max; ii++) {
+				pTarget = hd->Targets[ii];
+				if (pTarget && !(pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)) {
+					device->queue_depth = 1;
+				}
+			}
+		}
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
  *  Private routines...
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -1938,10 +3640,22 @@
  *     1 = _DATA_OUT
  *     0 = _DIR_NONE
  *    -1 = _DATA_IN
+ *
+ * Changed: 3-20-2002 pdelaney to use the default data
+ * direction and the defines set up in the
+ * 2.4 kernel series
+ *     1 = _DATA_OUT	changed to SCSI_DATA_WRITE (1)
+ *     0 = _DIR_NONE	changed to SCSI_DATA_NONE (3)
+ *    -1 = _DATA_IN	changed to SCSI_DATA_READ (2)
+ * If the direction is unknown, fall through to original code.
  */
 static int
 mptscsih_io_direction(Scsi_Cmnd *cmd)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	if (cmd->sc_data_direction != SCSI_DATA_UNKNOWN)
+		return cmd->sc_data_direction;
+#endif
 	switch (cmd->cmnd[0]) {
 	/*  _DATA_OUT commands	*/
 	case WRITE_6:		case WRITE_10:		case WRITE_12:
@@ -1956,7 +3670,8 @@
 	case REASSIGN_BLOCKS:
 	case PERSISTENT_RESERVE_OUT:
 	case 0xea:
-		return 1;
+	case 0xa3:
+		return SCSI_DATA_WRITE;
 
 	/*  No data transfer commands  */
 	case SEEK_6:		case SEEK_10:
@@ -1964,26 +3679,26 @@
 	case TEST_UNIT_READY:
 	case START_STOP:
 	case ALLOW_MEDIUM_REMOVAL:
-		return 0;
+		return SCSI_DATA_NONE;
 
 	/*  Conditional data transfer commands	*/
 	case FORMAT_UNIT:
 		if (cmd->cmnd[1] & 0x10)	/* FmtData (data out phase)? */
-			return 1;
+			return SCSI_DATA_WRITE;
 		else
-			return 0;
+			return SCSI_DATA_NONE;
 
 	case VERIFY:
 		if (cmd->cmnd[1] & 0x02)	/* VERIFY:BYTCHK (data out phase)? */
-			return 1;
+			return SCSI_DATA_WRITE;
 		else
-			return 0;
+			return SCSI_DATA_NONE;
 
 	case RESERVE_10:
-		if (cmd->cmnd[1] & 0x03)	/* RESERSE:{LongID|Extent} (data out phase)? */
-			return 1;
+		if (cmd->cmnd[1] & 0x03)	/* RESERVE:{LongID|Extent} (data out phase)? */
+			return SCSI_DATA_WRITE;
 		else
-			return 0;
+			return SCSI_DATA_NONE;
 
 #if 0
 	case REZERO_UNIT:	/* (or REWIND) */
@@ -1995,21 +3710,32 @@
 
 	/*  Must be data _IN!  */
 	default:
-		return -1;
+		return SCSI_DATA_READ;
 	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Utility function to copy sense data from the scsi_cmnd buffer
+ * to the FC and SCSI target structures.
+ *
+ */
 static void
 copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply)
 {
-	MPT_SCSI_DEV	*mpt_sdev = NULL;
+	VirtDevice	*target;
+	SCSIIORequest_t	*pReq;
 	u32		 sense_count = le32_to_cpu(pScsiReply->SenseCount);
-	char		 devFoo[32];
+	int		 index;
+	char		 devFoo[96];
 	IO_Info_t	 thisIo;
 
-	if (sc && sc->device)
-		mpt_sdev = (MPT_SCSI_DEV*) sc->device->hostdata;
+	/* Get target structure
+	 */
+	pReq = (SCSIIORequest_t *) mf;
+	index = (int) pReq->TargetID;
+	target = hd->Targets[index];
+	if (hd->is_multipath && sc->device->hostdata)
+		target = (VirtDevice *) sc->device->hostdata;
 
 	if (sense_count) {
 		u8 *sense_data;
@@ -2017,49 +3743,84 @@
 
 		/* Copy the sense received into the scsi command block. */
 		req_index = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
-		sense_data = ((u8 *)hd->ioc->sense_buf_pool + (req_index * 256));
+		sense_data = ((u8 *)hd->ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));
 		memcpy(sc->sense_buffer, sense_data, SNS_LEN(sc));
-		/* Cache SenseData for this SCSI device! */
-		if (mpt_sdev) {
-			memcpy(mpt_sdev->CachedSense.data, sense_data, sense_count);
-			mpt_sdev->sense_sz = sense_count;
+
+		/* save sense data to the target device
+		 */
+		if (target) {
+			int sz;
+
+			sz = MIN(pReq->SenseBufferLength, sense_count);
+			if (sz > SCSI_STD_SENSE_BYTES)
+				sz =  SCSI_STD_SENSE_BYTES;
+			memcpy(target->sense, sense_data, sz);
+			target->tflags |= MPT_TARGET_FLAGS_VALID_SENSE;
 		}
-	} else {
-		dprintk((KERN_INFO MYNAM ": Hmmm... SenseData len=0! (?)\n"));
-	}
 
+		/* Log SMART data (asc = 0x5D, non-IM case only) if required.
+		 */
+		if ((hd->ioc->events) && (hd->ioc->eventTypes & (1 << MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE))) {
+			if ((sense_data[12] == 0x5D) && (target->raidVolume == 0)) {
+				int idx;
+				MPT_ADAPTER *ioc = hd->ioc;
+
+				idx = ioc->eventContext % ioc->eventLogSize;
+				ioc->events[idx].event = MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE;
+				ioc->events[idx].eventContext = ioc->eventContext;
+
+				ioc->events[idx].data[0] = (pReq->LUN[1] << 24) ||
+					(MPI_EVENT_SCSI_DEV_STAT_RC_SMART_DATA << 16) ||
+					(pReq->Bus << 8) || pReq->TargetID;
+
+				ioc->events[idx].data[1] = (sense_data[13] << 8) || sense_data[12];
+
+				ioc->eventContext++;
+			}
+		}
 
-	thisIo.cdbPtr = sc->cmnd;
-	thisIo.sensePtr = sc->sense_buffer;
-	thisIo.SCSIStatus = pScsiReply->SCSIStatus;
-	thisIo.DoDisplay = 1;
-	sprintf(devFoo, "ioc%d,scsi%d:%d", hd->ioc->id, sc->target, sc->lun);
-	thisIo.DevIDStr = devFoo;
+		/* Print an error report for the user.
+		 */
+		thisIo.cdbPtr = sc->cmnd;
+		thisIo.sensePtr = sc->sense_buffer;
+		thisIo.SCSIStatus = pScsiReply->SCSIStatus;
+		thisIo.DoDisplay = 1;
+		if (hd->is_multipath)
+			sprintf(devFoo, "%d:%d:%d \"%s\"",
+					hd->ioc->id,
+					pReq->TargetID,
+					pReq->LUN[1],
+					target->dev_vol_name);
+		else
+			sprintf(devFoo, "%d:%d:%d", hd->ioc->id, sc->target, sc->lun);
+		thisIo.DevIDStr = devFoo;
 /* fubar */
-	thisIo.dataPtr = NULL;
-	thisIo.inqPtr = NULL;
-	if (sc->device) {
-		thisIo.inqPtr = sc->device->vendor-8;		/* FIXME!!! */
+		thisIo.dataPtr = NULL;
+		thisIo.inqPtr = NULL;
+		if (sc->device) {
+			thisIo.inqPtr = sc->device->vendor-8;	/* FIXME!!! */
+		}
+		(void) mpt_ScsiHost_ErrorReport(&thisIo);
+
+	} else {
+		dprintk((MYIOC_s_INFO_FMT "Hmmm... SenseData len=0! (?)\n",
+				hd->ioc->name));
 	}
-	(void) mpt_ScsiHost_ErrorReport(&thisIo);
 
 	return;
 }
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static u32
-SCPNT_TO_MSGCTX(Scsi_Cmnd *sc)
+SCPNT_TO_LOOKUP_IDX(Scsi_Cmnd *sc)
 {
 	MPT_SCSI_HOST *hd;
-	MPT_FRAME_HDR *mf;
 	int i;
 
 	hd = (MPT_SCSI_HOST *) sc->host->hostdata;
 
 	for (i = 0; i < hd->ioc->req_depth; i++) {
 		if (hd->ScsiLookup[i] == sc) {
-			mf = MPT_INDEX_2_MFPTR(hd->ioc, i);
-			return mf->u.frame.hwhdr.msgctxu.MsgContext;
+			return i;
 		}
 	}
 
@@ -2075,18 +3836,261 @@
 #	include "../../scsi/scsi_module.c"
 #endif
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Search the pendingQ for a command with specific index.
+ * If found, delete and return mf pointer  
+ * If not found, return NULL
+ */
+static MPT_FRAME_HDR *
+mptscsih_search_pendingQ(MPT_SCSI_HOST *hd, int scpnt_idx)
+{
+	unsigned long	 flags;
+	MPT_DONE_Q	*buffer;
+	MPT_FRAME_HDR	*mf = NULL;
+	MPT_FRAME_HDR	*cmdMfPtr = NULL;
+
+	ddvtprintk((MYIOC_s_INFO_FMT ": search_pendingQ called...", hd->ioc->name));
+	cmdMfPtr = MPT_INDEX_2_MFPTR(hd->ioc, scpnt_idx);
+	spin_lock_irqsave(&hd->freedoneQlock, flags);
+	if (!Q_IS_EMPTY(&hd->pendingQ)) {
+		buffer = hd->pendingQ.head;
+		do {
+			mf = (MPT_FRAME_HDR *) buffer->argp;
+			if (mf == cmdMfPtr) {
+				Q_DEL_ITEM(buffer);
+
+				/* clear the arg pointer
+				 */
+				buffer->argp = NULL;
+
+				/* Add to the freeQ
+				 */
+				Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+				break;
+			}
+			mf = NULL;
+		} while ((buffer = buffer->forw) != (MPT_DONE_Q *) &hd->pendingQ);
+	}
+	spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+	ddvtprintk((" ...return %p\n", mf));
+	return mf;
+}
+
+/* Post all commands on the pendingQ to the FW.
+ * Lock Q when deleting/adding members
+ * Lock io_request_lock for OS callback.
+ */
+static void
+post_pendingQ_commands(MPT_SCSI_HOST *hd)
+{
+	MPT_FRAME_HDR	*mf;
+	MPT_DONE_Q	*buffer;
+	unsigned long	 flags;
+
+	/* Flush the pendingQ.
+	 */
+	ddvtprintk((MYIOC_s_INFO_FMT ": post_pendingQ_commands called\n", hd->ioc->name));
+	while (1) {
+		spin_lock_irqsave(&hd->freedoneQlock, flags);
+		if (Q_IS_EMPTY(&hd->pendingQ)) {
+			spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			break;
+		}
+
+		buffer = hd->pendingQ.head;
+		/* Delete from Q
+		 */
+		Q_DEL_ITEM(buffer);
+
+		mf = (MPT_FRAME_HDR *) buffer->argp;
+		buffer->argp = NULL;
+
+		/* Add to the freeQ
+		 */
+		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+
+		if (!mf) {
+			/* This should never happen */
+			printk(MYIOC_s_WARN_FMT "post_pendingQ_commands: mf %p\n", hd->ioc->name, (void *) mf);
+			continue;
+		}
+
+		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		ddvtprintk((MYIOC_s_INFO_FMT "Issued SCSI cmd (mf=%p)\n",
+				hd->ioc->name, mf));
+	}
+
+	return;
+}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static int
 mptscsih_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
 {
-	dprintk((KERN_INFO MYNAM ": IOC %s_reset routed to SCSI host driver!\n",
+	MPT_SCSI_HOST	*hd = NULL;
+	unsigned long	 flags;
+
+	dtmprintk((KERN_WARNING MYNAM
+			": IOC %s_reset routed to SCSI host driver!\n",
 			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
 
+	/* If a FW reload request arrives after base installed but
+	 * before all scsi hosts have been attached, then an alt_ioc
+	 * may have a NULL sh pointer.
+	 */
+	if ((ioc->sh == NULL) || (ioc->sh->hostdata == NULL))
+		return 0;
+	else
+		hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+
 	if (reset_phase == MPT_IOC_PRE_RESET) {
-		/* FIXME! Do pre-reset cleanup */
+		dtmprintk((MYIOC_s_WARN_FMT "Do Pre-Diag Reset handling\n",
+			ioc->name));
+
+		/* Clean Up:
+		 * 1. Set Hard Reset Pending Flag
+		 * All new commands go to doneQ
+		 */
+		hd->resetPending = 1;
+
+		/* 2. Flush running commands
+		 *	Clean drop test code - if compiled
+		 *	Clean ScsiLookup (and associated memory)
+		 *	AND clean mytaskQ
+		 */
+
+		/* 2a. Drop Test Command.
+		 */
+#ifdef	DROP_TEST
+		{
+			Scsi_Cmnd	*sc;
+			unsigned long	 flags;
+			u16		 req_idx;
+
+			/* Free resources for the drop test MF
+			 * and chain buffers.
+			 */
+			if (dropMfPtr) {
+				req_idx = le16_to_cpu(dropMfPtr->u.frame.hwhdr.msgctxu.fld.req_idx);
+				sc = hd->ScsiLookup[req_idx];
+				if (sc == NULL) {
+					printk(MYIOC_s_ERR_FMT
+					"Drop Test: NULL ScsiCmd ptr!\n",
+					ioc->name);
+				} else {
+					sc->host_scribble = NULL;
+					sc->result = DID_RESET << 16;
+					hd->ScsiLookup[req_idx] = NULL;
+					atomic_dec(&queue_depth);
+                                        MPT_HOST_LOCK(flags);
+					sc->scsi_done(sc);	/* Issue callback */
+                                        MPT_HOST_UNLOCK(flags);
+				}
+
+				mptscsih_freeChainBuffers(hd, req_idx);
+				mpt_free_msg_frame(ScsiDoneCtx, ioc->id, dropMfPtr);
+				printk(MYIOC_s_INFO_FMT
+						"Free'd: mf (%p) reqidx (%4x)\n",
+						hd->ioc->name, dropMfPtr,
+						req_idx);
+			}
+			dropMfPtr = NULL;
+		}
+#endif
+
+		/* 2b. Reply to OS all known outstanding I/O commands.
+		 */
+		mptscsih_flush_running_cmds(hd);
+
+		/* 2c. If there was an internal command that
+		 * has not completed, configuration or io request,
+		 * free these resources.
+		 */
+		if (hd->cmdPtr) {
+			del_timer(&hd->timer);
+			mpt_free_msg_frame(ScsiScanDvCtx, ioc->id, hd->cmdPtr);
+			atomic_dec(&queue_depth);
+		}
+
+		/* 2d. If a task management has not completed,
+		 * free resources associated with this request.
+		 */
+		if (hd->tmPtr) {
+			del_timer(&hd->TMtimer);
+			mpt_free_msg_frame(ScsiTaskCtx, ioc->id, hd->tmPtr);
+		}
+
+#ifndef MPT_SCSI_USE_NEW_EH
+		/* 2e. Delete all commands on taskQ
+		 * Should be superfluous - as this taskQ should
+		 * be empty.
+		 */
+		clean_taskQ(hd);
+#endif
+		dtmprintk((MYIOC_s_WARN_FMT "Pre-Reset handling complete.\n",
+			ioc->name));
+
 	} else {
-		/* FIXME! Do post-reset cleanup */
+		dtmprintk((MYIOC_s_WARN_FMT "Do Post-Diag Reset handling\n",
+			ioc->name));
+
+		/* Once a FW reload begins, all new OS commands are
+		 * redirected to the doneQ w/ a reset status.
+		 * Init all control structures.
+		 */
+
+		/* ScsiLookup initialization
+		 */
+		{
+			int ii;
+			for (ii=0; ii < hd->ioc->req_depth; ii++)
+				hd->ScsiLookup[ii] = NULL;
+		}
+
+		/* 2. Chain Buffer initialization
+		 */
+		mptscsih_initChainBuffers(hd, 0);
+
+		/* 3. tmPtr clear
+		 */
+		if (hd->tmPtr) {
+			hd->tmPtr = NULL;
+		}
+
+		/* 4. Renegotiate to all devices, if SCSI
+		 */
+		if (hd->is_spi)
+			mptscsih_writeSDP1(hd, 0, 0, MPT_SCSICFG_ALL_IDS | MPT_SCSICFG_USE_NVRAM);
+
+		/* 5. Enable new commands to be posted
+		 */
+		spin_lock_irqsave(&ioc->FreeQlock, flags);
+		hd->tmPending = 0;
+		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+		hd->resetPending = 0;
+		hd->numTMrequests = 0;
+
+		/* 6. If there was an internal command,
+		 * wake this process up.
+		 */
+		if (hd->cmdPtr) {
+			/*
+			 * Wake up the original calling thread
+			 */
+			hd->pLocal = &hd->localReply;
+			hd->pLocal->completion = MPT_SCANDV_DID_RESET;
+			scandv_wait_done = 1;
+			wake_up(&scandv_waitq);
+			hd->cmdPtr = NULL;
+		}
+
+		/* 7. Flush doneQ
+		 */
+		flush_doneQ(hd);
+
+		dtmprintk((MYIOC_s_WARN_FMT "Post-Reset handling complete.\n",
+			ioc->name));
 	}
 
 	return 1;		/* currently means nothing really */
@@ -2096,9 +4100,11 @@
 static int
 mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)
 {
+	MPT_SCSI_HOST *hd;
 	u8 event = le32_to_cpu(pEvReply->Event) & 0xFF;
 
-	dprintk((KERN_INFO MYNAM ": MPT event (=%02Xh) routed to SCSI host driver!\n", event));
+	dprintk((MYIOC_s_INFO_FMT "MPT event (=%02Xh) routed to SCSI host driver!\n",
+			ioc->name, event));
 
 	switch (event) {
 	case MPI_EVENT_UNIT_ATTENTION:			/* 03 */
@@ -2124,13 +4130,69 @@
 		/*
 		 *  CHECKME!  Falling thru...
 		 */
+		break;
+
+	case MPI_EVENT_INTEGRATED_RAID:			/* 0B */
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+		/* negoNvram set to 0 if DV enabled and to USE_NVRAM if 
+		 * if DV disabled. Need to check for target mode.
+		 */
+		hd = NULL;
+		if (ioc->sh)
+			hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+
+		if (hd && (hd->is_spi) && (hd->negoNvram == 0)) {
+			ScsiCfgData	*pSpi;
+			Ioc3PhysDisk_t	*pPDisk;
+			int		 numPDisk;
+			u8		 reason;
+			u8		 physDiskNum;
+			
+			reason = (le32_to_cpu(pEvReply->Data[0]) & 0x00FF0000) >> 16;
+			if (reason == MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED) {
+				/* New or replaced disk. 
+				 * Set DV flag and schedule DV.
+				 */
+				pSpi = &ioc->spi_data;
+				physDiskNum = (le32_to_cpu(pEvReply->Data[0]) & 0xFF000000) >> 24;
+				if (pSpi->pIocPg3) {
+					pPDisk =  pSpi->pIocPg3->PhysDisk;
+					numPDisk =pSpi->pIocPg3->NumPhysDisks;
+
+					while (numPDisk) {
+						if (physDiskNum == pPDisk->PhysDiskNum) {
+							pSpi->dvStatus[pPDisk->PhysDiskID] = MPT_SCSICFG_NEED_DV;
+							pSpi->forceDv = MPT_SCSICFG_NEED_DV;
+							ddvtprintk(("NEED_DV set for phys disk id %d\n", pPDisk->PhysDiskID));
+							break;
+						}
+						pPDisk++;
+						numPDisk--;
+					}
+				}
+			}
+		}
+#endif
+
+#if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
+		printk("Raid Event RF: ");
+		{
+			u32 *m = (u32 *)pEvReply;
+			int ii;
+			int n = (int)pEvReply->MsgLength;
+			for (ii=6; ii < n; ii++)
+				printk(" %08x", le32_to_cpu(m[ii]));
+			printk("\n");
+		}
+#endif
+		break;
 
 	case MPI_EVENT_NONE:				/* 00 */
 	case MPI_EVENT_LOG_DATA:			/* 01 */
 	case MPI_EVENT_STATE_CHANGE:			/* 02 */
 	case MPI_EVENT_EVENT_CHANGE:			/* 0A */
 	default:
-		dprintk((KERN_INFO MYNAM ": Ignoring event (=%02Xh)\n", event));
+		dprintk((KERN_INFO "  Ignoring event (=%02Xh)\n", event));
 		break;
 	}
 
@@ -2149,7 +4211,6 @@
 //extern ASCQ_Table_t	 *mpt_ASCQ_TablePtr;
 //extern int		  mpt_ASCQ_TableSz;
 
-/*  Lie!  */
 #define MYNAM	"mptscsih"
 
 #endif		/* } */
@@ -2327,8 +4388,6 @@
  *  Sense_Key_Specific() - If Sense_Key_Specific_Valid bit is set,
  *			   then print additional information via
  *			   a call to SDMS_SystemAlert().
- *
- *  Return: nothing
  */
 static void Sense_Key_Specific(IO_Info_t *ioop, char *msg1)
 {
@@ -2463,25 +4522,27 @@
 		} else if (ASC == 0x29 && (ASCQ < sizeof(asc_29_ascq_NN_strings)/sizeof(char*)-1))
 			*s1 = asc_29_ascq_NN_strings[ASCQ];
 		/*
-		 *	else { leave all *s[1-4] values pointing to the empty "" string }
+		 *	Else { leave all *s[1-4] values pointing to the empty "" string }
 		 */
 		return *s1;
 	}
 
 	/*
-	 *  Need to check ASC here; if it is "special," then
-	 *  the ASCQ is variable, and indicates failed component number.
-	 *  We must treat the ASCQ as a "don't care" while searching the
-	 *  mptscsih_ASCQ_Table[] by masking it off, and then restoring it later
-	 *  on when we actually need to identify the failed component.
+	 * Need to check ASC here; if it is "special," then
+	 * the ASCQ is variable, and indicates failed component number.
+	 * We must treat the ASCQ as a "dont care" while searching the
+	 * mptscsih_ASCQ_Table[] by masking it off, and then restoring it later
+	 * on when we actually need to identify the failed component.
 	 */
 	if (SPECIAL_ASCQ(ASC,ASCQ))
 		ASCQ = 0xFF;
 
-	/*  OK, now search mptscsih_ASCQ_Table[] for a matching entry  */
+	/* OK, now search mptscsih_ASCQ_Table[] for a matching entry */
 	for (idx = 0; mptscsih_ASCQ_TablePtr && idx < mpt_ASCQ_TableSz; idx++)
-		if ((ASC == mptscsih_ASCQ_TablePtr[idx].ASC) && (ASCQ == mptscsih_ASCQ_TablePtr[idx].ASCQ))
-			return (*s1 = mptscsih_ASCQ_TablePtr[idx].Description);
+		if ((ASC == mptscsih_ASCQ_TablePtr[idx].ASC) && (ASCQ == mptscsih_ASCQ_TablePtr[idx].ASCQ)) {
+			*s1 = mptscsih_ASCQ_TablePtr[idx].Description;
+			return *s1;
+		}
 
 	if ((ASC >= 0x80) || (ASCQ >= 0x80))
 		*s1 = ascq_vendor_uniq;
@@ -2523,8 +4584,11 @@
 	 *    SPINNING UP (02,04/01),
 	 *    LOGICAL UNIT NOT SUPPORTED (05,25/00), etc.
 	 */
+	if (sk == SK_NO_SENSE) {
+		return 0;
+	}
 	if (	(sk==SK_UNIT_ATTENTION	&& asc==0x29 && (ascq==0x00 || ascq==0x01))
-	     || (sk==SK_NOT_READY	&& asc==0x04 && ascq==0x01)
+	     || (sk==SK_NOT_READY	&& asc==0x04 && (ascq==0x01 || ascq==0x02))
 	     || (sk==SK_ILLEGAL_REQUEST && asc==0x25 && ascq==0x00)
 	   )
 	{
@@ -2591,6 +4655,2724 @@
 	PrintF(("%s\n", foo));
 
 	return l;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_initTarget - Target, LUN alloc/free functionality.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@bus_id: Bus number (?)
+ *	@target_id: SCSI target id
+ *	@lun: SCSI LUN id
+ *	@data: Pointer to data
+ *	@dlen: Number of INQUIRY bytes
+ *
+ *	NOTE: It's only SAFE to call this routine if data points to
+ *	sane & valid STANDARD INQUIRY data!
+ *
+ *	Allocate and initialize memory for this target.
+ *	Save inquiry data.
+ *
+ *	Returns pointer to VirtDevice structure.
+ */
+static VirtDevice *
+mptscsih_initTarget(MPT_SCSI_HOST *hd, int bus_id, int target_id, u8 lun, char *data, int dlen)
+{
+	VirtDevice	*vdev;
+	int		 sz;
+
+	dprintk((MYIOC_s_INFO_FMT "initTarget (%d,%d,%d) called, hd=%p\n",
+			hd->ioc->name, bus_id, target_id, lun, hd));
+
+	if ((vdev = hd->Targets[target_id]) == NULL) {
+		if ((vdev = kmalloc(sizeof(VirtDevice), GFP_ATOMIC)) == NULL) {
+			printk(MYIOC_s_ERR_FMT "initTarget kmalloc(%d) FAILED!\n",
+					hd->ioc->name, (int)sizeof(VirtDevice));
+		} else {
+			memset(vdev, 0, sizeof(VirtDevice));
+			rwlock_init(&vdev->VdevLock);
+			Q_INIT(&vdev->WaitQ, void);
+			Q_INIT(&vdev->SentQ, void);
+			Q_INIT(&vdev->DoneQ, void);
+			vdev->tflags = 0;
+			vdev->ioc_id = hd->ioc->id;
+			vdev->target_id = target_id;
+			vdev->bus_id = bus_id;
+
+			hd->Targets[target_id] = vdev;
+			dprintk((KERN_INFO "  *NEW* Target structure (id %d) @ %p\n",
+					target_id, vdev));
+		}
+	}
+
+	if (vdev) {
+		if (hd->ioc->spi_data.isRaid & (1 << target_id))
+			vdev->raidVolume = 1;
+		else
+			vdev->raidVolume = 0;
+	}
+
+	if (vdev && data) {
+		if (!(vdev->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY)) {
+
+			/* Copy the inquiry data  - if we haven't yet.
+			*/
+			sz = MIN(dlen, SCSI_STD_INQUIRY_BYTES);
+
+			memcpy (vdev->inq_data, data, sz);
+			vdev->tflags |= MPT_TARGET_FLAGS_VALID_INQUIRY;
+
+			/* Update the target capabilities
+			 */
+			if (dlen > 56)
+				mptscsih_setTargetNegoParms(hd, vdev, data[56]);
+			else
+				mptscsih_setTargetNegoParms(hd, vdev, 0);
+		}
+
+		/* Is LUN supported? If so, upper 3 bits will be 0
+		 * in first byte of inquiry data.
+		 */
+		if ((*data & 0xe0) == 0)
+			vdev->luns |= (1 << lun);
+	}
+
+
+	dprintk((KERN_INFO "  target = %p\n", vdev));
+	return vdev;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Update the target negotiation parameters based on the
+ *  the Inquiry data, adapter capabilities, and NVRAM settings.
+ *
+ */
+void mptscsih_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtDevice *target, char byte56)
+{
+	ScsiCfgData *pspi_data = &hd->ioc->spi_data;
+	int  id = (int) target->target_id;
+	int  nvram;
+	char canQ = 0;
+	u8 width = MPT_NARROW;
+	u8 factor = MPT_ASYNC;
+	u8 offset = 0;
+	u8 version, nfactor;
+	u8 noQas = 1;
+
+	/* Set flags based on Inquiry data
+	 */
+	if (target->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY) {
+		version = target->inq_data[2] & 0x03;
+		if (version < 2) {
+			width = 0;
+			factor = MPT_ULTRA2;
+			offset = pspi_data->maxSyncOffset;
+		} else {
+			if (target->inq_data[7] & 0x20) {
+				width = 1;
+			}
+
+			if (target->inq_data[7] & 0x10) {
+				/* bits 2 & 3 show DT support
+				 */
+				if ((byte56 & 0x04) == 0)
+					factor = MPT_ULTRA2;
+				else
+					factor = MPT_ULTRA320;
+
+				/* bit 1 QAS support, non-raid only
+				 */
+				if ((target->raidVolume == 0) && (byte56 & 0x02) != 0)
+					noQas = 0;
+
+				offset = pspi_data->maxSyncOffset;
+			} else {
+				factor = MPT_ASYNC;
+				offset = 0;
+			}
+		}
+
+		if (target->inq_data[7] & 0x02) {
+			canQ = 1;
+		}
+
+		/* Update tflags based on NVRAM settings. (SCSI only)
+		 */
+		if (pspi_data->nvram && (pspi_data->nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+			nvram = pspi_data->nvram[id];
+			nfactor = (nvram & MPT_NVRAM_SYNC_MASK) >> 8;
+
+			if (width)
+				width = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;
+
+			if (offset > 0) {
+				/* Ensure factor is set to the
+				 * maximum of: adapter, nvram, inquiry
+				 */
+				if (nfactor) {
+					if (nfactor < pspi_data->minSyncFactor )
+						nfactor = pspi_data->minSyncFactor;
+
+					factor = MAX (factor, nfactor);
+					if (factor == MPT_ASYNC)
+						offset = 0;
+				} else {
+					offset = 0;
+					factor = MPT_ASYNC;
+				}
+			} else {
+				factor = MPT_ASYNC;
+			}
+		}
+
+		/* Make sure data is consistent
+		 */
+		if ((!width) && (factor < MPT_ULTRA2)) {
+			factor = MPT_ULTRA2;
+		}
+
+		/* Save the data to the target structure.
+		 */
+		target->minSyncFactor = factor;
+		target->maxOffset = offset;
+		target->maxWidth = width;
+		if (canQ) {
+			target->tflags |= MPT_TARGET_FLAGS_Q_YES;
+		}
+
+		target->tflags |= MPT_TARGET_FLAGS_VALID_NEGO;
+
+		/* Disable unused features.
+		 */
+		target->negoFlags = pspi_data->noQas;
+		if (!width)
+			target->negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+
+		if (!offset)
+			target->negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+
+		if (noQas)
+			target->negoFlags |= MPT_TARGET_NO_NEGO_QAS;
+
+		/* GEM, processor WORKAROUND
+		 */
+		if (((target->inq_data[0] & 0x1F) == 0x03) || ((target->inq_data[0] & 0x1F) > 0x08)){
+			target->negoFlags |= (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC);
+			pspi_data->dvStatus[id] |= MPT_SCSICFG_BLK_NEGO;
+		}
+
+		/* Disable QAS if mixed configuration case
+		 */
+		if ((noQas) && (!pspi_data->noQas) && ((target->inq_data[0] & 0x1F) == 0x00)){
+			VirtDevice	*vdev;
+			int ii;
+
+			pspi_data->noQas = MPT_TARGET_NO_NEGO_QAS;
+			for (ii = 0; ii < id; ii++) {
+				vdev = hd->Targets[id];
+				if (vdev != NULL)
+					vdev->negoFlags |= MPT_TARGET_NO_NEGO_QAS;
+			}
+		}
+
+	}
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Clear sense valid flag.
+ */
+static void clear_sense_flag(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq)
+{
+	VirtDevice	*target;
+	int		 index = (int) pReq->TargetID;
+
+	if ((target = hd->Targets[index])) {
+		target->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;
+	}
+
+	return;
+}
+
+/* 
+ * If DV disabled (negoNvram set to USE_NVARM) or if not LUN 0, return.
+ * Else set the NEED_DV flag after Read Capacity Issued (disks) 
+ * or Mode Sense (cdroms). Tapes, key off of Inquiry command.
+ */
+static void mptscsih_set_dvflags(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq, char *data)
+{
+	u8 cmd = pReq->CDB[0];
+	
+	if (pReq->LUN[1] != 0)
+		return;
+
+	if (hd->negoNvram != 0)
+		return;
+
+	if ((cmd == READ_CAPACITY) || (cmd == MODE_SENSE) || 
+		((cmd == INQUIRY) && ((data[0] & 0x1F) == 0x01))) {
+		u8 dvStatus = hd->ioc->spi_data.dvStatus[pReq->TargetID];
+		if (!(dvStatus & MPT_SCSICFG_DV_DONE)) {
+			ScsiCfgData *pSpi = &hd->ioc->spi_data;
+			if ((pSpi->isRaid & (1 << pReq->TargetID)) && pSpi->pIocPg3) {
+				/* Set NEED_DV for all hidden disks
+				 */
+				Ioc3PhysDisk_t *pPDisk =  pSpi->pIocPg3->PhysDisk;
+				int		numPDisk = pSpi->pIocPg3->NumPhysDisks;
+				
+				while (numPDisk) {
+					pSpi->dvStatus[pPDisk->PhysDiskID] |= MPT_SCSICFG_NEED_DV;
+					ddvtprintk(("NEED_DV set for phys disk id %d\n", pPDisk->PhysDiskID));
+					pPDisk++;
+					numPDisk--;
+				}
+			}
+			pSpi->dvStatus[pReq->TargetID] |= MPT_SCSICFG_NEED_DV;
+			ddvtprintk(("NEED_DV set for visible disk id %d\n", 
+					pReq->TargetID));
+		};
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * If no Target, bus reset on 1st I/O. Set the flag to 
+ * prevent any future negotiations to this device.
+ */
+static void mptscsih_no_negotiate(MPT_SCSI_HOST *hd, int target_id)
+{
+
+	if ((hd->Targets) && (hd->Targets[target_id] == NULL))
+		hd->ioc->spi_data.dvStatus[target_id] |= MPT_SCSICFG_BLK_NEGO;
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  SCSI Config Page functionality ...
+ */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_setDevicePage1Flags  - add Requested and Configuration fields flags
+ *	based on width, factor and offset parameters.
+ *	@width: bus width
+ *	@factor: sync factor
+ *	@offset: sync offset
+ *	@requestedPtr: pointer to requested values (updated)
+ *	@configurationPtr: pointer to configuration values (updated)
+ *	@flags: flags to block WDTR or SDTR negotiation
+ *
+ *	Return: None.
+ *
+ *	Remark: Called by writeSDP1 and _dv_params
+ */
+static void
+mptscsih_setDevicePage1Flags (u8 width, u8 factor, u8 offset, int *requestedPtr, int *configurationPtr, u8 flags)
+{
+	u8 nowide = flags & MPT_TARGET_NO_NEGO_WIDE;
+	u8 nosync = flags & MPT_TARGET_NO_NEGO_SYNC;
+
+	*configurationPtr = 0;
+	*requestedPtr = width ? MPI_SCSIDEVPAGE1_RP_WIDE : 0;
+	*requestedPtr |= (offset << 16) | (factor << 8);
+
+	if (width && offset && !nowide && !nosync) {
+		if (factor < MPT_ULTRA160) {
+			*requestedPtr |= (MPI_SCSIDEVPAGE1_RP_IU + MPI_SCSIDEVPAGE1_RP_DT);
+			if ((flags & MPT_TARGET_NO_NEGO_QAS) == 0)
+				*requestedPtr |= MPI_SCSIDEVPAGE1_RP_QAS;
+		} else if (factor < MPT_ULTRA2) {
+			*requestedPtr |= MPI_SCSIDEVPAGE1_RP_DT;
+		}
+	}
+
+	if (nowide)
+		*configurationPtr |= MPI_SCSIDEVPAGE1_CONF_WDTR_DISALLOWED;
+
+	if (nosync)
+		*configurationPtr |= MPI_SCSIDEVPAGE1_CONF_SDTR_DISALLOWED;
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_writeSDP1  - write SCSI Device Page 1
+ *	@hd: Pointer to a SCSI Host Strucutre
+ *	@portnum: IOC port number
+ *	@target_id: writeSDP1 for single ID
+ *	@flags: MPT_SCSICFG_ALL_IDS, MPT_SCSICFG_USE_NVRAM, MPT_SCSICFG_BLK_NEGO
+ *
+ *	Return: -EFAULT if read of config page header fails
+ *		or 0 if success.
+ *
+ *	Remark: If a target has been found, the settings from the
+ *		target structure are used, else the device is set
+ *		to async/narrow.
+ *
+ *	Remark: Called during init and after a FW reload.
+ *	Remark: We do not wait for a return, write pages sequentially.
+ */
+static int
+mptscsih_writeSDP1(MPT_SCSI_HOST *hd, int portnum, int target_id, int flags)
+{
+	MPT_ADAPTER		*ioc = hd->ioc;
+	Config_t		*pReq = NULL;
+	SCSIDevicePage1_t	*pData = NULL;
+	VirtDevice		*pTarget = NULL;
+	MPT_FRAME_HDR		*mf;
+	dma_addr_t		 dataDma;
+	u16			 req_idx;
+	u32			 frameOffset;
+	u32			 requested, configuration, flagsLength;
+	int			 ii, nvram;
+	int			 id = 0, maxid = 0;
+	u8			 width;
+	u8			 factor;
+	u8			 offset;
+	u8			 bus = 0;
+	u8			 negoFlags;
+
+	if (ioc->spi_data.sdp1length == 0)
+		return 0;
+
+	if (flags & MPT_SCSICFG_ALL_IDS) {
+		id = 0;
+		maxid = ioc->sh->max_id - 1;
+	} else if (ioc->sh) {
+		id = target_id;
+		maxid = MIN(id, ioc->sh->max_id - 1);
+	}
+
+	for (; id <= maxid; id++) {
+		if (id == ioc->pfacts[portnum].PortSCSIID)
+			continue;
+
+		if (flags & MPT_SCSICFG_USE_NVRAM) {
+			/* Use NVRAM, adapter maximums and target settings.
+			 * Data over-riden by target structure information, if present
+			 */
+			width = ioc->spi_data.maxBusWidth;
+			offset = ioc->spi_data.maxSyncOffset;
+			factor = ioc->spi_data.minSyncFactor;
+			if (ioc->spi_data.nvram && (ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+				nvram = ioc->spi_data.nvram[id];
+
+				if (width)
+					width = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;
+
+				if (offset > 0) {
+					factor = (nvram & MPT_NVRAM_SYNC_MASK) >> 8;
+					if (factor == 0) {
+						/* Key for async */
+						factor = MPT_ASYNC;
+						offset = 0;
+					} else if (factor < ioc->spi_data.minSyncFactor) {
+						factor = ioc->spi_data.minSyncFactor;
+					}
+				} else
+					factor = MPT_ASYNC;
+			}
+
+			/* Set the negotiation flags.
+			 */
+			negoFlags = ioc->spi_data.noQas;
+			if (!width)
+				negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+	
+			if (!offset)
+				negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+		} else {
+			width = 0;
+			factor = MPT_ASYNC;
+			offset = 0;
+			negoFlags = MPT_TARGET_NO_NEGO_SYNC;
+		}
+
+		/* If id is not a raid volume, get the updated
+		 * transmission settings from the target structure.
+		 */
+		if (hd->Targets && (pTarget = hd->Targets[id]) && !pTarget->raidVolume) {
+			width = pTarget->maxWidth;
+			factor = pTarget->minSyncFactor;
+			offset = pTarget->maxOffset;
+			negoFlags = pTarget->negoFlags;
+			pTarget = NULL;
+		}
+
+		if (flags & MPT_SCSICFG_BLK_NEGO)
+			negoFlags = MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC;
+
+		/* REMOVE - can this be removed without problems?????
+		else if (negoFlags == (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC))
+			continue;
+		*/
+
+		mptscsih_setDevicePage1Flags(width, factor, offset,
+					&requested, &configuration, negoFlags);
+
+
+		/* Get a MF for this command.
+		 */
+		if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc->id)) == NULL) {
+			dprintk((MYIOC_s_WARN_FMT "write SDP1: no msg frames!\n",
+						ioc->name));
+			return -EAGAIN;
+		}
+
+		/* Set the request and the data pointers.
+		 * Request takes: 36 bytes (32 bit SGE)
+		 * SCSI Device Page 1 requires 16 bytes
+		 * 40 + 16 <= size of SCSI IO Request = 56 bytes
+		 * and MF size >= 64 bytes.
+		 * Place data at end of MF.
+		 */
+		pReq = (Config_t *)mf;
+
+		req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+		frameOffset = ioc->req_sz - sizeof(SCSIDevicePage1_t);
+
+		pData = (SCSIDevicePage1_t *)((u8 *) mf + frameOffset);
+		dataDma = ioc->req_frames_dma + (req_idx * ioc->req_sz) + frameOffset;
+
+		/* Complete the request frame (same for all requests).
+		 */
+		pReq->Action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+		pReq->Reserved = 0;
+		pReq->ChainOffset = 0;
+		pReq->Function = MPI_FUNCTION_CONFIG;
+		pReq->Reserved1[0] = 0;
+		pReq->Reserved1[1] = 0;
+		pReq->Reserved1[2] = 0;
+		pReq->MsgFlags = 0;
+		for (ii=0; ii < 8; ii++) {
+			pReq->Reserved2[ii] = 0;
+		}
+		pReq->Header.PageVersion = ioc->spi_data.sdp1version;
+		pReq->Header.PageLength = ioc->spi_data.sdp1length;
+		pReq->Header.PageNumber = 1;
+		pReq->Header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+		pReq->PageAddress = cpu_to_le32(id | (bus << 8 ));
+
+		/* Add a SGE to the config request.
+		 */
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE | ioc->spi_data.sdp1length * 4;
+
+		mpt_add_sge((char *)&pReq->PageBufferSGE, flagsLength, dataDma);
+
+		/* Set up the common data portion
+		 */
+		pData->Header.PageVersion = pReq->Header.PageVersion;
+		pData->Header.PageLength = pReq->Header.PageLength;
+		pData->Header.PageNumber = pReq->Header.PageNumber;
+		pData->Header.PageType = pReq->Header.PageType;
+		pData->RequestedParameters = cpu_to_le32(requested);
+		pData->Reserved = 0;
+		pData->Configuration = cpu_to_le32(configuration);
+
+		dprintk((MYIOC_s_INFO_FMT 
+			"write SDP1: id %d pgaddr 0x%x req 0x%x config 0x%x\n",
+				ioc->name, id, (id | (bus<<8)), 
+				requested, configuration));
+
+		mptscsih_put_msgframe(ScsiDoneCtx, ioc->id, mf);
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_taskmgmt_timeout - Call back for timeout on a
+ *	task management request.
+ *	@data: Pointer to MPT_SCSI_HOST recast as an unsigned long
+ *
+ */
+static void mptscsih_taskmgmt_timeout(unsigned long data)
+{
+	MPT_SCSI_HOST *hd = (MPT_SCSI_HOST *) data;
+
+	dtmprintk((KERN_WARNING MYNAM ": %s: mptscsih_taskmgmt_timeout: "
+		   "TM request timed out!\n", hd->ioc->name));
+
+	/* Delete the timer that triggered this callback.
+	 * Remark: del_timer checks to make sure timer is active
+	 * before deleting.
+	 */
+	del_timer(&hd->TMtimer);
+
+#ifdef MPT_SCSI_USE_NEW_EH
+	/* Set the error flag to 1 so that the function that started the
+	 * task management request knows it timed out.
+	 */
+	hd->tmState = TM_STATE_ERROR;
+#endif
+
+	/* Call the reset handler. Already had a TM request
+	 * timeout - so issue a diagnostic reset
+	 */
+	if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
+		printk((KERN_WARNING " Firmware Reload FAILED!!\n"));
+	}
+#ifdef MPT_SCSI_USE_NEW_EH
+	else {
+		/* Because we have reset the IOC, no TM requests can be
+		 * pending.  So let's make sure the tmPending flag is reset.
+		 */
+		nehprintk((KERN_WARNING MYNAM 
+			   ": %s: mptscsih_taskmgmt_timeout\n", 
+			   hd->ioc->name));
+		hd->tmPending = 0;
+	}
+#endif
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Bus Scan and Domain Validation functionality ...
+ */
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_scandv_complete - Scan and DV callback routine registered
+ *	to Fustion MPT (base) driver.
+ *
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@mf: Pointer to original MPT request frame
+ *	@mr: Pointer to MPT reply frame (NULL if TurboReply)
+ *
+ *	This routine is called from mpt.c::mpt_interrupt() at the completion
+ *	of any SCSI IO request.
+ *	This routine is registered with the Fusion MPT (base) driver at driver
+ *	load/init time via the mpt_register() API call.
+ *
+ *	Returns 1 indicating alloc'd request frame ptr should be freed.
+ *
+ *	Remark: Sets a completion code and (possibly) saves sense data
+ *	in the IOC member localReply structure.
+ *	Used ONLY for bus scan, DV and other internal commands.
+ */
+static int
+mptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)
+{
+	MPT_SCSI_HOST	*hd;
+	SCSIIORequest_t *pReq;
+	int		 completionCode;
+	u16		 req_idx;
+
+	if ((mf == NULL) ||
+	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
+		printk(MYIOC_s_ERR_FMT
+			"ScanDvComplete, %s req frame ptr! (=%p)\n",
+				ioc->name, mf?"BAD":"NULL", (void *) mf);
+		goto wakeup;
+	}
+
+	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+	del_timer(&hd->timer);
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	hd->ScsiLookup[req_idx] = NULL;
+	pReq = (SCSIIORequest_t *) mf;
+
+	if (mf != hd->cmdPtr) {
+		printk(MYIOC_s_WARN_FMT "ScanDvComplete (mf=%p, cmdPtr=%p)\n",
+				hd->ioc->name, (void *)mf, (void *) hd->cmdPtr);
+	}
+	hd->cmdPtr = NULL;
+
+	ddvprintk((MYIOC_s_INFO_FMT "ScanDvComplete (mf=%p,mr=%p)\n",
+			hd->ioc->name, mf, mr));
+
+	atomic_dec(&queue_depth);
+
+	hd->pLocal = &hd->localReply;
+
+	/* If target struct exists, clear sense valid flag.
+	 */
+	clear_sense_flag(hd, pReq);
+
+	if (mr == NULL) {
+		completionCode = MPT_SCANDV_GOOD;
+	} else {
+		SCSIIOReply_t	*pReply;
+		u16		 status;
+
+		pReply = (SCSIIOReply_t *) mr;
+
+		status = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+
+		ddvprintk((KERN_NOTICE "  IOCStatus=%04xh, SCSIState=%02xh, SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
+			     status, pReply->SCSIState, pReply->SCSIStatus,
+			     le32_to_cpu(pReply->IOCLogInfo)));
+
+		switch(status) {
+
+		case MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:	/* 0x0043 */
+			completionCode = MPT_SCANDV_SELECTION_TIMEOUT;
+			break;
+
+		case MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:		/* 0x0046 */
+		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
+		case MPI_IOCSTATUS_SCSI_IOC_TERMINATED:		/* 0x004B */
+		case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:		/* 0x004C */
+			completionCode = MPT_SCANDV_DID_RESET;
+			break;
+
+		case MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:		/* 0x0045 */
+		case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:	/* 0x0040 */
+		case MPI_IOCSTATUS_SUCCESS:			/* 0x0000 */
+			if (pReply->Function == MPI_FUNCTION_CONFIG) {
+				ConfigReply_t *pr = (ConfigReply_t *)mr;
+				completionCode = MPT_SCANDV_GOOD;
+				hd->pLocal->header.PageVersion = pr->Header.PageVersion;
+				hd->pLocal->header.PageLength = pr->Header.PageLength;
+				hd->pLocal->header.PageNumber = pr->Header.PageNumber;
+				hd->pLocal->header.PageType = pr->Header.PageType;
+
+			} else if (pReply->Function == MPI_FUNCTION_RAID_ACTION) {
+				/* If the RAID Volume request is successful,
+				 * return GOOD, else indicate that
+				 * some type of error occurred.
+				 */
+				MpiRaidActionReply_t	*pr = (MpiRaidActionReply_t *)mr;
+				if (pr->ActionStatus == MPI_RAID_ACTION_ASTATUS_SUCCESS)
+					completionCode = MPT_SCANDV_GOOD;
+				else
+					completionCode = MPT_SCANDV_SOME_ERROR;
+
+			} else if (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
+				VirtDevice	*target;
+				u8		*sense_data;
+				int		 sz;
+
+				/* save sense data in global & target structure
+				 */
+				completionCode = MPT_SCANDV_SENSE;
+				hd->pLocal->scsiStatus = pReply->SCSIStatus;
+				sense_data = ((u8 *)hd->ioc->sense_buf_pool +
+					(req_idx * MPT_SENSE_BUFFER_ALLOC));
+
+				sz = MIN (pReq->SenseBufferLength,
+							SCSI_STD_SENSE_BYTES);
+				memcpy(hd->pLocal->sense, sense_data, sz);
+
+				target = hd->Targets[pReq->TargetID];
+				if (target) {
+					memcpy(target->sense, sense_data, sz);
+					target->tflags
+						|= MPT_TARGET_FLAGS_VALID_SENSE;
+				}
+
+				ddvprintk((KERN_NOTICE "  Check Condition, sense ptr %p\n",
+						sense_data));
+			} else if (pReply->SCSIState & (MPI_SCSI_STATE_AUTOSENSE_FAILED |
+							MPI_SCSI_STATE_NO_SCSI_STATUS)) {
+				completionCode = MPT_SCANDV_DID_RESET;
+			} else if (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
+				completionCode = MPT_SCANDV_DID_RESET;
+			} else {
+				/* If no error, this will be equivalent
+				 * to MPT_SCANDV_GOOD
+				 */
+				completionCode = (int) pReply->SCSIStatus;
+			}
+			break;
+
+		case MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:		/* 0x0047 */
+			if (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED)
+				completionCode = MPT_SCANDV_DID_RESET;
+			else
+				completionCode = MPT_SCANDV_SOME_ERROR;
+			break;
+
+		default:
+			completionCode = MPT_SCANDV_SOME_ERROR;
+			break;
+
+		}	/* switch(status) */
+
+		ddvprintk((KERN_NOTICE "  completionCode set to %08xh\n",
+				completionCode));
+	} /* end of address reply case */
+
+	hd->pLocal->completion = completionCode;
+
+	/* MF and RF are freed in mpt_interrupt
+	 */
+wakeup:
+	/* Free Chain buffers (will never chain) in scan or dv */
+	//mptscsih_freeChainBuffers(hd, req_idx);
+
+	/*
+	 * Wake up the original calling thread
+	 */
+	scandv_wait_done = 1;
+	wake_up(&scandv_waitq);
+
+	return 1;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_timer_expired - Call back for timer process.
+ *	Used only for dv functionality.
+ *	@data: Pointer to MPT_SCSI_HOST recast as an unsigned long
+ *
+ */
+static void mptscsih_timer_expired(unsigned long data)
+{
+	MPT_SCSI_HOST *hd = (MPT_SCSI_HOST *) data;
+#ifndef MPT_SCSI_USE_NEW_EH
+	unsigned long  flags;
+#endif
+
+
+	ddvprintk((MYIOC_s_WARN_FMT "Timer Expired! Cmd %p\n", hd->ioc->name, hd->cmdPtr));
+
+	if (hd->cmdPtr) {
+		MPIHeader_t *cmd = (MPIHeader_t *)hd->cmdPtr;
+
+		if (cmd->Function == MPI_FUNCTION_SCSI_IO_REQUEST) {
+			/* Desire to issue a task management request here.
+			 * TM requests MUST be single threaded.
+			 * If old eh code and no TM current, issue request.
+			 * If new eh code, do nothing. Wait for OS cmd timeout
+			 *	for bus reset.
+			 */
+#ifndef MPT_SCSI_USE_NEW_EH
+			spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+			if (hd->tmPending) {
+				spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+				return;
+			} else 
+				hd->tmPending = 1;
+			spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+			if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,
+							0, 0, 0, NO_SLEEP) < 0) {
+				printk(MYIOC_s_WARN_FMT "TM FAILED!\n", hd->ioc->name);
+			}
+#else
+			ddvtprintk((MYIOC_s_NOTE_FMT "DV Cmd Timeout: NoOp\n", hd->ioc->name));
+#endif
+		} else {
+			/* Perform a FW reload */
+			if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
+				printk(MYIOC_s_WARN_FMT "Firmware Reload FAILED!\n", hd->ioc->name);
+			}
+		}
+	} else {
+		/* This should NEVER happen */
+		printk(MYIOC_s_WARN_FMT "Null cmdPtr!!!!\n", hd->ioc->name);
+	}
+
+	/* No more processing.
+	 * TM call will generate an interrupt for SCSI TM Management.
+	 * The FW will reply to all outstanding commands, callback will finish cleanup.
+	 * Hard reset clean-up will free all resources.
+	 */
+	ddvprintk((MYIOC_s_WARN_FMT "Timer Expired Complete!\n", hd->ioc->name));
+
+	return;
+}
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_do_raid - Format and Issue a RAID volume request message.
+ *	@hd: Pointer to scsi host structure
+ *	@action: What do be done.
+ *	@id: Logical target id.
+ *	@bus: Target locations bus.
+ *
+ *	Returns: < 0 on a fatal error
+ *		0 on success
+ *
+ *	Remark: Wait to return until reply processed by the ISR.
+ */
+static int
+mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 action, INTERNAL_CMD *io)
+{
+	MpiRaidActionRequest_t	*pReq;
+	MPT_FRAME_HDR		*mf;
+	int			in_isr;
+
+	in_isr = in_interrupt();
+	if (in_isr) {
+		dprintk((MYIOC_s_WARN_FMT "Internal raid request not allowed in ISR context!\n",
+       				hd->ioc->name));
+		return -EPERM;
+	}
+
+	/* Get and Populate a free Frame
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiScanDvCtx, hd->ioc->id)) == NULL) {
+		ddvprintk((MYIOC_s_WARN_FMT "_do_raid: no msg frames!\n",
+					hd->ioc->name));
+		return -EAGAIN;
+	}
+	pReq = (MpiRaidActionRequest_t *)mf;
+	pReq->Action = action;
+	pReq->Reserved1 = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_RAID_ACTION;
+	pReq->VolumeID = io->id;
+	pReq->VolumeBus = io->bus;
+	pReq->PhysDiskNum = io->physDiskNum;
+	pReq->MsgFlags = 0;
+	pReq->Reserved2 = 0;
+	pReq->ActionDataWord = 0; /* Reserved for this action */
+	//pReq->ActionDataSGE = 0;
+
+	mpt_add_sge((char *)&pReq->ActionDataSGE, 
+		MPT_SGE_FLAGS_SSIMPLE_READ | 0, (dma_addr_t) -1);
+
+	ddvprintk((MYIOC_s_INFO_FMT "RAID Volume action %x id %d\n",
+			hd->ioc->name, action, io->id));
+
+	hd->pLocal = NULL;
+	hd->timer.expires = jiffies + HZ*2; /* 2 second timeout */
+	scandv_wait_done = 0;
+
+	/* Save cmd pointer, for resource free if timeout or
+	 * FW reload occurs
+	 */
+	hd->cmdPtr = mf;
+
+	add_timer(&hd->timer);
+	mptscsih_put_msgframe(ScsiScanDvCtx, hd->ioc->id, mf);
+	wait_event(scandv_waitq, scandv_wait_done);
+
+	if ((hd->pLocal == NULL) || (hd->pLocal->completion != MPT_SCANDV_GOOD))
+		return -1;
+
+	return 0;
+}
+#endif /* ~MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_do_cmd - Do internal command.
+ *	@hd: MPT_SCSI_HOST pointer
+ *	@io: INTERNAL_CMD pointer.
+ *
+ *	Issue the specified internally generated command and do command
+ *	specific cleanup. For bus scan / DV only.
+ *	NOTES: If command is Inquiry and status is good,
+ *	initialize a target structure, save the data
+ *
+ *	Remark: Single threaded access only.
+ *
+ *	Return:
+ *		< 0 if an illegal command or no resources
+ *
+ *		   0 if good
+ *
+ *		 > 0 if command complete but some type of completion error.
+ */
+static int
+mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *io)
+{
+	MPT_FRAME_HDR	*mf;
+	SCSIIORequest_t	*pScsiReq;
+	SCSIIORequest_t	 ReqCopy;
+	int		 my_idx, ii, dir;
+	int		 rc, cmdTimeout;
+	int		in_isr;
+	char		 cmdLen;
+	char		 CDB[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+	char		 cmd = io->cmd;
+
+	in_isr = in_interrupt();
+	if (in_isr) {
+		dprintk((MYIOC_s_WARN_FMT "Internal SCSI IO request not allowed in ISR context!\n",
+       				hd->ioc->name));
+		return -EPERM;
+	}
+
+
+	/* Set command specific information
+	 */
+	switch (cmd) {
+	case CMD_Inquiry:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		CDB[4] = io->size;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_TestUnitReady:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_StartStopUnit:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		CDB[4] = 1;	/*Spin up the disk */
+		cmdTimeout = 15;
+		break;
+
+	case CMD_ReadBuffer:
+		cmdLen = 10;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		if (io->flags & MPT_ICFLAG_ECHO) {
+			CDB[1] = 0x0A;
+		} else {
+			CDB[1] = 0x02;
+		}
+
+		if (io->flags & MPT_ICFLAG_BUF_CAP) {
+			CDB[1] |= 0x01;
+		}
+		CDB[6] = (io->size >> 16) & 0xFF;
+		CDB[7] = (io->size >>  8) & 0xFF;
+		CDB[8] = io->size & 0xFF;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_WriteBuffer:
+		cmdLen = 10;
+		dir = MPI_SCSIIO_CONTROL_WRITE;
+		CDB[0] = cmd;
+		if (io->flags & MPT_ICFLAG_ECHO) {
+			CDB[1] = 0x0A;
+		} else {
+			CDB[1] = 0x02;
+		}
+		CDB[6] = (io->size >> 16) & 0xFF;
+		CDB[7] = (io->size >>  8) & 0xFF;
+		CDB[8] = io->size & 0xFF;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_Reserve6:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_Release6:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_SynchronizeCache:
+		cmdLen = 10;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+//		CDB[1] = 0x02;	/* set immediate bit */
+		cmdTimeout = 10;
+		break;
+
+	default:
+		/* Error Case */
+		return -EFAULT;
+	}
+
+	/* Get and Populate a free Frame
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiScanDvCtx, hd->ioc->id)) == NULL) {
+		ddvprintk((MYIOC_s_WARN_FMT "No msg frames!\n",
+					hd->ioc->name));
+		return -EBUSY;
+	}
+
+	pScsiReq = (SCSIIORequest_t *) mf;
+
+	/* Get the request index */
+	my_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	ADD_INDEX_LOG(my_idx); /* for debug */
+
+	if (io->flags & MPT_ICFLAG_PHYS_DISK) {
+		pScsiReq->TargetID = io->physDiskNum;
+		pScsiReq->Bus = 0;
+		pScsiReq->ChainOffset = 0;
+		pScsiReq->Function = MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;
+	} else {
+		pScsiReq->TargetID = io->id;
+		pScsiReq->Bus = io->bus;
+		pScsiReq->ChainOffset = 0;
+		pScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
+	}
+
+	pScsiReq->CDBLength = cmdLen;
+	pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+
+	pScsiReq->Reserved = 0;
+
+	pScsiReq->MsgFlags = mpt_msg_flags();
+	/* MsgContext set in mpt_get_msg_fram call  */
+
+	for (ii=0; ii < 8; ii++)
+		pScsiReq->LUN[ii] = 0;
+	pScsiReq->LUN[1] = io->lun;
+
+	if (io->flags & MPT_ICFLAG_TAGGED_CMD)
+		pScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_SIMPLEQ);
+	else
+		pScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_UNTAGGED);
+
+	for (ii=0; ii < 16; ii++)
+		pScsiReq->CDB[ii] = CDB[ii];
+
+	pScsiReq->DataLength = cpu_to_le32(io->size);
+	pScsiReq->SenseBufferLowAddr = cpu_to_le32(hd->ioc->sense_buf_low_dma
+					   + (my_idx * MPT_SENSE_BUFFER_ALLOC));
+
+	ddvprintk((MYIOC_s_INFO_FMT "Sending Command 0x%x for (%d:%d:%d)\n",
+			hd->ioc->name, cmd, io->bus, io->id, io->lun));
+
+	if (dir == MPI_SCSIIO_CONTROL_READ) {
+		mpt_add_sge((char *) &pScsiReq->SGL,
+			MPT_SGE_FLAGS_SSIMPLE_READ | io->size,
+			io->data_dma);
+	} else {
+		mpt_add_sge((char *) &pScsiReq->SGL,
+			MPT_SGE_FLAGS_SSIMPLE_WRITE | io->size,
+			io->data_dma);
+	}
+
+	/* The ISR will free the request frame, but we need
+	 * the information to initialize the target. Duplicate.
+	 */
+	memcpy(&ReqCopy, pScsiReq, sizeof(SCSIIORequest_t));
+
+	/* Issue this command after:
+	 *	finish init
+	 *	add timer
+	 * Wait until the reply has been received
+	 *  ScsiScanDvCtx callback function will
+	 *	set hd->pLocal;
+	 *	set scandv_wait_done and call wake_up
+	 */
+	hd->pLocal = NULL;
+	hd->timer.expires = jiffies + HZ*cmdTimeout;
+	scandv_wait_done = 0;
+
+	/* Save cmd pointer, for resource free if timeout or
+	 * FW reload occurs
+	 */
+	hd->cmdPtr = mf;
+
+	add_timer(&hd->timer);
+	mptscsih_put_msgframe(ScsiScanDvCtx, hd->ioc->id, mf);
+	wait_event(scandv_waitq, scandv_wait_done);
+
+	if (hd->pLocal) {
+		rc = hd->pLocal->completion;
+		hd->pLocal->skip = 0;
+
+		/* Always set fatal error codes in some cases.
+		 */
+		if (rc == MPT_SCANDV_SELECTION_TIMEOUT)
+			rc = -ENXIO;
+		else if (rc == MPT_SCANDV_SOME_ERROR)
+			rc =  -rc;
+	} else {
+		rc = -EFAULT;
+		/* This should never happen. */
+		ddvprintk((MYIOC_s_INFO_FMT "_do_cmd: Null pLocal!!!\n",
+				hd->ioc->name));
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_synchronize_cache - Send SYNCHRONIZE_CACHE to all disks.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@portnum: IOC port number
+ *
+ *	Uses the ISR, but with special processing.
+ *	MUST be single-threaded.
+ *
+ *	Return: 0 on completion
+ */
+static int
+mptscsih_synchronize_cache(MPT_SCSI_HOST *hd, int portnum)
+{
+	MPT_ADAPTER		*ioc= hd->ioc;
+	VirtDevice		*pTarget = NULL;
+	SCSIDevicePage1_t	*pcfg1Data = NULL;
+	INTERNAL_CMD		 iocmd;
+	CONFIGPARMS		 cfg;
+	dma_addr_t		 cfg1_dma_addr = -1;
+	ConfigPageHeader_t	 header1;
+	int			 bus = 0;
+	int			 id = 0;
+	int			 lun = 0;
+	int			 hostId = ioc->pfacts[portnum].PortSCSIID;
+	int			 max_id;
+	int			 requested, configuration, data;
+	int			 doConfig = 0;
+	u8			 flags, factor;
+
+	max_id = ioc->sh->max_id - 1;
+
+	/* Following parameters will not change
+	 * in this routine.
+	 */
+	iocmd.cmd = CMD_SynchronizeCache;
+	iocmd.flags = 0;
+	iocmd.physDiskNum = -1;
+	iocmd.data = NULL;
+	iocmd.data_dma = -1;
+	iocmd.size = 0;
+	iocmd.rsvd = iocmd.rsvd2 = 0;
+
+	/* No SCSI hosts
+	 */
+	if (hd->Targets == NULL)
+		return 0;
+
+	/* Skip the host
+	 */
+	if (id == hostId)
+		id++;
+
+	/* Write SDP1 for all SCSI devices 
+	 * Alloc memory and set up config buffer
+	 */
+	if (hd->is_spi) {
+		if (ioc->spi_data.sdp1length > 0) {
+			pcfg1Data = (SCSIDevicePage1_t *)pci_alloc_consistent(ioc->pcidev,
+					 ioc->spi_data.sdp1length * 4, &cfg1_dma_addr);
+	
+			if (pcfg1Data != NULL) {
+				doConfig = 1;
+				header1.PageVersion = ioc->spi_data.sdp1version;
+				header1.PageLength = ioc->spi_data.sdp1length;
+				header1.PageNumber = 1;
+				header1.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+				cfg.hdr = &header1;
+				cfg.physAddr = cfg1_dma_addr;
+				cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+				cfg.dir = 1;
+				cfg.timeout = 0;
+			}
+		}
+	}
+
+	/* loop through all devices on this port
+	 */
+	while (bus < MPT_MAX_BUS) {
+		iocmd.bus = bus;
+		iocmd.id = id;
+		pTarget = hd->Targets[(int)id];
+
+		if (doConfig) {
+
+			/* Set the negotiation flags */
+			if (pTarget && (pTarget = hd->Targets[id]) && !pTarget->raidVolume) {
+				flags = pTarget->negoFlags;
+			} else {
+				flags = hd->ioc->spi_data.noQas;
+				if (hd->ioc->spi_data.nvram && (hd->ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+					data = hd->ioc->spi_data.nvram[id];
+	
+					if (data & MPT_NVRAM_WIDE_DISABLE)
+						flags |= MPT_TARGET_NO_NEGO_WIDE;
+
+					factor = (data & MPT_NVRAM_SYNC_MASK) >> MPT_NVRAM_SYNC_SHIFT;
+					if ((factor == 0) || (factor == MPT_ASYNC))
+						flags |= MPT_TARGET_NO_NEGO_SYNC;
+				}
+			}
+	
+			/* Force to async, narrow */
+			mptscsih_setDevicePage1Flags(0, MPT_ASYNC, 0, &requested,
+					&configuration, flags);
+			pcfg1Data->RequestedParameters = le32_to_cpu(requested);
+			pcfg1Data->Reserved = 0;
+			pcfg1Data->Configuration = le32_to_cpu(configuration);
+			cfg.pageAddr = (bus<<8) | id;
+			mpt_config(hd->ioc, &cfg);
+		}
+
+		/* If target Ptr NULL or if this target is NOT a disk, skip.
+		 */
+	//	if (pTarget && ((pTarget->inq_data[0] & 0x1F) == 0)) {
+		if (pTarget) {
+			for (lun=0; lun <= MPT_LAST_LUN; lun++) {
+				/* If LUN present, issue the command
+				 */
+				if (pTarget->luns & (1<<lun)) {
+					iocmd.lun = lun;
+					(void) mptscsih_do_cmd(hd, &iocmd);
+				}
+			}
+		}
+
+		/* get next relevant device */
+		id++;
+
+		if (id == hostId)
+			id++;
+
+		if (id > max_id) {
+			id = 0;
+			bus++;
+		}
+	}
+
+	if (pcfg1Data) {
+		pci_free_consistent(ioc->pcidev, header1.PageLength * 4, pcfg1Data, cfg1_dma_addr);
+	}
+
+	return 0;
+}
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_domainValidation - Top level handler for domain validation.
+ *	@hd: Pointer to MPT_SCSI_HOST structure.
+ *
+ *	Uses the ISR, but with special processing.
+ *	Called from schedule, should not be in interrupt mode.
+ *	While thread alive, do dv for all devices needing dv
+ *
+ *	Return: None.
+ */
+static void
+mptscsih_domainValidation(void *arg)
+{
+	MPT_SCSI_HOST		*hd = NULL;
+	MPT_ADAPTER		*ioc = NULL;
+	unsigned long		 flags;
+	int 			 id, maxid, dvStatus, did;
+	int			 ii, isPhysDisk;
+	u8			 oldQas;
+
+	spin_lock_irqsave(&dvtaskQ_lock, flags);
+	dvtaskQ_active = 1;
+	if (dvtaskQ_release) {
+		dvtaskQ_active = 0;
+		spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+		return;
+	}
+	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+
+	/* For this ioc, loop through all devices and do dv to each device.
+	 * When complete with this ioc, search through the ioc list, and 
+	 * for each scsi ioc found, do dv for all devices. Exit when no
+	 * device needs dv.
+	 */
+	did = 1;
+	while (did) {
+		did = 0;
+		for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc = mpt_adapter_find_next(ioc)) {
+			spin_lock_irqsave(&dvtaskQ_lock, flags);
+			if (dvtaskQ_release) {
+				dvtaskQ_active = 0;
+				spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+				return;
+			}
+			spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/4);
+
+			/* DV only to SCSI adapters */
+			if ((int)ioc->chip_type <= (int)FC929)
+				continue;
+			
+			/* Make sure everything looks ok */
+			if (ioc->sh == NULL)
+				continue;
+
+			hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+			if (hd == NULL)
+				continue;
+
+			maxid = MIN (ioc->sh->max_id, MPT_MAX_SCSI_DEVICES);
+
+			for (id = 0; id < maxid; id++) {
+				oldQas = hd->ioc->spi_data.noQas;
+				spin_lock_irqsave(&dvtaskQ_lock, flags);
+				if (dvtaskQ_release) {
+					dvtaskQ_active = 0;
+					spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+					return;
+				}
+				spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+				dvStatus = hd->ioc->spi_data.dvStatus[id];
+
+				if (dvStatus & MPT_SCSICFG_NEED_DV) {
+
+					hd->ioc->spi_data.dvStatus[id] |= MPT_SCSICFG_DV_PENDING;
+					hd->ioc->spi_data.dvStatus[id] &= ~MPT_SCSICFG_NEED_DV;
+
+					set_current_state(TASK_INTERRUPTIBLE);
+					schedule_timeout(HZ/4);
+
+					/* If hidden phys disk, block IO's to all
+					 *	raid volumes
+					 * else, process normally
+					 */
+					isPhysDisk = mptscsih_is_phys_disk(ioc, id);
+					if (isPhysDisk) {
+						for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+							if (hd->ioc->spi_data.isRaid & (1 << ii)) {
+								hd->ioc->spi_data.dvStatus[ii] |= MPT_SCSICFG_DV_PENDING;
+							}
+						}
+					}
+
+					mptscsih_doDv(hd, 0, id);
+					did++;
+					hd->ioc->spi_data.dvStatus[id] |= MPT_SCSICFG_DV_DONE;
+					hd->ioc->spi_data.dvStatus[id] &= ~MPT_SCSICFG_DV_PENDING;
+
+					if (isPhysDisk) {
+						for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+							if (hd->ioc->spi_data.isRaid & (1 << ii)) {
+								hd->ioc->spi_data.dvStatus[ii] &= ~MPT_SCSICFG_DV_PENDING;
+							}
+						}
+					}
+
+					/* Post OS IOs that were pended while
+					 * DV running.
+					 */
+					post_pendingQ_commands(hd);
+
+					if ((!oldQas) && (hd->ioc->spi_data.noQas))
+						mptscsih_qas_check(hd);
+				}
+			}
+		}
+	}
+
+	spin_lock_irqsave(&dvtaskQ_lock, flags);
+	dvtaskQ_active = 0;
+	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+
+	return;
+}
+
+/* Search IOC page 3 to determine if this is hidden physical disk
+ */
+static int mptscsih_is_phys_disk(MPT_ADAPTER *ioc, int id)
+{
+	if (ioc->spi_data.pIocPg3) {
+		Ioc3PhysDisk_t *pPDisk =  ioc->spi_data.pIocPg3->PhysDisk;
+		int		numPDisk = ioc->spi_data.pIocPg3->NumPhysDisks;
+
+		while (numPDisk) {
+			if (pPDisk->PhysDiskID == id) {
+				return 1;
+			}
+			pPDisk++;
+			numPDisk--;
+		}
+	}
+	return 0;
+}
+
+/* Write SDP1 if no QAS has been enabled
+ */
+static void mptscsih_qas_check(MPT_SCSI_HOST *hd)
+{
+	VirtDevice *pTarget = NULL;
+	int ii;
+	int change = 0;
+
+	if (hd->Targets == NULL)
+		return;
+
+	for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+		change = 0;
+		pTarget = hd->Targets[ii];
+
+		if ((pTarget != NULL) && (!pTarget->raidVolume)) {
+			if ((pTarget->negoFlags & hd->ioc->spi_data.noQas) == 0) {
+				change = 1;
+				pTarget->negoFlags |= hd->ioc->spi_data.noQas;
+			}
+		} else {
+			if (mptscsih_is_phys_disk(hd->ioc, ii) == 1)
+				change = 1;
+		}
+
+		if ((change) && (hd->ioc->spi_data.dvStatus[ii] & MPT_SCSICFG_DV_DONE))
+			mptscsih_writeSDP1(hd, 0, ii, 0);
+	}
+	return;
+}
+
+
+
+#define MPT_GET_NVRAM_VALS	0x01
+#define MPT_UPDATE_MAX		0x02
+#define MPT_SET_MAX		0x04
+#define MPT_SET_MIN		0x08
+#define MPT_FALLBACK		0x10
+#define MPT_SAVE		0x20
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_doDv - Perform domain validation to a target.
+ *	@hd: Pointer to MPT_SCSI_HOST structure.
+ *	@portnum: IOC port number.
+ *	@target: Physical ID of this target
+ *
+ *	Uses the ISR, but with special processing.
+ *	MUST be single-threaded.
+ *	Test will exit if target is at async & narrow.
+ *
+ *	Return: None.
+ */
+static void
+mptscsih_doDv(MPT_SCSI_HOST *hd, int portnum, int id)
+{
+	MPT_ADAPTER		*ioc = hd->ioc;
+	VirtDevice		*pTarget = NULL;
+	SCSIDevicePage1_t	*pcfg1Data = NULL;
+	SCSIDevicePage0_t	*pcfg0Data = NULL;
+	u8			*pbuf1 = NULL;
+	u8			*pbuf2 = NULL;
+	u8			*pDvBuf = NULL;
+	dma_addr_t		 dvbuf_dma = -1;
+	dma_addr_t		 buf1_dma = -1;
+	dma_addr_t		 buf2_dma = -1;
+	dma_addr_t		 cfg1_dma_addr = -1;
+	dma_addr_t		 cfg0_dma_addr = -1;
+	ConfigPageHeader_t	 header1;
+	ConfigPageHeader_t	 header0;
+	DVPARAMETERS		 dv;
+	INTERNAL_CMD		 iocmd;
+	CONFIGPARMS		 cfg;
+	int			 dv_alloc = 0;
+	int			 rc, sz = 0;
+	int			 bufsize = 0;
+	int			 dataBufSize = 0;
+	int			 echoBufSize = 0;
+	int			 notDone;
+	int			 patt;
+	int			 repeat;
+	char			 firstPass = 1;
+	char			 doFallback = 0;
+	char			 readPage0;
+	char			 bus, lun;
+	char			 inq0 = 0;
+
+	if (ioc->spi_data.sdp1length == 0)
+		return;
+
+	if (ioc->spi_data.sdp0length == 0)
+		return;
+
+	if (id == ioc->pfacts[portnum].PortSCSIID)
+		return;
+
+	lun = 0;
+	bus = 0;
+	ddvtprintk((MYIOC_s_NOTE_FMT 
+			"DV started: numIOs %d bus=%d, id %d dv @ %p\n",
+			ioc->name, atomic_read(&queue_depth), bus, id, &dv));
+
+	/* Prep DV structure
+	 */
+	memset (&dv, 0, sizeof(DVPARAMETERS));
+	dv.id = id;
+
+	/* Populate tmax with the current maximum
+	 * transfer parameters for this target.
+	 * Exit if narrow and async.
+	 */
+	dv.cmd = MPT_GET_NVRAM_VALS;
+	mptscsih_dv_parms(hd, &dv, NULL);
+	if ((!dv.max.width) && (!dv.max.offset))
+		return;
+
+	/* Prep SCSI IO structure
+	 */
+	iocmd.id = id;
+	iocmd.bus = bus;
+	iocmd.lun = lun;
+	iocmd.flags = 0;
+	iocmd.physDiskNum = -1;
+	iocmd.rsvd = iocmd.rsvd2 = 0;
+
+	/* Use tagged commands if possible.
+	 */
+	pTarget = hd->Targets[id];
+	if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES))
+		iocmd.flags |= MPT_ICFLAG_TAGGED_CMD;
+
+	if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY)) {
+		/* Another GEM workaround. Check peripheral device type,
+		 * if PROCESSOR, quit DV.
+		 */
+		if (((pTarget->inq_data[0] & 0x1F) == 0x03) || ((pTarget->inq_data[0] & 0x1F) > 0x08)) {
+			pTarget->negoFlags |= (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC);
+			return;
+		}
+	}
+
+	/* Prep cfg structure
+	 */
+	cfg.pageAddr = (bus<<8) | id;
+	cfg.hdr = NULL;
+
+	/* Prep SDP0 header
+	 */
+	header0.PageVersion = ioc->spi_data.sdp0version;
+	header0.PageLength = ioc->spi_data.sdp0length;
+	header0.PageNumber = 0;
+	header0.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+
+	/* Prep SDP1 header
+	 */
+	header1.PageVersion = ioc->spi_data.sdp1version;
+	header1.PageLength = ioc->spi_data.sdp1length;
+	header1.PageNumber = 1;
+	header1.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+
+	if (header0.PageLength & 1)
+		dv_alloc = (header0.PageLength * 4) + 4;
+
+	dv_alloc +=  (2048 + (header1.PageLength * 4));
+
+	pDvBuf = pci_alloc_consistent(ioc->pcidev, dv_alloc, &dvbuf_dma);
+	if (pDvBuf == NULL)
+		return;
+
+	sz = 0;
+	pbuf1 = (u8 *)pDvBuf;
+	buf1_dma = dvbuf_dma;
+	sz +=1024;
+
+	pbuf2 = (u8 *) (pDvBuf + sz);
+	buf2_dma = dvbuf_dma + sz;
+	sz +=1024;
+
+	pcfg0Data = (SCSIDevicePage0_t *) (pDvBuf + sz);
+	cfg0_dma_addr = dvbuf_dma + sz;
+	sz += header0.PageLength * 4;
+
+	/* 8-byte alignment
+	 */
+	if (header0.PageLength & 1)
+		sz += 4;
+
+	pcfg1Data = (SCSIDevicePage1_t *) (pDvBuf + sz);
+	cfg1_dma_addr = dvbuf_dma + sz;
+
+	/* Skip this ID? Set cfg.hdr to force config page write
+	 */
+	if ((ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID) &&
+			(!(ioc->spi_data.nvram[id] & MPT_NVRAM_ID_SCAN_ENABLE))) { 
+
+		ddvprintk((MYIOC_s_NOTE_FMT "DV Skipped: bus, id, lun (%d, %d, %d)\n",
+			ioc->name, bus, id, lun));
+
+		dv.cmd = MPT_SET_MAX;
+		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+		cfg.hdr = &header1;
+		goto target_done;
+	}
+
+	/* Finish iocmd inititialization - hidden or visible disk? */
+	if (ioc->spi_data.pIocPg3) {
+		/* Searc IOC page 3 for matching id
+		 */
+		Ioc3PhysDisk_t *pPDisk =  ioc->spi_data.pIocPg3->PhysDisk;
+		int		numPDisk = ioc->spi_data.pIocPg3->NumPhysDisks;
+
+		while (numPDisk) {
+			if (pPDisk->PhysDiskID == id) {
+				/* match */
+				iocmd.flags |= MPT_ICFLAG_PHYS_DISK;
+				iocmd.physDiskNum = pPDisk->PhysDiskNum;
+
+				/* Quiesce the IM
+				 */
+				if (mptscsih_do_raid(hd, MPI_RAID_ACTION_QUIESCE_PHYS_IO, &iocmd) < 0) {
+					ddvprintk((MYIOC_s_ERR_FMT "RAID Queisce FAILED!\n", ioc->name));
+					goto target_done;
+				}
+				break;
+			}
+			pPDisk++;
+			numPDisk--;
+		}
+	}
+
+	/* RAID Volume ID's may double for a physical device. If RAID but
+	 * not a physical ID as well, skip DV.
+	 */
+	if ((hd->ioc->spi_data.isRaid & (1 << id)) && !(iocmd.flags & MPT_ICFLAG_PHYS_DISK))
+		goto target_done;
+
+
+	/* Basic Test.
+	 * Async & Narrow - Inquiry
+	 * Async & Narrow - Inquiry
+	 * Maximum transfer rate - Inquiry
+	 * Compare buffers:
+	 *	If compare, test complete.
+	 *	If miscompare and first pass, repeat
+	 *	If miscompare and not first pass, fall back and repeat
+	 */
+	hd->pLocal = NULL;
+	readPage0 = 0;
+	sz = SCSI_STD_INQUIRY_BYTES;
+	while (1) {
+		ddvprintk((MYIOC_s_NOTE_FMT "DV: Start Basic test.\n", ioc->name));
+		dv.cmd = MPT_SET_MIN;
+		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+		cfg.hdr = &header1;
+		cfg.physAddr = cfg1_dma_addr;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+		cfg.dir = 1;
+		if (mpt_config(hd->ioc, &cfg) != 0)
+			goto target_done;
+
+		iocmd.cmd = CMD_Inquiry;
+		iocmd.data_dma = buf1_dma;
+		iocmd.data = pbuf1;
+		iocmd.size = sz;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+
+		/* Another GEM workaround. Check peripheral device type,
+		 * if PROCESSOR, quit DV.
+		 */
+		if (((pbuf1[0] & 0x1F) == 0x03) || ((pbuf1[0] & 0x1F) > 0x08))
+			goto target_done;
+
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+
+		if (doFallback)
+			dv.cmd = MPT_FALLBACK;
+		else
+			dv.cmd = MPT_SET_MAX;
+
+		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+		if (mpt_config(hd->ioc, &cfg) != 0)
+			goto target_done;
+
+		if ((!dv.now.width) && (!dv.now.offset))
+			goto target_done;
+
+		iocmd.cmd = CMD_Inquiry;
+		iocmd.data_dma = buf2_dma;
+		iocmd.data = pbuf2;
+		iocmd.size = sz;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+		else if (hd->pLocal == NULL)
+			goto target_done;
+		else {
+			/* Save the return code.
+			 * If this is the first pass,
+			 * read SCSI Device Page 0
+			 * and update the target max parameters.
+			 */
+			rc = hd->pLocal->completion;
+			doFallback = 0;
+			if (rc == MPT_SCANDV_GOOD) {
+				if (!readPage0) {
+					u32 sdp0_info;
+					u32 sdp0_nego;
+
+					cfg.hdr = &header0;
+					cfg.physAddr = cfg0_dma_addr;
+					cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+					cfg.dir = 0;
+					if (mpt_config(hd->ioc, &cfg) != 0)
+						goto target_done;
+
+					sdp0_info = le32_to_cpu(pcfg0Data->Information) & 0x0E;
+					sdp0_nego = (le32_to_cpu(pcfg0Data->NegotiatedParameters) & 0xFF00 ) >> 8;
+
+					/* Quantum and Fujitsu workarounds.
+					 * Quantum: PPR U320 -> PPR reply with Ultra2 and wide
+					 * Fujitsu: PPR U320 -> Msg Reject and Ultra2 and wide
+					 * Resetart with a request for U160.
+					 */
+					if ((dv.now.factor == MPT_ULTRA320) && (sdp0_nego == MPT_ULTRA2)) { 
+							doFallback = 1;
+					} else {
+						dv.cmd = MPT_UPDATE_MAX;
+						mptscsih_dv_parms(hd, &dv, (void *)pcfg0Data);
+						/* Update the SCSI device page 1 area
+						 */
+						pcfg1Data->RequestedParameters = pcfg0Data->NegotiatedParameters;
+						readPage0 = 1;
+					}
+				}
+
+				/* Quantum workaround. Restart this test will the fallback
+				 * flag set.
+				 */
+				if (doFallback == 0) {
+					if (memcmp(pbuf1, pbuf2, sz) != 0) {
+						if (!firstPass)
+							doFallback = 1;
+					} else
+						break;	/* test complete */
+				}
+
+
+			} else if ((rc == MPT_SCANDV_DID_RESET) || (rc == MPT_SCANDV_SENSE))
+				doFallback = 1;	/* set fallback flag */
+			else
+				goto target_done;
+
+			firstPass = 0;
+		}
+	}
+	ddvprintk((MYIOC_s_NOTE_FMT "DV: Basic test completed OK.\n", ioc->name));
+	inq0 = (*pbuf1) & 0x1F;
+
+	/* Continue only for disks
+	 */
+	if (inq0 != 0)
+		goto target_done;
+
+	/* Start the Enhanced Test.
+	 * 0) issue TUR to clear out check conditions
+	 * 1) read capacity of echo (regular) buffer
+	 * 2) reserve device
+	 * 3) do write-read-compare data pattern test
+	 * 4) release
+	 * 5) update nego parms to target struct
+	 */
+	cfg.hdr = &header1;
+	cfg.physAddr = cfg1_dma_addr;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+	cfg.dir = 1;
+
+	iocmd.cmd = CMD_TestUnitReady;
+	iocmd.data_dma = -1;
+	iocmd.data = NULL;
+	iocmd.size = 0;
+	notDone = 1;
+	while (notDone) {
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+
+		if (hd->pLocal == NULL)
+			goto target_done;
+
+		rc = hd->pLocal->completion;
+		if (rc == MPT_SCANDV_GOOD)
+			notDone = 0;
+		else if (rc == MPT_SCANDV_SENSE) {
+			u8 skey = hd->pLocal->sense[2] & 0x0F;
+			u8 asc = hd->pLocal->sense[12];
+			u8 ascq = hd->pLocal->sense[13];
+			ddvprintk((MYIOC_s_INFO_FMT
+				"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
+				ioc->name, skey, asc, ascq));
+
+			if (skey == SK_UNIT_ATTENTION)
+				notDone++; /* repeat */
+			else if ((skey == SK_NOT_READY) &&
+					(asc == 0x04)&&(ascq == 0x01)) {
+				/* wait then repeat */
+				mdelay (2000);
+				notDone++;
+			} else if ((skey == SK_NOT_READY) && (asc == 0x3A)) {
+				/* no medium, try read test anyway */
+				notDone = 0;
+			} else {
+				/* All other errors are fatal.
+				 */
+				ddvprintk((MYIOC_s_INFO_FMT "DV: fatal error.",
+						ioc->name));
+				goto target_done;
+			}
+		} else
+			goto target_done;
+	}
+
+	iocmd.cmd = CMD_ReadBuffer;
+	iocmd.data_dma = buf1_dma;
+	iocmd.data = pbuf1;
+	iocmd.size = 4;
+	iocmd.flags |= MPT_ICFLAG_BUF_CAP;
+
+	dataBufSize = 0;
+	echoBufSize = 0;
+	for (patt = 0; patt < 2; patt++) {
+		if (patt == 0)
+			iocmd.flags |= MPT_ICFLAG_ECHO;
+		else
+			iocmd.flags &= ~MPT_ICFLAG_ECHO;
+
+		notDone = 1;
+		while (notDone) {
+			bufsize = 0;
+
+			/* If not ready after 8 trials,
+			 * give up on this device.
+			 */
+			if (notDone > 8)
+				goto target_done;
+
+			if (mptscsih_do_cmd(hd, &iocmd) < 0)
+				goto target_done;
+			else if (hd->pLocal == NULL)
+				goto target_done;
+			else {
+				rc = hd->pLocal->completion;
+				ddvprintk(("ReadBuffer Comp Code %d", rc));
+				ddvprintk(("  buff: %0x %0x %0x %0x\n",
+					pbuf1[0], pbuf1[1], pbuf1[2], pbuf1[3]));
+
+				if (rc == MPT_SCANDV_GOOD) {
+					notDone = 0;
+					if (iocmd.flags & MPT_ICFLAG_ECHO) {
+						bufsize =  ((pbuf1[2] & 0x1F) <<8) | pbuf1[3];
+					} else {
+						bufsize =  pbuf1[1]<<16 | pbuf1[2]<<8 | pbuf1[3];
+					}
+				} else if (rc == MPT_SCANDV_SENSE) {
+					u8 skey = hd->pLocal->sense[2] & 0x0F;
+					u8 asc = hd->pLocal->sense[12];
+					u8 ascq = hd->pLocal->sense[13];
+					ddvprintk((MYIOC_s_INFO_FMT
+						"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
+						ioc->name, skey, asc, ascq));
+					if (skey == SK_ILLEGAL_REQUEST) {
+						notDone = 0;
+					} else if (skey == SK_UNIT_ATTENTION) {
+						notDone++; /* repeat */
+					} else if ((skey == SK_NOT_READY) &&
+						(asc == 0x04)&&(ascq == 0x01)) {
+						/* wait then repeat */
+						mdelay (2000);
+						notDone++;
+					} else {
+						/* All other errors are fatal.
+						 */
+						ddvprintk((MYIOC_s_INFO_FMT "DV: fatal error.",
+							ioc->name));
+						goto target_done;
+					}
+				} else {
+					/* All other errors are fatal
+					 */
+					goto target_done;
+				}
+			}
+		}
+
+		if (iocmd.flags & MPT_ICFLAG_ECHO)
+			echoBufSize = bufsize;
+		else
+			dataBufSize = bufsize;
+	}
+	sz = 0;
+	iocmd.flags &= ~MPT_ICFLAG_BUF_CAP;
+
+	/* Use echo buffers if possible,
+	 * Exit if both buffers are 0.
+	 */
+	if (echoBufSize > 0) {
+		iocmd.flags |= MPT_ICFLAG_ECHO;
+		if (dataBufSize > 0)
+			bufsize = MIN(echoBufSize, dataBufSize);
+		else
+			bufsize = echoBufSize;
+	} else if (dataBufSize == 0)
+		goto target_done;
+
+	ddvprintk((MYIOC_s_INFO_FMT "%s Buffer Capacity %d\n", ioc->name,
+		(iocmd.flags & MPT_ICFLAG_ECHO) ? "Echo" : " ", bufsize));
+
+	/* Data buffers for write-read-compare test max 1K.
+	 */
+	sz = MIN(bufsize, 1024);
+
+	/* --- loop ----
+	 * On first pass, always issue a reserve.
+	 * On additional loops, only if a reset has occurred.
+	 * iocmd.flags indicates if echo or regular buffer
+	 */
+	for (patt = 0; patt < 4; patt++) {
+		ddvprintk(("Pattern %d\n", patt));
+		if ((iocmd.flags & MPT_ICFLAG_RESERVED) && (iocmd.flags & MPT_ICFLAG_DID_RESET)) {
+			iocmd.cmd = CMD_TestUnitReady;
+			iocmd.data_dma = -1;
+			iocmd.data = NULL;
+			iocmd.size = 0;
+			if (mptscsih_do_cmd(hd, &iocmd) < 0)
+				goto target_done;
+
+			iocmd.cmd = CMD_Release6;
+			iocmd.data_dma = -1;
+			iocmd.data = NULL;
+			iocmd.size = 0;
+			if (mptscsih_do_cmd(hd, &iocmd) < 0)
+				goto target_done;
+			else if (hd->pLocal == NULL)
+				goto target_done;
+			else {
+				rc = hd->pLocal->completion;
+				ddvprintk(("Release rc %d\n", rc));
+				if (rc == MPT_SCANDV_GOOD)
+					iocmd.flags &= ~MPT_ICFLAG_RESERVED;
+				else
+					goto target_done;
+			}
+			iocmd.flags &= ~MPT_ICFLAG_RESERVED;
+		}
+		iocmd.flags &= ~MPT_ICFLAG_DID_RESET;
+
+		repeat = 5;
+		while (repeat && (!(iocmd.flags & MPT_ICFLAG_RESERVED))) {
+			iocmd.cmd = CMD_Reserve6;
+			iocmd.data_dma = -1;
+			iocmd.data = NULL;
+			iocmd.size = 0;
+			if (mptscsih_do_cmd(hd, &iocmd) < 0)
+				goto target_done;
+			else if (hd->pLocal == NULL)
+				goto target_done;
+			else {
+				rc = hd->pLocal->completion;
+				if (rc == MPT_SCANDV_GOOD) {
+					iocmd.flags |= MPT_ICFLAG_RESERVED;
+				} else if (rc == MPT_SCANDV_SENSE) {
+					/* Wait if coming ready
+					 */
+					u8 skey = hd->pLocal->sense[2] & 0x0F;
+					u8 asc = hd->pLocal->sense[12];
+					u8 ascq = hd->pLocal->sense[13];
+					ddvprintk((MYIOC_s_INFO_FMT
+						"DV: Reserve Failed: ", ioc->name));
+					ddvprintk(("SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
+							skey, asc, ascq));
+
+					if ((skey == SK_NOT_READY) && (asc == 0x04)&&
+									(ascq == 0x01)) {
+						/* wait then repeat */
+						mdelay (2000);
+						notDone++;
+					} else {
+						ddvprintk((MYIOC_s_INFO_FMT 
+							"DV: Reserved Failed.", ioc->name));
+						goto target_done;
+					}
+				} else {
+					ddvprintk((MYIOC_s_INFO_FMT "DV: Reserved Failed.",
+							 ioc->name));
+					goto target_done;
+				}
+			}
+		}
+
+		mptscsih_fillbuf(pbuf1, sz, patt, 1);
+		iocmd.cmd = CMD_WriteBuffer;
+		iocmd.data_dma = buf1_dma;
+		iocmd.data = pbuf1;
+		iocmd.size = sz;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+		else if (hd->pLocal == NULL)
+			goto target_done;
+		else {
+			rc = hd->pLocal->completion;
+			if (rc == MPT_SCANDV_GOOD)
+				;		/* Issue read buffer */
+			else if (rc == MPT_SCANDV_DID_RESET) {
+				/* If using echo buffers, reset to data buffers.
+				 * Else do Fallback and restart
+				 * this test (re-issue reserve
+				 * because of bus reset).
+				 */
+				if ((iocmd.flags & MPT_ICFLAG_ECHO) && (dataBufSize >= bufsize)) {
+					iocmd.flags &= ~MPT_ICFLAG_ECHO;
+				} else {
+					dv.cmd = MPT_FALLBACK;
+					mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+					if (mpt_config(hd->ioc, &cfg) != 0)
+						goto target_done;
+
+					if ((!dv.now.width) && (!dv.now.offset))
+						goto target_done;
+				}
+
+				iocmd.flags |= MPT_ICFLAG_DID_RESET;
+				patt = -1;
+				continue;
+			} else if (rc == MPT_SCANDV_SENSE) {
+				/* Restart data test if UA, else quit.
+				 */
+				u8 skey = hd->pLocal->sense[2] & 0x0F;
+				ddvprintk((MYIOC_s_INFO_FMT
+					"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n", ioc->name, skey,
+					hd->pLocal->sense[12], hd->pLocal->sense[13]));
+				if (skey == SK_UNIT_ATTENTION) {
+					patt = -1;
+					continue;
+				} else if (skey == SK_ILLEGAL_REQUEST) {
+					if (iocmd.flags & MPT_ICFLAG_ECHO) {
+						if (dataBufSize >= bufsize) {
+							iocmd.flags &= ~MPT_ICFLAG_ECHO;
+							patt = -1;
+							continue;
+						}
+					} 
+					goto target_done;
+				}
+				else
+					goto target_done;
+			} else {
+				/* fatal error */
+				goto target_done;
+			}
+		}
+
+		iocmd.cmd = CMD_ReadBuffer;
+		iocmd.data_dma = buf2_dma;
+		iocmd.data = pbuf2;
+		iocmd.size = sz;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+		else if (hd->pLocal == NULL)
+			goto target_done;
+		else {
+			rc = hd->pLocal->completion;
+			if (rc == MPT_SCANDV_GOOD) {
+				 /* If buffers compare,
+				  * go to next pattern,
+				  * else, do a fallback and restart
+				  * data transfer test.
+				  */
+				if (memcmp (pbuf1, pbuf2, sz) == 0) {
+					; /* goto next pattern */
+				} else {
+					/* Miscompare with Echo buffer, go to data buffer,
+					 * if that buffer exists.
+					 * Miscompare with Data buffer, check first 4 bytes,
+					 * some devices return capacity. Exit in this case.
+					 */
+					if (iocmd.flags & MPT_ICFLAG_ECHO) {
+						if (dataBufSize >= bufsize)
+							iocmd.flags &= ~MPT_ICFLAG_ECHO;
+						else
+							goto target_done;
+					} else {
+						if (dataBufSize == (pbuf2[1]<<16 | pbuf2[2]<<8 | pbuf2[3])) {
+							/* Argh. Device returning wrong data.
+							 * Quit DV for this device.
+							 */
+							goto target_done;
+						}
+
+						/* Had an actual miscompare. Slow down.*/
+						dv.cmd = MPT_FALLBACK;
+						mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+						if (mpt_config(hd->ioc, &cfg) != 0)
+							goto target_done;
+
+						if ((!dv.now.width) && (!dv.now.offset))
+							goto target_done;
+					}
+
+					patt = -1;
+					continue;
+				}
+			} else if (rc == MPT_SCANDV_DID_RESET) {
+				/* Do Fallback and restart
+				 * this test (re-issue reserve
+				 * because of bus reset).
+				 */
+				dv.cmd = MPT_FALLBACK;
+				mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+				if (mpt_config(hd->ioc, &cfg) != 0)
+					 goto target_done;
+
+				if ((!dv.now.width) && (!dv.now.offset))
+					goto target_done;
+
+				iocmd.flags |= MPT_ICFLAG_DID_RESET;
+				patt = -1;
+				continue;
+			} else if (rc == MPT_SCANDV_SENSE) {
+				/* Restart data test if UA, else quit.
+				 */
+				u8 skey = hd->pLocal->sense[2] & 0x0F;
+				ddvprintk((MYIOC_s_INFO_FMT
+					"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n", ioc->name, skey,
+					hd->pLocal->sense[12], hd->pLocal->sense[13]));
+				if (skey == SK_UNIT_ATTENTION) {
+					patt = -1;
+					continue;
+				}
+				else
+					goto target_done;
+			} else {
+				/* fatal error */
+				goto target_done;
+			}
+		}
+
+	} /* --- end of patt loop ---- */
+
+target_done:
+	if (iocmd.flags & MPT_ICFLAG_RESERVED) {
+		iocmd.cmd = CMD_Release6;
+		iocmd.data_dma = -1;
+		iocmd.data = NULL;
+		iocmd.size = 0;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			printk(MYIOC_s_INFO_FMT "DV: Release failed. id %d",
+					ioc->name, id);
+		else if (hd->pLocal) {
+			if (hd->pLocal->completion == MPT_SCANDV_GOOD)
+				iocmd.flags &= ~MPT_ICFLAG_RESERVED;
+		} else {
+			printk(MYIOC_s_INFO_FMT "DV: Release failed. id %d", 
+						ioc->name, id);
+		}
+	}
+
+
+	/* Set if cfg1_dma_addr contents is valid
+	 */
+	if (cfg.hdr != NULL) {
+
+		/* If disk, not U320, disable QAS
+		 */
+		if ((inq0 == 0) && (dv.now.factor > MPT_ULTRA320))
+			hd->ioc->spi_data.noQas = MPT_TARGET_NO_NEGO_QAS;
+
+		dv.cmd = MPT_SAVE;
+		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+		/* Save the final negotiated settings to
+		 * SCSI device page 1.
+		 */
+		cfg.hdr = &header1;
+		cfg.physAddr = cfg1_dma_addr;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+		cfg.dir = 1;
+		mpt_config(hd->ioc, &cfg);
+	}
+
+	/* If this is a RAID Passthrough, enable internal IOs
+	 */
+	if (iocmd.flags & MPT_ICFLAG_PHYS_DISK) {
+		if (mptscsih_do_raid(hd, MPI_RAID_ACTION_ENABLE_PHYS_IO, &iocmd) < 0)
+			ddvprintk((MYIOC_s_ERR_FMT "RAID Queisce FAILED!\n", ioc->name));
+	}
+
+	/* Done with the DV scan of the current target
+	 */
+	if (pDvBuf)
+		pci_free_consistent(ioc->pcidev, dv_alloc, pDvBuf, dvbuf_dma);
+
+	ddvtprintk((MYIOC_s_INFO_FMT "DV Done. IOs outstanding = %d\n",
+			ioc->name, atomic_read(&queue_depth)));
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_dv_parms - perform a variety of operations on the
+ *	parameters used for negotiation.
+ *	@hd: Pointer to a SCSI host.
+ *	@dv: Pointer to a structure that contains the maximum and current
+ *		negotiated parameters.
+ */
+static void
+mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVPARAMETERS *dv,void *pPage)
+{
+	VirtDevice		*pTarget = NULL;
+	SCSIDevicePage0_t	*pPage0 = NULL;
+	SCSIDevicePage1_t	*pPage1 = NULL;
+	int			val = 0, data, configuration;
+	u8			width = 0;
+	u8			offset = 0;
+	u8			factor = 0;
+	u8			negoFlags = 0;
+	u8			cmd = dv->cmd;
+	u8			id = dv->id;
+
+	switch (cmd) {
+	case MPT_GET_NVRAM_VALS:
+		ddvprintk((MYIOC_s_NOTE_FMT "Getting NVRAM: ",
+							 hd->ioc->name));
+		/* Get the NVRAM values and save in tmax
+		 * If not an LVD bus, the adapter minSyncFactor has been
+		 * already throttled back.
+		 */
+		if ((hd->Targets)&&((pTarget = hd->Targets[(int)id]) != NULL) && !pTarget->raidVolume) {
+			width = pTarget->maxWidth;
+			offset = pTarget->maxOffset;
+			factor = pTarget->minSyncFactor;
+			negoFlags = pTarget->negoFlags;
+		} else {
+			if (hd->ioc->spi_data.nvram && (hd->ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+				data = hd->ioc->spi_data.nvram[id];
+				width = data & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;
+				if ((offset = hd->ioc->spi_data.maxSyncOffset) == 0)
+					factor = MPT_ASYNC;
+				else {
+					factor = (data & MPT_NVRAM_SYNC_MASK) >> MPT_NVRAM_SYNC_SHIFT;
+					if ((factor == 0) || (factor == MPT_ASYNC)){
+						factor = MPT_ASYNC;
+						offset = 0;
+					}
+				}
+			} else {
+				width = MPT_NARROW;
+				offset = 0;
+				factor = MPT_ASYNC;
+			}
+
+			/* Set the negotiation flags */
+			negoFlags = hd->ioc->spi_data.noQas;
+			if (!width)
+				negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+
+			if (!offset)
+				negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+		}
+
+		/* limit by adapter capabilities */
+		width = MIN(width, hd->ioc->spi_data.maxBusWidth);
+		offset = MIN(offset, hd->ioc->spi_data.maxSyncOffset);
+		factor = MAX(factor, hd->ioc->spi_data.minSyncFactor);
+
+		/* Check Consistency */
+		if (offset && (factor < MPT_ULTRA2) && !width)
+			factor = MPT_ULTRA2;
+
+		dv->max.width = width;
+		dv->max.offset = offset;
+		dv->max.factor = factor;
+		dv->max.flags = negoFlags;
+		ddvprintk((" width %d, factor %x, offset %x flags %x\n",
+				width, factor, offset, negoFlags));
+		break;
+
+	case MPT_UPDATE_MAX:
+		ddvprintk((MYIOC_s_NOTE_FMT
+			"Updating with SDP0 Data: ", hd->ioc->name));
+		/* Update tmax values with those from Device Page 0.*/
+		pPage0 = (SCSIDevicePage0_t *) pPage;
+		if (pPage0) {
+			val = cpu_to_le32(pPage0->NegotiatedParameters);
+			dv->max.width = val & MPI_SCSIDEVPAGE0_NP_WIDE ? 1 : 0;
+			dv->max.offset = (val&MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) >> 16;
+			dv->max.factor = (val&MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> 8;
+		}
+
+		dv->now.width = dv->max.width;
+		dv->now.offset = dv->max.offset;
+		dv->now.factor = dv->max.factor;
+		ddvprintk(("width %d, factor %x, offset %x, flags %x\n",
+				dv->now.width, dv->now.factor, dv->now.offset, dv->now.flags));
+		break;
+
+	case MPT_SET_MAX:
+		ddvprintk((MYIOC_s_NOTE_FMT "Setting Max: ",
+								hd->ioc->name));
+		/* Set current to the max values. Update the config page.*/
+		dv->now.width = dv->max.width;
+		dv->now.offset = dv->max.offset;
+		dv->now.factor = dv->max.factor;
+		dv->now.flags = dv->max.flags;
+
+		pPage1 = (SCSIDevicePage1_t *)pPage;
+		if (pPage1) {
+			mptscsih_setDevicePage1Flags (dv->now.width, dv->now.factor,
+				dv->now.offset, &val, &configuration, dv->now.flags);
+			pPage1->RequestedParameters = le32_to_cpu(val);
+			pPage1->Reserved = 0;
+			pPage1->Configuration = le32_to_cpu(configuration);
+
+		}
+
+		ddvprintk(("width %d, factor %x, offset %x request %x, config %x\n",
+				dv->now.width, dv->now.factor, dv->now.offset, val, configuration));
+		break;
+
+	case MPT_SET_MIN:
+		ddvprintk((MYIOC_s_NOTE_FMT "Setting Min: ",
+								hd->ioc->name));
+		/* Set page to asynchronous and narrow 
+		 * Do not update now, breaks fallback routine. */
+		width = MPT_NARROW;
+		offset = 0;
+		factor = MPT_ASYNC;
+		negoFlags = dv->max.flags;
+
+		pPage1 = (SCSIDevicePage1_t *)pPage;
+		if (pPage1) {
+			mptscsih_setDevicePage1Flags (width, factor,
+				offset, &val, &configuration, negoFlags);
+			pPage1->RequestedParameters = le32_to_cpu(val);
+			pPage1->Reserved = 0;
+			pPage1->Configuration = le32_to_cpu(configuration);
+		}
+		ddvprintk(("width %d, factor %x, offset %x request %x config %x\n",
+				dv->now.width, dv->now.factor,
+				dv->now.offset, val, configuration));
+		break;
+
+	case MPT_FALLBACK:
+		ddvprintk((MYIOC_s_NOTE_FMT
+			"Fallback: Start: offset %d, factor %x, width %d \n",
+				hd->ioc->name, dv->now.offset, 
+				dv->now.factor, dv->now.width));
+		width = dv->now.width;
+		offset = dv->now.offset;
+		factor = dv->now.factor;
+		if ((offset) && (dv->max.width)) {
+			if (factor < MPT_ULTRA160)
+				factor = MPT_ULTRA160;
+			else if (factor < MPT_ULTRA2) {
+				factor = MPT_ULTRA2;
+				width = MPT_WIDE;
+			} else if ((factor == MPT_ULTRA2) && width) {
+				factor = MPT_ULTRA2;
+				width = MPT_NARROW;
+			} else if (factor < MPT_ULTRA) {
+				factor = MPT_ULTRA;
+				width = MPT_WIDE;
+			} else if ((factor == MPT_ULTRA) && width) {
+				factor = MPT_ULTRA;
+				width = MPT_NARROW;
+			} else if (factor < MPT_FAST) {
+				factor = MPT_FAST;
+				width = MPT_WIDE;
+			} else if ((factor == MPT_FAST) && width) {
+				factor = MPT_FAST;
+				width = MPT_NARROW;
+			} else if (factor < MPT_SCSI) {
+				factor = MPT_SCSI;
+				width = MPT_WIDE;
+			} else if ((factor == MPT_SCSI) && width) {
+				factor = MPT_SCSI;
+				width = MPT_NARROW;
+			} else {
+				factor = MPT_ASYNC;
+				offset = 0;
+			}
+
+		} else if (offset) {
+			width = MPT_NARROW;
+			if (factor < MPT_ULTRA)
+				factor = MPT_ULTRA;
+			else if (factor < MPT_FAST)
+				factor = MPT_FAST;
+			else if (factor < MPT_SCSI)
+				factor = MPT_SCSI;
+			else {
+				factor = MPT_ASYNC;
+				offset = 0;
+			}
+
+		} else {
+			width = MPT_NARROW;
+			factor = MPT_ASYNC;
+		}
+		dv->max.flags |= MPT_TARGET_NO_NEGO_QAS;
+
+		dv->now.width = width;
+		dv->now.offset = offset;
+		dv->now.factor = factor;
+		dv->now.flags = dv->max.flags;
+
+		pPage1 = (SCSIDevicePage1_t *)pPage;
+		if (pPage1) {
+			mptscsih_setDevicePage1Flags (width, factor, offset, &val,
+						&configuration, dv->now.flags);
+
+			pPage1->RequestedParameters = le32_to_cpu(val);
+			pPage1->Reserved = 0;
+			pPage1->Configuration = le32_to_cpu(configuration);
+		}
+
+		ddvprintk(("Finish: offset %d, factor %x, width %d, request %x config %x\n",
+			     dv->now.offset, dv->now.factor, dv->now.width, val, configuration));
+		break;
+
+	case MPT_SAVE:
+		ddvprintk((MYIOC_s_NOTE_FMT
+			"Saving to Target structure: ", hd->ioc->name));
+		ddvprintk(("offset %d, factor %x, width %d \n",
+			     dv->now.offset, dv->now.factor, dv->now.width));
+
+		/* Save these values to target structures
+		 * or overwrite nvram (phys disks only).
+		 */
+
+		if ((hd->Targets)&&((pTarget = hd->Targets[(int)id]) != NULL) && !pTarget->raidVolume ) {
+			pTarget->maxWidth = dv->now.width;
+			pTarget->maxOffset = dv->now.offset;
+			pTarget->minSyncFactor = dv->now.factor;
+			pTarget->negoFlags = dv->now.flags;
+		} else {
+			/* Preserv all flags, use
+			 * read-modify-write algorithm
+			 */
+			if (hd->ioc->spi_data.nvram) {
+				data = hd->ioc->spi_data.nvram[id];
+
+				if (dv->now.width)
+					data &= ~MPT_NVRAM_WIDE_DISABLE;
+				else
+					data |= MPT_NVRAM_WIDE_DISABLE;
+
+				if (!dv->now.offset)
+					factor = MPT_ASYNC;
+
+				data &= ~MPT_NVRAM_SYNC_MASK;
+				data |= (dv->now.factor << MPT_NVRAM_SYNC_SHIFT) & MPT_NVRAM_SYNC_MASK;
+
+				hd->ioc->spi_data.nvram[id] = data;
+			}
+		}
+		break;
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_fillbuf - fill a buffer with a special data pattern
+ *		cleanup. For bus scan only.
+ *
+ *	@buffer: Pointer to data buffer to be filled.
+ *	@size: Number of bytes to fill
+ *	@index: Pattern index
+ *	@width: bus width, 0 (8 bits) or 1 (16 bits)
+ */
+static void
+mptscsih_fillbuf(char *buffer, int size, int index, int width)
+{
+	char *ptr = buffer;
+	int ii;
+	char byte;
+	short val;
+
+	switch (index) {
+	case 0:
+
+		if (width) {
+			/* Pattern:  0000 FFFF 0000 FFFF
+			 */
+			for (ii=0; ii < size; ii++, ptr++) {
+				if (ii & 0x02)
+					*ptr = 0xFF;
+				else
+					*ptr = 0x00;
+			}
+		} else {
+			/* Pattern:  00 FF 00 FF
+			 */
+			for (ii=0; ii < size; ii++, ptr++) {
+				if (ii & 0x01)
+					*ptr = 0xFF;
+				else
+					*ptr = 0x00;
+			}
+		}
+		break;
+
+	case 1:
+		if (width) {
+			/* Pattern:  5555 AAAA 5555 AAAA 5555
+			 */
+			for (ii=0; ii < size; ii++, ptr++) {
+				if (ii & 0x02)
+					*ptr = 0xAA;
+				else
+					*ptr = 0x55;
+			}
+		} else {
+			/* Pattern:  55 AA 55 AA 55
+			 */
+			for (ii=0; ii < size; ii++, ptr++) {
+				if (ii & 0x01)
+					*ptr = 0xAA;
+				else
+					*ptr = 0x55;
+			}
+		}
+		break;
+
+	case 2:
+		/* Pattern:  00 01 02 03 04 05
+		 * ... FE FF 00 01..
+		 */
+		for (ii=0; ii < size; ii++, ptr++)
+			*ptr = (char) ii;
+		break;
+
+	case 3:
+		if (width) {
+			/* Wide Pattern:  FFFE 0001 FFFD 0002
+			 * ...  4000 DFFF 8000 EFFF
+			 */
+			byte = 0;
+			for (ii=0; ii < size/2; ii++) {
+				/* Create the base pattern
+				 */
+				val = (1 << byte);
+				/* every 64 (0x40) bytes flip the pattern
+				 * since we fill 2 bytes / iteration,
+				 * test for ii = 0x20
+				 */
+				if (ii & 0x20)
+					val = ~(val);
+
+				if (ii & 0x01) {
+					*ptr = (char)( (val & 0xFF00) >> 8);
+					ptr++;
+					*ptr = (char)(val & 0xFF);
+					byte++;
+					byte &= 0x0F;
+				} else {
+					val = ~val;
+					*ptr = (char)( (val & 0xFF00) >> 8);
+					ptr++;
+					*ptr = (char)(val & 0xFF);
+				}
+
+				ptr++;
+			}
+		} else {
+			/* Narrow Pattern:  FE 01 FD 02 FB 04
+			 * .. 7F 80 01 FE 02 FD ...  80 7F
+			 */
+			byte = 0;
+			for (ii=0; ii < size; ii++, ptr++) {
+				/* Base pattern - first 32 bytes
+				 */
+				if (ii & 0x01) {
+					*ptr = (1 << byte);
+					byte++;
+					byte &= 0x07;
+				} else {
+					*ptr = (char) (~(1 << byte));
+				}
+
+				/* Flip the pattern every 32 bytes
+				 */
+				if (ii & 0x20)
+					*ptr = ~(*ptr);
+			}
+		}
+		break;
+	}
+}
+#endif /* ~MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Commandline Parsing routines and defines.
+ *
+ * insmod format:
+ *	insmod mptscsih mptscsih="width:1 dv:n factor:0x09"
+ *  boot format:
+ *	mptscsih=width:1,dv:n,factor:0x8
+ *
+ */
+#ifdef MODULE
+#define	ARG_SEP	' '
+#else
+#define	ARG_SEP	','
+#endif
+
+static char setup_token[] __initdata =
+	"dv:"
+	"width:"
+	"factor:"
+       ;	/* DONNOT REMOVE THIS ';' */
+
+#define OPT_DV			1
+#define OPT_MAX_WIDTH		2
+#define OPT_MIN_SYNC_FACTOR	3
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+__init get_setup_token(char *p)
+{
+	char *cur = setup_token;
+	char *pc;
+	int i = 0;
+
+	while (cur != NULL && (pc = strchr(cur, ':')) != NULL) {
+		++pc;
+		++i;
+		if (!strncmp(p, cur, pc - cur))
+			return i;
+		cur = pc;
+	}
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+__init mptscsih_setup(char *str)
+{
+	char *cur = str;
+	char *pc, *pv;
+	unsigned long val;
+	int  c;
+
+	while (cur != NULL && (pc = strchr(cur, ':')) != NULL) {
+		char *pe;
+
+		val = 0;
+		pv = pc;
+		c = *++pv;
+
+		if	(c == 'n')
+			val = 0;
+		else if	(c == 'y')
+			val = 1;
+		else
+			val = (int) simple_strtoul(pv, &pe, 0);
+
+		printk("Found Token: %s, value %x\n", cur, (int)val);
+		switch (get_setup_token(cur)) {
+		case OPT_DV:
+			driver_setup.dv = val;
+			break;
+
+		case OPT_MAX_WIDTH:
+			driver_setup.max_width = val;
+			break;
+
+		case OPT_MIN_SYNC_FACTOR:
+			driver_setup.min_sync_fac = val;
+			break;
+
+		default:
+			printk("mptscsih_setup: unexpected boot option '%.*s' ignored\n", (int)(pc-cur+1), cur);
+			break;
+		}
+
+		if ((cur = strchr(cur, ARG_SEP)) != NULL)
+			++cur;
+	}
+	return 1;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
diff -Nru a/drivers/message/fusion/mptscsih.h b/drivers/message/fusion/mptscsih.h
--- a/drivers/message/fusion/mptscsih.h	Thu Jun 20 15:54:01 2002
+++ b/drivers/message/fusion/mptscsih.h	Thu Jun 20 15:54:01 2002
@@ -15,11 +15,12 @@
  *
  *      (see also mptbase.c)
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id$
+ *  $Id$
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -68,14 +69,48 @@
  *	SCSI Public stuff...
  */
 
-#ifdef __sparc__
-#define MPT_SCSI_CAN_QUEUE	63
-#define MPT_SCSI_CMD_PER_LUN	63
-	/* FIXME!  Still investigating qd=64 hang on sparc64... */
-#else
-#define MPT_SCSI_CAN_QUEUE	64
-#define MPT_SCSI_CMD_PER_LUN	64
-#endif
+/*
+ *	Try to keep these at 2^N-1
+ */
+#define MPT_FC_CAN_QUEUE	63
+//#define MPT_SCSI_CAN_QUEUE	31
+#define MPT_SCSI_CAN_QUEUE	MPT_FC_CAN_QUEUE
+#define MPT_SCSI_CMD_PER_LUN	 7
+
+#define MPT_SCSI_SG_DEPTH	40
+
+/* To disable domain validation, uncomment the
+ * following line. No effect for FC devices.
+ * For SCSI devices, driver will negotiate to
+ * NVRAM settings (if available) or to maximum adapter
+ * capabilities.
+ */
+/* #define MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
+
+
+/* SCSI driver setup structure. Settings can be overridden
+ * by command line options.
+ */
+#define MPTSCSIH_DOMAIN_VALIDATION      1
+#define MPTSCSIH_MAX_WIDTH              1
+#define MPTSCSIH_MIN_SYNC               0x08
+
+struct mptscsih_driver_setup
+{
+        u8      dv;
+        u8      max_width;
+        u8      min_sync_fac;
+};
+
+
+#define MPTSCSIH_DRIVER_SETUP                   \
+{                                               \
+        MPTSCSIH_DOMAIN_VALIDATION,             \
+        MPTSCSIH_MAX_WIDTH,                     \
+        MPTSCSIH_MIN_SYNC,                      \
+}
+
+
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -143,6 +178,7 @@
 #define x_scsi_dev_reset	mptscsih_dev_reset
 #define x_scsi_host_reset	mptscsih_host_reset
 #define x_scsi_bios_param	mptscsih_bios_param
+#define x_scsi_select_queue_depths	mptscsih_select_queue_depths
 
 #define x_scsi_taskmgmt_bh	mptscsih_taskmgmt_bh
 #define x_scsi_old_abort	mptscsih_old_abort
@@ -155,18 +191,18 @@
 extern	int		 x_scsi_detect(Scsi_Host_Template *);
 extern	int		 x_scsi_release(struct Scsi_Host *host);
 extern	const char	*x_scsi_info(struct Scsi_Host *);
-/*extern	int		 x_scsi_command(Scsi_Cmnd *);*/
 extern	int		 x_scsi_queuecommand(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
 #ifdef MPT_SCSI_USE_NEW_EH
 extern	int		 x_scsi_abort(Scsi_Cmnd *);
 extern	int		 x_scsi_bus_reset(Scsi_Cmnd *);
 extern	int		 x_scsi_dev_reset(Scsi_Cmnd *);
-/*extern	int		 x_scsi_host_reset(Scsi_Cmnd *);*/
+extern	int		 x_scsi_host_reset(Scsi_Cmnd *);
 #else
 extern	int		 x_scsi_old_abort(Scsi_Cmnd *);
 extern	int		 x_scsi_old_reset(Scsi_Cmnd *, unsigned int);
 #endif
 extern	int		 x_scsi_bios_param(Disk *, kdev_t, int *);
+extern	void		 x_scsi_select_queue_depths(struct Scsi_Host *, Scsi_Device *);
 extern	void		 x_scsi_taskmgmt_bh(void *);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
@@ -177,6 +213,33 @@
 
 #ifdef MPT_SCSI_USE_NEW_EH
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1)
+
+#define MPT_SCSIHOST {						\
+	next:				NULL,			\
+	PROC_SCSI_DECL						\
+	name:				"MPT SCSI Host",	\
+	detect:				x_scsi_detect,		\
+	release:			x_scsi_release,		\
+	info:				x_scsi_info,		\
+	command:			NULL,			\
+	queuecommand:			x_scsi_queuecommand,	\
+	eh_strategy_handler:		NULL,			\
+	eh_abort_handler:		x_scsi_abort,		\
+	eh_device_reset_handler:	x_scsi_dev_reset,	\
+	eh_bus_reset_handler:		x_scsi_bus_reset,	\
+	eh_host_reset_handler:		x_scsi_host_reset,	\
+	bios_param:			x_scsi_bios_param,	\
+	can_queue:			MPT_SCSI_CAN_QUEUE,	\
+	this_id:			-1,			\
+	sg_tablesize:			MPT_SCSI_SG_DEPTH,	\
+	cmd_per_lun:			MPT_SCSI_CMD_PER_LUN,	\
+	unchecked_isa_dma:		0,			\
+	use_clustering:			ENABLE_CLUSTERING,	\
+}
+
+#else  /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1) */
+
 #define MPT_SCSIHOST {						\
 	next:				NULL,			\
 	PROC_SCSI_DECL						\
@@ -194,13 +257,16 @@
 	bios_param:			x_scsi_bios_param,	\
 	can_queue:			MPT_SCSI_CAN_QUEUE,	\
 	this_id:			-1,			\
-	sg_tablesize:			25,			\
+	sg_tablesize:			MPT_SCSI_SG_DEPTH,	\
 	cmd_per_lun:			MPT_SCSI_CMD_PER_LUN,	\
 	unchecked_isa_dma:		0,			\
 	use_clustering:			ENABLE_CLUSTERING,	\
+	use_new_eh_code:		1			\
 }
 
-#else
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1) */
+
+#else /* MPT_SCSI_USE_NEW_EH */
 
 #define MPT_SCSIHOST {						\
 	next:				NULL,			\
@@ -216,12 +282,12 @@
 	bios_param:			x_scsi_bios_param,	\
 	can_queue:			MPT_SCSI_CAN_QUEUE,	\
 	this_id:			-1,			\
-	sg_tablesize:			25,			\
+	sg_tablesize:			MPT_SCSI_SG_DEPTH,	\
 	cmd_per_lun:			MPT_SCSI_CMD_PER_LUN,	\
 	unchecked_isa_dma:		0,			\
 	use_clustering:			ENABLE_CLUSTERING	\
 }
-#endif
+#endif  /* MPT_SCSI_USE_NEW_EH */
 
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
diff -Nru a/drivers/message/fusion/scsi3.h b/drivers/message/fusion/scsi3.h
--- a/drivers/message/fusion/scsi3.h	Thu Jun 20 15:54:01 2002
+++ b/drivers/message/fusion/scsi3.h	Thu Jun 20 15:54:01 2002
@@ -4,11 +4,12 @@
  *      (Ultimately) SCSI-3 definitions; for now, inheriting
  *      SCSI-2 definitions.
  *
- *  Copyright (c) 1996-2001 Steven J. Ralston
+ *  Copyright (c) 1996-2002 Steven J. Ralston
  *  Written By: Steven J. Ralston (19960517)
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id$
+ *  $Id$
  */
 
 #ifndef SCSI3_H_INCLUDED
@@ -63,7 +64,10 @@
 #define CMD_Write10            0x2A
 #define CMD_WriteVerify        0x2E
 #define CMD_Verify             0x2F
+#define CMD_SynchronizeCache   0x35
 #define CMD_ReadDefectData     0x37
+#define CMD_WriteBuffer        0x3B
+#define CMD_ReadBuffer         0x3C
 #define CMD_ReadLong           0x3E
 #define CMD_LogSelect          0x4C
 #define CMD_LogSense           0x4D
diff -Nru a/drivers/mtd/maps/Config.in b/drivers/mtd/maps/Config.in
--- a/drivers/mtd/maps/Config.in	Thu Jun 20 15:54:01 2002
+++ b/drivers/mtd/maps/Config.in	Thu Jun 20 15:54:01 2002
@@ -13,7 +13,7 @@
    int '    Bus width in octets' CONFIG_MTD_PHYSMAP_BUSWIDTH 2
 fi
 
-if [ "$CONFIG_SPARC" = "y" -o "$CONFIG_SPARC64" = "y" ]; then
+if [ "$CONFIG_SPARC32" = "y" -o "$CONFIG_SPARC64" = "y" ]; then
    dep_tristate '  Sun Microsystems userflash support' CONFIG_MTD_SUN_UFLASH $CONFIG_MTD_CFI
 fi
 
@@ -26,7 +26,7 @@
    dep_tristate '  JEDEC Flash device mapped on Mixcom piggyback card' CONFIG_MTD_MIXMEM $CONFIG_MTD_JEDEC
    dep_tristate '  JEDEC Flash device mapped on Octagon 5066 SBC' CONFIG_MTD_OCTAGON $CONFIG_MTD_JEDEC
    dep_tristate '  JEDEC Flash device mapped on Tempustech VMAX SBC301' CONFIG_MTD_VMAX $CONFIG_MTD_JEDEC
-   dep_tristate '  BIOS flash chip on Intel L440GX boards' CONFIG_MTD_L440GX $CONFIG_I386 $CONFIG_MTD_JEDEC
+   dep_tristate '  BIOS flash chip on Intel L440GX boards' CONFIG_MTD_L440GX $CONFIG_X86 $CONFIG_MTD_JEDEC
 fi
 
 if [ "$CONFIG_PPC" = "y" ]; then
@@ -46,7 +46,7 @@
    dep_tristate '  Momenco Ocelot boot flash device' CONFIG_MTD_OCELOT $CONFIG_MOMENCO_OCELOT
 fi
 
-if [ "$CONFIG_SH" = "y" ]; then
+if [ "$CONFIG_SUPERH" = "y" ]; then
    dep_tristate '  CFI Flash device mapped on Hitachi SolutionEngine' CONFIG_MTD_SOLUTIONENGINE $CONFIG_MTD_CFI $CONFIG_SH $CONFIG_MTD_REDBOOT_PARTS
 fi
 
diff -Nru a/drivers/net/3c509.c b/drivers/net/3c509.c
--- a/drivers/net/3c509.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/3c509.c	Thu Jun 20 15:54:00 2002
@@ -229,10 +229,6 @@
 	{ }	/* terminate list */
 };
 
-MODULE_DEVICE_TABLE(isapnp, el3_isapnp_adapters);
-MODULE_LICENSE("GPL");
-
-
 static u16 el3_isapnp_phys_addr[8][3];
 #endif /* __ISAPNP__ */
 static int nopnp;
@@ -1265,6 +1261,8 @@
 MODULE_PARM_DESC(nopnp, "disable ISA PnP support (0-1)");
 #endif	/* __ISAPNP__ */
 MODULE_DESCRIPTION("3Com Etherlink III (3c509, 3c509B) ISA/PnP ethernet driver");
+MODULE_DEVICE_TABLE(isapnp, el3_isapnp_adapters);
+MODULE_LICENSE("GPL");
 
 int
 init_module(void)
diff -Nru a/drivers/net/8139cp.c b/drivers/net/8139cp.c
--- a/drivers/net/8139cp.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/8139cp.c	Thu Jun 20 15:54:01 2002
@@ -100,13 +100,16 @@
 #define CP_DEF_MSG_ENABLE	(NETIF_MSG_DRV		| \
 				 NETIF_MSG_PROBE 	| \
 				 NETIF_MSG_LINK)
+#define CP_NUM_STATS		14	/* struct cp_dma_stats, plus one */
+#define CP_STATS_SIZE		64	/* size in bytes of DMA stats block */
 #define CP_REGS_SIZE		(0xff + 1)
 #define CP_REGS_VER		1		/* version 1 */
 #define CP_RX_RING_SIZE		64
 #define CP_TX_RING_SIZE		64
 #define CP_RING_BYTES		\
 		((sizeof(struct cp_desc) * CP_RX_RING_SIZE) +	\
-		(sizeof(struct cp_desc) * CP_TX_RING_SIZE))
+		 (sizeof(struct cp_desc) * CP_TX_RING_SIZE) +	\
+		 CP_STATS_SIZE)
 #define NEXT_TX(N)		(((N) + 1) & (CP_TX_RING_SIZE - 1))
 #define NEXT_RX(N)		(((N) + 1) & (CP_RX_RING_SIZE - 1))
 #define TX_BUFFS_AVAIL(CP)					\
@@ -135,6 +138,7 @@
 	/* NIC register offsets */
 	MAC0		= 0x00,	/* Ethernet hardware address. */
 	MAR0		= 0x08,	/* Multicast filter. */
+	StatsAddr	= 0x10,	/* 64-bit start addr of 64-byte DMA stats blk */
 	TxRingAddr	= 0x20, /* 64-bit start addr of Tx ring */
 	HiTxRingAddr	= 0x28, /* 64-bit start addr of high priority Tx ring */
 	Cmd		= 0x37, /* Command register */
@@ -197,6 +201,9 @@
 	RxErrLong	= (1 << 21), /* Rx error, packet > 4096 bytes */
 	RxErrFIFO	= (1 << 22), /* Rx error, FIFO overflowed, pkt bad */
 
+	/* StatsAddr register */
+	DumpStats	= (1 << 3),  /* Begin stats dump */
+
 	/* RxConfig register */
 	RxCfgFIFOShift	= 13,	     /* Shift, to get Rx FIFO thresh value */
 	RxCfgDMAShift	= 8,	     /* Shift, to get Rx Max DMA value */
@@ -284,6 +291,22 @@
 	unsigned		frag;
 };
 
+struct cp_dma_stats {
+	u64			tx_ok;
+	u64			rx_ok;
+	u64			tx_err;
+	u32			rx_err;
+	u16			rx_fifo;
+	u16			frame_align;
+	u32			tx_ok_1col;
+	u32			tx_ok_mcol;
+	u64			rx_ok_phys;
+	u64			rx_ok_bcast;
+	u32			rx_ok_mcast;
+	u16			tx_abort;
+	u16			tx_underrun;
+} __attribute__((packed));
+
 struct cp_extra_stats {
 	unsigned long		rx_frags;
 };
@@ -312,6 +335,8 @@
 
 	struct net_device_stats net_stats;
 	struct cp_extra_stats	cp_stats;
+	struct cp_dma_stats	*nic_stats;
+	dma_addr_t		nic_stats_dma;
 
 	struct pci_dev		*pdev;
 	u32			rx_config;
@@ -373,6 +398,26 @@
 };
 MODULE_DEVICE_TABLE(pci, cp_pci_tbl);
 
+static struct {
+	const char str[ETH_GSTRING_LEN];
+} ethtool_stats_keys[] = {
+	{ "tx_ok" },
+	{ "rx_ok" },
+	{ "tx_err" },
+	{ "rx_err" },
+	{ "rx_fifo" },
+	{ "frame_align" },
+	{ "tx_ok_1col" },
+	{ "tx_ok_mcol" },
+	{ "rx_ok_phys" },
+	{ "rx_ok_bcast" },
+	{ "rx_ok_mcast" },
+	{ "tx_abort" },
+	{ "tx_underrun" },
+	{ "rx_frags" },
+};
+
+
 static inline void cp_set_rxbufsize (struct cp_private *cp)
 {
 	unsigned int mtu = cp->dev->mtu;
@@ -836,7 +881,7 @@
 		     i++, mclist = mclist->next) {
 			int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
 
-			mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
 			rx_mode |= AcceptMulticast;
 		}
 	}
@@ -949,9 +994,9 @@
 	cpw32_f(HiTxRingAddr + 4, 0);
 
 	cpw32_f(RxRingAddr, cp->ring_dma);
-	cpw32_f(RxRingAddr + 4, 0);
+	cpw32_f(RxRingAddr + 4, 0);		/* FIXME: 64-bit PCI */
 	cpw32_f(TxRingAddr, cp->ring_dma + (sizeof(struct cp_desc) * CP_RX_RING_SIZE));
-	cpw32_f(TxRingAddr + 4, 0);
+	cpw32_f(TxRingAddr + 4, 0);		/* FIXME: 64-bit PCI */
 
 	cpw16(MultiIntr, 0);
 
@@ -1010,10 +1055,19 @@
 
 static int cp_alloc_rings (struct cp_private *cp)
 {
-	cp->rx_ring = pci_alloc_consistent(cp->pdev, CP_RING_BYTES, &cp->ring_dma);
-	if (!cp->rx_ring)
+	void *mem;
+
+	mem = pci_alloc_consistent(cp->pdev, CP_RING_BYTES, &cp->ring_dma);
+	if (!mem)
 		return -ENOMEM;
+
+	cp->rx_ring = mem;
 	cp->tx_ring = &cp->rx_ring[CP_RX_RING_SIZE];
+
+	mem += (CP_RING_BYTES - CP_STATS_SIZE);
+	cp->nic_stats = mem;
+	cp->nic_stats_dma = cp->ring_dma + (CP_RING_BYTES - CP_STATS_SIZE);
+
 	return cp_init_rings(cp);
 }
 
@@ -1052,6 +1106,7 @@
 	pci_free_consistent(cp->pdev, CP_RING_BYTES, cp->rx_ring, cp->ring_dma);
 	cp->rx_ring = NULL;
 	cp->tx_ring = NULL;
+	cp->nic_stats = NULL;
 }
 
 static int cp_open (struct net_device *dev)
@@ -1181,6 +1236,7 @@
 		strcpy (info.version, DRV_VERSION);
 		strcpy (info.bus_info, cp->pdev->slot_name);
 		info.regdump_len = CP_REGS_SIZE;
+		info.n_stats = CP_NUM_STATS;
 		if (copy_to_user (useraddr, &info, sizeof (info)))
 			return -EFAULT;
 		return 0;
@@ -1356,6 +1412,83 @@
 		else
 			cp->dev->features &= ~NETIF_F_SG;
 
+		return 0;
+	}
+
+	/* get string list(s) */
+	case ETHTOOL_GSTRINGS: {
+		struct ethtool_gstrings estr = { ETHTOOL_GSTRINGS };
+
+		if (copy_from_user(&estr, useraddr, sizeof(estr)))
+			return -EFAULT;
+		if (estr.string_set != ETH_SS_STATS)
+			return -EINVAL;
+
+		estr.len = CP_NUM_STATS;
+		if (copy_to_user(useraddr, &estr, sizeof(estr)))
+			return -EFAULT;
+		if (copy_to_user(useraddr + sizeof(estr),
+				 &ethtool_stats_keys,
+				 sizeof(ethtool_stats_keys)))
+			return -EFAULT;
+		return 0;
+	}
+
+	/* get NIC-specific statistics */
+	case ETHTOOL_GSTATS: {
+		struct ethtool_stats estats = { ETHTOOL_GSTATS };
+		u64 *tmp_stats;
+		unsigned int work = 100;
+		const unsigned int sz = sizeof(u64) * CP_NUM_STATS;
+		int i;
+
+		/* begin NIC statistics dump */
+		cpw32(StatsAddr + 4, 0); /* FIXME: 64-bit PCI */
+		cpw32(StatsAddr, cp->nic_stats_dma | DumpStats);
+		cpr32(StatsAddr);
+
+		estats.n_stats = CP_NUM_STATS;
+		if (copy_to_user(useraddr, &estats, sizeof(estats)))
+			return -EFAULT;
+
+		while (work-- > 0) {
+			if ((cpr32(StatsAddr) & DumpStats) == 0)
+				break;
+			cpu_relax();
+		}
+
+		if (cpr32(StatsAddr) & DumpStats)
+			return -EIO;
+
+		tmp_stats = kmalloc(sz, GFP_KERNEL);
+		if (!tmp_stats)
+			return -ENOMEM;
+		memset(tmp_stats, 0, sz);
+
+		i = 0;
+		tmp_stats[i++] = le64_to_cpu(cp->nic_stats->tx_ok);
+		tmp_stats[i++] = le64_to_cpu(cp->nic_stats->rx_ok);
+		tmp_stats[i++] = le64_to_cpu(cp->nic_stats->tx_err);
+		tmp_stats[i++] = le32_to_cpu(cp->nic_stats->rx_err);
+		tmp_stats[i++] = le16_to_cpu(cp->nic_stats->rx_fifo);
+		tmp_stats[i++] = le16_to_cpu(cp->nic_stats->frame_align);
+		tmp_stats[i++] = le32_to_cpu(cp->nic_stats->tx_ok_1col);
+		tmp_stats[i++] = le32_to_cpu(cp->nic_stats->tx_ok_mcol);
+		tmp_stats[i++] = le64_to_cpu(cp->nic_stats->rx_ok_phys);
+		tmp_stats[i++] = le64_to_cpu(cp->nic_stats->rx_ok_bcast);
+		tmp_stats[i++] = le32_to_cpu(cp->nic_stats->rx_ok_mcast);
+		tmp_stats[i++] = le16_to_cpu(cp->nic_stats->tx_abort);
+		tmp_stats[i++] = le16_to_cpu(cp->nic_stats->tx_underrun);
+		tmp_stats[i++] = cp->cp_stats.rx_frags;
+		if (i != CP_NUM_STATS)
+			BUG();
+
+		i = copy_to_user(useraddr + sizeof(estats),
+				 tmp_stats, sz);
+		kfree(tmp_stats);
+
+		if (i)
+			return -EFAULT;
 		return 0;
 	}
 
diff -Nru a/drivers/net/8139too.c b/drivers/net/8139too.c
--- a/drivers/net/8139too.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/net/8139too.c	Thu Jun 20 15:53:59 2002
@@ -3,7 +3,7 @@
 	8139too.c: A RealTek RTL-8139 Fast Ethernet driver for Linux.
 
 	Maintained by Jeff Garzik <jgarzik@mandrakesoft.com>
-	Copyright 2000,2001 Jeff Garzik
+	Copyright 2000-2002 Jeff Garzik
 
 	Much code comes from Donald Becker's rtl8139.c driver,
 	versions 1.13 and older.  This driver was originally based
@@ -92,7 +92,7 @@
 */
 
 #define DRV_NAME	"8139too"
-#define DRV_VERSION	"0.9.24"
+#define DRV_VERSION	"0.9.25"
 
 
 #include <linux/config.h>
@@ -201,6 +201,8 @@
 	HAS_LNK_CHNG = 0x040000,
 };
 
+#define RTL_NUM_STATS 4		/* number of ETHTOOL_GSTATS u64's */
+#define RTL_REGS_VER 1		/* version of reg. data in ETHTOOL_GREGS */
 #define RTL_MIN_IO_SIZE 0x80
 #define RTL8139B_IO_SIZE 256
 
@@ -269,6 +271,14 @@
 };
 MODULE_DEVICE_TABLE (pci, rtl8139_pci_tbl);
 
+static struct {
+	const char str[ETH_GSTRING_LEN];
+} ethtool_stats_keys[] = {
+	{ "early_rx" },
+	{ "tx_buf_mapped" },
+	{ "tx_timeouts" },
+	{ "rx_lost_in_ring" },
+};
 
 /* The rest of these values should never change. */
 
@@ -566,6 +576,7 @@
 	struct rtl_extra_stats xstats;
 	int time_to_die;
 	struct mii_if_info mii;
+	unsigned int regs_len;
 };
 
 MODULE_AUTHOR ("Jeff Garzik <jgarzik@mandrakesoft.com>");
@@ -807,6 +818,7 @@
 	ioaddr = (void *) pio_start;
 	dev->base_addr = pio_start;
 	tp->mmio_addr = ioaddr;
+	tp->regs_len = pio_len;
 #else
 	/* ioremap MMIO region */
 	ioaddr = ioremap (mmio_start, mmio_len);
@@ -817,6 +829,7 @@
 	}
 	dev->base_addr = (long) ioaddr;
 	tp->mmio_addr = ioaddr;
+	tp->regs_len = mmio_len;
 #endif /* USE_IO_OPS */
 
 	/* Bring old chips out of low-power mode. */
@@ -1008,6 +1021,7 @@
 	} else
 #endif
 		tp->phys[0] = 32;
+	tp->mii.phy_id = tp->phys[0];
 
 	/* The lower four bits are the media type. */
 	option = (board_idx >= MAX_UNITS) ? 0 : media[board_idx];
@@ -2230,6 +2244,7 @@
 		strcpy (info.driver, DRV_NAME);
 		strcpy (info.version, DRV_VERSION);
 		strcpy (info.bus_info, np->pci_dev->slot_name);
+		info.regdump_len = np->regs_len;
 		if (copy_to_user (useraddr, &info, sizeof (info)))
 			return -EFAULT;
 		return 0;
@@ -2309,6 +2324,104 @@
 			return rc;
 		}
 
+/* TODO: we are too slack to do reg dumping for pio, for now */
+#ifndef CONFIG_8139TOO_PIO
+	/* NIC register dump */
+	case ETHTOOL_GREGS: {
+                struct ethtool_regs regs;
+		unsigned int regs_len = np->regs_len;
+                u8 *regbuf = kmalloc(regs_len, GFP_KERNEL);
+                int rc;
+
+		if (!regbuf)
+			return -ENOMEM;
+		memset(regbuf, 0, regs_len);
+
+                rc = copy_from_user(&regs, useraddr, sizeof(regs));
+		if (rc) {
+			rc = -EFAULT;
+			goto err_out_gregs;
+		}
+                
+                if (regs.len > regs_len)
+                        regs.len = regs_len;
+                if (regs.len < regs_len) {
+			rc = -EINVAL;
+			goto err_out_gregs;
+		}
+
+                regs.version = RTL_REGS_VER;
+                rc = copy_to_user(useraddr, &regs, sizeof(regs));
+		if (rc) {
+			rc = -EFAULT;
+			goto err_out_gregs;
+		}
+
+                useraddr += offsetof(struct ethtool_regs, data);
+
+                spin_lock_irq(&np->lock);
+                memcpy_fromio(regbuf, np->mmio_addr, regs_len);
+                spin_unlock_irq(&np->lock);
+
+                if (copy_to_user(useraddr, regbuf, regs_len))
+                        rc = -EFAULT;
+
+err_out_gregs:
+		kfree(regbuf);
+		return rc;
+	}
+#endif /* CONFIG_8139TOO_PIO */
+
+	/* get string list(s) */
+	case ETHTOOL_GSTRINGS: {
+		struct ethtool_gstrings estr = { ETHTOOL_GSTRINGS };
+
+		if (copy_from_user(&estr, useraddr, sizeof(estr)))
+			return -EFAULT;
+		if (estr.string_set != ETH_SS_STATS)
+			return -EINVAL;
+
+		estr.len = RTL_NUM_STATS;
+		if (copy_to_user(useraddr, &estr, sizeof(estr)))
+			return -EFAULT;
+		if (copy_to_user(useraddr + sizeof(estr),
+				 &ethtool_stats_keys,
+				 sizeof(ethtool_stats_keys)))
+			return -EFAULT;
+		return 0;
+	}
+
+	/* get NIC-specific statistics */
+	case ETHTOOL_GSTATS: {
+		struct ethtool_stats estats = { ETHTOOL_GSTATS };
+		u64 *tmp_stats;
+		const unsigned int sz = sizeof(u64) * RTL_NUM_STATS;
+		int i;
+
+		estats.n_stats = RTL_NUM_STATS;
+		if (copy_to_user(useraddr, &estats, sizeof(estats)))
+			return -EFAULT;
+
+		tmp_stats = kmalloc(sz, GFP_KERNEL);
+		if (!tmp_stats)
+			return -ENOMEM;
+		memset(tmp_stats, 0, sz);
+
+		i = 0;
+		tmp_stats[i++] = np->xstats.early_rx;
+		tmp_stats[i++] = np->xstats.tx_buf_mapped;
+		tmp_stats[i++] = np->xstats.tx_timeouts;
+		tmp_stats[i++] = np->xstats.rx_lost_in_ring;
+		if (i != RTL_NUM_STATS)
+			BUG();
+
+		i = copy_to_user(useraddr + sizeof(estats), tmp_stats, sz);
+		kfree(tmp_stats);
+
+		if (i)
+			return -EFAULT;
+		return 0;
+	}
 	default:
 		break;
 	}
@@ -2427,7 +2540,7 @@
 		     i++, mclist = mclist->next) {
 			int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
 
-			mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
 			rx_mode |= AcceptMulticast;
 		}
 	}
diff -Nru a/drivers/net/Config.in b/drivers/net/Config.in
--- a/drivers/net/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/Config.in	Thu Jun 20 15:54:00 2002
@@ -124,7 +124,7 @@
       tristate '    EtherExpress 16 support' CONFIG_EEXPRESS
       tristate '    EtherExpressPro support/EtherExpress 10 (i82595) support' CONFIG_EEXPRESS_PRO
       if [ "$CONFIG_OBSOLETE" = "y" ]; then
-         tristate '    FMV-181/182/183/184 support' CONFIG_FMV18X
+         tristate '    FMV-181/182/183/184 support (OBSOLETE)' CONFIG_FMV18X
       fi
       tristate '    HP PCLAN+ (27247B and 27252A) support' CONFIG_HPLAN_PLUS
       tristate '    HP PCLAN (27245 and other 27xxx series) support' CONFIG_HPLAN
@@ -135,7 +135,7 @@
 	 dep_tristate '    SEEQ8005 support (EXPERIMENTAL)' CONFIG_SEEQ8005 $CONFIG_EXPERIMENTAL
       fi
       if [ "$CONFIG_OBSOLETE" = "y" ]; then
-         tristate '    SK_G16 support' CONFIG_SK_G16
+         tristate '    SK_G16 support (OBSOLETE)' CONFIG_SK_G16
       fi
    fi
    if [ "$CONFIG_MCA" = "y" ]; then
@@ -186,7 +186,7 @@
       dep_tristate '    VIA Rhine support' CONFIG_VIA_RHINE $CONFIG_PCI
       dep_mbool '      Use MMIO instead of PIO (EXPERIMENTAL)' CONFIG_VIA_RHINE_MMIO $CONFIG_VIA_RHINE $CONFIG_EXPERIMENTAL
       if [ "$CONFIG_OBSOLETE" = "y" ]; then
-	 dep_bool '    Zenith Z-Note support (EXPERIMENTAL)' CONFIG_ZNET $CONFIG_ISA
+	 dep_bool '    Zenith Z-Note support (OBSOLETE)' CONFIG_ZNET $CONFIG_ISA
       fi
       if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_MIPS" = "y" ]; then
 	 bool '    Philips SAA9730 Ethernet support (EXPERIMENTAL)' CONFIG_LAN_SAA9730
@@ -251,9 +251,9 @@
    if [ "$CONFIG_INET" = "y" ]; then
       bool 'HIPPI driver support (EXPERIMENTAL)' CONFIG_HIPPI
       if [ "$CONFIG_HIPPI" = "y" -a "$CONFIG_PCI" = "y" ]; then
-         dep_tristate '  Essential RoadRunner HIPPI PCI adapter support' CONFIG_ROADRUNNER $CONFIG_PCI
+         dep_tristate '  Essential RoadRunner HIPPI PCI adapter support (EXPERIMENTAL)' CONFIG_ROADRUNNER $CONFIG_PCI
          if [ "$CONFIG_ROADRUNNER" != "n" ]; then
-   	    bool '    Use large TX/RX rings' CONFIG_ROADRUNNER_LARGE_RINGS
+   	    bool '    Use large TX/RX rings (EXPERIMENTAL)' CONFIG_ROADRUNNER_LARGE_RINGS
          fi
       fi
    fi
diff -Nru a/drivers/net/dl2k.c b/drivers/net/dl2k.c
--- a/drivers/net/dl2k.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/dl2k.c	Thu Jun 20 15:54:01 2002
@@ -1,6 +1,6 @@
 /*  D-Link DL2000-based Gigabit Ethernet Adapter Linux driver */
 /*
-    Copyright (c) 2001,2002 by D-Link Corporation
+    Copyright (c) 2001, 2002 by D-Link Corporation
     Written by Edward Peng.<edward_peng@dlink.com.tw>
     Created 03-May-2001, base on Linux' sundance.c.
 
@@ -33,12 +33,13 @@
     1.11	2002/05/23	Added ISR schedule scheme.
     				Fixed miscount of rx frame error for DGE-550SX.
     				Fixed VLAN bug.
+    1.12	2002/06/13	Lock tx_coalesce=1 on 10/100Mbps mode.
  */
 
 #include "dl2k.h"
 
 static char version[] __devinitdata =
-    KERN_INFO "D-Link DL2000-based linux driver v1.11 2002/05/23\n";
+    KERN_INFO "D-Link DL2000-based linux driver v1.12 2002/06/13\n";
 
 #define MAX_UNITS 8
 static int mtu[MAX_UNITS];
@@ -138,15 +139,15 @@
 	}
 	SET_MODULE_OWNER (dev);
 
-#ifdef USE_IO_OPS
-	ioaddr = pci_resource_start (pdev, 0);
-#else
+#ifdef MEM_MAPPING
 	ioaddr = pci_resource_start (pdev, 1);
 	ioaddr = (long) ioremap (ioaddr, RIO_IO_SIZE);
 	if (!ioaddr) {
 		err = -ENOMEM;
 		goto err_out_dev;
 	}
+#else
+	ioaddr = pci_resource_start (pdev, 0);
 #endif
 	dev->base_addr = ioaddr;
 	dev->irq = irq;
@@ -158,6 +159,7 @@
 
 	/* Parse manual configuration */
 	np->an_enable = 1;
+	np->tx_coalesce = 1;
 	if (card_idx < MAX_UNITS) {
 		if (media[card_idx] != NULL) {
 			np->an_enable = 0;
@@ -213,7 +215,7 @@
 
 		if (tx_coalesce < 1)
 			tx_coalesce = 1;
-		if (tx_coalesce > TX_RING_SIZE-1)
+		else if (tx_coalesce > TX_RING_SIZE-1)
 			tx_coalesce = TX_RING_SIZE - 1;
 	}
 	dev->open = &rio_open;
@@ -303,7 +305,7 @@
       err_out_unmap_tx:
 	pci_free_consistent (pdev, TX_TOTAL_SIZE, np->tx_ring, np->tx_ring_dma);
       err_out_iounmap:
-#ifndef USE_IO_OPS
+#ifdef MEM_MAPPING
 	iounmap ((void *) ioaddr);
 
       err_out_dev:
@@ -361,7 +363,7 @@
 	}
 
 	/* Check CRC */
-	crc = ~ether_crc_le(256 - 4, sromdata);
+	crc = ~ether_crc_le (256 - 4, sromdata);
 	if (psrom->crc != crc) {
 		printk (KERN_ERR "%s: EEPROM data CRC error.\n", dev->name);
 		return -1;
@@ -636,7 +638,7 @@
 
 	/* DL2K bug: DMA fails to get next descriptor ptr in 10Mbps mode
 	 * Work around: Always use 1 descriptor in 10Mbps mode */
-	if (entry % tx_coalesce == 0 || np->speed == 10)
+	if (entry % np->tx_coalesce == 0 || np->speed == 10)
 		txdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |
 					      WordAlignDisable | 
 					      TxDMAIndicate |
@@ -936,6 +938,10 @@
 				mii_get_media_pcs (dev);
 			else
 				mii_get_media (dev);
+			if (np->speed == 1000)
+				np->tx_coalesce = tx_coalesce;
+			else 
+				np->tx_coalesce = 1;
 			macctrl = 0;
 			macctrl |= (np->vlan) ? AutoVLANuntagging : 0;
 			macctrl |= (np->full_duplex) ? DuplexSelect : 0;
@@ -1671,7 +1677,7 @@
 				     np->rx_ring_dma);
 		pci_free_consistent (pdev, TX_TOTAL_SIZE, np->tx_ring,
 				     np->tx_ring_dma);
-#ifndef USE_IO_OPS
+#ifdef MEM_MAPPING
 		iounmap ((char *) (dev->base_addr));
 #endif
 		kfree (dev);
diff -Nru a/drivers/net/dl2k.h b/drivers/net/dl2k.h
--- a/drivers/net/dl2k.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/dl2k.h	Thu Jun 20 15:54:00 2002
@@ -33,15 +33,15 @@
 #include <linux/delay.h>
 #include <linux/spinlock.h>
 #include <linux/time.h>
-#define TX_RING_SIZE	128
-#define TX_QUEUE_LEN	120	/* Limit ring entries actually used.  */
-#define RX_RING_SIZE 	128
+#define TX_RING_SIZE	256
+#define TX_QUEUE_LEN	(TX_RING_SIZE - 1) /* Limit ring entries actually used.*/
+#define RX_RING_SIZE 	256
 #define TX_TOTAL_SIZE	TX_RING_SIZE*sizeof(struct netdev_desc)
 #define RX_TOTAL_SIZE	RX_RING_SIZE*sizeof(struct netdev_desc)
 
 /* This driver was written to use PCI memory space, however x86-oriented
    hardware often uses I/O space accesses. */
-#ifdef USE_IO_OPS
+#ifndef MEM_MAPPING
 #undef readb
 #undef readw
 #undef readl
@@ -658,6 +658,7 @@
 	unsigned int chip_id;		/* PCI table chip id */
 	unsigned int rx_coalesce; 	/* Maximum frames each RxDMAComplete intr */
 	unsigned int rx_timeout; 	/* Wait time between RxDMAComplete intr */
+	unsigned int tx_coalesce;	/* Maximum frames each tx interrupt */
 	unsigned int full_duplex:1;	/* Full-duplex operation requested. */
 	unsigned int an_enable:2;	/* Auto-Negotiated Enable */
 	unsigned int jumbo:1;		/* Jumbo frame enable */
@@ -681,10 +682,10 @@
 };
 
 /* The station address location in the EEPROM. */
-#ifdef USE_IO_OPS
-#define PCI_IOTYPE (PCI_USES_MASTER | PCI_USES_IO  | PCI_ADDR0)
-#else
+#ifdef MEM_MAPPING
 #define PCI_IOTYPE (PCI_USES_MASTER | PCI_USES_MEM | PCI_ADDR1)
+#else
+#define PCI_IOTYPE (PCI_USES_MASTER | PCI_USES_IO  | PCI_ADDR0)
 #endif
 /* The struct pci_device_id consist of:
         vendor, device          Vendor and device ID to match (or PCI_ANY_ID)
diff -Nru a/drivers/net/hamradio/soundmodem/Makefile b/drivers/net/hamradio/soundmodem/Makefile
--- a/drivers/net/hamradio/soundmodem/Makefile	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/hamradio/soundmodem/Makefile	Thu Jun 20 15:54:00 2002
@@ -23,14 +23,14 @@
 
 # Dependencies on generates files need to be listed explicitly
 
-sm_afsk1200.o:   sm_tbl_afsk1200.h
-sm_afsk2400_7.o: sm_tbl_afsk2400_7.h
-sm_afsk2400_8.o: sm_tbl_afsk2400_8.h
-sm_afsk2666.o:   sm_tbl_afsk2666.h
-sm_psk4800.o:    sm_tbl_psk4800.h
-sm_hapn4800.o:   sm_tbl_hapn4800.h
-sm_fsk9600.o:    sm_tbl_fsk9600.h
+$(obj)/sm_afsk1200.o:   $(obj)/sm_tbl_afsk1200.h
+$(obj)/sm_afsk2400_7.o: $(obj)/sm_tbl_afsk2400_7.h
+$(obj)/sm_afsk2400_8.o: $(obj)/sm_tbl_afsk2400_8.h
+$(obj)/sm_afsk2666.o:   $(obj)/sm_tbl_afsk2666.h
+$(obj)/sm_psk4800.o:    $(obj)/sm_tbl_psk4800.h
+$(obj)/sm_hapn4800.o:   $(obj)/sm_tbl_hapn4800.h
+$(obj)/sm_fsk9600.o:    $(obj)/sm_tbl_fsk9600.h
 
-sm_tbl_%: gentbl
-	./gentbl
+$(obj)/sm_tbl_%: $(obj)/gentbl
+	$<
 
diff -Nru a/drivers/net/irda/actisys.c b/drivers/net/irda/actisys.c
--- a/drivers/net/irda/actisys.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/irda/actisys.c	Thu Jun 20 15:54:01 2002
@@ -42,7 +42,6 @@
 #include <linux/init.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irda_device.h>
 
 /* 
@@ -110,7 +109,7 @@
 	return 0;
 }
 
-void actisys_cleanup(void)
+void __exit actisys_cleanup(void)
 {
 	/* We have to remove both dongles */
 	irda_device_unregister_dongle(&dongle);
@@ -269,7 +268,6 @@
 	return ret;
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no> - Jean Tourrilhes <jt@hpl.hp.com>");
 MODULE_DESCRIPTION("ACTiSYS IR-220L and IR-220L+ dongle driver");	
 MODULE_LICENSE("GPL");
@@ -281,10 +279,7 @@
  *    Initialize Actisys module
  *
  */
-int init_module(void)
-{
-	return actisys_init();
-}
+module_init(actisys_init);
 
 /*
  * Function cleanup_module (void)
@@ -292,8 +287,4 @@
  *    Cleanup Actisys module
  *
  */
-void cleanup_module(void)
-{
-	actisys_cleanup();
-}
-#endif /* MODULE */
+module_exit(actisys_cleanup);
diff -Nru a/drivers/net/irda/ali-ircc.c b/drivers/net/irda/ali-ircc.c
--- a/drivers/net/irda/ali-ircc.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/irda/ali-ircc.c	Thu Jun 20 15:54:00 2002
@@ -40,8 +40,6 @@
 
 #include <net/irda/wrapper.h>
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
-#include <net/irda/irlap_frame.h>
 #include <net/irda/irda_device.h>
 
 #include <net/irda/ali-ircc.h>
@@ -88,9 +86,7 @@
 /* Some prototypes */
 static int  ali_ircc_open(int i, chipio_t *info);
 
-#ifdef MODULE
 static int  ali_ircc_close(struct ali_ircc_cb *self);
-#endif /* MODULE */
 
 static int  ali_ircc_setup(chipio_t *info);
 static int  ali_ircc_is_receiving(struct ali_ircc_cb *self);
@@ -228,8 +224,7 @@
  *    Close all configured chips
  *
  */
-#ifdef MODULE
-static void ali_ircc_cleanup(void)
+static void __exit ali_ircc_cleanup(void)
 {
 	int i;
 
@@ -244,7 +239,6 @@
 	
 	IRDA_DEBUG(2, __FUNCTION__ "(), ----------------- End -----------------\n");
 }
-#endif /* MODULE */
 
 /*
  * Function ali_ircc_open (int i, chipio_t *inf)
@@ -387,14 +381,13 @@
 }
 
 
-#ifdef MODULE
 /*
  * Function ali_ircc_close (self)
  *
  *    Close driver instance
  *
  */
-static int ali_ircc_close(struct ali_ircc_cb *self)
+static int __exit ali_ircc_close(struct ali_ircc_cb *self)
 {
 	int iobase;
 
@@ -428,7 +421,6 @@
 	
 	return 0;
 }
-#endif /* MODULE */
 
 /*
  * Function ali_ircc_init_43 (chip, info)
@@ -2288,7 +2280,6 @@
 	IRDA_DEBUG(1, __FUNCTION__ "(), ----------------- End ------------------\n");
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Benjamin Kong <benjamin_kong@ali.com.tw>");
 MODULE_DESCRIPTION("ALi FIR Controller Driver");
 MODULE_LICENSE("GPL");
@@ -2301,13 +2292,5 @@
 MODULE_PARM(dma, "1-4i");
 MODULE_PARM_DESC(dma, "DMA channels");
 
-int init_module(void)
-{
-	return ali_ircc_init();	
-}
-
-void cleanup_module(void)
-{
-	ali_ircc_cleanup();
-}
-#endif /* MODULE */
+module_init(ali_ircc_init);
+module_exit(ali_ircc_cleanup);
diff -Nru a/drivers/net/irda/ep7211_ir.c b/drivers/net/irda/ep7211_ir.c
--- a/drivers/net/irda/ep7211_ir.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/irda/ep7211_ir.c	Thu Jun 20 15:54:00 2002
@@ -11,7 +11,6 @@
 #include <linux/init.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irda_device.h>
 
 #include <asm/io.h>
@@ -123,7 +122,5 @@
 MODULE_DESCRIPTION("EP7211 I/R driver");
 MODULE_LICENSE("GPL");
 		
-#ifdef MODULE
 module_init(ep7211_ir_init);
-#endif /* MODULE */
 module_exit(ep7211_ir_cleanup);
diff -Nru a/drivers/net/irda/esi.c b/drivers/net/irda/esi.c
--- a/drivers/net/irda/esi.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/irda/esi.c	Thu Jun 20 15:54:01 2002
@@ -38,7 +38,6 @@
 #include <linux/init.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irda_device.h>
 
 static void esi_open(dongle_t *self, struct qos_info *qos);
@@ -60,7 +59,7 @@
 	return irda_device_register_dongle(&dongle);
 }
 
-void esi_cleanup(void)
+void __exit esi_cleanup(void)
 {
 	irda_device_unregister_dongle(&dongle);
 }
@@ -133,7 +132,6 @@
 	return 0;
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("Extended Systems JetEye PC dongle driver");
 MODULE_LICENSE("GPL");
@@ -144,10 +142,7 @@
  *    Initialize ESI module
  *
  */
-int init_module(void)
-{
-	return esi_init();
-}
+module_init(esi_init);
 
 /*
  * Function cleanup_module (void)
@@ -155,9 +150,5 @@
  *    Cleanup ESI module
  *
  */
-void cleanup_module(void)
-{
-        esi_cleanup();
-}
-#endif /* MODULE */
+module_exit(esi_cleanup);
 
diff -Nru a/drivers/net/irda/girbil.c b/drivers/net/irda/girbil.c
--- a/drivers/net/irda/girbil.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/net/irda/girbil.c	Thu Jun 20 15:53:59 2002
@@ -29,7 +29,6 @@
 #include <linux/init.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irda_device.h>
 #include <net/irda/irtty.h>
 
@@ -79,7 +78,7 @@
 	return irda_device_register_dongle(&dongle);
 }
 
-void girbil_cleanup(void)
+void __exit girbil_cleanup(void)
 {
 	irda_device_unregister_dongle(&dongle);
 }
@@ -231,7 +230,6 @@
 	return ret;
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("Greenwich GIrBIL dongle driver");
 MODULE_LICENSE("GPL");
@@ -243,10 +241,7 @@
  *    Initialize Girbil module
  *
  */
-int init_module(void)
-{
-	return girbil_init();
-}
+module_init(girbil_init);
 
 /*
  * Function cleanup_module (void)
@@ -254,8 +249,5 @@
  *    Cleanup Girbil module
  *
  */
-void cleanup_module(void)
-{
-        girbil_cleanup();
-}
-#endif /* MODULE */
+module_exit(girbil_cleanup);
+
diff -Nru a/drivers/net/irda/irda-usb.c b/drivers/net/irda/irda-usb.c
--- a/drivers/net/irda/irda-usb.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/irda/irda-usb.c	Thu Jun 20 15:54:01 2002
@@ -65,11 +65,6 @@
 #include <linux/rtnetlink.h>
 #include <linux/usb.h>
 
-#include <net/irda/irda.h>
-#include <net/irda/irlap.h>
-#include <net/irda/irda_device.h>
-#include <net/irda/wrapper.h>
-
 #include <net/irda/irda-usb.h>
 
 /*------------------------------------------------------------------*/
diff -Nru a/drivers/net/irda/irport.c b/drivers/net/irda/irport.c
--- a/drivers/net/irda/irport.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/irda/irport.c	Thu Jun 20 15:54:00 2002
@@ -55,7 +55,6 @@
 #include <asm/io.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/wrapper.h>
 #include <net/irda/irport.h>
 
@@ -121,8 +120,7 @@
  *    Close all configured ports
  *
  */
-#ifdef MODULE
-static void irport_cleanup(void)
+static void __exit irport_cleanup(void)
 {
  	int i;
 
@@ -133,7 +131,6 @@
  			irport_close(dev_self[i]);
  	}
 }
-#endif /* MODULE */
 
 struct irport_cb *
 irport_open(int i, unsigned int iobase, unsigned int irq)
@@ -1026,7 +1023,6 @@
 	return &self->stats;
 }
 
-#ifdef MODULE
 MODULE_PARM(io, "1-4i");
 MODULE_PARM_DESC(io, "Base I/O addresses");
 MODULE_PARM(irq, "1-4i");
@@ -1036,15 +1032,6 @@
 MODULE_DESCRIPTION("Half duplex serial driver for IrDA SIR mode");
 MODULE_LICENSE("GPL");
 
-
-void cleanup_module(void)
-{
-	irport_cleanup();
-}
-
-int init_module(void)
-{
-	return irport_init();
-}
-#endif /* MODULE */
+module_init(irport_init);
+module_exit(irport_cleanup);
 
diff -Nru a/drivers/net/irda/irtty.c b/drivers/net/irda/irtty.c
--- a/drivers/net/irda/irtty.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/irda/irtty.c	Thu Jun 20 15:54:00 2002
@@ -37,7 +37,6 @@
 #include <net/irda/irda.h>
 #include <net/irda/irtty.h>
 #include <net/irda/wrapper.h>
-#include <net/irda/timer.h>
 #include <net/irda/irda_device.h>
 
 static hashbin_t *irtty = NULL;
@@ -113,8 +112,7 @@
  *    Called when the irda module is removed. Here we remove all instances
  *    of the driver, and the master array.
  */
-#ifdef MODULE
-static void irtty_cleanup(void) 
+static void __exit irtty_cleanup(void) 
 {
 	int ret;
 	
@@ -132,7 +130,6 @@
 	 */
 	hashbin_delete(irtty, NULL);
 }
-#endif /* MODULE */
 
 /* 
  *  Function irtty_open(tty)
@@ -1058,8 +1055,6 @@
 	return &self->stats;
 }
 
-#ifdef MODULE
-
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("IrDA TTY device driver");
 MODULE_LICENSE("GPL");
@@ -1074,10 +1069,7 @@
  *    Initialize IrTTY module
  *
  */
-int init_module(void)
-{
-	return irtty_init();
-}
+module_init(irtty_init);
 
 /*
  * Function cleanup_module (void)
@@ -1085,9 +1077,4 @@
  *    Cleanup IrTTY module
  *
  */
-void cleanup_module(void)
-{
-	irtty_cleanup();
-}
-
-#endif /* MODULE */
+module_exit(irtty_cleanup);
diff -Nru a/drivers/net/irda/litelink.c b/drivers/net/irda/litelink.c
--- a/drivers/net/irda/litelink.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/irda/litelink.c	Thu Jun 20 15:54:01 2002
@@ -35,7 +35,6 @@
 #include <linux/init.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irda_device.h>
 
 #define MIN_DELAY 25      /* 15 us, but wait a little more to be sure */
@@ -63,7 +62,7 @@
 	return irda_device_register_dongle(&dongle);
 }
 
-void litelink_cleanup(void)
+void __exit litelink_cleanup(void)
 {
 	irda_device_unregister_dongle(&dongle);
 }
@@ -163,7 +162,6 @@
 	return 0;
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("Parallax Litelink dongle driver");	
 MODULE_LICENSE("GPL");
@@ -175,10 +173,7 @@
  *    Initialize Litelink module
  *
  */
-int init_module(void)
-{
-	return litelink_init();
-}
+module_init(litelink_init);
 
 /*
  * Function cleanup_module (void)
@@ -186,8 +181,4 @@
  *    Cleanup Litelink module
  *
  */
-void cleanup_module(void)
-{
-	litelink_cleanup();
-}
-#endif /* MODULE */
+module_exit(litelink_cleanup);
diff -Nru a/drivers/net/irda/mcp2120.c b/drivers/net/irda/mcp2120.c
--- a/drivers/net/irda/mcp2120.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/irda/mcp2120.c	Thu Jun 20 15:54:01 2002
@@ -25,7 +25,6 @@
 #include <linux/init.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irda_device.h>
 #include <net/irda/irtty.h>
 
@@ -56,7 +55,7 @@
 	return irda_device_register_dongle(&dongle);
 }
 
-void mcp2120_cleanup(void)
+void __exit mcp2120_cleanup(void)
 {
 	irda_device_unregister_dongle(&dongle);
 }
@@ -222,7 +221,6 @@
 	return ret;
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Felix Tang <tangf@eyetap.org>");
 MODULE_DESCRIPTION("Microchip MCP2120");
 MODULE_LICENSE("GPL");
@@ -234,10 +232,7 @@
  *    Initialize MCP2120 module
  *
  */
-int init_module(void)
-{
-	return mcp2120_init();
-}
+module_init(mcp2120_init);
 
 /*
  * Function cleanup_module (void)
@@ -245,8 +240,4 @@
  *    Cleanup MCP2120 module
  *
  */
-void cleanup_module(void)
-{
-        mcp2120_cleanup();
-}
-#endif /* MODULE */
+module_exit(mcp2120_cleanup);
diff -Nru a/drivers/net/irda/nsc-ircc.c b/drivers/net/irda/nsc-ircc.c
--- a/drivers/net/irda/nsc-ircc.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/net/irda/nsc-ircc.c	Thu Jun 20 15:53:59 2002
@@ -61,8 +61,6 @@
 
 #include <net/irda/wrapper.h>
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
-#include <net/irda/irlap_frame.h>
 #include <net/irda/irda_device.h>
 
 #include <net/irda/nsc-ircc.h>
@@ -123,9 +121,7 @@
 
 /* Some prototypes */
 static int  nsc_ircc_open(int i, chipio_t *info);
-#ifdef MODULE
 static int  nsc_ircc_close(struct nsc_ircc_cb *self);
-#endif /* MODULE */
 static int  nsc_ircc_setup(chipio_t *info);
 static void nsc_ircc_pio_receive(struct nsc_ircc_cb *self);
 static int  nsc_ircc_dma_receive(struct nsc_ircc_cb *self); 
@@ -225,8 +221,7 @@
  *    Close all configured chips
  *
  */
-#ifdef MODULE
-static void nsc_ircc_cleanup(void)
+static void __exit nsc_ircc_cleanup(void)
 {
 	int i;
 
@@ -237,7 +232,6 @@
 			nsc_ircc_close(dev_self[i]);
 	}
 }
-#endif /* MODULE */
 
 /*
  * Function nsc_ircc_open (iobase, irq)
@@ -245,7 +239,7 @@
  *    Open driver instance
  *
  */
-static int nsc_ircc_open(int i, chipio_t *info)
+static int __init nsc_ircc_open(int i, chipio_t *info)
 {
 	struct net_device *dev;
 	struct nsc_ircc_cb *self;
@@ -384,14 +378,13 @@
 	return 0;
 }
 
-#ifdef MODULE
 /*
  * Function nsc_ircc_close (self)
  *
  *    Close driver instance
  *
  */
-static int nsc_ircc_close(struct nsc_ircc_cb *self)
+static int __exit nsc_ircc_close(struct nsc_ircc_cb *self)
 {
 	int iobase;
 
@@ -424,7 +417,6 @@
 	
 	return 0;
 }
-#endif /* MODULE */
 
 /*
  * Function nsc_ircc_init_108 (iobase, cfg_base, irq, dma)
@@ -2046,7 +2038,6 @@
 	return 0;
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("NSC IrDA Device Driver");
 MODULE_LICENSE("GPL");
@@ -2063,14 +2054,6 @@
 MODULE_PARM(dongle_id, "i");
 MODULE_PARM_DESC(dongle_id, "Type-id of used dongle");
 
-int init_module(void)
-{
-	return nsc_ircc_init();
-}
-
-void cleanup_module(void)
-{
-	nsc_ircc_cleanup();
-}
-#endif /* MODULE */
+module_init(nsc_ircc_init);
+module_exit(nsc_ircc_cleanup);
 
diff -Nru a/drivers/net/irda/old_belkin.c b/drivers/net/irda/old_belkin.c
--- a/drivers/net/irda/old_belkin.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/irda/old_belkin.c	Thu Jun 20 15:54:01 2002
@@ -36,7 +36,6 @@
 #include <linux/irda.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irda_device.h>
 
 /*
@@ -90,7 +89,7 @@
 	return irda_device_register_dongle(&dongle);
 }
 
-void old_belkin_cleanup(void)
+void __exit old_belkin_cleanup(void)
 {
 	irda_device_unregister_dongle(&dongle);
 }
@@ -149,7 +148,6 @@
 	return 0;
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Jean Tourrilhes <jt@hpl.hp.com>");
 MODULE_DESCRIPTION("Belkin (old) SmartBeam dongle driver");	
 MODULE_LICENSE("GPL");
@@ -161,10 +159,7 @@
  *    Initialize Old-Belkin module
  *
  */
-int init_module(void)
-{
-	return old_belkin_init();
-}
+module_init(old_belkin_init);
 
 /*
  * Function cleanup_module (void)
@@ -172,9 +167,4 @@
  *    Cleanup Old-Belkin module
  *
  */
-void cleanup_module(void)
-{
-	old_belkin_cleanup();
-}
-#endif /* MODULE */
-
+module_exit(old_belkin_cleanup);
diff -Nru a/drivers/net/irda/sa1100_ir.c b/drivers/net/irda/sa1100_ir.c
--- a/drivers/net/irda/sa1100_ir.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/irda/sa1100_ir.c	Thu Jun 20 15:54:00 2002
@@ -33,7 +33,6 @@
 #include <linux/pm.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/wrapper.h>
 #include <net/irda/irda_device.h>
 
@@ -1078,9 +1077,7 @@
 	kfree(si);
 }
 
-#ifdef MODULE
 static
-#endif
 int __init sa1100_irda_init(void)
 {
 	struct net_device *dev;
@@ -1181,10 +1178,8 @@
 
 __setup("sa1100ir=", sa1100ir_setup);
 
-#ifdef MODULE
 module_init(sa1100_irda_init);
 module_exit(sa1100_irda_exit);
-#endif
 
 MODULE_AUTHOR("Russell King <rmk@arm.linux.org.uk>");
 MODULE_DESCRIPTION("StrongARM SA1100 IrDA driver");
diff -Nru a/drivers/net/irda/smc-ircc.c b/drivers/net/irda/smc-ircc.c
--- a/drivers/net/irda/smc-ircc.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/net/irda/smc-ircc.c	Thu Jun 20 15:53:59 2002
@@ -59,8 +59,6 @@
 
 #include <net/irda/wrapper.h>
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
-#include <net/irda/irlap_frame.h>
 #include <net/irda/irda_device.h>
 #include <net/irda/smc-ircc.h>
 #include <net/irda/irport.h>
@@ -1160,15 +1158,12 @@
 	return 0;
 }
 
-#ifdef MODULE
-
 /*
  * Function ircc_close (self)
  *
  *    Close driver instance
  *
  */
-#ifdef MODULE
 static int __exit ircc_close(struct ircc_cb *self)
 {
 	int iobase;
@@ -1207,7 +1202,6 @@
 
 	return 0;
 }
-#endif /* MODULE */
 
 int __init smc_init(void)
 {
@@ -1243,5 +1237,3 @@
 MODULE_PARM_DESC(ircc_sir, "SIR Base Address");
 MODULE_PARM(ircc_cfg, "1-4i");
 MODULE_PARM_DESC(ircc_cfg, "Configuration register base address");
-
-#endif /* MODULE */
diff -Nru a/drivers/net/irda/tekram.c b/drivers/net/irda/tekram.c
--- a/drivers/net/irda/tekram.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/irda/tekram.c	Thu Jun 20 15:54:01 2002
@@ -29,7 +29,6 @@
 #include <linux/init.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irda_device.h>
 #include <net/irda/irtty.h>
 
@@ -60,7 +59,7 @@
 	return irda_device_register_dongle(&dongle);
 }
 
-void tekram_cleanup(void)
+void __exit tekram_cleanup(void)
 {
 	irda_device_unregister_dongle(&dongle);
 }
@@ -264,7 +263,6 @@
 	return ret;
 }
 
-#ifdef MODULE
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("Tekram IrMate IR-210B dongle driver");
 MODULE_LICENSE("GPL");
@@ -275,10 +273,7 @@
  *    Initialize Tekram module
  *
  */
-int init_module(void)
-{
-	return tekram_init();
-}
+module_init(tekram_init);
 
 /*
  * Function cleanup_module (void)
@@ -286,8 +281,4 @@
  *    Cleanup Tekram module
  *
  */
-void cleanup_module(void)
-{
-        tekram_cleanup();
-}
-#endif /* MODULE */
+module_exit(tekram_cleanup);
diff -Nru a/drivers/net/irda/toshoboe.c b/drivers/net/irda/toshoboe.c
--- a/drivers/net/irda/toshoboe.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/net/irda/toshoboe.c	Thu Jun 20 15:53:59 2002
@@ -69,8 +69,6 @@
 
 #include <net/irda/wrapper.h>
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
-#include <net/irda/irlap_frame.h>
 #include <net/irda/irda_device.h>
 
 #include <linux/pm.h>
diff -Nru a/drivers/net/irda/vlsi_ir.c b/drivers/net/irda/vlsi_ir.c
--- a/drivers/net/irda/vlsi_ir.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/irda/vlsi_ir.c	Thu Jun 20 15:54:00 2002
@@ -37,7 +37,6 @@
 #include <net/irda/irda.h>
 #include <net/irda/irda_device.h>
 #include <net/irda/wrapper.h>
-#include <net/irda/irlap.h>
 
 #include <net/irda/vlsi_ir.h>
 
diff -Nru a/drivers/net/irda/w83977af_ir.c b/drivers/net/irda/w83977af_ir.c
--- a/drivers/net/irda/w83977af_ir.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/irda/w83977af_ir.c	Thu Jun 20 15:54:00 2002
@@ -56,7 +56,6 @@
 #include <asm/byteorder.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/wrapper.h>
 #include <net/irda/irda_device.h>
 #include <net/irda/w83977af.h>
@@ -135,8 +134,7 @@
  *    Close all configured chips
  *
  */
-#ifdef MODULE
-void w83977af_cleanup(void)
+void __exit w83977af_cleanup(void)
 {
 	int i;
 
@@ -147,7 +145,6 @@
 			w83977af_close(dev_self[i]);
 	}
 }
-#endif /* MODULE */
 
 /*
  * Function w83977af_open (iobase, irq)
@@ -1374,8 +1371,6 @@
 	return &self->stats;
 }
 
-#ifdef MODULE
-
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("Winbond W83977AF IrDA Device Driver");
 MODULE_LICENSE("GPL");
@@ -1394,10 +1389,7 @@
  *    
  *
  */
-int init_module(void)
-{
-	return w83977af_init();
-}
+module_init(w83977af_init);
 
 /*
  * Function cleanup_module (void)
@@ -1405,8 +1397,4 @@
  *    
  *
  */
-void cleanup_module(void)
-{
-	w83977af_cleanup();
-}
-#endif /* MODULE */
+module_exit(w83977af_cleanup);
diff -Nru a/drivers/net/skfp/h/smt.h b/drivers/net/skfp/h/smt.h
--- a/drivers/net/skfp/h/smt.h	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/skfp/h/smt.h	Thu Jun 20 15:54:01 2002
@@ -543,7 +543,7 @@
 
 struct smt_p_001d {
 	struct smt_para	para ;		/* generic parameter header */
-	u_int		allocatable ;	/* total sync bw availabel for alloc */
+	u_int		allocatable ;	/* total sync bw available for alloc */
 } ;
 
 /*
diff -Nru a/drivers/net/sungem.c b/drivers/net/sungem.c
--- a/drivers/net/sungem.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/sungem.c	Thu Jun 20 15:54:01 2002
@@ -41,6 +41,7 @@
 #include <linux/ethtool.h>
 #include <linux/crc32.h>
 #include <linux/random.h>
+#include <linux/tqueue.h>
 
 #include <asm/system.h>
 #include <asm/bitops.h>
diff -Nru a/drivers/net/tun.c b/drivers/net/tun.c
--- a/drivers/net/tun.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/net/tun.c	Thu Jun 20 15:54:01 2002
@@ -275,7 +275,7 @@
 		total += sizeof(pi);
 	}       
 
-	len = MIN(skb->len, len);
+	len = min(skb->len, len);
 
 	skb_copy_datagram_iovec(skb, 0, iv, len);
 	total += len;
diff -Nru a/drivers/net/wan/Config.in b/drivers/net/wan/Config.in
--- a/drivers/net/wan/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/wan/Config.in	Thu Jun 20 15:54:00 2002
@@ -70,8 +70,8 @@
 
       dep_tristate '    Cyclades-PC300 support (RS-232/V.35, X.21, T1/E1 boards)' CONFIG_PC300 $CONFIG_HDLC $CONFIG_PCI
       if [ "$CONFIG_PC300" != "n" ]; then
-         if [ "$CONFIG_PPP" != "n" -a "$CONFIG_PPP_MULTLINK" != "n" -a \
-	      "$CONFIG_PPP_SYNCTTY" != "n" -a "$CONFIG_HDLC_PPP" = "y" ]; then
+         if [ "$CONFIG_PPP" != "n" -a "$CONFIG_PPP_MULTILINK" != "n" -a \
+	      "$CONFIG_PPP_SYNC_TTY" != "n" -a "$CONFIG_HDLC_PPP" = "y" ]; then
 	    bool '      Cyclades-PC300 MLPPP support' CONFIG_PC300_MLPPP
 	 else
 	    comment 'Cyclades-PC300 MLPPP support is disabled.'
@@ -111,7 +111,7 @@
 	 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
 	    dep_tristate '    Cyclom 2X(tm) cards (EXPERIMENTAL)' CONFIG_CYCLADES_SYNC $CONFIG_WAN_ROUTER_DRIVERS
 	    if [ "$CONFIG_CYCLADES_SYNC" != "n" ]; then
-	       bool '      Cyclom 2X X.25 support' CONFIG_CYCLOMX_X25
+	       bool '      Cyclom 2X X.25 support (EXPERIMENTAL)' CONFIG_CYCLOMX_X25
 	    fi
 	 fi
       fi
diff -Nru a/drivers/net/wireless/Config.in b/drivers/net/wireless/Config.in
--- a/drivers/net/wireless/Config.in	Thu Jun 20 15:54:00 2002
+++ b/drivers/net/wireless/Config.in	Thu Jun 20 15:54:00 2002
@@ -19,8 +19,8 @@
 fi
 
 if [ "$CONFIG_PCI" = "y" ]; then
-   dep_tristate '    Hermes in PLX9052 based PCI adaptor support (Netgear MA301 etc.)' CONFIG_PLX_HERMES $CONFIG_HERMES $CONFIG_EXPERIMENTAL
-   dep_tristate '    Prism 2.5 PCI 802.11b adaptor support' CONFIG_PCI_HERMES $CONFIG_HERMES $CONFIG_EXPERIMENTAL
+   dep_tristate '    Hermes in PLX9052 based PCI adaptor support (Netgear MA301 etc.) (EXPERIMENTAL)' CONFIG_PLX_HERMES $CONFIG_HERMES $CONFIG_EXPERIMENTAL
+   dep_tristate '    Prism 2.5 PCI 802.11b adaptor support (EXPERIMENTAL)' CONFIG_PCI_HERMES $CONFIG_HERMES $CONFIG_EXPERIMENTAL
 fi
 
 # If Pcmcia is compiled in, offer Pcmcia cards...
diff -Nru a/drivers/pci/Makefile b/drivers/pci/Makefile
--- a/drivers/pci/Makefile	Thu Jun 20 15:54:01 2002
+++ b/drivers/pci/Makefile	Thu Jun 20 15:54:01 2002
@@ -34,7 +34,13 @@
 
 include $(TOPDIR)/Rules.make
 
-names.o: devlist.h classlist.h
+# Dependencies on generated files need to be listed explicitly
 
-devlist.h classlist.h: pci.ids gen-devlist
-	./gen-devlist <pci.ids
+$(obj)/names.o: $(obj)/devlist.h $(obj)/classlist.h
+
+# And that's how to generate them
+
+$(obj)/devlist.h: $(src)/pci.ids $(obj)/gen-devlist
+	$(obj)/gen-devlist < $<
+
+$(obj)/classlist.h: $(obj)/devlist.h
diff -Nru a/drivers/pcmcia/hd64465_ss.c b/drivers/pcmcia/hd64465_ss.c
--- a/drivers/pcmcia/hd64465_ss.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/pcmcia/hd64465_ss.c	Thu Jun 20 15:54:01 2002
@@ -37,6 +37,7 @@
 #include <linux/vmalloc.h>
 #include <asm/errno.h>
 #include <linux/irq.h>
+#include <linux/tqueue.h>
 
 #include <asm/io.h>
 #include <asm/hd64465.h>
diff -Nru a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
--- a/drivers/pcmcia/i82092.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/pcmcia/i82092.c	Thu Jun 20 15:54:01 2002
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <linux/tqueue.h>
 
 #include <pcmcia/cs_types.h>
 #include <pcmcia/ss.h>
diff -Nru a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
--- a/drivers/pcmcia/i82365.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/pcmcia/i82365.c	Thu Jun 20 15:54:01 2002
@@ -46,6 +46,7 @@
 #include <linux/ioport.h>
 #include <linux/delay.h>
 #include <linux/proc_fs.h>
+#include <linux/tqueue.h>
 #include <asm/irq.h>
 #include <asm/io.h>
 #include <asm/bitops.h>
diff -Nru a/drivers/pcmcia/tcic.c b/drivers/pcmcia/tcic.c
--- a/drivers/pcmcia/tcic.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/pcmcia/tcic.c	Thu Jun 20 15:54:01 2002
@@ -49,6 +49,7 @@
 #include <linux/ioport.h>
 #include <linux/delay.h>
 #include <linux/proc_fs.h>
+#include <linux/tqueue.h>
 
 #include <pcmcia/version.h>
 #include <pcmcia/cs_types.h>
diff -Nru a/drivers/sbus/char/Makefile b/drivers/sbus/char/Makefile
--- a/drivers/sbus/char/Makefile	Thu Jun 20 15:54:01 2002
+++ b/drivers/sbus/char/Makefile	Thu Jun 20 15:54:01 2002
@@ -31,5 +31,3 @@
 obj-$(CONFIG_BBC_I2C)			+= bbc.o
 
 include $(TOPDIR)/Rules.make
-
-sunkbdmap.o: sunkeymap.c
diff -Nru a/drivers/scsi/3w-xxxx.c b/drivers/scsi/3w-xxxx.c
--- a/drivers/scsi/3w-xxxx.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/scsi/3w-xxxx.c	Thu Jun 20 15:54:01 2002
@@ -141,12 +141,23 @@
                  Empty stale responses before draining aen queue.
                  Fix tw_scsi_eh_abort() to not reset on every io abort.
                  Set can_queue in SHT to 255 to prevent hang from AEN.
+   1.02.00.022 - Fix possible null pointer dereference in tw_scsi_release().
+   1.02.00.023 - Fix bug in tw_aen_drain_queue() where unit # was always zero.
+   1.02.00.024 - Add severity levels to AEN strings.
+   1.02.00.025 - Fix command interrupt spurious error messages.
+                 Fix bug in raw command post with data ioctl method.
+                 Fix bug where rollcall sometimes failed with cable errors.
+                 Print unit # on all command timeouts.
 */
 
 #include <linux/module.h>
 
 MODULE_AUTHOR ("3ware Inc.");
+#ifdef __SMP__
+MODULE_DESCRIPTION ("3ware Storage Controller Linux Driver (SMP)");
+#else
 MODULE_DESCRIPTION ("3ware Storage Controller Linux Driver");
+#endif
 MODULE_LICENSE("GPL");
 
 #include <linux/kernel.h>
@@ -190,7 +201,7 @@
 };
 
 /* Globals */
-char *tw_driver_version="1.02.00.021";
+char *tw_driver_version="1.02.00.025";
 TW_Device_Extension *tw_device_extension_list[TW_MAX_SLOT];
 int tw_device_extension_count = 0;
 
@@ -214,7 +225,7 @@
 
 	/* Print some useful info when certain aen codes come out */
 	if (aen == 0x0ff) {
-		printk(KERN_WARNING "3w-xxxx: scsi%d: AEN: AEN queue overflow.\n", tw_dev->host->host_no);
+		printk(KERN_WARNING "3w-xxxx: scsi%d: AEN: INFO: AEN queue overflow.\n", tw_dev->host->host_no);
 	} else {
 		if ((aen & 0x0ff) < TW_AEN_STRING_MAX) {
 			if ((tw_aen_string[aen & 0xff][strlen(tw_aen_string[aen & 0xff])-1]) == '#') {
@@ -286,7 +297,7 @@
 	status_reg_addr = tw_dev->registers.status_reg_addr;
 	response_que_addr = tw_dev->registers.response_que_addr;
 
-	if (tw_poll_status(tw_dev, TW_STATUS_ATTENTION_INTERRUPT, 30)) {
+	if (tw_poll_status(tw_dev, TW_STATUS_ATTENTION_INTERRUPT | TW_STATUS_MICROCONTROLLER_READY, 30)) {
 		dprintk(KERN_WARNING "3w-xxxx: tw_aen_drain_queue(): No attention interrupt for card %d.\n", tw_device_extension_count);
 		return 1;
 	}
@@ -396,7 +407,7 @@
 						break;
 					default:
 						if (aen == 0x0ff) {
-							printk(KERN_WARNING "3w-xxxx: AEN: AEN queue overflow.\n");
+							printk(KERN_WARNING "3w-xxxx: AEN: INFO: AEN queue overflow.\n");
 						} else {
 							if ((aen & 0x0ff) < TW_AEN_STRING_MAX) {
 								if ((tw_aen_string[aen & 0xff][strlen(tw_aen_string[aen & 0xff])-1]) == '#') {
@@ -413,7 +424,7 @@
 
 				/* Now put the aen on the aen_queue */
 				if (queue == 1) {
-					tw_dev->aen_queue[tw_dev->aen_tail] = aen_code;
+					tw_dev->aen_queue[tw_dev->aen_tail] = aen;
 					if (tw_dev->aen_tail == TW_Q_LENGTH - 1) {
 						tw_dev->aen_tail = TW_Q_START;
 					} else {
@@ -1348,7 +1359,7 @@
 					}
 					tw_dev->pending_request_count--;
 				} else {
-					printk(KERN_WARNING "3w-xxxx: scsi%d: Error posting pending commands.\n", tw_dev->host->host_no);
+					/* If we get here, we will continue re-posting on the next command interrupt */
 					break;
 				}
 			}
@@ -1379,8 +1390,13 @@
 
 				/* Check for correct state */
 				if (tw_dev->state[request_id] != TW_S_POSTED) {
-					printk(KERN_WARNING "3w-xxxx: scsi%d: Received a request id (%d) (opcode = 0x%x) that wasn't posted.\n", tw_dev->host->host_no, request_id, command_packet->byte0.opcode);
-					error = 1;
+					/* Handle timed out ioctl's */
+					if (tw_dev->srb[request_id] != 0) {
+						if (tw_dev->srb[request_id]->cmnd[0] != TW_IOCTL) {
+							printk(KERN_WARNING "3w-xxxx: scsi%d: Received a request id (%d) (opcode = 0x%x) that wasn't posted.\n", tw_dev->host->host_no, request_id, command_packet->byte0.opcode);
+							error = 1;
+						}
+					}
 				}
 
 				dprintk(KERN_NOTICE "3w-xxxx: tw_interrupt(): Response queue request id: %d.\n", request_id);
@@ -1472,8 +1488,9 @@
 	TW_Passthru *passthru = NULL;
 	int tw_aen_code, i, use_sg;
 	char *data_ptr;
-	int total_bytes = 0;
+	int total_bytes = 0, posted = 0;
 	dma_addr_t dma_handle;
+	struct timeval before, timeout;
 
 	ioctl = (TW_Ioctl *)tw_dev->srb[request_id]->request_buffer;
 	if (ioctl == NULL) {
@@ -1625,7 +1642,7 @@
 						if ((u32 *)command_packet->byte8.param.sgl[i].address != NULL) {
 							error = copy_from_user(data_ptr, (u32 *)command_packet->byte8.param.sgl[i].address, command_packet->byte8.param.sgl[i].length);
 							if (error) {
-								printk(KERN_WARNING "3w-xxxx: scsi%d: Error copying param sglist from userspace.\n", tw_dev->host->host_no);
+								dprintk(KERN_WARNING "3w-xxxx: scsi%d: Error copying param sglist from userspace.\n", tw_dev->host->host_no);
 								goto tw_ioctl_bail;
 							}
 						} else {
@@ -1656,7 +1673,7 @@
 							if ((u32 *)command_packet->byte8.io.sgl[i].address != NULL) {
 								error = copy_from_user(data_ptr, (u32 *)command_packet->byte8.io.sgl[i].address, command_packet->byte8.io.sgl[i].length);
 								if (error) {
-									printk(KERN_WARNING "3w-xxxx: scsi%d: Error copying io sglist from userspace.\n", tw_dev->host->host_no);
+									dprintk(KERN_WARNING "3w-xxxx: scsi%d: Error copying io sglist from userspace.\n", tw_dev->host->host_no);
 									goto tw_ioctl_bail;
 								}
 							} else {
@@ -1672,15 +1689,31 @@
 					command_packet->byte8.io.sgl[0].length = total_bytes;
 				}
 
+				spin_unlock(&tw_dev->tw_lock);
 				spin_unlock_irq(tw_dev->host->host_lock);
-				spin_unlock_irq(&tw_dev->tw_lock);
+
+				set_bit(TW_IN_IOCTL, &tw_dev->flags);
 
 				/* Finally post the command packet */
 				tw_post_command_packet(tw_dev, request_id);
+				posted = 1;
+				do_gettimeofday(&before);
 
+			tw_ioctl_retry:
 				mdelay(TW_IOCTL_WAIT_TIME);
-				spin_lock_irq(&tw_dev->tw_lock);
+				if (test_bit(TW_IN_IOCTL, &tw_dev->flags)) {
+					do_gettimeofday(&timeout);
+					if (before.tv_sec + TW_IOCTL_TIMEOUT < timeout.tv_sec) {
+						spin_lock_irq(tw_dev->host->host_lock);
+						spin_lock(&tw_dev->tw_lock);
+						goto tw_ioctl_bail;
+					} else {
+						goto tw_ioctl_retry;
+					}
+				}
+
 				spin_lock_irq(tw_dev->host->host_lock);
+				spin_lock(&tw_dev->tw_lock);
 
 				if (signal_pending(current)) {
 					dprintk(KERN_WARNING "3w-xxxx: scsi%d: tw_ioctl(): Signal pending, aborting ioctl().\n", tw_dev->host->host_no);
@@ -1697,7 +1730,7 @@
 						if ((u32 *)command_save->byte8.param.sgl[i].address != NULL) {
 							error = copy_to_user((u32 *)command_save->byte8.param.sgl[i].address, data_ptr, command_save->byte8.param.sgl[i].length);
 							if (error) {
-								printk(KERN_WARNING "3w-xxxx: scsi%d: Error copying param sglist to userspace.\n", tw_dev->host->host_no);
+								dprintk(KERN_WARNING "3w-xxxx: scsi%d: Error copying param sglist to userspace.\n", tw_dev->host->host_no);
 								goto tw_ioctl_bail;
 							}
 							dprintk(KERN_WARNING "3w-xxxx: scsi%d: Copied %ld bytes to pid %d.\n", tw_dev->host->host_no, command_save->byte8.param.sgl[i].length, current->pid);
@@ -1717,7 +1750,7 @@
 							if ((u32 *)command_save->byte8.io.sgl[i].address != NULL) {
 								error = copy_to_user((u32 *)command_save->byte8.io.sgl[i].address, data_ptr, command_save->byte8.io.sgl[i].length);
 								if (error) {
-									printk(KERN_WARNING "3w-xxxx: scsi%d: Error copying io sglist to userspace.\n", tw_dev->host->host_no);
+									dprintk(KERN_WARNING "3w-xxxx: scsi%d: Error copying io sglist to userspace.\n", tw_dev->host->host_no);
 									goto tw_ioctl_bail;
 								}
 								dprintk(KERN_WARNING "3w-xxxx: scsi%d: Copied %ld bytes to pid %d.\n", tw_dev->host->host_no, command_save->byte8.io.sgl[i].length, current->pid);
@@ -1742,7 +1775,8 @@
 				/* Now complete the io */
 				tw_dev->state[request_id] = TW_S_COMPLETED;
 				tw_state_request_finish(tw_dev, request_id);
-				tw_dev->posted_request_count--;
+				if (posted)
+					tw_dev->posted_request_count--;
 				tw_dev->srb[request_id]->scsi_done(tw_dev->srb[request_id]);
 				return 0;
 			} else {
@@ -1818,6 +1852,7 @@
 			break;
 		case TW_CMD_PACKET_WITH_DATA:
 			dprintk(KERN_WARNING "3w-xxxx: tw_ioctl_complete(): caught TW_CMD_PACKET_WITH_DATA.\n");
+			clear_bit(TW_IN_IOCTL, &tw_dev->flags);
 			return TW_ISR_DONT_COMPLETE; /* Special case for isr to not complete io */
 		default:
 			memset(buff, 0, tw_dev->srb[request_id]->request_bufflen);
@@ -2121,14 +2156,14 @@
 	for (i=0;i<TW_Q_LENGTH;i++) {
 		if (tw_dev->srb[i] == SCpnt) {
 			if (tw_dev->state[i] == TW_S_STARTED) {
-				printk(KERN_WARNING "3w-xxxx: scsi%d: Command (0x%x) timed out.\n", tw_dev->host->host_no, (u32)SCpnt);
+				printk(KERN_WARNING "3w-xxxx: scsi%d: Unit #%d: Command (0x%x) timed out.\n", tw_dev->host->host_no, tw_dev->srb[i]==0 ? 0 : tw_dev->srb[i]->target, (u32)SCpnt);
 				tw_dev->state[i] = TW_S_COMPLETED;
 				tw_state_request_finish(tw_dev, i);
 				spin_unlock(&tw_dev->tw_lock);
 				return (SUCCESS);
 			}
 			if (tw_dev->state[i] == TW_S_PENDING) {
-				printk(KERN_WARNING "3w-xxxx: scsi%d: Command (0x%x) timed out.\n", tw_dev->host->host_no, (u32)SCpnt);
+				printk(KERN_WARNING "3w-xxxx: scsi%d: Unit #%d: Command (0x%x) timed out.\n", tw_dev->host->host_no, tw_dev->srb[i]==0 ? 0 : tw_dev->srb[i]->target, (u32)SCpnt);
 				if (tw_dev->pending_head == TW_Q_LENGTH-1) {
 					tw_dev->pending_head = TW_Q_START;
 				} else {
@@ -2142,7 +2177,7 @@
 			}
 			if (tw_dev->state[i] == TW_S_POSTED) {
 				/* If the command has already been posted, we have to reset the card */
-				printk(KERN_WARNING "3w-xxxx: scsi%d: Command (0x%x) timed out, resetting card.\n", tw_dev->host->host_no, (u32)SCpnt);
+				printk(KERN_WARNING "3w-xxxx: scsi%d: Unit #%d: Command (0x%x) timed out, resetting card.\n", tw_dev->host->host_no, tw_dev->srb[i]==0 ? 0 : tw_dev->srb[i]->target, (u32)SCpnt);
 				/* We have to let AEN requests through before the reset */
 				spin_unlock(&tw_dev->tw_lock);
 				spin_unlock_irq(tw_dev->host->host_lock);
@@ -2360,6 +2395,11 @@
 
 	dprintk(KERN_NOTICE "3w-xxxx: tw_scsi_release()\n");
 
+	/* Fake like we just shut down, so notify the card that
+	 * we "shut down cleanly".
+	 */
+	tw_halt(0, 0, 0);  // parameters aren't actually used
+
 	/* Free up the IO region */
 	release_region((tw_dev->tw_pci_dev->resource[0].start), TW_IO_ADDRESS_RANGE);
 
@@ -2371,11 +2411,6 @@
 
 	/* Tell kernel scsi-layer we are gone */
 	scsi_unregister(tw_host);
-	
-	/* Fake like we just shut down, so notify the card that
-	 * we "shut down cleanly".
-	 */
-	tw_halt(0, 0, 0);  // parameters aren't actually used
 
 	return 0;
 } /* End tw_scsi_release() */
diff -Nru a/drivers/scsi/3w-xxxx.h b/drivers/scsi/3w-xxxx.h
--- a/drivers/scsi/3w-xxxx.h	Thu Jun 20 15:54:00 2002
+++ b/drivers/scsi/3w-xxxx.h	Thu Jun 20 15:54:00 2002
@@ -60,43 +60,44 @@
 
 /* AEN strings */
 static char *tw_aen_string[] = {
-	"AEN queue empty",                      // 0x000
-	"Soft reset occurred",                  // 0x001
-	"Unit degraded: Unit #",                // 0x002
-	"Controller error",                     // 0x003 
-	"Rebuild failed: Unit #",               // 0x004
-	"Rebuild complete: Unit #",             // 0x005
-	"Incomplete unit detected: Unit #",     // 0x006
-	"Initialization complete: Unit #",      // 0x007
-	"Unclean shutdown detected: Unit #",    // 0x008
-	"ATA port timeout: Port #",             // 0x009
-	"Drive error: Port #",                  // 0x00A
-	"Rebuild started: Unit #",              // 0x00B 
-	"Initialization started: Unit #",       // 0x00C
-	"Logical unit deleted: Unit #",         // 0x00D
-	NULL,                                   // 0x00E unused
-	"SMART threshold exceeded: Port #",     // 0x00F
+	"INFO: AEN queue empty",                       // 0x000
+	"INFO: Soft reset occurred",                   // 0x001
+	"ERROR: Unit degraded: Unit #",                // 0x002
+	"ERROR: Controller error",                     // 0x003 
+	"ERROR: Rebuild failed: Unit #",               // 0x004
+	"INFO: Rebuild complete: Unit #",              // 0x005
+	"ERROR: Incomplete unit detected: Unit #",     // 0x006
+	"INFO: Initialization complete: Unit #",       // 0x007
+	"WARNING: Unclean shutdown detected: Unit #",  // 0x008
+	"WARNING: ATA port timeout: Port #",           // 0x009
+	"ERROR: Drive error: Port #",                  // 0x00A
+	"INFO: Rebuild started: Unit #",               // 0x00B 
+	"INFO: Initialization started: Unit #",        // 0x00C
+	"ERROR: Logical unit deleted: Unit #",         // 0x00D
+	NULL,                                          // 0x00E unused
+	"WARNING: SMART threshold exceeded: Port #",   // 0x00F
 	NULL, NULL, NULL, NULL, NULL,
 	NULL, NULL, NULL, NULL, NULL,
 	NULL, NULL, NULL, NULL, NULL,
-	NULL, NULL,                             // 0x010-0x020 unused
-	"ATA UDMA downgrade: Port #",           // 0x021
-	"ATA UDMA upgrade: Port #",             // 0x022
-	"Sector repair occurred: Port #",       // 0x023
-	"SBUF integrity check failure",         // 0x024
-	"Lost cached write: Port #",            // 0x025
-	"Drive ECC error detected: Port #",     // 0x026
-	"DCB checksum error: Port #",           // 0x027
-	"DCB unsupported version: Port #",      // 0x028
-	"Verify started: Unit #",               // 0x029
-	"Verify failed: Port #",                // 0x02A
-	"Verify complete: Unit #",              // 0x02B
-	"Overwrote bad sector during rebuild: Port #",  //0x2C
-	"Encountered bad sector during rebuild: Port #", //0x2D
-	"Replacement drive is too small: Port #" //0x2E
+	NULL, NULL,                                    // 0x010-0x020 unused
+	"WARNING: ATA UDMA downgrade: Port #",         // 0x021
+	"WARNING: ATA UDMA upgrade: Port #",           // 0x022
+	"WARNING: Sector repair occurred: Port #",     // 0x023
+	"ERROR: SBUF integrity check failure",         // 0x024
+	"ERROR: Lost cached write: Port #",            // 0x025
+	"ERROR: Drive ECC error detected: Port #",     // 0x026
+	"ERROR: DCB checksum error: Port #",           // 0x027
+	"ERROR: DCB unsupported version: Port #",      // 0x028
+	"INFO: Verify started: Unit #",                // 0x029
+	"ERROR: Verify failed: Port #",                // 0x02A
+	"INFO: Verify complete: Unit #",               // 0x02B
+	"ERROR: Overwrote bad sector during rebuild: Port #",   //0x02C
+	"ERROR: Encountered bad sector during rebuild: Port #", //0x02D
+	"INFO: Replacement drive is too small: Port #",         //0x02E
+	"WARNING: Verify error: Unit not previously initialized: Unit #" //0x02F
 };
 
-#define TW_AEN_STRING_MAX                      0x02F
+#define TW_AEN_STRING_MAX                      0x030
 
 /*
    Sense key lookup table
@@ -225,11 +226,13 @@
 #define TW_MAX_AEN_TRIES                      100
 #define TW_UNIT_ONLINE                        1
 #define TW_IN_INTR                            1
+#define TW_IN_IOCTL                           2
 #define TW_MAX_SECTORS                        256
 #define TW_AEN_WAIT_TIME                      1000
 #define TW_IOCTL_WAIT_TIME                    (1 * HZ) /* 1 second */
 #define TW_ISR_DONT_COMPLETE                  2
 #define TW_ISR_DONT_RESULT                    3
+#define TW_IOCTL_TIMEOUT                      25 /* 25 seconds */
 
 /* Macros */
 #define TW_STATUS_ERRORS(x) \
diff -Nru a/drivers/scsi/53c700_d.h_shipped b/drivers/scsi/53c700_d.h_shipped
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/scsi/53c700_d.h_shipped	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,1329 @@
+/* DO NOT EDIT - Generated automatically by script_asm.pl */
+static u32 SCRIPT[] = {
+/*
+; Script for the NCR (or symbios) 53c700 and 53c700-66 chip
+;
+; Copyright (C) 2001 James.Bottomley@HansenPartnership.com
+;;-----------------------------------------------------------------------------
+;;  
+;;  This program is free software; you can redistribute it and/or modify
+;;  it under the terms of the GNU General Public License as published by
+;;  the Free Software Foundation; either version 2 of the License, or
+;;  (at your option) any later version.
+;;
+;;  This program is distributed in the hope that it will be useful,
+;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
+;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;;  GNU General Public License for more details.
+;;
+;;  You should have received a copy of the GNU General Public License
+;;  along with this program; if not, write to the Free Software
+;;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+;;
+;;-----------------------------------------------------------------------------
+;
+; This script is designed to be modified for the particular command in
+; operation.  The particular variables pertaining to the commands are:
+;
+ABSOLUTE	Device_ID = 0		; ID of target for command
+ABSOLUTE	MessageCount = 0	; Number of bytes in message
+ABSOLUTE	MessageLocation = 0	; Addr of message
+ABSOLUTE	CommandCount = 0	; Number of bytes in command
+ABSOLUTE	CommandAddress = 0	; Addr of Command
+ABSOLUTE	StatusAddress = 0	; Addr to receive status return
+ABSOLUTE	ReceiveMsgAddress = 0	; Addr to receive msg
+;
+; This is the magic component for handling scatter-gather.  Each of the
+; SG components is preceeded by a script fragment which moves the
+; necessary amount of data and jumps to the next SG segment.  The final
+; SG segment jumps back to .  However, this address is the first SG script
+; segment.
+;
+ABSOLUTE	SGScriptStartAddress = 0
+
+; The following represent status interrupts we use 3 hex digits for
+; this: 0xPRS where 
+
+; P:
+ABSOLUTE	AFTER_SELECTION 	= 0x100
+ABSOLUTE	BEFORE_CMD 		= 0x200
+ABSOLUTE	AFTER_CMD 		= 0x300
+ABSOLUTE	AFTER_STATUS 		= 0x400
+ABSOLUTE	AFTER_DATA_IN		= 0x500
+ABSOLUTE	AFTER_DATA_OUT		= 0x600
+ABSOLUTE	DURING_DATA_IN		= 0x700
+
+; R:
+ABSOLUTE	NOT_MSG_OUT 		= 0x10
+ABSOLUTE	UNEXPECTED_PHASE 	= 0x20
+ABSOLUTE	NOT_MSG_IN 		= 0x30
+ABSOLUTE	UNEXPECTED_MSG		= 0x40
+ABSOLUTE	MSG_IN			= 0x50
+ABSOLUTE	SDTR_MSG_R		= 0x60
+ABSOLUTE	REJECT_MSG_R		= 0x70
+ABSOLUTE	DISCONNECT		= 0x80
+ABSOLUTE	MSG_OUT			= 0x90
+ABSOLUTE	WDTR_MSG_R		= 0xA0
+
+; S:
+ABSOLUTE	GOOD_STATUS 		= 0x1
+
+; Combinations, since the script assembler can't process |
+ABSOLUTE	NOT_MSG_OUT_AFTER_SELECTION = 0x110
+ABSOLUTE	UNEXPECTED_PHASE_BEFORE_CMD = 0x220
+ABSOLUTE	UNEXPECTED_PHASE_AFTER_CMD = 0x320
+ABSOLUTE	NOT_MSG_IN_AFTER_STATUS = 0x430
+ABSOLUTE	GOOD_STATUS_AFTER_STATUS = 0x401
+ABSOLUTE	UNEXPECTED_PHASE_AFTER_DATA_IN = 0x520
+ABSOLUTE	UNEXPECTED_PHASE_AFTER_DATA_OUT = 0x620
+ABSOLUTE	UNEXPECTED_MSG_BEFORE_CMD = 0x240
+ABSOLUTE	MSG_IN_BEFORE_CMD = 0x250
+ABSOLUTE	MSG_IN_AFTER_CMD = 0x350
+ABSOLUTE	SDTR_MSG_BEFORE_CMD = 0x260
+ABSOLUTE	REJECT_MSG_BEFORE_CMD = 0x270
+ABSOLUTE	DISCONNECT_AFTER_CMD = 0x380
+ABSOLUTE	SDTR_MSG_AFTER_CMD = 0x360
+ABSOLUTE	WDTR_MSG_AFTER_CMD = 0x3A0
+ABSOLUTE	MSG_IN_AFTER_STATUS = 0x440
+ABSOLUTE	DISCONNECT_AFTER_DATA = 0x580
+ABSOLUTE	MSG_IN_AFTER_DATA_IN = 0x550
+ABSOLUTE	MSG_IN_AFTER_DATA_OUT = 0x650
+ABSOLUTE	MSG_OUT_AFTER_DATA_IN = 0x590
+ABSOLUTE	DATA_IN_AFTER_DATA_IN = 0x5a0
+ABSOLUTE	MSG_IN_DURING_DATA_IN = 0x750
+ABSOLUTE	DISCONNECT_DURING_DATA = 0x780
+
+;
+; Other interrupt conditions
+; 
+ABSOLUTE	RESELECTED_DURING_SELECTION = 0x1000
+ABSOLUTE	COMPLETED_SELECTION_AS_TARGET = 0x1001
+ABSOLUTE	RESELECTION_IDENTIFIED = 0x1003
+;
+; Fatal interrupt conditions.  If you add to this, also add to the
+; array of corresponding messages
+;
+ABSOLUTE	FATAL = 0x2000
+ABSOLUTE	FATAL_UNEXPECTED_RESELECTION_MSG = 0x2000
+ABSOLUTE	FATAL_SEND_MSG = 0x2001
+ABSOLUTE	FATAL_NOT_MSG_IN_AFTER_SELECTION = 0x2002
+ABSOLUTE	FATAL_ILLEGAL_MSG_LENGTH = 0x2003
+
+ABSOLUTE	DEBUG_INTERRUPT	= 0x3000
+ABSOLUTE	DEBUG_INTERRUPT1 = 0x3001
+ABSOLUTE	DEBUG_INTERRUPT2 = 0x3002
+ABSOLUTE	DEBUG_INTERRUPT3 = 0x3003
+ABSOLUTE	DEBUG_INTERRUPT4 = 0x3004
+ABSOLUTE	DEBUG_INTERRUPT5 = 0x3005
+ABSOLUTE	DEBUG_INTERRUPT6 = 0x3006
+
+
+;
+; SCSI Messages we interpret in the script
+;
+ABSOLUTE	COMMAND_COMPLETE_MSG	= 0x00
+ABSOLUTE	EXTENDED_MSG		= 0x01
+ABSOLUTE	SDTR_MSG		= 0x01
+ABSOLUTE	SAVE_DATA_PTRS_MSG	= 0x02
+ABSOLUTE	RESTORE_DATA_PTRS_MSG	= 0x03
+ABSOLUTE	WDTR_MSG		= 0x03
+ABSOLUTE	DISCONNECT_MSG		= 0x04
+ABSOLUTE	REJECT_MSG		= 0x07
+ABSOLUTE	PARITY_ERROR_MSG	= 0x09
+ABSOLUTE	SIMPLE_TAG_MSG		= 0x20
+ABSOLUTE	IDENTIFY_MSG		= 0x80
+ABSOLUTE	IDENTIFY_MSG_MASK	= 0x7F
+ABSOLUTE	TWO_BYTE_MSG		= 0x20
+ABSOLUTE	TWO_BYTE_MSG_MASK	= 0x0F
+
+; This is where the script begins
+
+ENTRY	StartUp
+
+StartUp:
+	SELECT	ATN Device_ID, Reselect
+
+at 0x00000000 : */	0x41000000,0x00000020,
+/*
+	JUMP	Finish, WHEN STATUS
+
+at 0x00000002 : */	0x830b0000,0x00000460,
+/*
+	JUMP	SendIdentifyMsg, IF MSG_OUT
+
+at 0x00000004 : */	0x860a0000,0x000001b0,
+/*
+	INT	NOT_MSG_OUT_AFTER_SELECTION
+
+at 0x00000006 : */	0x98080000,0x00000110,
+/*
+
+Reselect:
+	WAIT	RESELECT SelectedAsTarget
+
+at 0x00000008 : */	0x50000000,0x00000058,
+/*
+	INT	RESELECTED_DURING_SELECTION, WHEN MSG_IN
+
+at 0x0000000a : */	0x9f0b0000,0x00001000,
+/*
+	INT	FATAL_NOT_MSG_IN_AFTER_SELECTION
+
+at 0x0000000c : */	0x98080000,0x00002002,
+/*
+
+	ENTRY	GetReselectionData
+GetReselectionData:
+	MOVE	1, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x0000000e : */	0x0f000001,0x00000000,
+/*
+	INT	RESELECTION_IDENTIFIED
+
+at 0x00000010 : */	0x98080000,0x00001003,
+/*
+
+	ENTRY	GetReselectionWithTag
+GetReselectionWithTag:
+	MOVE	3, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x00000012 : */	0x0f000003,0x00000000,
+/*
+	INT	RESELECTION_IDENTIFIED
+
+at 0x00000014 : */	0x98080000,0x00001003,
+/*
+	
+	ENTRY	SelectedAsTarget
+SelectedAsTarget:
+; Basically tell the selecting device that there's nothing here
+	SET	TARGET
+
+at 0x00000016 : */	0x58000200,0x00000000,
+/*
+	DISCONNECT
+
+at 0x00000018 : */	0x48000000,0x00000000,
+/*
+	CLEAR	TARGET
+
+at 0x0000001a : */	0x60000200,0x00000000,
+/*
+	INT	COMPLETED_SELECTION_AS_TARGET
+
+at 0x0000001c : */	0x98080000,0x00001001,
+/*
+;
+; These are the messaging entries
+;
+; Send a message.  Message count should be correctly patched
+	ENTRY	SendMessage
+SendMessage:
+	MOVE	MessageCount, MessageLocation, WHEN MSG_OUT
+
+at 0x0000001e : */	0x0e000000,0x00000000,
+/*
+ResumeSendMessage:
+	RETURN,	WHEN NOT MSG_OUT
+
+at 0x00000020 : */	0x96030000,0x00000000,
+/*
+	INT	FATAL_SEND_MSG
+
+at 0x00000022 : */	0x98080000,0x00002001,
+/*
+
+	ENTRY	SendMessagePhaseMismatch
+SendMessagePhaseMismatch:
+	CLEAR	ACK
+
+at 0x00000024 : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeSendMessage
+
+at 0x00000026 : */	0x80080000,0x00000080,
+/*
+;
+; Receive a message.  Need to identify the message to
+; receive it correctly
+	ENTRY	ReceiveMessage
+ReceiveMessage:
+	MOVE	1, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x00000028 : */	0x0f000001,0x00000000,
+/*
+;
+; Use this entry if we've just tried to look at the first byte
+; of the message and want to process it further
+ProcessReceiveMessage:
+	JUMP	ReceiveExtendedMessage, IF EXTENDED_MSG
+
+at 0x0000002a : */	0x800c0001,0x000000d0,
+/*
+	RETURN,	IF NOT TWO_BYTE_MSG, AND MASK TWO_BYTE_MSG_MASK
+
+at 0x0000002c : */	0x90040f20,0x00000000,
+/*
+	CLEAR	ACK
+
+at 0x0000002e : */	0x60000040,0x00000000,
+/*
+	MOVE	1, ReceiveMsgAddress + 1, WHEN MSG_IN
+
+at 0x00000030 : */	0x0f000001,0x00000001,
+/*
+	RETURN
+
+at 0x00000032 : */	0x90080000,0x00000000,
+/*
+ReceiveExtendedMessage:
+	CLEAR	ACK
+
+at 0x00000034 : */	0x60000040,0x00000000,
+/*
+	MOVE	1, ReceiveMsgAddress + 1, WHEN MSG_IN
+
+at 0x00000036 : */	0x0f000001,0x00000001,
+/*
+	JUMP	Receive1Byte, IF 0x01
+
+at 0x00000038 : */	0x800c0001,0x00000110,
+/*
+	JUMP	Receive2Byte, IF 0x02
+
+at 0x0000003a : */	0x800c0002,0x00000128,
+/*
+	JUMP	Receive3Byte, IF 0x03
+
+at 0x0000003c : */	0x800c0003,0x00000140,
+/*
+	JUMP	Receive4Byte, IF 0x04
+
+at 0x0000003e : */	0x800c0004,0x00000158,
+/*
+	JUMP	Receive5Byte, IF 0x05
+
+at 0x00000040 : */	0x800c0005,0x00000170,
+/*
+	INT	FATAL_ILLEGAL_MSG_LENGTH
+
+at 0x00000042 : */	0x98080000,0x00002003,
+/*
+Receive1Byte:
+	CLEAR	ACK
+
+at 0x00000044 : */	0x60000040,0x00000000,
+/*
+	MOVE	1, ReceiveMsgAddress + 2, WHEN MSG_IN
+
+at 0x00000046 : */	0x0f000001,0x00000002,
+/*
+	RETURN
+
+at 0x00000048 : */	0x90080000,0x00000000,
+/*
+Receive2Byte:
+	CLEAR	ACK
+
+at 0x0000004a : */	0x60000040,0x00000000,
+/*
+	MOVE	2, ReceiveMsgAddress + 2, WHEN MSG_IN
+
+at 0x0000004c : */	0x0f000002,0x00000002,
+/*
+	RETURN
+
+at 0x0000004e : */	0x90080000,0x00000000,
+/*
+Receive3Byte:
+	CLEAR	ACK
+
+at 0x00000050 : */	0x60000040,0x00000000,
+/*
+	MOVE	3, ReceiveMsgAddress + 2, WHEN MSG_IN
+
+at 0x00000052 : */	0x0f000003,0x00000002,
+/*
+	RETURN
+
+at 0x00000054 : */	0x90080000,0x00000000,
+/*
+Receive4Byte:
+	CLEAR	ACK
+
+at 0x00000056 : */	0x60000040,0x00000000,
+/*
+	MOVE	4, ReceiveMsgAddress + 2, WHEN MSG_IN
+
+at 0x00000058 : */	0x0f000004,0x00000002,
+/*
+	RETURN
+
+at 0x0000005a : */	0x90080000,0x00000000,
+/*
+Receive5Byte:
+	CLEAR	ACK
+
+at 0x0000005c : */	0x60000040,0x00000000,
+/*
+	MOVE	5, ReceiveMsgAddress + 2, WHEN MSG_IN
+
+at 0x0000005e : */	0x0f000005,0x00000002,
+/*
+	RETURN
+
+at 0x00000060 : */	0x90080000,0x00000000,
+/*
+;
+; Come here from the message processor to ignore the message
+;
+	ENTRY	IgnoreMessage
+IgnoreMessage:
+	CLEAR	ACK
+
+at 0x00000062 : */	0x60000040,0x00000000,
+/*
+	RETURN
+
+at 0x00000064 : */	0x90080000,0x00000000,
+/*
+;
+; Come here to send a reply to a message
+;
+	ENTRY	SendMessageWithATN
+SendMessageWithATN:
+	SET	ATN
+
+at 0x00000066 : */	0x58000008,0x00000000,
+/*
+	CLEAR	ACK
+
+at 0x00000068 : */	0x60000040,0x00000000,
+/*
+	JUMP	SendMessage
+
+at 0x0000006a : */	0x80080000,0x00000078,
+/*
+
+SendIdentifyMsg:
+	CALL	SendMessage
+
+at 0x0000006c : */	0x88080000,0x00000078,
+/*
+	CLEAR	ATN
+
+at 0x0000006e : */	0x60000008,0x00000000,
+/*
+
+IgnoreMsgBeforeCommand:
+	CLEAR	ACK
+
+at 0x00000070 : */	0x60000040,0x00000000,
+/*
+	ENTRY	SendCommand
+SendCommand:
+	JUMP	Finish, WHEN STATUS
+
+at 0x00000072 : */	0x830b0000,0x00000460,
+/*
+	JUMP	MsgInBeforeCommand, IF MSG_IN
+
+at 0x00000074 : */	0x870a0000,0x000002c0,
+/*
+	INT	UNEXPECTED_PHASE_BEFORE_CMD, IF NOT CMD
+
+at 0x00000076 : */	0x9a020000,0x00000220,
+/*
+	MOVE	CommandCount, CommandAddress, WHEN CMD
+
+at 0x00000078 : */	0x0a000000,0x00000000,
+/*
+ResumeSendCommand:
+	JUMP	Finish, WHEN STATUS
+
+at 0x0000007a : */	0x830b0000,0x00000460,
+/*
+	JUMP	MsgInAfterCmd, IF MSG_IN
+
+at 0x0000007c : */	0x870a0000,0x00000248,
+/*
+	JUMP	DataIn, IF DATA_IN
+
+at 0x0000007e : */	0x810a0000,0x000002f8,
+/*
+	JUMP	DataOut, IF DATA_OUT
+
+at 0x00000080 : */	0x800a0000,0x00000338,
+/*
+	INT	UNEXPECTED_PHASE_AFTER_CMD
+
+at 0x00000082 : */	0x98080000,0x00000320,
+/*
+
+IgnoreMsgDuringData:
+	CLEAR	ACK
+
+at 0x00000084 : */	0x60000040,0x00000000,
+/*
+	; fall through to MsgInDuringData
+
+Entry MsgInDuringData
+MsgInDuringData:
+;
+; Could be we have nothing more to transfer
+;
+	JUMP	Finish, WHEN STATUS
+
+at 0x00000086 : */	0x830b0000,0x00000460,
+/*
+	MOVE	1, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x00000088 : */	0x0f000001,0x00000000,
+/*
+	JUMP	DisconnectDuringDataIn, IF DISCONNECT_MSG
+
+at 0x0000008a : */	0x800c0004,0x00000398,
+/*
+	JUMP	IgnoreMsgDuringData, IF SAVE_DATA_PTRS_MSG
+
+at 0x0000008c : */	0x800c0002,0x00000210,
+/*
+	JUMP	IgnoreMsgDuringData, IF RESTORE_DATA_PTRS_MSG
+
+at 0x0000008e : */	0x800c0003,0x00000210,
+/*
+	INT	MSG_IN_DURING_DATA_IN
+
+at 0x00000090 : */	0x98080000,0x00000750,
+/*
+
+MsgInAfterCmd:
+	MOVE	1, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x00000092 : */	0x0f000001,0x00000000,
+/*
+	JUMP	DisconnectAfterCmd, IF DISCONNECT_MSG
+
+at 0x00000094 : */	0x800c0004,0x00000298,
+/*
+	JUMP	IgnoreMsgInAfterCmd, IF SAVE_DATA_PTRS_MSG
+
+at 0x00000096 : */	0x800c0002,0x00000288,
+/*
+	JUMP	IgnoreMsgInAfterCmd, IF RESTORE_DATA_PTRS_MSG
+
+at 0x00000098 : */	0x800c0003,0x00000288,
+/*
+	CALL	ProcessReceiveMessage
+
+at 0x0000009a : */	0x88080000,0x000000a8,
+/*
+	INT	MSG_IN_AFTER_CMD
+
+at 0x0000009c : */	0x98080000,0x00000350,
+/*
+	CLEAR	ACK
+
+at 0x0000009e : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeSendCommand
+
+at 0x000000a0 : */	0x80080000,0x000001e8,
+/*
+
+IgnoreMsgInAfterCmd:
+	CLEAR	ACK
+
+at 0x000000a2 : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeSendCommand
+
+at 0x000000a4 : */	0x80080000,0x000001e8,
+/*
+
+DisconnectAfterCmd:
+	CLEAR	ACK
+
+at 0x000000a6 : */	0x60000040,0x00000000,
+/*
+	WAIT	DISCONNECT
+
+at 0x000000a8 : */	0x48000000,0x00000000,
+/*
+	ENTRY	Disconnect1
+Disconnect1:
+	INT	DISCONNECT_AFTER_CMD
+
+at 0x000000aa : */	0x98080000,0x00000380,
+/*
+	ENTRY	Disconnect2
+Disconnect2:
+; We return here after a reselection
+	CLEAR	ACK
+
+at 0x000000ac : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeSendCommand
+
+at 0x000000ae : */	0x80080000,0x000001e8,
+/*
+
+MsgInBeforeCommand:
+	MOVE	1, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x000000b0 : */	0x0f000001,0x00000000,
+/*
+	JUMP	IgnoreMsgBeforeCommand, IF SAVE_DATA_PTRS_MSG
+
+at 0x000000b2 : */	0x800c0002,0x000001c0,
+/*
+	JUMP	IgnoreMsgBeforeCommand, IF RESTORE_DATA_PTRS_MSG
+
+at 0x000000b4 : */	0x800c0003,0x000001c0,
+/*
+	CALL	ProcessReceiveMessage
+
+at 0x000000b6 : */	0x88080000,0x000000a8,
+/*
+	INT	MSG_IN_BEFORE_CMD
+
+at 0x000000b8 : */	0x98080000,0x00000250,
+/*
+	CLEAR	ACK
+
+at 0x000000ba : */	0x60000040,0x00000000,
+/*
+	JUMP	SendCommand
+
+at 0x000000bc : */	0x80080000,0x000001c8,
+/*
+
+DataIn:
+	CALL	SGScriptStartAddress
+
+at 0x000000be : */	0x88080000,0x00000000,
+/*
+ResumeDataIn:
+	JUMP	Finish, WHEN STATUS
+
+at 0x000000c0 : */	0x830b0000,0x00000460,
+/*
+	JUMP	MsgInAfterDataIn, IF MSG_IN
+
+at 0x000000c2 : */	0x870a0000,0x00000358,
+/*
+	JUMP	DataInAfterDataIn, if DATA_IN
+
+at 0x000000c4 : */	0x810a0000,0x00000328,
+/*
+	INT	MSG_OUT_AFTER_DATA_IN, if MSG_OUT
+
+at 0x000000c6 : */	0x9e0a0000,0x00000590,
+/*
+	INT	UNEXPECTED_PHASE_AFTER_DATA_IN
+
+at 0x000000c8 : */	0x98080000,0x00000520,
+/*
+
+DataInAfterDataIn:
+	INT	DATA_IN_AFTER_DATA_IN
+
+at 0x000000ca : */	0x98080000,0x000005a0,
+/*
+	JUMP	ResumeDataIn
+
+at 0x000000cc : */	0x80080000,0x00000300,
+/*
+
+DataOut:
+	CALL	SGScriptStartAddress
+
+at 0x000000ce : */	0x88080000,0x00000000,
+/*
+ResumeDataOut:
+	JUMP	Finish, WHEN STATUS
+
+at 0x000000d0 : */	0x830b0000,0x00000460,
+/*
+	JUMP	MsgInAfterDataOut, IF MSG_IN
+
+at 0x000000d2 : */	0x870a0000,0x000003e8,
+/*
+	INT	UNEXPECTED_PHASE_AFTER_DATA_OUT
+
+at 0x000000d4 : */	0x98080000,0x00000620,
+/*
+
+MsgInAfterDataIn:
+	MOVE	1, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x000000d6 : */	0x0f000001,0x00000000,
+/*
+	JUMP	DisconnectAfterDataIn, IF DISCONNECT_MSG
+
+at 0x000000d8 : */	0x800c0004,0x000003c0,
+/*
+	JUMP	IgnoreMsgAfterData, IF SAVE_DATA_PTRS_MSG
+
+at 0x000000da : */	0x800c0002,0x00000428,
+/*
+	JUMP	IgnoreMsgAfterData, IF RESTORE_DATA_PTRS_MSG
+
+at 0x000000dc : */	0x800c0003,0x00000428,
+/*
+	CALL	ProcessReceiveMessage
+
+at 0x000000de : */	0x88080000,0x000000a8,
+/*
+	INT	MSG_IN_AFTER_DATA_IN
+
+at 0x000000e0 : */	0x98080000,0x00000550,
+/*
+	CLEAR	ACK
+
+at 0x000000e2 : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeDataIn
+
+at 0x000000e4 : */	0x80080000,0x00000300,
+/*
+
+DisconnectDuringDataIn:
+	CLEAR	ACK
+
+at 0x000000e6 : */	0x60000040,0x00000000,
+/*
+	WAIT	DISCONNECT
+
+at 0x000000e8 : */	0x48000000,0x00000000,
+/*
+	ENTRY	Disconnect3
+Disconnect3:
+	INT	DISCONNECT_DURING_DATA
+
+at 0x000000ea : */	0x98080000,0x00000780,
+/*
+	ENTRY	Disconnect4
+Disconnect4:
+; we return here after a reselection
+	CLEAR	ACK
+
+at 0x000000ec : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeSendCommand
+
+at 0x000000ee : */	0x80080000,0x000001e8,
+/*
+
+
+DisconnectAfterDataIn:
+	CLEAR	ACK
+
+at 0x000000f0 : */	0x60000040,0x00000000,
+/*
+	WAIT	DISCONNECT
+
+at 0x000000f2 : */	0x48000000,0x00000000,
+/*
+	ENTRY	Disconnect5
+Disconnect5:
+	INT	DISCONNECT_AFTER_DATA
+
+at 0x000000f4 : */	0x98080000,0x00000580,
+/*
+	ENTRY	Disconnect6
+Disconnect6:
+; we return here after a reselection
+	CLEAR	ACK
+
+at 0x000000f6 : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeDataIn
+
+at 0x000000f8 : */	0x80080000,0x00000300,
+/*
+
+MsgInAfterDataOut:
+	MOVE	1, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x000000fa : */	0x0f000001,0x00000000,
+/*
+	JUMP	DisconnectAfterDataOut, if DISCONNECT_MSG
+
+at 0x000000fc : */	0x800c0004,0x00000438,
+/*
+	JUMP	IgnoreMsgAfterData, IF SAVE_DATA_PTRS_MSG
+
+at 0x000000fe : */	0x800c0002,0x00000428,
+/*
+	JUMP	IgnoreMsgAfterData, IF RESTORE_DATA_PTRS_MSG
+
+at 0x00000100 : */	0x800c0003,0x00000428,
+/*
+	CALL	ProcessReceiveMessage
+
+at 0x00000102 : */	0x88080000,0x000000a8,
+/*
+	INT	MSG_IN_AFTER_DATA_OUT
+
+at 0x00000104 : */	0x98080000,0x00000650,
+/*
+	CLEAR	ACK
+
+at 0x00000106 : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeDataOut
+
+at 0x00000108 : */	0x80080000,0x00000340,
+/*
+
+IgnoreMsgAfterData:
+	CLEAR	ACK
+
+at 0x0000010a : */	0x60000040,0x00000000,
+/*
+; Data in and out do the same thing on resume, so pick one
+	JUMP	ResumeDataIn
+
+at 0x0000010c : */	0x80080000,0x00000300,
+/*
+
+DisconnectAfterDataOut:
+	CLEAR	ACK
+
+at 0x0000010e : */	0x60000040,0x00000000,
+/*
+	WAIT	DISCONNECT
+
+at 0x00000110 : */	0x48000000,0x00000000,
+/*
+	ENTRY	Disconnect7
+Disconnect7:
+	INT	DISCONNECT_AFTER_DATA
+
+at 0x00000112 : */	0x98080000,0x00000580,
+/*
+	ENTRY	Disconnect8
+Disconnect8:
+; we return here after a reselection
+	CLEAR	ACK
+
+at 0x00000114 : */	0x60000040,0x00000000,
+/*
+	JUMP	ResumeDataOut
+
+at 0x00000116 : */	0x80080000,0x00000340,
+/*
+
+Finish:
+	MOVE	1, StatusAddress, WHEN STATUS
+
+at 0x00000118 : */	0x0b000001,0x00000000,
+/*
+	INT	NOT_MSG_IN_AFTER_STATUS, WHEN NOT MSG_IN
+
+at 0x0000011a : */	0x9f030000,0x00000430,
+/*
+	MOVE	1, ReceiveMsgAddress, WHEN MSG_IN
+
+at 0x0000011c : */	0x0f000001,0x00000000,
+/*
+	JUMP	FinishCommandComplete, IF COMMAND_COMPLETE_MSG
+
+at 0x0000011e : */	0x800c0000,0x00000490,
+/*
+	CALL	ProcessReceiveMessage
+
+at 0x00000120 : */	0x88080000,0x000000a8,
+/*
+	INT	MSG_IN_AFTER_STATUS
+
+at 0x00000122 : */	0x98080000,0x00000440,
+/*
+	ENTRY	FinishCommandComplete
+FinishCommandComplete:
+	CLEAR	ACK
+
+at 0x00000124 : */	0x60000040,0x00000000,
+/*
+	WAIT	DISCONNECT
+
+at 0x00000126 : */	0x48000000,0x00000000,
+/*
+	ENTRY	Finish1
+Finish1:
+	INT	GOOD_STATUS_AFTER_STATUS
+
+at 0x00000128 : */	0x98080000,0x00000401,
+};
+
+#define A_AFTER_CMD	0x00000300
+static u32 A_AFTER_CMD_used[] __attribute((unused)) = {
+};
+
+#define A_AFTER_DATA_IN	0x00000500
+static u32 A_AFTER_DATA_IN_used[] __attribute((unused)) = {
+};
+
+#define A_AFTER_DATA_OUT	0x00000600
+static u32 A_AFTER_DATA_OUT_used[] __attribute((unused)) = {
+};
+
+#define A_AFTER_SELECTION	0x00000100
+static u32 A_AFTER_SELECTION_used[] __attribute((unused)) = {
+};
+
+#define A_AFTER_STATUS	0x00000400
+static u32 A_AFTER_STATUS_used[] __attribute((unused)) = {
+};
+
+#define A_BEFORE_CMD	0x00000200
+static u32 A_BEFORE_CMD_used[] __attribute((unused)) = {
+};
+
+#define A_COMMAND_COMPLETE_MSG	0x00000000
+static u32 A_COMMAND_COMPLETE_MSG_used[] __attribute((unused)) = {
+	0x0000011e,
+};
+
+#define A_COMPLETED_SELECTION_AS_TARGET	0x00001001
+static u32 A_COMPLETED_SELECTION_AS_TARGET_used[] __attribute((unused)) = {
+	0x0000001d,
+};
+
+#define A_CommandAddress	0x00000000
+static u32 A_CommandAddress_used[] __attribute((unused)) = {
+	0x00000079,
+};
+
+#define A_CommandCount	0x00000000
+static u32 A_CommandCount_used[] __attribute((unused)) = {
+	0x00000078,
+};
+
+#define A_DATA_IN_AFTER_DATA_IN	0x000005a0
+static u32 A_DATA_IN_AFTER_DATA_IN_used[] __attribute((unused)) = {
+	0x000000cb,
+};
+
+#define A_DEBUG_INTERRUPT	0x00003000
+static u32 A_DEBUG_INTERRUPT_used[] __attribute((unused)) = {
+};
+
+#define A_DEBUG_INTERRUPT1	0x00003001
+static u32 A_DEBUG_INTERRUPT1_used[] __attribute((unused)) = {
+};
+
+#define A_DEBUG_INTERRUPT2	0x00003002
+static u32 A_DEBUG_INTERRUPT2_used[] __attribute((unused)) = {
+};
+
+#define A_DEBUG_INTERRUPT3	0x00003003
+static u32 A_DEBUG_INTERRUPT3_used[] __attribute((unused)) = {
+};
+
+#define A_DEBUG_INTERRUPT4	0x00003004
+static u32 A_DEBUG_INTERRUPT4_used[] __attribute((unused)) = {
+};
+
+#define A_DEBUG_INTERRUPT5	0x00003005
+static u32 A_DEBUG_INTERRUPT5_used[] __attribute((unused)) = {
+};
+
+#define A_DEBUG_INTERRUPT6	0x00003006
+static u32 A_DEBUG_INTERRUPT6_used[] __attribute((unused)) = {
+};
+
+#define A_DISCONNECT	0x00000080
+static u32 A_DISCONNECT_used[] __attribute((unused)) = {
+};
+
+#define A_DISCONNECT_AFTER_CMD	0x00000380
+static u32 A_DISCONNECT_AFTER_CMD_used[] __attribute((unused)) = {
+	0x000000ab,
+};
+
+#define A_DISCONNECT_AFTER_DATA	0x00000580
+static u32 A_DISCONNECT_AFTER_DATA_used[] __attribute((unused)) = {
+	0x000000f5,
+	0x00000113,
+};
+
+#define A_DISCONNECT_DURING_DATA	0x00000780
+static u32 A_DISCONNECT_DURING_DATA_used[] __attribute((unused)) = {
+	0x000000eb,
+};
+
+#define A_DISCONNECT_MSG	0x00000004
+static u32 A_DISCONNECT_MSG_used[] __attribute((unused)) = {
+	0x0000008a,
+	0x00000094,
+	0x000000d8,
+	0x000000fc,
+};
+
+#define A_DURING_DATA_IN	0x00000700
+static u32 A_DURING_DATA_IN_used[] __attribute((unused)) = {
+};
+
+#define A_Device_ID	0x00000000
+static u32 A_Device_ID_used[] __attribute((unused)) = {
+	0x00000000,
+};
+
+#define A_EXTENDED_MSG	0x00000001
+static u32 A_EXTENDED_MSG_used[] __attribute((unused)) = {
+	0x0000002a,
+};
+
+#define A_FATAL	0x00002000
+static u32 A_FATAL_used[] __attribute((unused)) = {
+};
+
+#define A_FATAL_ILLEGAL_MSG_LENGTH	0x00002003
+static u32 A_FATAL_ILLEGAL_MSG_LENGTH_used[] __attribute((unused)) = {
+	0x00000043,
+};
+
+#define A_FATAL_NOT_MSG_IN_AFTER_SELECTION	0x00002002
+static u32 A_FATAL_NOT_MSG_IN_AFTER_SELECTION_used[] __attribute((unused)) = {
+	0x0000000d,
+};
+
+#define A_FATAL_SEND_MSG	0x00002001
+static u32 A_FATAL_SEND_MSG_used[] __attribute((unused)) = {
+	0x00000023,
+};
+
+#define A_FATAL_UNEXPECTED_RESELECTION_MSG	0x00002000
+static u32 A_FATAL_UNEXPECTED_RESELECTION_MSG_used[] __attribute((unused)) = {
+};
+
+#define A_GOOD_STATUS	0x00000001
+static u32 A_GOOD_STATUS_used[] __attribute((unused)) = {
+};
+
+#define A_GOOD_STATUS_AFTER_STATUS	0x00000401
+static u32 A_GOOD_STATUS_AFTER_STATUS_used[] __attribute((unused)) = {
+	0x00000129,
+};
+
+#define A_IDENTIFY_MSG	0x00000080
+static u32 A_IDENTIFY_MSG_used[] __attribute((unused)) = {
+};
+
+#define A_IDENTIFY_MSG_MASK	0x0000007f
+static u32 A_IDENTIFY_MSG_MASK_used[] __attribute((unused)) = {
+};
+
+#define A_MSG_IN	0x00000050
+static u32 A_MSG_IN_used[] __attribute((unused)) = {
+};
+
+#define A_MSG_IN_AFTER_CMD	0x00000350
+static u32 A_MSG_IN_AFTER_CMD_used[] __attribute((unused)) = {
+	0x0000009d,
+};
+
+#define A_MSG_IN_AFTER_DATA_IN	0x00000550
+static u32 A_MSG_IN_AFTER_DATA_IN_used[] __attribute((unused)) = {
+	0x000000e1,
+};
+
+#define A_MSG_IN_AFTER_DATA_OUT	0x00000650
+static u32 A_MSG_IN_AFTER_DATA_OUT_used[] __attribute((unused)) = {
+	0x00000105,
+};
+
+#define A_MSG_IN_AFTER_STATUS	0x00000440
+static u32 A_MSG_IN_AFTER_STATUS_used[] __attribute((unused)) = {
+	0x00000123,
+};
+
+#define A_MSG_IN_BEFORE_CMD	0x00000250
+static u32 A_MSG_IN_BEFORE_CMD_used[] __attribute((unused)) = {
+	0x000000b9,
+};
+
+#define A_MSG_IN_DURING_DATA_IN	0x00000750
+static u32 A_MSG_IN_DURING_DATA_IN_used[] __attribute((unused)) = {
+	0x00000091,
+};
+
+#define A_MSG_OUT	0x00000090
+static u32 A_MSG_OUT_used[] __attribute((unused)) = {
+};
+
+#define A_MSG_OUT_AFTER_DATA_IN	0x00000590
+static u32 A_MSG_OUT_AFTER_DATA_IN_used[] __attribute((unused)) = {
+	0x000000c7,
+};
+
+#define A_MessageCount	0x00000000
+static u32 A_MessageCount_used[] __attribute((unused)) = {
+	0x0000001e,
+};
+
+#define A_MessageLocation	0x00000000
+static u32 A_MessageLocation_used[] __attribute((unused)) = {
+	0x0000001f,
+};
+
+#define A_NOT_MSG_IN	0x00000030
+static u32 A_NOT_MSG_IN_used[] __attribute((unused)) = {
+};
+
+#define A_NOT_MSG_IN_AFTER_STATUS	0x00000430
+static u32 A_NOT_MSG_IN_AFTER_STATUS_used[] __attribute((unused)) = {
+	0x0000011b,
+};
+
+#define A_NOT_MSG_OUT	0x00000010
+static u32 A_NOT_MSG_OUT_used[] __attribute((unused)) = {
+};
+
+#define A_NOT_MSG_OUT_AFTER_SELECTION	0x00000110
+static u32 A_NOT_MSG_OUT_AFTER_SELECTION_used[] __attribute((unused)) = {
+	0x00000007,
+};
+
+#define A_PARITY_ERROR_MSG	0x00000009
+static u32 A_PARITY_ERROR_MSG_used[] __attribute((unused)) = {
+};
+
+#define A_REJECT_MSG	0x00000007
+static u32 A_REJECT_MSG_used[] __attribute((unused)) = {
+};
+
+#define A_REJECT_MSG_BEFORE_CMD	0x00000270
+static u32 A_REJECT_MSG_BEFORE_CMD_used[] __attribute((unused)) = {
+};
+
+#define A_REJECT_MSG_R	0x00000070
+static u32 A_REJECT_MSG_R_used[] __attribute((unused)) = {
+};
+
+#define A_RESELECTED_DURING_SELECTION	0x00001000
+static u32 A_RESELECTED_DURING_SELECTION_used[] __attribute((unused)) = {
+	0x0000000b,
+};
+
+#define A_RESELECTION_IDENTIFIED	0x00001003
+static u32 A_RESELECTION_IDENTIFIED_used[] __attribute((unused)) = {
+	0x00000011,
+	0x00000015,
+};
+
+#define A_RESTORE_DATA_PTRS_MSG	0x00000003
+static u32 A_RESTORE_DATA_PTRS_MSG_used[] __attribute((unused)) = {
+	0x0000008e,
+	0x00000098,
+	0x000000b4,
+	0x000000dc,
+	0x00000100,
+};
+
+#define A_ReceiveMsgAddress	0x00000000
+static u32 A_ReceiveMsgAddress_used[] __attribute((unused)) = {
+	0x0000000f,
+	0x00000013,
+	0x00000029,
+	0x00000031,
+	0x00000037,
+	0x00000047,
+	0x0000004d,
+	0x00000053,
+	0x00000059,
+	0x0000005f,
+	0x00000089,
+	0x00000093,
+	0x000000b1,
+	0x000000d7,
+	0x000000fb,
+	0x0000011d,
+};
+
+#define A_SAVE_DATA_PTRS_MSG	0x00000002
+static u32 A_SAVE_DATA_PTRS_MSG_used[] __attribute((unused)) = {
+	0x0000008c,
+	0x00000096,
+	0x000000b2,
+	0x000000da,
+	0x000000fe,
+};
+
+#define A_SDTR_MSG	0x00000001
+static u32 A_SDTR_MSG_used[] __attribute((unused)) = {
+};
+
+#define A_SDTR_MSG_AFTER_CMD	0x00000360
+static u32 A_SDTR_MSG_AFTER_CMD_used[] __attribute((unused)) = {
+};
+
+#define A_SDTR_MSG_BEFORE_CMD	0x00000260
+static u32 A_SDTR_MSG_BEFORE_CMD_used[] __attribute((unused)) = {
+};
+
+#define A_SDTR_MSG_R	0x00000060
+static u32 A_SDTR_MSG_R_used[] __attribute((unused)) = {
+};
+
+#define A_SGScriptStartAddress	0x00000000
+static u32 A_SGScriptStartAddress_used[] __attribute((unused)) = {
+	0x000000bf,
+	0x000000cf,
+};
+
+#define A_SIMPLE_TAG_MSG	0x00000020
+static u32 A_SIMPLE_TAG_MSG_used[] __attribute((unused)) = {
+};
+
+#define A_StatusAddress	0x00000000
+static u32 A_StatusAddress_used[] __attribute((unused)) = {
+	0x00000119,
+};
+
+#define A_TWO_BYTE_MSG	0x00000020
+static u32 A_TWO_BYTE_MSG_used[] __attribute((unused)) = {
+	0x0000002c,
+};
+
+#define A_TWO_BYTE_MSG_MASK	0x0000000f
+static u32 A_TWO_BYTE_MSG_MASK_used[] __attribute((unused)) = {
+	0x0000002c,
+};
+
+#define A_UNEXPECTED_MSG	0x00000040
+static u32 A_UNEXPECTED_MSG_used[] __attribute((unused)) = {
+};
+
+#define A_UNEXPECTED_MSG_BEFORE_CMD	0x00000240
+static u32 A_UNEXPECTED_MSG_BEFORE_CMD_used[] __attribute((unused)) = {
+};
+
+#define A_UNEXPECTED_PHASE	0x00000020
+static u32 A_UNEXPECTED_PHASE_used[] __attribute((unused)) = {
+};
+
+#define A_UNEXPECTED_PHASE_AFTER_CMD	0x00000320
+static u32 A_UNEXPECTED_PHASE_AFTER_CMD_used[] __attribute((unused)) = {
+	0x00000083,
+};
+
+#define A_UNEXPECTED_PHASE_AFTER_DATA_IN	0x00000520
+static u32 A_UNEXPECTED_PHASE_AFTER_DATA_IN_used[] __attribute((unused)) = {
+	0x000000c9,
+};
+
+#define A_UNEXPECTED_PHASE_AFTER_DATA_OUT	0x00000620
+static u32 A_UNEXPECTED_PHASE_AFTER_DATA_OUT_used[] __attribute((unused)) = {
+	0x000000d5,
+};
+
+#define A_UNEXPECTED_PHASE_BEFORE_CMD	0x00000220
+static u32 A_UNEXPECTED_PHASE_BEFORE_CMD_used[] __attribute((unused)) = {
+	0x00000077,
+};
+
+#define A_WDTR_MSG	0x00000003
+static u32 A_WDTR_MSG_used[] __attribute((unused)) = {
+};
+
+#define A_WDTR_MSG_AFTER_CMD	0x000003a0
+static u32 A_WDTR_MSG_AFTER_CMD_used[] __attribute((unused)) = {
+};
+
+#define A_WDTR_MSG_R	0x000000a0
+static u32 A_WDTR_MSG_R_used[] __attribute((unused)) = {
+};
+
+#define Ent_Disconnect1	0x000002a8
+#define Ent_Disconnect2	0x000002b0
+#define Ent_Disconnect3	0x000003a8
+#define Ent_Disconnect4	0x000003b0
+#define Ent_Disconnect5	0x000003d0
+#define Ent_Disconnect6	0x000003d8
+#define Ent_Disconnect7	0x00000448
+#define Ent_Disconnect8	0x00000450
+#define Ent_Finish1	0x000004a0
+#define Ent_Finish2	0x000004a8
+#define Ent_FinishCommandComplete	0x00000490
+#define Ent_GetReselectionData	0x00000038
+#define Ent_GetReselectionWithTag	0x00000048
+#define Ent_IgnoreMessage	0x00000188
+#define Ent_MsgInDuringData	0x00000218
+#define Ent_ReceiveMessage	0x000000a0
+#define Ent_SelectedAsTarget	0x00000058
+#define Ent_SendCommand	0x000001c8
+#define Ent_SendMessage	0x00000078
+#define Ent_SendMessagePhaseMismatch	0x00000090
+#define Ent_SendMessageWithATN	0x00000198
+#define Ent_StartUp	0x00000000
+static u32 LABELPATCHES[] __attribute((unused)) = {
+	0x00000001,
+	0x00000003,
+	0x00000005,
+	0x00000009,
+	0x00000027,
+	0x0000002b,
+	0x00000039,
+	0x0000003b,
+	0x0000003d,
+	0x0000003f,
+	0x00000041,
+	0x0000006b,
+	0x0000006d,
+	0x00000073,
+	0x00000075,
+	0x0000007b,
+	0x0000007d,
+	0x0000007f,
+	0x00000081,
+	0x00000087,
+	0x0000008b,
+	0x0000008d,
+	0x0000008f,
+	0x00000095,
+	0x00000097,
+	0x00000099,
+	0x0000009b,
+	0x000000a1,
+	0x000000a5,
+	0x000000af,
+	0x000000b3,
+	0x000000b5,
+	0x000000b7,
+	0x000000bd,
+	0x000000c1,
+	0x000000c3,
+	0x000000c5,
+	0x000000cd,
+	0x000000d1,
+	0x000000d3,
+	0x000000d9,
+	0x000000db,
+	0x000000dd,
+	0x000000df,
+	0x000000e5,
+	0x000000ef,
+	0x000000f9,
+	0x000000fd,
+	0x000000ff,
+	0x00000101,
+	0x00000103,
+	0x00000109,
+	0x0000010d,
+	0x00000117,
+	0x0000011f,
+	0x00000121,
+};
+
+static struct {
+	u32	offset;
+	void		*address;
+} EXTERNAL_PATCHES[] __attribute((unused)) = {
+};
+
+static u32 INSTRUCTIONS __attribute((unused))	= 149;
+static u32 PATCHES __attribute((unused))	= 56;
+static u32 EXTERNAL_PATCHES_LEN __attribute((unused))	= 0;
diff -Nru a/drivers/scsi/53c7xx_d.h_shipped b/drivers/scsi/53c7xx_d.h_shipped
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/scsi/53c7xx_d.h_shipped	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,2874 @@
+/* DO NOT EDIT - Generated automatically by script_asm.pl */
+static u32 SCRIPT[] = {
+/*
+
+
+
+
+
+; 53c710 driver.  Modified from Drew Eckhardts driver
+; for 53c810 by Richard Hirst [richard@sleepie.demon.co.uk]
+;
+; I have left the script for the 53c8xx family in here, as it is likely
+; to be useful to see what I changed when bug hunting.
+
+; NCR 53c810 driver, main script
+; Sponsored by 
+;	iX Multiuser Multitasking Magazine
+;	hm@ix.de
+;
+; Copyright 1993, 1994, 1995 Drew Eckhardt
+;      Visionary Computing 
+;      (Unix and Linux consulting and custom programming)
+;      drew@PoohSticks.ORG
+;      +1 (303) 786-7975
+;
+; TolerANT and SCSI SCRIPTS are registered trademarks of NCR Corporation.
+;
+; PRE-ALPHA
+;
+; For more information, please consult 
+;
+; NCR 53C810
+; PCI-SCSI I/O Processor
+; Data Manual
+;
+; NCR 53C710 
+; SCSI I/O Processor
+; Programmers Guide
+;
+; NCR Microelectronics
+; 1635 Aeroplaza Drive
+; Colorado Springs, CO 80916
+; 1+ (719) 578-3400
+;
+; Toll free literature number
+; +1 (800) 334-5454
+;
+; IMPORTANT : This code is self modifying due to the limitations of 
+;	the NCR53c7,8xx series chips.  Persons debugging this code with
+;	the remote debugger should take this into account, and NOT set
+;	breakpoints in modified instructions.
+;
+; Design:
+; The NCR53c7,8xx family of SCSI chips are busmasters with an onboard 
+; microcontroller using a simple instruction set.   
+;
+; So, to minimize the effects of interrupt latency, and to maximize 
+; throughput, this driver offloads the practical maximum amount 
+; of processing to the SCSI chip while still maintaining a common
+; structure.
+;
+; Where tradeoffs were needed between efficiency on the older
+; chips and the newer NCR53c800 series, the NCR53c800 series 
+; was chosen.
+;
+; While the NCR53c700 and NCR53c700-66 lacked the facilities to fully
+; automate SCSI transfers without host processor intervention, this 
+; isn't the case with the NCR53c710 and newer chips which allow 
+;
+; - reads and writes to the internal registers from within the SCSI
+; 	scripts, allowing the SCSI SCRIPTS(tm) code to save processor
+; 	state so that multiple threads of execution are possible, and also
+; 	provide an ALU for loop control, etc.
+; 
+; - table indirect addressing for some instructions. This allows 
+;	pointers to be located relative to the DSA ((Data Structure
+;	Address) register.
+;
+; These features make it possible to implement a mailbox style interface,
+; where the same piece of code is run to handle I/O for multiple threads
+; at once minimizing our need to relocate code.  Since the NCR53c700/
+; NCR53c800 series have a unique combination of features, making a 
+; a standard ingoing/outgoing mailbox system, costly, I've modified it.
+;
+; - Mailboxes are a mixture of code and data.  This lets us greatly
+; 	simplify the NCR53c810 code and do things that would otherwise
+;	not be possible.
+;
+; The saved data pointer is now implemented as follows :
+;
+; 	Control flow has been architected such that if control reaches
+;	munge_save_data_pointer, on a restore pointers message or 
+;	reconnection, a jump to the address formerly in the TEMP register
+;	will allow the SCSI command to resume execution.
+;
+
+;
+; Note : the DSA structures must be aligned on 32 bit boundaries,
+; since the source and destination of MOVE MEMORY instructions 
+; must share the same alignment and this is the alignment of the
+; NCR registers.
+;
+
+; For some systems (MVME166, for example) dmode is always the same, so don't
+; waste time writing it
+
+
+
+
+
+
+
+
+
+
+
+ABSOLUTE dsa_temp_lun = 0		; Patch to lun for current dsa
+ABSOLUTE dsa_temp_next = 0		; Patch to dsa next for current dsa
+ABSOLUTE dsa_temp_addr_next = 0		; Patch to address of dsa next address 
+					; 	for current dsa
+ABSOLUTE dsa_temp_sync = 0		; Patch to address of per-target
+					;	sync routine
+ABSOLUTE dsa_sscf_710 = 0		; Patch to address of per-target
+					;	sscf value (53c710)
+ABSOLUTE dsa_temp_target = 0		; Patch to id for current dsa
+ABSOLUTE dsa_temp_addr_saved_pointer = 0; Patch to address of per-command
+					; 	saved data pointer
+ABSOLUTE dsa_temp_addr_residual = 0	; Patch to address of per-command
+					;	current residual code
+ABSOLUTE dsa_temp_addr_saved_residual = 0; Patch to address of per-command
+					; saved residual code
+ABSOLUTE dsa_temp_addr_new_value = 0	; Address of value for JUMP operand
+ABSOLUTE dsa_temp_addr_array_value = 0 	; Address to copy to
+ABSOLUTE dsa_temp_addr_dsa_value = 0	; Address of this DSA value
+
+;
+; Once a device has initiated reselection, we need to compare it 
+; against the singly linked list of commands which have disconnected
+; and are pending reselection.  These commands are maintained in 
+; an unordered singly linked list of DSA structures, through the
+; DSA pointers at their 'centers' headed by the reconnect_dsa_head
+; pointer.
+; 
+; To avoid complications in removing commands from the list,
+; I minimize the amount of expensive (at eight operations per
+; addition @ 500-600ns each) pointer operations which must
+; be done in the NCR driver by precomputing them on the 
+; host processor during dsa structure generation.
+;
+; The fixed-up per DSA code knows how to recognize the nexus
+; associated with the corresponding SCSI command, and modifies
+; the source and destination pointers for the MOVE MEMORY 
+; instruction which is executed when reselected_ok is called
+; to remove the command from the list.  Similarly, DSA is 
+; loaded with the address of the next DSA structure and
+; reselected_check_next is called if a failure occurs.
+;
+; Perhaps more concisely, the net effect of the mess is 
+;
+; for (dsa = reconnect_dsa_head, dest = &reconnect_dsa_head, 
+;     src = NULL; dsa; dest = &dsa->next, dsa = dsa->next) {
+; 	src = &dsa->next;
+; 	if (target_id == dsa->id && target_lun == dsa->lun) {
+; 		*dest = *src;
+; 		break;
+;         }	
+; }
+;
+; if (!dsa)
+;           error (int_err_unexpected_reselect);
+; else  
+;     longjmp (dsa->jump_resume, 0);
+;
+; 	
+
+
+; Define DSA structure used for mailboxes
+ENTRY dsa_code_template
+dsa_code_template:
+ENTRY dsa_code_begin
+dsa_code_begin:
+; RGH: Don't care about TEMP and DSA here
+	
+	MOVE MEMORY 4, dsa_temp_addr_dsa_value, addr_scratch
+
+at 0x00000000 : */	0xc0000004,0x00000000,0x00000000,
+/*
+	
+
+	MOVE MEMORY 4, addr_scratch, saved_dsa
+
+at 0x00000003 : */	0xc0000004,0x00000000,0x00000000,
+/*
+	; We are about to go and select the device, so must set SSCF bits
+	MOVE MEMORY 4, dsa_sscf_710, addr_scratch
+
+at 0x00000006 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+	MOVE SCRATCH3 TO SFBR
+
+at 0x00000009 : */	0x72370000,0x00000000,
+/*
+
+
+
+	MOVE SFBR TO SBCL
+
+at 0x0000000b : */	0x6a0b0000,0x00000000,
+/*
+	MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x0000000d : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+	CALL select
+
+at 0x00000010 : */	0x88080000,0x000001f8,
+/*
+; Handle the phase mismatch which may have resulted from the 
+; MOVE FROM dsa_msgout if we returned here.  The CLEAR ATN 
+; may or may not be necessary, and we should update script_asm.pl
+; to handle multiple pieces.
+    CLEAR ATN
+
+at 0x00000012 : */	0x60000008,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x00000014 : */	0x60000040,0x00000000,
+/*
+
+; Replace second operand with address of JUMP instruction dest operand
+; in schedule table for this DSA.  Becomes dsa_jump_dest in 53c7,8xx.c.
+ENTRY dsa_code_fix_jump
+dsa_code_fix_jump:
+	MOVE MEMORY 4, NOP_insn, 0
+
+at 0x00000016 : */	0xc0000004,0x00000000,0x00000000,
+/*
+	JUMP select_done
+
+at 0x00000019 : */	0x80080000,0x00000230,
+/*
+
+; wrong_dsa loads the DSA register with the value of the dsa_next
+; field.
+;
+wrong_dsa:
+
+;                NOTE DSA is corrupt when we arrive here!
+
+;		Patch the MOVE MEMORY INSTRUCTION such that 
+;		the destination address is the address of the OLD 
+;		next pointer.
+;
+	MOVE MEMORY 4, dsa_temp_addr_next, reselected_ok_patch + 8
+
+at 0x0000001b : */	0xc0000004,0x00000000,0x000007ec,
+/*
+	
+;
+; 	Move the _contents_ of the next pointer into the DSA register as 
+;	the next I_T_L or I_T_L_Q tupple to check against the established
+;	nexus.
+;
+	MOVE MEMORY 4, dsa_temp_next, addr_scratch
+
+at 0x0000001e : */	0xc0000004,0x00000000,0x00000000,
+/*
+	
+
+	MOVE MEMORY 4, addr_scratch, saved_dsa
+
+at 0x00000021 : */	0xc0000004,0x00000000,0x00000000,
+/*
+	MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x00000024 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+	JUMP reselected_check_next
+
+at 0x00000027 : */	0x80080000,0x000006f0,
+/*
+
+ABSOLUTE dsa_save_data_pointer = 0
+ENTRY dsa_code_save_data_pointer
+dsa_code_save_data_pointer:
+
+	; When we get here, TEMP has been saved in jump_temp+4, DSA is corrupt
+	; We MUST return with DSA correct
+    	MOVE MEMORY 4, jump_temp+4, dsa_temp_addr_saved_pointer
+
+at 0x00000029 : */	0xc0000004,0x000009c8,0x00000000,
+/*
+; HARD CODED : 24 bytes needs to agree with 53c7,8xx.h
+    	MOVE MEMORY 24, dsa_temp_addr_residual, dsa_temp_addr_saved_residual
+
+at 0x0000002c : */	0xc0000018,0x00000000,0x00000000,
+/*
+        CLEAR ACK
+
+at 0x0000002f : */	0x60000040,0x00000000,
+/*
+
+
+
+	MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x00000031 : */	0xc0000004,0x00000000,0x00000000,
+/*
+	JUMP jump_temp
+
+at 0x00000034 : */	0x80080000,0x000009c4,
+/*
+
+ABSOLUTE dsa_restore_pointers = 0
+ENTRY dsa_code_restore_pointers
+dsa_code_restore_pointers:
+
+	; TEMP and DSA are corrupt when we get here, but who cares!
+    	MOVE MEMORY 4, dsa_temp_addr_saved_pointer, jump_temp + 4
+
+at 0x00000036 : */	0xc0000004,0x00000000,0x000009c8,
+/*
+; HARD CODED : 24 bytes needs to agree with 53c7,8xx.h
+    	MOVE MEMORY 24, dsa_temp_addr_saved_residual, dsa_temp_addr_residual
+
+at 0x00000039 : */	0xc0000018,0x00000000,0x00000000,
+/*
+        CLEAR ACK
+
+at 0x0000003c : */	0x60000040,0x00000000,
+/*
+	; Restore DSA, note we don't care about TEMP
+	MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x0000003e : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+	JUMP jump_temp
+
+at 0x00000041 : */	0x80080000,0x000009c4,
+/*
+
+
+ABSOLUTE dsa_check_reselect = 0
+; dsa_check_reselect determines whether or not the current target and
+; lun match the current DSA
+ENTRY dsa_code_check_reselect
+dsa_code_check_reselect:
+
+	
+	
+	MOVE LCRC TO SFBR		; LCRC has our ID and his ID bits set
+
+at 0x00000043 : */	0x72230000,0x00000000,
+/*
+	JUMP REL (wrong_dsa), IF NOT dsa_temp_target, AND MASK 0x80
+
+at 0x00000045 : */	0x80848000,0x00ffff50,
+/*
+
+
+
+
+
+;
+; Hack - move to scratch first, since SFBR is not writeable
+; 	via the CPU and hence a MOVE MEMORY instruction.
+;
+	
+	MOVE MEMORY 1, reselected_identify, addr_scratch
+
+at 0x00000047 : */	0xc0000001,0x00000000,0x00000000,
+/*
+	
+
+	; BIG ENDIAN ON MVME16x
+	MOVE SCRATCH3 TO SFBR
+
+at 0x0000004a : */	0x72370000,0x00000000,
+/*
+
+
+
+; FIXME : we need to accommodate bit fielded and binary here for '7xx/'8xx chips
+; Are you sure about that?  richard@sleepie.demon.co.uk
+	JUMP REL (wrong_dsa), IF NOT dsa_temp_lun, AND MASK 0xf8
+
+at 0x0000004c : */	0x8084f800,0x00ffff34,
+/*
+;		Patch the MOVE MEMORY INSTRUCTION such that
+;		the source address is the address of this dsa's
+;		next pointer.
+	MOVE MEMORY 4, dsa_temp_addr_next, reselected_ok_patch + 4
+
+at 0x0000004e : */	0xc0000004,0x00000000,0x000007e8,
+/*
+	CALL reselected_ok
+
+at 0x00000051 : */	0x88080000,0x00000798,
+/*
+
+;	Restore DSA following memory moves in reselected_ok
+;	dsa_temp_sync doesn't really care about DSA, but it has an
+;	optional debug INT so a valid DSA is a good idea.
+	MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x00000053 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+	CALL dsa_temp_sync	
+
+at 0x00000056 : */	0x88080000,0x00000000,
+/*
+; Release ACK on the IDENTIFY message _after_ we've set the synchronous 
+; transfer parameters! 
+	CLEAR ACK
+
+at 0x00000058 : */	0x60000040,0x00000000,
+/*
+; Implicitly restore pointers on reselection, so a RETURN
+; will transfer control back to the right spot.
+    	CALL REL (dsa_code_restore_pointers)
+
+at 0x0000005a : */	0x88880000,0x00ffff68,
+/*
+    	RETURN
+
+at 0x0000005c : */	0x90080000,0x00000000,
+/*
+ENTRY dsa_zero
+dsa_zero:
+ENTRY dsa_code_template_end
+dsa_code_template_end:
+
+; Perform sanity check for dsa_fields_start == dsa_code_template_end - 
+; dsa_zero, puke.
+
+ABSOLUTE dsa_fields_start =  0	; Sanity marker
+				; 	pad 48 bytes (fix this RSN)
+ABSOLUTE dsa_next = 48		; len 4 Next DSA
+ 				; del 4 Previous DSA address
+ABSOLUTE dsa_cmnd = 56		; len 4 Scsi_Cmnd * for this thread.
+ABSOLUTE dsa_select = 60	; len 4 Device ID, Period, Offset for 
+			 	;	table indirect select
+ABSOLUTE dsa_msgout = 64	; len 8 table indirect move parameter for 
+				;       select message
+ABSOLUTE dsa_cmdout = 72	; len 8 table indirect move parameter for 
+				;	command
+ABSOLUTE dsa_dataout = 80	; len 4 code pointer for dataout
+ABSOLUTE dsa_datain = 84	; len 4 code pointer for datain
+ABSOLUTE dsa_msgin = 88		; len 8 table indirect move for msgin
+ABSOLUTE dsa_status = 96 	; len 8 table indirect move for status byte
+ABSOLUTE dsa_msgout_other = 104	; len 8 table indirect for normal message out
+				; (Synchronous transfer negotiation, etc).
+ABSOLUTE dsa_end = 112
+
+ABSOLUTE schedule = 0 		; Array of JUMP dsa_begin or JUMP (next),
+				; terminated by a call to JUMP wait_reselect
+
+; Linked lists of DSA structures
+ABSOLUTE reconnect_dsa_head = 0	; Link list of DSAs which can reconnect
+ABSOLUTE addr_reconnect_dsa_head = 0 ; Address of variable containing
+				; address of reconnect_dsa_head
+
+; These select the source and destination of a MOVE MEMORY instruction
+ABSOLUTE dmode_memory_to_memory = 0x0
+ABSOLUTE dmode_memory_to_ncr = 0x0
+ABSOLUTE dmode_ncr_to_memory = 0x0
+
+ABSOLUTE addr_scratch = 0x0
+ABSOLUTE addr_temp = 0x0
+
+ABSOLUTE saved_dsa = 0x0
+ABSOLUTE emulfly = 0x0
+ABSOLUTE addr_dsa = 0x0
+
+
+
+; Interrupts - 
+; MSB indicates type
+; 0	handle error condition
+; 1 	handle message 
+; 2 	handle normal condition
+; 3	debugging interrupt
+; 4 	testing interrupt 
+; Next byte indicates specific error
+
+; XXX not yet implemented, I'm not sure if I want to - 
+; Next byte indicates the routine the error occurred in
+; The LSB indicates the specific place the error occurred
+ 
+ABSOLUTE int_err_unexpected_phase = 0x00000000	; Unexpected phase encountered
+ABSOLUTE int_err_selected = 0x00010000		; SELECTED (nee RESELECTED)
+ABSOLUTE int_err_unexpected_reselect = 0x00020000 
+ABSOLUTE int_err_check_condition = 0x00030000	
+ABSOLUTE int_err_no_phase = 0x00040000
+ABSOLUTE int_msg_wdtr = 0x01000000		; WDTR message received
+ABSOLUTE int_msg_sdtr = 0x01010000		; SDTR received
+ABSOLUTE int_msg_1 = 0x01020000			; single byte special message
+						; received
+
+ABSOLUTE int_norm_select_complete = 0x02000000	; Select complete, reprogram
+						; registers.
+ABSOLUTE int_norm_reselect_complete = 0x02010000	; Nexus established
+ABSOLUTE int_norm_command_complete = 0x02020000 ; Command complete
+ABSOLUTE int_norm_disconnected = 0x02030000	; Disconnected 
+ABSOLUTE int_norm_aborted =0x02040000		; Aborted *dsa
+ABSOLUTE int_norm_reset = 0x02050000		; Generated BUS reset.
+ABSOLUTE int_norm_emulateintfly = 0x02060000	; 53C710 Emulated intfly
+ABSOLUTE int_debug_break = 0x03000000		; Break point
+
+ABSOLUTE int_debug_panic = 0x030b0000		; Panic driver
+
+
+ABSOLUTE int_test_1 = 0x04000000		; Test 1 complete
+ABSOLUTE int_test_2 = 0x04010000		; Test 2 complete
+ABSOLUTE int_test_3 = 0x04020000		; Test 3 complete
+
+
+; These should start with 0x05000000, with low bits incrementing for 
+; each one.
+
+
+						
+ABSOLUTE NCR53c7xx_msg_abort = 0	; Pointer to abort message
+ABSOLUTE NCR53c7xx_msg_reject = 0       ; Pointer to reject message
+ABSOLUTE NCR53c7xx_zero	= 0		; long with zero in it, use for source
+ABSOLUTE NCR53c7xx_sink = 0		; long to dump worthless data in
+ABSOLUTE NOP_insn = 0			; NOP instruction
+
+; Pointer to message, potentially multi-byte
+ABSOLUTE msg_buf = 0
+
+; Pointer to holding area for reselection information
+ABSOLUTE reselected_identify = 0
+ABSOLUTE reselected_tag = 0
+
+; Request sense command pointer, it's a 6 byte command, should
+; be constant for all commands since we always want 16 bytes of 
+; sense and we don't need to change any fields as we did under 
+; SCSI-I when we actually cared about the LUN field.
+;EXTERNAL NCR53c7xx_sense		; Request sense command
+
+
+; dsa_schedule  
+; PURPOSE : after a DISCONNECT message has been received, and pointers
+;	saved, insert the current DSA structure at the head of the 
+; 	disconnected queue and fall through to the scheduler.
+;
+; CALLS : OK
+;
+; INPUTS : dsa - current DSA structure, reconnect_dsa_head - list
+;	of disconnected commands
+;
+; MODIFIES : SCRATCH, reconnect_dsa_head
+; 
+; EXITS : always passes control to schedule
+
+ENTRY dsa_schedule
+dsa_schedule:
+
+
+
+
+;
+; Calculate the address of the next pointer within the DSA 
+; structure of the command that is currently disconnecting
+;
+
+    ; Read what should be the current DSA from memory - actual DSA
+    ; register is probably corrupt
+    MOVE MEMORY 4, saved_dsa, addr_scratch
+
+at 0x0000005e : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+    MOVE SCRATCH0 + dsa_next TO SCRATCH0
+
+at 0x00000061 : */	0x7e343000,0x00000000,
+/*
+    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY
+
+at 0x00000063 : */	0x7f350000,0x00000000,
+/*
+    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY
+
+at 0x00000065 : */	0x7f360000,0x00000000,
+/*
+    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY
+
+at 0x00000067 : */	0x7f370000,0x00000000,
+/*
+
+; Point the next field of this DSA structure at the current disconnected 
+; list
+    
+    MOVE MEMORY 4, addr_scratch, dsa_schedule_insert + 8
+
+at 0x00000069 : */	0xc0000004,0x00000000,0x000001b8,
+/*
+    
+dsa_schedule_insert:
+    MOVE MEMORY 4, reconnect_dsa_head, 0 
+
+at 0x0000006c : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+; And update the head pointer.
+
+    ; Read what should be the current DSA from memory - actual DSA
+    ; register is probably corrupt
+    MOVE MEMORY 4, saved_dsa, addr_scratch
+
+at 0x0000006f : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+    
+    MOVE MEMORY 4, addr_scratch, reconnect_dsa_head
+
+at 0x00000072 : */	0xc0000004,0x00000000,0x00000000,
+/*
+    
+
+
+
+
+
+    CLEAR ACK
+
+at 0x00000075 : */	0x60000040,0x00000000,
+/*
+
+
+    ; Time to correct DSA following memory move
+    MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x00000077 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+    WAIT DISCONNECT
+
+at 0x0000007a : */	0x48000000,0x00000000,
+/*
+
+
+
+
+
+
+    JUMP schedule
+
+at 0x0000007c : */	0x80080000,0x00000000,
+/*
+
+
+;
+; select
+;
+; PURPOSE : establish a nexus for the SCSI command referenced by DSA.
+;	On success, the current DSA structure is removed from the issue 
+;	queue.  Usually, this is entered as a fall-through from schedule,
+;	although the contingent allegiance handling code will write
+;	the select entry address to the DSP to restart a command as a 
+;	REQUEST SENSE.  A message is sent (usually IDENTIFY, although
+;	additional SDTR or WDTR messages may be sent).  COMMAND OUT
+;	is handled.
+;
+; INPUTS : DSA - SCSI command, issue_dsa_head
+;
+; CALLS : NOT OK
+;
+; MODIFIES : SCRATCH, issue_dsa_head
+;
+; EXITS : on reselection or selection, go to select_failed
+;	otherwise, RETURN so control is passed back to 
+;	dsa_begin.
+;
+
+ENTRY select
+select:
+
+
+
+
+
+
+
+
+    CLEAR TARGET
+
+at 0x0000007e : */	0x60000200,0x00000000,
+/*
+
+; XXX
+;
+; In effect, SELECTION operations are backgrounded, with execution
+; continuing until code which waits for REQ or a fatal interrupt is 
+; encountered.
+;
+; So, for more performance, we could overlap the code which removes 
+; the command from the NCRs issue queue with the selection, but 
+; at this point I don't want to deal with the error recovery.
+;
+
+
+
+    ; Enable selection timer
+
+
+
+    MOVE CTEST7 & 0xef TO CTEST7
+
+at 0x00000080 : */	0x7c1bef00,0x00000000,
+/*
+
+
+    SELECT ATN FROM dsa_select, select_failed
+
+at 0x00000082 : */	0x4300003c,0x00000828,
+/*
+    JUMP select_msgout, WHEN MSG_OUT
+
+at 0x00000084 : */	0x860b0000,0x00000218,
+/*
+ENTRY select_msgout
+select_msgout:
+
+    ; Disable selection timer
+    MOVE CTEST7 | 0x10 TO CTEST7
+
+at 0x00000086 : */	0x7a1b1000,0x00000000,
+/*
+
+    MOVE FROM dsa_msgout, WHEN MSG_OUT
+
+at 0x00000088 : */	0x1e000000,0x00000040,
+/*
+
+
+
+
+
+
+
+
+
+
+   RETURN
+
+at 0x0000008a : */	0x90080000,0x00000000,
+/*
+
+; 
+; select_done
+; 
+; PURPOSE: continue on to normal data transfer; called as the exit 
+;	point from dsa_begin.
+;
+; INPUTS: dsa
+;
+; CALLS: OK
+;
+;
+
+select_done:
+
+; NOTE DSA is corrupt when we arrive here!
+    MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x0000008c : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+
+
+
+
+
+; After a successful selection, we should get either a CMD phase or 
+; some transfer request negotiation message.
+
+    JUMP cmdout, WHEN CMD
+
+at 0x0000008f : */	0x820b0000,0x0000025c,
+/*
+    INT int_err_unexpected_phase, WHEN NOT MSG_IN 
+
+at 0x00000091 : */	0x9f030000,0x00000000,
+/*
+
+select_msg_in:
+    CALL msg_in, WHEN MSG_IN
+
+at 0x00000093 : */	0x8f0b0000,0x0000041c,
+/*
+    JUMP select_msg_in, WHEN MSG_IN
+
+at 0x00000095 : */	0x870b0000,0x0000024c,
+/*
+
+cmdout:
+    INT int_err_unexpected_phase, WHEN NOT CMD
+
+at 0x00000097 : */	0x9a030000,0x00000000,
+/*
+
+
+
+ENTRY cmdout_cmdout
+cmdout_cmdout:
+
+    MOVE FROM dsa_cmdout, WHEN CMD
+
+at 0x00000099 : */	0x1a000000,0x00000048,
+/*
+
+
+
+
+;
+; data_transfer  
+; other_out
+; other_in
+; other_transfer
+;
+; PURPOSE : handle the main data transfer for a SCSI command in 
+;	several parts.  In the first part, data_transfer, DATA_IN
+;	and DATA_OUT phases are allowed, with the user provided
+;	code (usually dynamically generated based on the scatter/gather
+;	list associated with a SCSI command) called to handle these 
+;	phases.
+;
+;	After control has passed to one of the user provided 
+;	DATA_IN or DATA_OUT routines, back calls are made to 
+;	other_transfer_in or other_transfer_out to handle non-DATA IN
+;	and DATA OUT phases respectively, with the state of the active
+;	data pointer being preserved in TEMP.
+;
+;	On completion, the user code passes control to other_transfer
+;	which causes DATA_IN and DATA_OUT to result in unexpected_phase
+;	interrupts so that data overruns may be trapped.
+;
+; INPUTS : DSA - SCSI command
+;
+; CALLS : OK in data_transfer_start, not ok in other_out and other_in, ok in
+;	other_transfer
+;
+; MODIFIES : SCRATCH
+;
+; EXITS : if STATUS IN is detected, signifying command completion,
+;	the NCR jumps to command_complete.  If MSG IN occurs, a 
+;	CALL is made to msg_in.  Otherwise, other_transfer runs in 
+;	an infinite loop.
+;	
+
+ENTRY data_transfer
+data_transfer:
+    JUMP cmdout_cmdout, WHEN CMD
+
+at 0x0000009b : */	0x820b0000,0x00000264,
+/*
+    CALL msg_in, WHEN MSG_IN
+
+at 0x0000009d : */	0x8f0b0000,0x0000041c,
+/*
+    INT int_err_unexpected_phase, WHEN MSG_OUT
+
+at 0x0000009f : */	0x9e0b0000,0x00000000,
+/*
+    JUMP do_dataout, WHEN DATA_OUT
+
+at 0x000000a1 : */	0x800b0000,0x000002a4,
+/*
+    JUMP do_datain, WHEN DATA_IN
+
+at 0x000000a3 : */	0x810b0000,0x000002fc,
+/*
+    JUMP command_complete, WHEN STATUS
+
+at 0x000000a5 : */	0x830b0000,0x0000065c,
+/*
+    JUMP data_transfer
+
+at 0x000000a7 : */	0x80080000,0x0000026c,
+/*
+ENTRY end_data_transfer
+end_data_transfer:
+
+;
+; FIXME: On NCR53c700 and NCR53c700-66 chips, do_dataout/do_datain 
+; should be fixed up whenever the nexus changes so it can point to the 
+; correct routine for that command.
+;
+
+
+; Nasty jump to dsa->dataout
+do_dataout:
+
+    MOVE MEMORY 4, saved_dsa, addr_scratch
+
+at 0x000000a9 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+    MOVE SCRATCH0 + dsa_dataout TO SCRATCH0	
+
+at 0x000000ac : */	0x7e345000,0x00000000,
+/*
+    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY 
+
+at 0x000000ae : */	0x7f350000,0x00000000,
+/*
+    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY 
+
+at 0x000000b0 : */	0x7f360000,0x00000000,
+/*
+    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY 
+
+at 0x000000b2 : */	0x7f370000,0x00000000,
+/*
+    
+    MOVE MEMORY 4, addr_scratch, dataout_to_jump + 4
+
+at 0x000000b4 : */	0xc0000004,0x00000000,0x000002e0,
+/*
+    
+dataout_to_jump:
+    MOVE MEMORY 4, 0, dataout_jump + 4 
+
+at 0x000000b7 : */	0xc0000004,0x00000000,0x000002f8,
+/*
+
+    ; Time to correct DSA following memory move
+    MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x000000ba : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+dataout_jump:
+    JUMP 0
+
+at 0x000000bd : */	0x80080000,0x00000000,
+/*
+
+; Nasty jump to dsa->dsain
+do_datain:
+
+    MOVE MEMORY 4, saved_dsa, addr_scratch
+
+at 0x000000bf : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+    MOVE SCRATCH0 + dsa_datain TO SCRATCH0	
+
+at 0x000000c2 : */	0x7e345400,0x00000000,
+/*
+    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY 
+
+at 0x000000c4 : */	0x7f350000,0x00000000,
+/*
+    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY 
+
+at 0x000000c6 : */	0x7f360000,0x00000000,
+/*
+    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY 
+
+at 0x000000c8 : */	0x7f370000,0x00000000,
+/*
+    
+    MOVE MEMORY 4, addr_scratch, datain_to_jump + 4
+
+at 0x000000ca : */	0xc0000004,0x00000000,0x00000338,
+/*
+    
+ENTRY datain_to_jump
+datain_to_jump:
+    MOVE MEMORY 4, 0, datain_jump + 4
+
+at 0x000000cd : */	0xc0000004,0x00000000,0x00000350,
+/*
+
+    ; Time to correct DSA following memory move
+    MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x000000d0 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+
+datain_jump:
+    JUMP 0
+
+at 0x000000d3 : */	0x80080000,0x00000000,
+/*
+
+
+
+; Note that other_out and other_in loop until a non-data phase
+; is discovered, so we only execute return statements when we
+; can go on to the next data phase block move statement.
+
+ENTRY other_out
+other_out:
+
+
+
+    INT int_err_unexpected_phase, WHEN CMD
+
+at 0x000000d5 : */	0x9a0b0000,0x00000000,
+/*
+    JUMP msg_in_restart, WHEN MSG_IN 
+
+at 0x000000d7 : */	0x870b0000,0x000003fc,
+/*
+    INT int_err_unexpected_phase, WHEN MSG_OUT
+
+at 0x000000d9 : */	0x9e0b0000,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN DATA_IN
+
+at 0x000000db : */	0x990b0000,0x00000000,
+/*
+    JUMP command_complete, WHEN STATUS
+
+at 0x000000dd : */	0x830b0000,0x0000065c,
+/*
+    JUMP other_out, WHEN NOT DATA_OUT
+
+at 0x000000df : */	0x80030000,0x00000354,
+/*
+
+; TEMP should be OK, as we got here from a call in the user dataout code.
+
+    RETURN
+
+at 0x000000e1 : */	0x90080000,0x00000000,
+/*
+
+ENTRY other_in
+other_in:
+
+
+
+    INT int_err_unexpected_phase, WHEN CMD
+
+at 0x000000e3 : */	0x9a0b0000,0x00000000,
+/*
+    JUMP msg_in_restart, WHEN MSG_IN 
+
+at 0x000000e5 : */	0x870b0000,0x000003fc,
+/*
+    INT int_err_unexpected_phase, WHEN MSG_OUT
+
+at 0x000000e7 : */	0x9e0b0000,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN DATA_OUT
+
+at 0x000000e9 : */	0x980b0000,0x00000000,
+/*
+    JUMP command_complete, WHEN STATUS
+
+at 0x000000eb : */	0x830b0000,0x0000065c,
+/*
+    JUMP other_in, WHEN NOT DATA_IN
+
+at 0x000000ed : */	0x81030000,0x0000038c,
+/*
+
+; TEMP should be OK, as we got here from a call in the user datain code.
+
+    RETURN
+
+at 0x000000ef : */	0x90080000,0x00000000,
+/*
+
+
+ENTRY other_transfer
+other_transfer:
+    INT int_err_unexpected_phase, WHEN CMD
+
+at 0x000000f1 : */	0x9a0b0000,0x00000000,
+/*
+    CALL msg_in, WHEN MSG_IN
+
+at 0x000000f3 : */	0x8f0b0000,0x0000041c,
+/*
+    INT int_err_unexpected_phase, WHEN MSG_OUT
+
+at 0x000000f5 : */	0x9e0b0000,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN DATA_OUT
+
+at 0x000000f7 : */	0x980b0000,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN DATA_IN
+
+at 0x000000f9 : */	0x990b0000,0x00000000,
+/*
+    JUMP command_complete, WHEN STATUS
+
+at 0x000000fb : */	0x830b0000,0x0000065c,
+/*
+    JUMP other_transfer
+
+at 0x000000fd : */	0x80080000,0x000003c4,
+/*
+
+;
+; msg_in_restart
+; msg_in
+; munge_msg
+;
+; PURPOSE : process messages from a target.  msg_in is called when the 
+;	caller hasn't read the first byte of the message.  munge_message
+;	is called when the caller has read the first byte of the message,
+;	and left it in SFBR.  msg_in_restart is called when the caller 
+;	hasn't read the first byte of the message, and wishes RETURN
+;	to transfer control back to the address of the conditional
+;	CALL instruction rather than to the instruction after it.
+;
+;	Various int_* interrupts are generated when the host system
+;	needs to intervene, as is the case with SDTR, WDTR, and
+;	INITIATE RECOVERY messages.
+;
+;	When the host system handles one of these interrupts,
+;	it can respond by reentering at reject_message, 
+;	which rejects the message and returns control to
+;	the caller of msg_in or munge_msg, accept_message
+;	which clears ACK and returns control, or reply_message
+;	which sends the message pointed to by the DSA 
+;	msgout_other table indirect field.
+;
+;	DISCONNECT messages are handled by moving the command
+;	to the reconnect_dsa_queue.
+
+; NOTE: DSA should be valid when we get here - we cannot save both it
+;	and TEMP in this routine.
+
+;
+; INPUTS : DSA - SCSI COMMAND, SFBR - first byte of message (munge_msg
+;	only)
+;
+; CALLS : NO.  The TEMP register isn't backed up to allow nested calls.
+;
+; MODIFIES : SCRATCH, DSA on DISCONNECT
+;
+; EXITS : On receipt of SAVE DATA POINTER, RESTORE POINTERS,
+;	and normal return from message handlers running under
+;	Linux, control is returned to the caller.  Receipt
+;	of DISCONNECT messages pass control to dsa_schedule.
+;
+ENTRY msg_in_restart
+msg_in_restart:
+; XXX - hackish
+;
+; Since it's easier to debug changes to the statically 
+; compiled code, rather than the dynamically generated 
+; stuff, such as
+;
+; 	MOVE x, y, WHEN data_phase
+; 	CALL other_z, WHEN NOT data_phase
+; 	MOVE x, y, WHEN data_phase
+;
+; I'd like to have certain routines (notably the message handler)
+; restart on the conditional call rather than the next instruction.
+;
+; So, subtract 8 from the return address
+
+    MOVE TEMP0 + 0xf8 TO TEMP0
+
+at 0x000000ff : */	0x7e1cf800,0x00000000,
+/*
+    MOVE TEMP1 + 0xff TO TEMP1 WITH CARRY
+
+at 0x00000101 : */	0x7f1dff00,0x00000000,
+/*
+    MOVE TEMP2 + 0xff TO TEMP2 WITH CARRY
+
+at 0x00000103 : */	0x7f1eff00,0x00000000,
+/*
+    MOVE TEMP3 + 0xff TO TEMP3 WITH CARRY
+
+at 0x00000105 : */	0x7f1fff00,0x00000000,
+/*
+
+ENTRY msg_in
+msg_in:
+    MOVE 1, msg_buf, WHEN MSG_IN
+
+at 0x00000107 : */	0x0f000001,0x00000000,
+/*
+
+munge_msg:
+    JUMP munge_extended, IF 0x01		; EXTENDED MESSAGE
+
+at 0x00000109 : */	0x800c0001,0x00000574,
+/*
+    JUMP munge_2, IF 0x20, AND MASK 0xdf	; two byte message
+
+at 0x0000010b : */	0x800cdf20,0x00000464,
+/*
+;
+; XXX - I've seen a handful of broken SCSI devices which fail to issue
+; 	a SAVE POINTERS message before disconnecting in the middle of 
+; 	a transfer, assuming that the DATA POINTER will be implicitly 
+; 	restored.  
+;
+; Historically, I've often done an implicit save when the DISCONNECT
+; message is processed.  We may want to consider having the option of 
+; doing that here. 
+;
+    JUMP munge_save_data_pointer, IF 0x02	; SAVE DATA POINTER
+
+at 0x0000010d : */	0x800c0002,0x0000046c,
+/*
+    JUMP munge_restore_pointers, IF 0x03	; RESTORE POINTERS 
+
+at 0x0000010f : */	0x800c0003,0x00000518,
+/*
+    JUMP munge_disconnect, IF 0x04		; DISCONNECT
+
+at 0x00000111 : */	0x800c0004,0x0000056c,
+/*
+    INT int_msg_1, IF 0x07			; MESSAGE REJECT
+
+at 0x00000113 : */	0x980c0007,0x01020000,
+/*
+    INT int_msg_1, IF 0x0f			; INITIATE RECOVERY
+
+at 0x00000115 : */	0x980c000f,0x01020000,
+/*
+
+
+
+    JUMP reject_message
+
+at 0x00000117 : */	0x80080000,0x00000604,
+/*
+
+munge_2:
+    JUMP reject_message
+
+at 0x00000119 : */	0x80080000,0x00000604,
+/*
+;
+; The SCSI standard allows targets to recover from transient 
+; error conditions by backing up the data pointer with a 
+; RESTORE POINTERS message.  
+;	
+; So, we must save and restore the _residual_ code as well as 
+; the current instruction pointer.  Because of this messiness,
+; it is simpler to put dynamic code in the dsa for this and to
+; just do a simple jump down there. 
+;
+
+munge_save_data_pointer:
+
+    ; We have something in TEMP here, so first we must save that
+    MOVE TEMP0 TO SFBR
+
+at 0x0000011b : */	0x721c0000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH0
+
+at 0x0000011d : */	0x6a340000,0x00000000,
+/*
+    MOVE TEMP1 TO SFBR
+
+at 0x0000011f : */	0x721d0000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH1
+
+at 0x00000121 : */	0x6a350000,0x00000000,
+/*
+    MOVE TEMP2 TO SFBR
+
+at 0x00000123 : */	0x721e0000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH2
+
+at 0x00000125 : */	0x6a360000,0x00000000,
+/*
+    MOVE TEMP3 TO SFBR
+
+at 0x00000127 : */	0x721f0000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH3
+
+at 0x00000129 : */	0x6a370000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, jump_temp + 4
+
+at 0x0000012b : */	0xc0000004,0x00000000,0x000009c8,
+/*
+    ; Now restore DSA
+    MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x0000012e : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+    MOVE DSA0 + dsa_save_data_pointer TO SFBR
+
+at 0x00000131 : */	0x76100000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH0
+
+at 0x00000133 : */	0x6a340000,0x00000000,
+/*
+    MOVE DSA1 + 0xff TO SFBR WITH CARRY
+
+at 0x00000135 : */	0x7711ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH1
+
+at 0x00000137 : */	0x6a350000,0x00000000,
+/*
+    MOVE DSA2 + 0xff TO SFBR WITH CARRY 
+
+at 0x00000139 : */	0x7712ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH2
+
+at 0x0000013b : */	0x6a360000,0x00000000,
+/*
+    MOVE DSA3 + 0xff TO SFBR WITH CARRY
+
+at 0x0000013d : */	0x7713ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH3
+
+at 0x0000013f : */	0x6a370000,0x00000000,
+/*
+
+    
+    MOVE MEMORY 4, addr_scratch, jump_dsa_save + 4
+
+at 0x00000141 : */	0xc0000004,0x00000000,0x00000514,
+/*
+    
+jump_dsa_save:
+    JUMP 0
+
+at 0x00000144 : */	0x80080000,0x00000000,
+/*
+
+munge_restore_pointers:
+
+    ; The code at dsa_restore_pointers will RETURN, but we don't care
+    ; about TEMP here, as it will overwrite it anyway.
+
+    MOVE DSA0 + dsa_restore_pointers TO SFBR
+
+at 0x00000146 : */	0x76100000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH0
+
+at 0x00000148 : */	0x6a340000,0x00000000,
+/*
+    MOVE DSA1 + 0xff TO SFBR WITH CARRY
+
+at 0x0000014a : */	0x7711ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH1
+
+at 0x0000014c : */	0x6a350000,0x00000000,
+/*
+    MOVE DSA2 + 0xff TO SFBR WITH CARRY
+
+at 0x0000014e : */	0x7712ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH2
+
+at 0x00000150 : */	0x6a360000,0x00000000,
+/*
+    MOVE DSA3 + 0xff TO SFBR WITH CARRY
+
+at 0x00000152 : */	0x7713ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH3
+
+at 0x00000154 : */	0x6a370000,0x00000000,
+/*
+
+    
+    MOVE MEMORY 4, addr_scratch, jump_dsa_restore + 4
+
+at 0x00000156 : */	0xc0000004,0x00000000,0x00000568,
+/*
+    
+jump_dsa_restore:
+    JUMP 0
+
+at 0x00000159 : */	0x80080000,0x00000000,
+/*
+
+
+munge_disconnect:
+
+
+
+
+
+
+
+
+
+ 
+
+
+
+
+
+
+
+
+
+
+    JUMP dsa_schedule
+
+at 0x0000015b : */	0x80080000,0x00000178,
+/*
+
+
+
+
+
+munge_extended:
+    CLEAR ACK
+
+at 0x0000015d : */	0x60000040,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN NOT MSG_IN
+
+at 0x0000015f : */	0x9f030000,0x00000000,
+/*
+    MOVE 1, msg_buf + 1, WHEN MSG_IN
+
+at 0x00000161 : */	0x0f000001,0x00000001,
+/*
+    JUMP munge_extended_2, IF 0x02
+
+at 0x00000163 : */	0x800c0002,0x000005a4,
+/*
+    JUMP munge_extended_3, IF 0x03 
+
+at 0x00000165 : */	0x800c0003,0x000005d4,
+/*
+    JUMP reject_message
+
+at 0x00000167 : */	0x80080000,0x00000604,
+/*
+
+munge_extended_2:
+    CLEAR ACK
+
+at 0x00000169 : */	0x60000040,0x00000000,
+/*
+    MOVE 1, msg_buf + 2, WHEN MSG_IN
+
+at 0x0000016b : */	0x0f000001,0x00000002,
+/*
+    JUMP reject_message, IF NOT 0x02	; Must be WDTR
+
+at 0x0000016d : */	0x80040002,0x00000604,
+/*
+    CLEAR ACK
+
+at 0x0000016f : */	0x60000040,0x00000000,
+/*
+    MOVE 1, msg_buf + 3, WHEN MSG_IN
+
+at 0x00000171 : */	0x0f000001,0x00000003,
+/*
+    INT int_msg_wdtr
+
+at 0x00000173 : */	0x98080000,0x01000000,
+/*
+
+munge_extended_3:
+    CLEAR ACK
+
+at 0x00000175 : */	0x60000040,0x00000000,
+/*
+    MOVE 1, msg_buf + 2, WHEN MSG_IN
+
+at 0x00000177 : */	0x0f000001,0x00000002,
+/*
+    JUMP reject_message, IF NOT 0x01	; Must be SDTR
+
+at 0x00000179 : */	0x80040001,0x00000604,
+/*
+    CLEAR ACK
+
+at 0x0000017b : */	0x60000040,0x00000000,
+/*
+    MOVE 2, msg_buf + 3, WHEN MSG_IN
+
+at 0x0000017d : */	0x0f000002,0x00000003,
+/*
+    INT int_msg_sdtr
+
+at 0x0000017f : */	0x98080000,0x01010000,
+/*
+
+ENTRY reject_message
+reject_message:
+    SET ATN
+
+at 0x00000181 : */	0x58000008,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x00000183 : */	0x60000040,0x00000000,
+/*
+    MOVE 1, NCR53c7xx_msg_reject, WHEN MSG_OUT
+
+at 0x00000185 : */	0x0e000001,0x00000000,
+/*
+    RETURN
+
+at 0x00000187 : */	0x90080000,0x00000000,
+/*
+
+ENTRY accept_message
+accept_message:
+    CLEAR ATN
+
+at 0x00000189 : */	0x60000008,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x0000018b : */	0x60000040,0x00000000,
+/*
+    RETURN
+
+at 0x0000018d : */	0x90080000,0x00000000,
+/*
+
+ENTRY respond_message
+respond_message:
+    SET ATN
+
+at 0x0000018f : */	0x58000008,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x00000191 : */	0x60000040,0x00000000,
+/*
+    MOVE FROM dsa_msgout_other, WHEN MSG_OUT
+
+at 0x00000193 : */	0x1e000000,0x00000068,
+/*
+    RETURN
+
+at 0x00000195 : */	0x90080000,0x00000000,
+/*
+
+;
+; command_complete
+;
+; PURPOSE : handle command termination when STATUS IN is detected by reading
+;	a status byte followed by a command termination message. 
+;
+;	Normal termination results in an INTFLY instruction, and 
+;	the host system can pick out which command terminated by 
+;	examining the MESSAGE and STATUS buffers of all currently 
+;	executing commands;
+;
+;	Abnormal (CHECK_CONDITION) termination results in an
+;	int_err_check_condition interrupt so that a REQUEST SENSE
+;	command can be issued out-of-order so that no other command
+;	clears the contingent allegiance condition.
+;	
+;
+; INPUTS : DSA - command	
+;
+; CALLS : OK
+;
+; EXITS : On successful termination, control is passed to schedule.
+;	On abnormal termination, the user will usually modify the 
+;	DSA fields and corresponding buffers and return control
+;	to select.
+;
+
+ENTRY command_complete
+command_complete:
+    MOVE FROM dsa_status, WHEN STATUS
+
+at 0x00000197 : */	0x1b000000,0x00000060,
+/*
+
+    MOVE SFBR TO SCRATCH0		; Save status
+
+at 0x00000199 : */	0x6a340000,0x00000000,
+/*
+
+ENTRY command_complete_msgin
+command_complete_msgin:
+    MOVE FROM dsa_msgin, WHEN MSG_IN
+
+at 0x0000019b : */	0x1f000000,0x00000058,
+/*
+; Indicate that we should be expecting a disconnect
+
+
+
+    ; Above code cleared the Unexpected Disconnect bit, what do we do?
+
+    CLEAR ACK
+
+at 0x0000019d : */	0x60000040,0x00000000,
+/*
+
+    WAIT DISCONNECT
+
+at 0x0000019f : */	0x48000000,0x00000000,
+/*
+
+;
+; The SCSI specification states that when a UNIT ATTENTION condition
+; is pending, as indicated by a CHECK CONDITION status message,
+; the target shall revert to asynchronous transfers.  Since
+; synchronous transfers parameters are maintained on a per INITIATOR/TARGET 
+; basis, and returning control to our scheduler could work on a command
+; running on another lun on that target using the old parameters, we must
+; interrupt the host processor to get them changed, or change them ourselves.
+;
+; Once SCSI-II tagged queueing is implemented, things will be even more
+; hairy, since contingent allegiance conditions exist on a per-target/lun
+; basis, and issuing a new command with a different tag would clear it.
+; In these cases, we must interrupt the host processor to get a request 
+; added to the HEAD of the queue with the request sense command, or we
+; must automatically issue the request sense command.
+
+
+
+
+
+
+
+    INT int_norm_emulateintfly
+
+at 0x000001a1 : */	0x98080000,0x02060000,
+/*
+
+
+
+
+
+
+    ; Time to correct DSA following memory move
+    MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x000001a3 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+
+
+    JUMP schedule
+
+at 0x000001a6 : */	0x80080000,0x00000000,
+/*
+command_failed:
+    INT int_err_check_condition
+
+at 0x000001a8 : */	0x98080000,0x00030000,
+/*
+
+
+
+
+;
+; wait_reselect
+;
+; PURPOSE : This is essentially the idle routine, where control lands
+;	when there are no new processes to schedule.  wait_reselect
+;	waits for reselection, selection, and new commands.
+;
+;	When a successful reselection occurs, with the aid 
+;	of fixed up code in each DSA, wait_reselect walks the 
+;	reconnect_dsa_queue, asking each dsa if the target ID
+;	and LUN match its.
+;
+;	If a match is found, a call is made back to reselected_ok,
+;	which through the miracles of self modifying code, extracts
+;	the found DSA from the reconnect_dsa_queue and then 
+;	returns control to the DSAs thread of execution.
+;
+; INPUTS : NONE
+;
+; CALLS : OK
+;
+; MODIFIES : DSA,
+;
+; EXITS : On successful reselection, control is returned to the 
+;	DSA which called reselected_ok.  If the WAIT RESELECT
+;	was interrupted by a new commands arrival signaled by 
+;	SIG_P, control is passed to schedule.  If the NCR is 
+;	selected, the host system is interrupted with an 
+;	int_err_selected which is usually responded to by
+;	setting DSP to the target_abort address.
+
+ENTRY wait_reselect
+wait_reselect:
+
+
+
+
+
+
+    WAIT RESELECT wait_reselect_failed
+
+at 0x000001aa : */	0x50000000,0x00000800,
+/*
+
+reselected:
+
+
+
+    CLEAR TARGET
+
+at 0x000001ac : */	0x60000200,0x00000000,
+/*
+    
+    ; Read all data needed to reestablish the nexus - 
+    MOVE 1, reselected_identify, WHEN MSG_IN
+
+at 0x000001ae : */	0x0f000001,0x00000000,
+/*
+    ; We used to CLEAR ACK here.
+
+
+
+
+
+    ; Point DSA at the current head of the disconnected queue.
+    
+    MOVE MEMORY 4, reconnect_dsa_head, addr_scratch
+
+at 0x000001b0 : */	0xc0000004,0x00000000,0x00000000,
+/*
+    
+
+    MOVE MEMORY 4, addr_scratch, saved_dsa
+
+at 0x000001b3 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+
+
+    ; Fix the update-next pointer so that the reconnect_dsa_head
+    ; pointer is the one that will be updated if this DSA is a hit 
+    ; and we remove it from the queue.
+
+    MOVE MEMORY 4, addr_reconnect_dsa_head, reselected_ok_patch + 8
+
+at 0x000001b6 : */	0xc0000004,0x00000000,0x000007ec,
+/*
+
+    ; Time to correct DSA following memory move
+    MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x000001b9 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+
+ENTRY reselected_check_next
+reselected_check_next:
+
+
+
+    ; Check for a NULL pointer.
+    MOVE DSA0 TO SFBR
+
+at 0x000001bc : */	0x72100000,0x00000000,
+/*
+    JUMP reselected_not_end, IF NOT 0
+
+at 0x000001be : */	0x80040000,0x00000738,
+/*
+    MOVE DSA1 TO SFBR
+
+at 0x000001c0 : */	0x72110000,0x00000000,
+/*
+    JUMP reselected_not_end, IF NOT 0
+
+at 0x000001c2 : */	0x80040000,0x00000738,
+/*
+    MOVE DSA2 TO SFBR
+
+at 0x000001c4 : */	0x72120000,0x00000000,
+/*
+    JUMP reselected_not_end, IF NOT 0
+
+at 0x000001c6 : */	0x80040000,0x00000738,
+/*
+    MOVE DSA3 TO SFBR
+
+at 0x000001c8 : */	0x72130000,0x00000000,
+/*
+    JUMP reselected_not_end, IF NOT 0
+
+at 0x000001ca : */	0x80040000,0x00000738,
+/*
+    INT int_err_unexpected_reselect
+
+at 0x000001cc : */	0x98080000,0x00020000,
+/*
+
+reselected_not_end:
+    ;
+    ; XXX the ALU is only eight bits wide, and the assembler
+    ; wont do the dirt work for us.  As long as dsa_check_reselect
+    ; is negative, we need to sign extend with 1 bits to the full
+    ; 32 bit width of the address.
+    ;
+    ; A potential work around would be to have a known alignment 
+    ; of the DSA structure such that the base address plus 
+    ; dsa_check_reselect doesn't require carrying from bytes 
+    ; higher than the LSB.
+    ;
+
+    MOVE DSA0 TO SFBR
+
+at 0x000001ce : */	0x72100000,0x00000000,
+/*
+    MOVE SFBR + dsa_check_reselect TO SCRATCH0
+
+at 0x000001d0 : */	0x6e340000,0x00000000,
+/*
+    MOVE DSA1 TO SFBR
+
+at 0x000001d2 : */	0x72110000,0x00000000,
+/*
+    MOVE SFBR + 0xff TO SCRATCH1 WITH CARRY
+
+at 0x000001d4 : */	0x6f35ff00,0x00000000,
+/*
+    MOVE DSA2 TO SFBR
+
+at 0x000001d6 : */	0x72120000,0x00000000,
+/*
+    MOVE SFBR + 0xff TO SCRATCH2 WITH CARRY
+
+at 0x000001d8 : */	0x6f36ff00,0x00000000,
+/*
+    MOVE DSA3 TO SFBR
+
+at 0x000001da : */	0x72130000,0x00000000,
+/*
+    MOVE SFBR + 0xff TO SCRATCH3 WITH CARRY
+
+at 0x000001dc : */	0x6f37ff00,0x00000000,
+/*
+
+    
+    MOVE MEMORY 4, addr_scratch, reselected_check + 4
+
+at 0x000001de : */	0xc0000004,0x00000000,0x00000794,
+/*
+    
+
+    ; Time to correct DSA following memory move
+    MOVE MEMORY 4, saved_dsa, addr_dsa
+
+at 0x000001e1 : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+reselected_check:
+    JUMP 0
+
+at 0x000001e4 : */	0x80080000,0x00000000,
+/*
+
+
+;
+;
+
+; We have problems here - the memory move corrupts TEMP and DSA.  This
+; routine is called from DSA code, and patched from many places.  Scratch
+; is probably free when it is called.
+; We have to:
+;   copy temp to scratch, one byte at a time
+;   write scratch to patch a jump in place of the return
+;   do the move memory
+;   jump to the patched in return address
+; DSA is corrupt when we get here, and can be left corrupt
+
+ENTRY reselected_ok
+reselected_ok:
+    MOVE TEMP0 TO SFBR
+
+at 0x000001e6 : */	0x721c0000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH0
+
+at 0x000001e8 : */	0x6a340000,0x00000000,
+/*
+    MOVE TEMP1 TO SFBR
+
+at 0x000001ea : */	0x721d0000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH1
+
+at 0x000001ec : */	0x6a350000,0x00000000,
+/*
+    MOVE TEMP2 TO SFBR
+
+at 0x000001ee : */	0x721e0000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH2
+
+at 0x000001f0 : */	0x6a360000,0x00000000,
+/*
+    MOVE TEMP3 TO SFBR
+
+at 0x000001f2 : */	0x721f0000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH3
+
+at 0x000001f4 : */	0x6a370000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, reselected_ok_jump + 4
+
+at 0x000001f6 : */	0xc0000004,0x00000000,0x000007f4,
+/*
+reselected_ok_patch:
+    MOVE MEMORY 4, 0, 0
+
+at 0x000001f9 : */	0xc0000004,0x00000000,0x00000000,
+/*
+reselected_ok_jump:
+    JUMP 0
+
+at 0x000001fc : */	0x80080000,0x00000000,
+/*
+
+
+
+
+
+selected:
+    INT int_err_selected;
+
+at 0x000001fe : */	0x98080000,0x00010000,
+/*
+
+;
+; A select or reselect failure can be caused by one of two conditions : 
+; 1.  SIG_P was set.  This will be the case if the user has written
+;	a new value to a previously NULL head of the issue queue.
+;
+; 2.  The NCR53c810 was selected or reselected by another device.
+;
+; 3.  The bus was already busy since we were selected or reselected
+;	before starting the command.
+
+wait_reselect_failed:
+
+
+
+; Check selected bit.  
+
+    ; Must work out how to tell if we are selected....
+
+
+
+
+; Reading CTEST2 clears the SIG_P bit in the ISTAT register.
+    MOVE CTEST2 & 0x40 TO SFBR	
+
+at 0x00000200 : */	0x74164000,0x00000000,
+/*
+    JUMP schedule, IF 0x40
+
+at 0x00000202 : */	0x800c0040,0x00000000,
+/*
+; Check connected bit.  
+; FIXME: this needs to change if we support target mode
+    MOVE ISTAT & 0x08 TO SFBR
+
+at 0x00000204 : */	0x74210800,0x00000000,
+/*
+    JUMP reselected, IF 0x08
+
+at 0x00000206 : */	0x800c0008,0x000006b0,
+/*
+; FIXME : Something bogus happened, and we shouldn't fail silently.
+
+
+
+    INT int_debug_panic
+
+at 0x00000208 : */	0x98080000,0x030b0000,
+/*
+
+
+
+select_failed:
+
+    ; Disable selection timer
+    MOVE CTEST7 | 0x10 TO CTEST7
+
+at 0x0000020a : */	0x7a1b1000,0x00000000,
+/*
+
+
+
+
+; Otherwise, mask the selected and reselected bits off SIST0
+
+    ; Let's assume we don't get selected for now
+    MOVE SSTAT0 & 0x10 TO SFBR
+
+at 0x0000020c : */	0x740d1000,0x00000000,
+/*
+
+
+
+
+    JUMP reselected, IF 0x10 
+
+at 0x0000020e : */	0x800c0010,0x000006b0,
+/*
+; If SIGP is set, the user just gave us another command, and
+; we should restart or return to the scheduler.
+; Reading CTEST2 clears the SIG_P bit in the ISTAT register.
+    MOVE CTEST2 & 0x40 TO SFBR	
+
+at 0x00000210 : */	0x74164000,0x00000000,
+/*
+    JUMP select, IF 0x40
+
+at 0x00000212 : */	0x800c0040,0x000001f8,
+/*
+; Check connected bit.  
+; FIXME: this needs to change if we support target mode
+; FIXME: is this really necessary? 
+    MOVE ISTAT & 0x08 TO SFBR
+
+at 0x00000214 : */	0x74210800,0x00000000,
+/*
+    JUMP reselected, IF 0x08
+
+at 0x00000216 : */	0x800c0008,0x000006b0,
+/*
+; FIXME : Something bogus happened, and we shouldn't fail silently.
+
+
+
+    INT int_debug_panic
+
+at 0x00000218 : */	0x98080000,0x030b0000,
+/*
+
+
+;
+; test_1
+; test_2
+;
+; PURPOSE : run some verification tests on the NCR.  test_1
+;	copies test_src to test_dest and interrupts the host
+;	processor, testing for cache coherency and interrupt
+; 	problems in the processes.
+;
+;	test_2 runs a command with offsets relative to the 
+;	DSA on entry, and is useful for miscellaneous experimentation.
+;
+
+; Verify that interrupts are working correctly and that we don't 
+; have a cache invalidation problem.
+
+ABSOLUTE test_src = 0, test_dest = 0
+ENTRY test_1
+test_1:
+    MOVE MEMORY 4, test_src, test_dest
+
+at 0x0000021a : */	0xc0000004,0x00000000,0x00000000,
+/*
+    INT int_test_1
+
+at 0x0000021d : */	0x98080000,0x04000000,
+/*
+
+;
+; Run arbitrary commands, with test code establishing a DSA
+;
+ 
+ENTRY test_2
+test_2:
+    CLEAR TARGET
+
+at 0x0000021f : */	0x60000200,0x00000000,
+/*
+
+    ; Enable selection timer
+
+
+
+    MOVE CTEST7 & 0xef TO CTEST7
+
+at 0x00000221 : */	0x7c1bef00,0x00000000,
+/*
+
+
+    SELECT ATN FROM 0, test_2_fail
+
+at 0x00000223 : */	0x43000000,0x000008dc,
+/*
+    JUMP test_2_msgout, WHEN MSG_OUT
+
+at 0x00000225 : */	0x860b0000,0x0000089c,
+/*
+ENTRY test_2_msgout
+test_2_msgout:
+
+    ; Disable selection timer
+    MOVE CTEST7 | 0x10 TO CTEST7
+
+at 0x00000227 : */	0x7a1b1000,0x00000000,
+/*
+
+    MOVE FROM 8, WHEN MSG_OUT
+
+at 0x00000229 : */	0x1e000000,0x00000008,
+/*
+    MOVE FROM 16, WHEN CMD 
+
+at 0x0000022b : */	0x1a000000,0x00000010,
+/*
+    MOVE FROM 24, WHEN DATA_IN
+
+at 0x0000022d : */	0x19000000,0x00000018,
+/*
+    MOVE FROM 32, WHEN STATUS
+
+at 0x0000022f : */	0x1b000000,0x00000020,
+/*
+    MOVE FROM 40, WHEN MSG_IN
+
+at 0x00000231 : */	0x1f000000,0x00000028,
+/*
+
+
+
+    CLEAR ACK
+
+at 0x00000233 : */	0x60000040,0x00000000,
+/*
+    WAIT DISCONNECT
+
+at 0x00000235 : */	0x48000000,0x00000000,
+/*
+test_2_fail:
+
+    ; Disable selection timer
+    MOVE CTEST7 | 0x10 TO CTEST7
+
+at 0x00000237 : */	0x7a1b1000,0x00000000,
+/*
+
+    INT int_test_2
+
+at 0x00000239 : */	0x98080000,0x04010000,
+/*
+
+ENTRY debug_break
+debug_break:
+    INT int_debug_break
+
+at 0x0000023b : */	0x98080000,0x03000000,
+/*
+
+;
+; initiator_abort
+; target_abort
+;
+; PURPOSE : Abort the currently established nexus from with initiator
+;	or target mode.
+;
+;  
+
+ENTRY target_abort
+target_abort:
+    SET TARGET
+
+at 0x0000023d : */	0x58000200,0x00000000,
+/*
+    DISCONNECT
+
+at 0x0000023f : */	0x48000000,0x00000000,
+/*
+    CLEAR TARGET
+
+at 0x00000241 : */	0x60000200,0x00000000,
+/*
+    JUMP schedule
+
+at 0x00000243 : */	0x80080000,0x00000000,
+/*
+    
+ENTRY initiator_abort
+initiator_abort:
+    SET ATN
+
+at 0x00000245 : */	0x58000008,0x00000000,
+/*
+;
+; The SCSI-I specification says that targets may go into MSG out at 
+; their leisure upon receipt of the ATN single.  On all versions of the 
+; specification, we can't change phases until REQ transitions true->false, 
+; so we need to sink/source one byte of data to allow the transition.
+;
+; For the sake of safety, we'll only source one byte of data in all 
+; cases, but to accommodate the SCSI-I dain bramage, we'll sink an  
+; arbitrary number of bytes.
+    JUMP spew_cmd, WHEN CMD
+
+at 0x00000247 : */	0x820b0000,0x0000094c,
+/*
+    JUMP eat_msgin, WHEN MSG_IN
+
+at 0x00000249 : */	0x870b0000,0x0000095c,
+/*
+    JUMP eat_datain, WHEN DATA_IN
+
+at 0x0000024b : */	0x810b0000,0x0000098c,
+/*
+    JUMP eat_status, WHEN STATUS
+
+at 0x0000024d : */	0x830b0000,0x00000974,
+/*
+    JUMP spew_dataout, WHEN DATA_OUT
+
+at 0x0000024f : */	0x800b0000,0x000009a4,
+/*
+    JUMP sated
+
+at 0x00000251 : */	0x80080000,0x000009ac,
+/*
+spew_cmd:
+    MOVE 1, NCR53c7xx_zero, WHEN CMD
+
+at 0x00000253 : */	0x0a000001,0x00000000,
+/*
+    JUMP sated
+
+at 0x00000255 : */	0x80080000,0x000009ac,
+/*
+eat_msgin:
+    MOVE 1, NCR53c7xx_sink, WHEN MSG_IN
+
+at 0x00000257 : */	0x0f000001,0x00000000,
+/*
+    JUMP eat_msgin, WHEN MSG_IN
+
+at 0x00000259 : */	0x870b0000,0x0000095c,
+/*
+    JUMP sated
+
+at 0x0000025b : */	0x80080000,0x000009ac,
+/*
+eat_status:
+    MOVE 1, NCR53c7xx_sink, WHEN STATUS
+
+at 0x0000025d : */	0x0b000001,0x00000000,
+/*
+    JUMP eat_status, WHEN STATUS
+
+at 0x0000025f : */	0x830b0000,0x00000974,
+/*
+    JUMP sated
+
+at 0x00000261 : */	0x80080000,0x000009ac,
+/*
+eat_datain:
+    MOVE 1, NCR53c7xx_sink, WHEN DATA_IN
+
+at 0x00000263 : */	0x09000001,0x00000000,
+/*
+    JUMP eat_datain, WHEN DATA_IN
+
+at 0x00000265 : */	0x810b0000,0x0000098c,
+/*
+    JUMP sated
+
+at 0x00000267 : */	0x80080000,0x000009ac,
+/*
+spew_dataout:
+    MOVE 1, NCR53c7xx_zero, WHEN DATA_OUT
+
+at 0x00000269 : */	0x08000001,0x00000000,
+/*
+sated:
+
+
+
+    MOVE 1, NCR53c7xx_msg_abort, WHEN MSG_OUT
+
+at 0x0000026b : */	0x0e000001,0x00000000,
+/*
+    WAIT DISCONNECT
+
+at 0x0000026d : */	0x48000000,0x00000000,
+/*
+    INT int_norm_aborted
+
+at 0x0000026f : */	0x98080000,0x02040000,
+/*
+
+
+ 
+
+; Little patched jump, used to overcome problems with TEMP getting
+; corrupted on memory moves.
+
+jump_temp:
+    JUMP 0
+
+at 0x00000271 : */	0x80080000,0x00000000,
+};
+
+#define A_NCR53c7xx_msg_abort	0x00000000
+static u32 A_NCR53c7xx_msg_abort_used[] __attribute((unused)) = {
+	0x0000026c,
+};
+
+#define A_NCR53c7xx_msg_reject	0x00000000
+static u32 A_NCR53c7xx_msg_reject_used[] __attribute((unused)) = {
+	0x00000186,
+};
+
+#define A_NCR53c7xx_sink	0x00000000
+static u32 A_NCR53c7xx_sink_used[] __attribute((unused)) = {
+	0x00000258,
+	0x0000025e,
+	0x00000264,
+};
+
+#define A_NCR53c7xx_zero	0x00000000
+static u32 A_NCR53c7xx_zero_used[] __attribute((unused)) = {
+	0x00000254,
+	0x0000026a,
+};
+
+#define A_NOP_insn	0x00000000
+static u32 A_NOP_insn_used[] __attribute((unused)) = {
+	0x00000017,
+};
+
+#define A_addr_dsa	0x00000000
+static u32 A_addr_dsa_used[] __attribute((unused)) = {
+	0x0000000f,
+	0x00000026,
+	0x00000033,
+	0x00000040,
+	0x00000055,
+	0x00000079,
+	0x0000008e,
+	0x000000bc,
+	0x000000d2,
+	0x00000130,
+	0x000001a5,
+	0x000001bb,
+	0x000001e3,
+};
+
+#define A_addr_reconnect_dsa_head	0x00000000
+static u32 A_addr_reconnect_dsa_head_used[] __attribute((unused)) = {
+	0x000001b7,
+};
+
+#define A_addr_scratch	0x00000000
+static u32 A_addr_scratch_used[] __attribute((unused)) = {
+	0x00000002,
+	0x00000004,
+	0x00000008,
+	0x00000020,
+	0x00000022,
+	0x00000049,
+	0x00000060,
+	0x0000006a,
+	0x00000071,
+	0x00000073,
+	0x000000ab,
+	0x000000b5,
+	0x000000c1,
+	0x000000cb,
+	0x0000012c,
+	0x00000142,
+	0x00000157,
+	0x000001b2,
+	0x000001b4,
+	0x000001df,
+	0x000001f7,
+};
+
+#define A_addr_temp	0x00000000
+static u32 A_addr_temp_used[] __attribute((unused)) = {
+};
+
+#define A_dmode_memory_to_memory	0x00000000
+static u32 A_dmode_memory_to_memory_used[] __attribute((unused)) = {
+};
+
+#define A_dmode_memory_to_ncr	0x00000000
+static u32 A_dmode_memory_to_ncr_used[] __attribute((unused)) = {
+};
+
+#define A_dmode_ncr_to_memory	0x00000000
+static u32 A_dmode_ncr_to_memory_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_check_reselect	0x00000000
+static u32 A_dsa_check_reselect_used[] __attribute((unused)) = {
+	0x000001d0,
+};
+
+#define A_dsa_cmdout	0x00000048
+static u32 A_dsa_cmdout_used[] __attribute((unused)) = {
+	0x0000009a,
+};
+
+#define A_dsa_cmnd	0x00000038
+static u32 A_dsa_cmnd_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_datain	0x00000054
+static u32 A_dsa_datain_used[] __attribute((unused)) = {
+	0x000000c2,
+};
+
+#define A_dsa_dataout	0x00000050
+static u32 A_dsa_dataout_used[] __attribute((unused)) = {
+	0x000000ac,
+};
+
+#define A_dsa_end	0x00000070
+static u32 A_dsa_end_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_fields_start	0x00000000
+static u32 A_dsa_fields_start_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_msgin	0x00000058
+static u32 A_dsa_msgin_used[] __attribute((unused)) = {
+	0x0000019c,
+};
+
+#define A_dsa_msgout	0x00000040
+static u32 A_dsa_msgout_used[] __attribute((unused)) = {
+	0x00000089,
+};
+
+#define A_dsa_msgout_other	0x00000068
+static u32 A_dsa_msgout_other_used[] __attribute((unused)) = {
+	0x00000194,
+};
+
+#define A_dsa_next	0x00000030
+static u32 A_dsa_next_used[] __attribute((unused)) = {
+	0x00000061,
+};
+
+#define A_dsa_restore_pointers	0x00000000
+static u32 A_dsa_restore_pointers_used[] __attribute((unused)) = {
+	0x00000146,
+};
+
+#define A_dsa_save_data_pointer	0x00000000
+static u32 A_dsa_save_data_pointer_used[] __attribute((unused)) = {
+	0x00000131,
+};
+
+#define A_dsa_select	0x0000003c
+static u32 A_dsa_select_used[] __attribute((unused)) = {
+	0x00000082,
+};
+
+#define A_dsa_sscf_710	0x00000000
+static u32 A_dsa_sscf_710_used[] __attribute((unused)) = {
+	0x00000007,
+};
+
+#define A_dsa_status	0x00000060
+static u32 A_dsa_status_used[] __attribute((unused)) = {
+	0x00000198,
+};
+
+#define A_dsa_temp_addr_array_value	0x00000000
+static u32 A_dsa_temp_addr_array_value_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_temp_addr_dsa_value	0x00000000
+static u32 A_dsa_temp_addr_dsa_value_used[] __attribute((unused)) = {
+	0x00000001,
+};
+
+#define A_dsa_temp_addr_new_value	0x00000000
+static u32 A_dsa_temp_addr_new_value_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_temp_addr_next	0x00000000
+static u32 A_dsa_temp_addr_next_used[] __attribute((unused)) = {
+	0x0000001c,
+	0x0000004f,
+};
+
+#define A_dsa_temp_addr_residual	0x00000000
+static u32 A_dsa_temp_addr_residual_used[] __attribute((unused)) = {
+	0x0000002d,
+	0x0000003b,
+};
+
+#define A_dsa_temp_addr_saved_pointer	0x00000000
+static u32 A_dsa_temp_addr_saved_pointer_used[] __attribute((unused)) = {
+	0x0000002b,
+	0x00000037,
+};
+
+#define A_dsa_temp_addr_saved_residual	0x00000000
+static u32 A_dsa_temp_addr_saved_residual_used[] __attribute((unused)) = {
+	0x0000002e,
+	0x0000003a,
+};
+
+#define A_dsa_temp_lun	0x00000000
+static u32 A_dsa_temp_lun_used[] __attribute((unused)) = {
+	0x0000004c,
+};
+
+#define A_dsa_temp_next	0x00000000
+static u32 A_dsa_temp_next_used[] __attribute((unused)) = {
+	0x0000001f,
+};
+
+#define A_dsa_temp_sync	0x00000000
+static u32 A_dsa_temp_sync_used[] __attribute((unused)) = {
+	0x00000057,
+};
+
+#define A_dsa_temp_target	0x00000000
+static u32 A_dsa_temp_target_used[] __attribute((unused)) = {
+	0x00000045,
+};
+
+#define A_emulfly	0x00000000
+static u32 A_emulfly_used[] __attribute((unused)) = {
+};
+
+#define A_int_debug_break	0x03000000
+static u32 A_int_debug_break_used[] __attribute((unused)) = {
+	0x0000023c,
+};
+
+#define A_int_debug_panic	0x030b0000
+static u32 A_int_debug_panic_used[] __attribute((unused)) = {
+	0x00000209,
+	0x00000219,
+};
+
+#define A_int_err_check_condition	0x00030000
+static u32 A_int_err_check_condition_used[] __attribute((unused)) = {
+	0x000001a9,
+};
+
+#define A_int_err_no_phase	0x00040000
+static u32 A_int_err_no_phase_used[] __attribute((unused)) = {
+};
+
+#define A_int_err_selected	0x00010000
+static u32 A_int_err_selected_used[] __attribute((unused)) = {
+	0x000001ff,
+};
+
+#define A_int_err_unexpected_phase	0x00000000
+static u32 A_int_err_unexpected_phase_used[] __attribute((unused)) = {
+	0x00000092,
+	0x00000098,
+	0x000000a0,
+	0x000000d6,
+	0x000000da,
+	0x000000dc,
+	0x000000e4,
+	0x000000e8,
+	0x000000ea,
+	0x000000f2,
+	0x000000f6,
+	0x000000f8,
+	0x000000fa,
+	0x00000160,
+};
+
+#define A_int_err_unexpected_reselect	0x00020000
+static u32 A_int_err_unexpected_reselect_used[] __attribute((unused)) = {
+	0x000001cd,
+};
+
+#define A_int_msg_1	0x01020000
+static u32 A_int_msg_1_used[] __attribute((unused)) = {
+	0x00000114,
+	0x00000116,
+};
+
+#define A_int_msg_sdtr	0x01010000
+static u32 A_int_msg_sdtr_used[] __attribute((unused)) = {
+	0x00000180,
+};
+
+#define A_int_msg_wdtr	0x01000000
+static u32 A_int_msg_wdtr_used[] __attribute((unused)) = {
+	0x00000174,
+};
+
+#define A_int_norm_aborted	0x02040000
+static u32 A_int_norm_aborted_used[] __attribute((unused)) = {
+	0x00000270,
+};
+
+#define A_int_norm_command_complete	0x02020000
+static u32 A_int_norm_command_complete_used[] __attribute((unused)) = {
+};
+
+#define A_int_norm_disconnected	0x02030000
+static u32 A_int_norm_disconnected_used[] __attribute((unused)) = {
+};
+
+#define A_int_norm_emulateintfly	0x02060000
+static u32 A_int_norm_emulateintfly_used[] __attribute((unused)) = {
+	0x000001a2,
+};
+
+#define A_int_norm_reselect_complete	0x02010000
+static u32 A_int_norm_reselect_complete_used[] __attribute((unused)) = {
+};
+
+#define A_int_norm_reset	0x02050000
+static u32 A_int_norm_reset_used[] __attribute((unused)) = {
+};
+
+#define A_int_norm_select_complete	0x02000000
+static u32 A_int_norm_select_complete_used[] __attribute((unused)) = {
+};
+
+#define A_int_test_1	0x04000000
+static u32 A_int_test_1_used[] __attribute((unused)) = {
+	0x0000021e,
+};
+
+#define A_int_test_2	0x04010000
+static u32 A_int_test_2_used[] __attribute((unused)) = {
+	0x0000023a,
+};
+
+#define A_int_test_3	0x04020000
+static u32 A_int_test_3_used[] __attribute((unused)) = {
+};
+
+#define A_msg_buf	0x00000000
+static u32 A_msg_buf_used[] __attribute((unused)) = {
+	0x00000108,
+	0x00000162,
+	0x0000016c,
+	0x00000172,
+	0x00000178,
+	0x0000017e,
+};
+
+#define A_reconnect_dsa_head	0x00000000
+static u32 A_reconnect_dsa_head_used[] __attribute((unused)) = {
+	0x0000006d,
+	0x00000074,
+	0x000001b1,
+};
+
+#define A_reselected_identify	0x00000000
+static u32 A_reselected_identify_used[] __attribute((unused)) = {
+	0x00000048,
+	0x000001af,
+};
+
+#define A_reselected_tag	0x00000000
+static u32 A_reselected_tag_used[] __attribute((unused)) = {
+};
+
+#define A_saved_dsa	0x00000000
+static u32 A_saved_dsa_used[] __attribute((unused)) = {
+	0x00000005,
+	0x0000000e,
+	0x00000023,
+	0x00000025,
+	0x00000032,
+	0x0000003f,
+	0x00000054,
+	0x0000005f,
+	0x00000070,
+	0x00000078,
+	0x0000008d,
+	0x000000aa,
+	0x000000bb,
+	0x000000c0,
+	0x000000d1,
+	0x0000012f,
+	0x000001a4,
+	0x000001b5,
+	0x000001ba,
+	0x000001e2,
+};
+
+#define A_schedule	0x00000000
+static u32 A_schedule_used[] __attribute((unused)) = {
+	0x0000007d,
+	0x000001a7,
+	0x00000203,
+	0x00000244,
+};
+
+#define A_test_dest	0x00000000
+static u32 A_test_dest_used[] __attribute((unused)) = {
+	0x0000021c,
+};
+
+#define A_test_src	0x00000000
+static u32 A_test_src_used[] __attribute((unused)) = {
+	0x0000021b,
+};
+
+#define Ent_accept_message	0x00000624
+#define Ent_cmdout_cmdout	0x00000264
+#define Ent_command_complete	0x0000065c
+#define Ent_command_complete_msgin	0x0000066c
+#define Ent_data_transfer	0x0000026c
+#define Ent_datain_to_jump	0x00000334
+#define Ent_debug_break	0x000008ec
+#define Ent_dsa_code_begin	0x00000000
+#define Ent_dsa_code_check_reselect	0x0000010c
+#define Ent_dsa_code_fix_jump	0x00000058
+#define Ent_dsa_code_restore_pointers	0x000000d8
+#define Ent_dsa_code_save_data_pointer	0x000000a4
+#define Ent_dsa_code_template	0x00000000
+#define Ent_dsa_code_template_end	0x00000178
+#define Ent_dsa_schedule	0x00000178
+#define Ent_dsa_zero	0x00000178
+#define Ent_end_data_transfer	0x000002a4
+#define Ent_initiator_abort	0x00000914
+#define Ent_msg_in	0x0000041c
+#define Ent_msg_in_restart	0x000003fc
+#define Ent_other_in	0x0000038c
+#define Ent_other_out	0x00000354
+#define Ent_other_transfer	0x000003c4
+#define Ent_reject_message	0x00000604
+#define Ent_reselected_check_next	0x000006f0
+#define Ent_reselected_ok	0x00000798
+#define Ent_respond_message	0x0000063c
+#define Ent_select	0x000001f8
+#define Ent_select_msgout	0x00000218
+#define Ent_target_abort	0x000008f4
+#define Ent_test_1	0x00000868
+#define Ent_test_2	0x0000087c
+#define Ent_test_2_msgout	0x0000089c
+#define Ent_wait_reselect	0x000006a8
+static u32 LABELPATCHES[] __attribute((unused)) = {
+	0x00000011,
+	0x0000001a,
+	0x0000001d,
+	0x00000028,
+	0x0000002a,
+	0x00000035,
+	0x00000038,
+	0x00000042,
+	0x00000050,
+	0x00000052,
+	0x0000006b,
+	0x00000083,
+	0x00000085,
+	0x00000090,
+	0x00000094,
+	0x00000096,
+	0x0000009c,
+	0x0000009e,
+	0x000000a2,
+	0x000000a4,
+	0x000000a6,
+	0x000000a8,
+	0x000000b6,
+	0x000000b9,
+	0x000000cc,
+	0x000000cf,
+	0x000000d8,
+	0x000000de,
+	0x000000e0,
+	0x000000e6,
+	0x000000ec,
+	0x000000ee,
+	0x000000f4,
+	0x000000fc,
+	0x000000fe,
+	0x0000010a,
+	0x0000010c,
+	0x0000010e,
+	0x00000110,
+	0x00000112,
+	0x00000118,
+	0x0000011a,
+	0x0000012d,
+	0x00000143,
+	0x00000158,
+	0x0000015c,
+	0x00000164,
+	0x00000166,
+	0x00000168,
+	0x0000016e,
+	0x0000017a,
+	0x000001ab,
+	0x000001b8,
+	0x000001bf,
+	0x000001c3,
+	0x000001c7,
+	0x000001cb,
+	0x000001e0,
+	0x000001f8,
+	0x00000207,
+	0x0000020f,
+	0x00000213,
+	0x00000217,
+	0x00000224,
+	0x00000226,
+	0x00000248,
+	0x0000024a,
+	0x0000024c,
+	0x0000024e,
+	0x00000250,
+	0x00000252,
+	0x00000256,
+	0x0000025a,
+	0x0000025c,
+	0x00000260,
+	0x00000262,
+	0x00000266,
+	0x00000268,
+};
+
+static struct {
+	u32	offset;
+	void		*address;
+} EXTERNAL_PATCHES[] __attribute((unused)) = {
+};
+
+static u32 INSTRUCTIONS __attribute((unused))	= 290;
+static u32 PATCHES __attribute((unused))	= 78;
+static u32 EXTERNAL_PATCHES_LEN __attribute((unused))	= 0;
diff -Nru a/drivers/scsi/53c7xx_u.h_shipped b/drivers/scsi/53c7xx_u.h_shipped
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/scsi/53c7xx_u.h_shipped	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,102 @@
+#undef A_NCR53c7xx_msg_abort
+#undef A_NCR53c7xx_msg_reject
+#undef A_NCR53c7xx_sink
+#undef A_NCR53c7xx_zero
+#undef A_NOP_insn
+#undef A_addr_dsa
+#undef A_addr_reconnect_dsa_head
+#undef A_addr_scratch
+#undef A_addr_temp
+#undef A_dmode_memory_to_memory
+#undef A_dmode_memory_to_ncr
+#undef A_dmode_ncr_to_memory
+#undef A_dsa_check_reselect
+#undef A_dsa_cmdout
+#undef A_dsa_cmnd
+#undef A_dsa_datain
+#undef A_dsa_dataout
+#undef A_dsa_end
+#undef A_dsa_fields_start
+#undef A_dsa_msgin
+#undef A_dsa_msgout
+#undef A_dsa_msgout_other
+#undef A_dsa_next
+#undef A_dsa_restore_pointers
+#undef A_dsa_save_data_pointer
+#undef A_dsa_select
+#undef A_dsa_sscf_710
+#undef A_dsa_status
+#undef A_dsa_temp_addr_array_value
+#undef A_dsa_temp_addr_dsa_value
+#undef A_dsa_temp_addr_new_value
+#undef A_dsa_temp_addr_next
+#undef A_dsa_temp_addr_residual
+#undef A_dsa_temp_addr_saved_pointer
+#undef A_dsa_temp_addr_saved_residual
+#undef A_dsa_temp_lun
+#undef A_dsa_temp_next
+#undef A_dsa_temp_sync
+#undef A_dsa_temp_target
+#undef A_emulfly
+#undef A_int_debug_break
+#undef A_int_debug_panic
+#undef A_int_err_check_condition
+#undef A_int_err_no_phase
+#undef A_int_err_selected
+#undef A_int_err_unexpected_phase
+#undef A_int_err_unexpected_reselect
+#undef A_int_msg_1
+#undef A_int_msg_sdtr
+#undef A_int_msg_wdtr
+#undef A_int_norm_aborted
+#undef A_int_norm_command_complete
+#undef A_int_norm_disconnected
+#undef A_int_norm_emulateintfly
+#undef A_int_norm_reselect_complete
+#undef A_int_norm_reset
+#undef A_int_norm_select_complete
+#undef A_int_test_1
+#undef A_int_test_2
+#undef A_int_test_3
+#undef A_msg_buf
+#undef A_reconnect_dsa_head
+#undef A_reselected_identify
+#undef A_reselected_tag
+#undef A_saved_dsa
+#undef A_schedule
+#undef A_test_dest
+#undef A_test_src
+#undef Ent_accept_message
+#undef Ent_cmdout_cmdout
+#undef Ent_command_complete
+#undef Ent_command_complete_msgin
+#undef Ent_data_transfer
+#undef Ent_datain_to_jump
+#undef Ent_debug_break
+#undef Ent_dsa_code_begin
+#undef Ent_dsa_code_check_reselect
+#undef Ent_dsa_code_fix_jump
+#undef Ent_dsa_code_restore_pointers
+#undef Ent_dsa_code_save_data_pointer
+#undef Ent_dsa_code_template
+#undef Ent_dsa_code_template_end
+#undef Ent_dsa_schedule
+#undef Ent_dsa_zero
+#undef Ent_end_data_transfer
+#undef Ent_initiator_abort
+#undef Ent_msg_in
+#undef Ent_msg_in_restart
+#undef Ent_other_in
+#undef Ent_other_out
+#undef Ent_other_transfer
+#undef Ent_reject_message
+#undef Ent_reselected_check_next
+#undef Ent_reselected_ok
+#undef Ent_respond_message
+#undef Ent_select
+#undef Ent_select_msgout
+#undef Ent_target_abort
+#undef Ent_test_1
+#undef Ent_test_2
+#undef Ent_test_2_msgout
+#undef Ent_wait_reselect
diff -Nru a/drivers/scsi/53c8xx_d.h b/drivers/scsi/53c8xx_d.h
--- a/drivers/scsi/53c8xx_d.h	Thu Jun 20 15:54:00 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,2678 +0,0 @@
-/* DO NOT EDIT - Generated automatically by script_asm.pl */
-static u32 SCRIPT[] = {
-/*
-
-
-; NCR 53c810 driver, main script
-; Sponsored by 
-;	iX Multiuser Multitasking Magazine
-;	hm@ix.de
-;
-; Copyright 1993, 1994, 1995 Drew Eckhardt
-;      Visionary Computing 
-;      (Unix and Linux consulting and custom programming)
-;      drew@PoohSticks.ORG
-;      +1 (303) 786-7975
-;
-; TolerANT and SCSI SCRIPTS are registered trademarks of NCR Corporation.
-;
-; PRE-ALPHA
-;
-; For more information, please consult 
-;
-; NCR 53C810
-; PCI-SCSI I/O Processor
-; Data Manual
-;
-; NCR 53C710 
-; SCSI I/O Processor
-; Programmers Guide
-;
-; NCR Microelectronics
-; 1635 Aeroplaza Drive
-; Colorado Springs, CO 80916
-; 1+ (719) 578-3400
-;
-; Toll free literature number
-; +1 (800) 334-5454
-;
-; IMPORTANT : This code is self modifying due to the limitations of 
-;	the NCR53c7,8xx series chips.  Persons debugging this code with
-;	the remote debugger should take this into account, and NOT set
-;	breakpoints in modified instructions.
-;
-; Design:
-; The NCR53c7,8xx family of SCSI chips are busmasters with an onboard 
-; microcontroller using a simple instruction set.   
-;
-; So, to minimize the effects of interrupt latency, and to maximize 
-; throughput, this driver offloads the practical maximum amount 
-; of processing to the SCSI chip while still maintaining a common
-; structure.
-;
-; Where tradeoffs were needed between efficiency on the older
-; chips and the newer NCR53c800 series, the NCR53c800 series 
-; was chosen.
-;
-; While the NCR53c700 and NCR53c700-66 lacked the facilities to fully
-; automate SCSI transfers without host processor intervention, this 
-; isn't the case with the NCR53c710 and newer chips which allow 
-;
-; - reads and writes to the internal registers from within the SCSI
-; 	scripts, allowing the SCSI SCRIPTS(tm) code to save processor
-; 	state so that multiple threads of execution are possible, and also
-; 	provide an ALU for loop control, etc.
-; 
-; - table indirect addressing for some instructions. This allows 
-;	pointers to be located relative to the DSA ((Data Structure
-;	Address) register.
-;
-; These features make it possible to implement a mailbox style interface,
-; where the same piece of code is run to handle I/O for multiple threads
-; at once minimizing our need to relocate code.  Since the NCR53c700/
-; NCR53c800 series have a unique combination of features, making a 
-; a standard ingoing/outgoing mailbox system, costly, I've modified it.
-;
-; - Mailboxes are a mixture of code and data.  This lets us greatly
-; 	simplify the NCR53c810 code and do things that would otherwise
-;	not be possible.
-;
-; The saved data pointer is now implemented as follows :
-;
-; 	Control flow has been architected such that if control reaches
-;	munge_save_data_pointer, on a restore pointers message or 
-;	reconnection, a jump to the address formerly in the TEMP register
-;	will allow the SCSI command to resume execution.
-;
-
-;
-; Note : the DSA structures must be aligned on 32 bit boundaries,
-; since the source and destination of MOVE MEMORY instructions 
-; must share the same alignment and this is the alignment of the
-; NCR registers.
-;
-
-ABSOLUTE dsa_temp_lun = 0		; Patch to lun for current dsa
-ABSOLUTE dsa_temp_next = 0		; Patch to dsa next for current dsa
-ABSOLUTE dsa_temp_addr_next = 0		; Patch to address of dsa next address 
-					; 	for current dsa
-ABSOLUTE dsa_temp_sync = 0		; Patch to address of per-target
-					;	sync routine
-ABSOLUTE dsa_temp_target = 0		; Patch to id for current dsa
-ABSOLUTE dsa_temp_addr_saved_pointer = 0; Patch to address of per-command
-					; 	saved data pointer
-ABSOLUTE dsa_temp_addr_residual = 0	; Patch to address of per-command
-					;	current residual code
-ABSOLUTE dsa_temp_addr_saved_residual = 0; Patch to address of per-command
-					; saved residual code
-ABSOLUTE dsa_temp_addr_new_value = 0	; Address of value for JUMP operand
-ABSOLUTE dsa_temp_addr_array_value = 0 	; Address to copy to
-ABSOLUTE dsa_temp_addr_dsa_value = 0	; Address of this DSA value
-
-;
-; Once a device has initiated reselection, we need to compare it 
-; against the singly linked list of commands which have disconnected
-; and are pending reselection.  These commands are maintained in 
-; an unordered singly linked list of DSA structures, through the
-; DSA pointers at their 'centers' headed by the reconnect_dsa_head
-; pointer.
-; 
-; To avoid complications in removing commands from the list,
-; I minimize the amount of expensive (at eight operations per
-; addition @ 500-600ns each) pointer operations which must
-; be done in the NCR driver by precomputing them on the 
-; host processor during dsa structure generation.
-;
-; The fixed-up per DSA code knows how to recognize the nexus
-; associated with the corresponding SCSI command, and modifies
-; the source and destination pointers for the MOVE MEMORY 
-; instruction which is executed when reselected_ok is called
-; to remove the command from the list.  Similarly, DSA is 
-; loaded with the address of the next DSA structure and
-; reselected_check_next is called if a failure occurs.
-;
-; Perhaps more concisely, the net effect of the mess is 
-;
-; for (dsa = reconnect_dsa_head, dest = &reconnect_dsa_head, 
-;     src = NULL; dsa; dest = &dsa->next, dsa = dsa->next) {
-; 	src = &dsa->next;
-; 	if (target_id == dsa->id && target_lun == dsa->lun) {
-; 		*dest = *src;
-; 		break;
-;         }	
-; }
-;
-; if (!dsa)
-;           error (int_err_unexpected_reselect);
-; else  
-;     longjmp (dsa->jump_resume, 0);
-;
-; 	
-
-
-; Define DSA structure used for mailboxes
-ENTRY dsa_code_template
-dsa_code_template:
-ENTRY dsa_code_begin
-dsa_code_begin:
-	MOVE dmode_memory_to_ncr TO DMODE
-
-at 0x00000000 : */	0x78380000,0x00000000,
-/*
-	MOVE MEMORY 4, dsa_temp_addr_dsa_value, addr_scratch
-
-at 0x00000002 : */	0xc0000004,0x00000000,0x00000000,
-/*
-	MOVE dmode_memory_to_memory TO DMODE
-
-at 0x00000005 : */	0x78380000,0x00000000,
-/*
-	CALL scratch_to_dsa
-
-at 0x00000007 : */	0x88080000,0x00000980,
-/*
-	CALL select
-
-at 0x00000009 : */	0x88080000,0x000001fc,
-/*
-; Handle the phase mismatch which may have resulted from the 
-; MOVE FROM dsa_msgout if we returned here.  The CLEAR ATN 
-; may or may not be necessary, and we should update script_asm.pl
-; to handle multiple pieces.
-    CLEAR ATN
-
-at 0x0000000b : */	0x60000008,0x00000000,
-/*
-    CLEAR ACK
-
-at 0x0000000d : */	0x60000040,0x00000000,
-/*
-
-; Replace second operand with address of JUMP instruction dest operand
-; in schedule table for this DSA.  Becomes dsa_jump_dest in 53c7,8xx.c.
-ENTRY dsa_code_fix_jump
-dsa_code_fix_jump:
-	MOVE MEMORY 4, NOP_insn, 0
-
-at 0x0000000f : */	0xc0000004,0x00000000,0x00000000,
-/*
-	JUMP select_done
-
-at 0x00000012 : */	0x80080000,0x00000224,
-/*
-
-; wrong_dsa loads the DSA register with the value of the dsa_next
-; field.
-;
-wrong_dsa:
-;		Patch the MOVE MEMORY INSTRUCTION such that 
-;		the destination address is the address of the OLD 
-;		next pointer.
-;
-	MOVE MEMORY 4, dsa_temp_addr_next, reselected_ok + 8
-
-at 0x00000014 : */	0xc0000004,0x00000000,0x00000758,
-/*
-	MOVE dmode_memory_to_ncr TO DMODE	
-
-at 0x00000017 : */	0x78380000,0x00000000,
-/*
-;
-; 	Move the _contents_ of the next pointer into the DSA register as 
-;	the next I_T_L or I_T_L_Q tupple to check against the established
-;	nexus.
-;
-	MOVE MEMORY 4, dsa_temp_next, addr_scratch
-
-at 0x00000019 : */	0xc0000004,0x00000000,0x00000000,
-/*
-	MOVE dmode_memory_to_memory TO DMODE
-
-at 0x0000001c : */	0x78380000,0x00000000,
-/*
-	CALL scratch_to_dsa
-
-at 0x0000001e : */	0x88080000,0x00000980,
-/*
-	JUMP reselected_check_next
-
-at 0x00000020 : */	0x80080000,0x000006a4,
-/*
-
-ABSOLUTE dsa_save_data_pointer = 0
-ENTRY dsa_code_save_data_pointer
-dsa_code_save_data_pointer:
-    	MOVE dmode_ncr_to_memory TO DMODE
-
-at 0x00000022 : */	0x78380000,0x00000000,
-/*
-    	MOVE MEMORY 4, addr_temp, dsa_temp_addr_saved_pointer
-
-at 0x00000024 : */	0xc0000004,0x00000000,0x00000000,
-/*
-    	MOVE dmode_memory_to_memory TO DMODE
-
-at 0x00000027 : */	0x78380000,0x00000000,
-/*
-; HARD CODED : 24 bytes needs to agree with 53c7,8xx.h
-    	MOVE MEMORY 24, dsa_temp_addr_residual, dsa_temp_addr_saved_residual
-
-at 0x00000029 : */	0xc0000018,0x00000000,0x00000000,
-/*
-        CLEAR ACK
-
-at 0x0000002c : */	0x60000040,0x00000000,
-/*
-
-
-
-    	RETURN
-
-at 0x0000002e : */	0x90080000,0x00000000,
-/*
-ABSOLUTE dsa_restore_pointers = 0
-ENTRY dsa_code_restore_pointers
-dsa_code_restore_pointers:
-    	MOVE dmode_memory_to_ncr TO DMODE
-
-at 0x00000030 : */	0x78380000,0x00000000,
-/*
-    	MOVE MEMORY 4, dsa_temp_addr_saved_pointer, addr_temp
-
-at 0x00000032 : */	0xc0000004,0x00000000,0x00000000,
-/*
-    	MOVE dmode_memory_to_memory TO DMODE
-
-at 0x00000035 : */	0x78380000,0x00000000,
-/*
-; HARD CODED : 24 bytes needs to agree with 53c7,8xx.h
-    	MOVE MEMORY 24, dsa_temp_addr_saved_residual, dsa_temp_addr_residual
-
-at 0x00000037 : */	0xc0000018,0x00000000,0x00000000,
-/*
-        CLEAR ACK
-
-at 0x0000003a : */	0x60000040,0x00000000,
-/*
-
-
-
-    	RETURN
-
-at 0x0000003c : */	0x90080000,0x00000000,
-/*
-
-ABSOLUTE dsa_check_reselect = 0
-; dsa_check_reselect determines whether or not the current target and
-; lun match the current DSA
-ENTRY dsa_code_check_reselect
-dsa_code_check_reselect:
-	MOVE SSID TO SFBR		; SSID contains 3 bit target ID
-
-at 0x0000003e : */	0x720a0000,0x00000000,
-/*
-; FIXME : we need to accommodate bit fielded and binary here for '7xx/'8xx chips
-	JUMP REL (wrong_dsa), IF NOT dsa_temp_target, AND MASK 0xf8
-
-at 0x00000040 : */	0x8084f800,0x00ffff48,
-/*
-;
-; Hack - move to scratch first, since SFBR is not writeable
-; 	via the CPU and hence a MOVE MEMORY instruction.
-;
-	MOVE dmode_memory_to_ncr TO DMODE
-
-at 0x00000042 : */	0x78380000,0x00000000,
-/*
-	MOVE MEMORY 1, reselected_identify, addr_scratch
-
-at 0x00000044 : */	0xc0000001,0x00000000,0x00000000,
-/*
-	MOVE dmode_memory_to_memory TO DMODE
-
-at 0x00000047 : */	0x78380000,0x00000000,
-/*
-	MOVE SCRATCH0 TO SFBR
-
-at 0x00000049 : */	0x72340000,0x00000000,
-/*
-; FIXME : we need to accommodate bit fielded and binary here for '7xx/'8xx chips
-	JUMP REL (wrong_dsa), IF NOT dsa_temp_lun, AND MASK 0xf8
-
-at 0x0000004b : */	0x8084f800,0x00ffff1c,
-/*
-;		Patch the MOVE MEMORY INSTRUCTION such that
-;		the source address is the address of this dsa's
-;		next pointer.
-	MOVE MEMORY 4, dsa_temp_addr_next, reselected_ok + 4
-
-at 0x0000004d : */	0xc0000004,0x00000000,0x00000754,
-/*
-	CALL reselected_ok
-
-at 0x00000050 : */	0x88080000,0x00000750,
-/*
-	CALL dsa_temp_sync	
-
-at 0x00000052 : */	0x88080000,0x00000000,
-/*
-; Release ACK on the IDENTIFY message _after_ we've set the synchronous 
-; transfer parameters! 
-	CLEAR ACK
-
-at 0x00000054 : */	0x60000040,0x00000000,
-/*
-; Implicitly restore pointers on reselection, so a RETURN
-; will transfer control back to the right spot.
-    	CALL REL (dsa_code_restore_pointers)
-
-at 0x00000056 : */	0x88880000,0x00ffff60,
-/*
-    	RETURN
-
-at 0x00000058 : */	0x90080000,0x00000000,
-/*
-ENTRY dsa_zero
-dsa_zero:
-ENTRY dsa_code_template_end
-dsa_code_template_end:
-
-; Perform sanity check for dsa_fields_start == dsa_code_template_end - 
-; dsa_zero, puke.
-
-ABSOLUTE dsa_fields_start =  0	; Sanity marker
-				; 	pad 48 bytes (fix this RSN)
-ABSOLUTE dsa_next = 48		; len 4 Next DSA
- 				; del 4 Previous DSA address
-ABSOLUTE dsa_cmnd = 56		; len 4 Scsi_Cmnd * for this thread.
-ABSOLUTE dsa_select = 60	; len 4 Device ID, Period, Offset for 
-			 	;	table indirect select
-ABSOLUTE dsa_msgout = 64	; len 8 table indirect move parameter for 
-				;       select message
-ABSOLUTE dsa_cmdout = 72	; len 8 table indirect move parameter for 
-				;	command
-ABSOLUTE dsa_dataout = 80	; len 4 code pointer for dataout
-ABSOLUTE dsa_datain = 84	; len 4 code pointer for datain
-ABSOLUTE dsa_msgin = 88		; len 8 table indirect move for msgin
-ABSOLUTE dsa_status = 96 	; len 8 table indirect move for status byte
-ABSOLUTE dsa_msgout_other = 104	; len 8 table indirect for normal message out
-				; (Synchronous transfer negotiation, etc).
-ABSOLUTE dsa_end = 112
-
-ABSOLUTE schedule = 0 		; Array of JUMP dsa_begin or JUMP (next),
-				; terminated by a call to JUMP wait_reselect
-
-; Linked lists of DSA structures
-ABSOLUTE reconnect_dsa_head = 0	; Link list of DSAs which can reconnect
-ABSOLUTE addr_reconnect_dsa_head = 0 ; Address of variable containing
-				; address of reconnect_dsa_head
-
-; These select the source and destination of a MOVE MEMORY instruction
-ABSOLUTE dmode_memory_to_memory = 0x0
-ABSOLUTE dmode_memory_to_ncr = 0x0
-ABSOLUTE dmode_ncr_to_memory = 0x0
-
-ABSOLUTE addr_scratch = 0x0
-ABSOLUTE addr_temp = 0x0
-
-
-; Interrupts - 
-; MSB indicates type
-; 0	handle error condition
-; 1 	handle message 
-; 2 	handle normal condition
-; 3	debugging interrupt
-; 4 	testing interrupt 
-; Next byte indicates specific error
-
-; XXX not yet implemented, I'm not sure if I want to - 
-; Next byte indicates the routine the error occurred in
-; The LSB indicates the specific place the error occurred
- 
-ABSOLUTE int_err_unexpected_phase = 0x00000000	; Unexpected phase encountered
-ABSOLUTE int_err_selected = 0x00010000		; SELECTED (nee RESELECTED)
-ABSOLUTE int_err_unexpected_reselect = 0x00020000 
-ABSOLUTE int_err_check_condition = 0x00030000	
-ABSOLUTE int_err_no_phase = 0x00040000
-ABSOLUTE int_msg_wdtr = 0x01000000		; WDTR message received
-ABSOLUTE int_msg_sdtr = 0x01010000		; SDTR received
-ABSOLUTE int_msg_1 = 0x01020000			; single byte special message
-						; received
-
-ABSOLUTE int_norm_select_complete = 0x02000000	; Select complete, reprogram
-						; registers.
-ABSOLUTE int_norm_reselect_complete = 0x02010000	; Nexus established
-ABSOLUTE int_norm_command_complete = 0x02020000 ; Command complete
-ABSOLUTE int_norm_disconnected = 0x02030000	; Disconnected 
-ABSOLUTE int_norm_aborted =0x02040000		; Aborted *dsa
-ABSOLUTE int_norm_reset = 0x02050000		; Generated BUS reset.
-ABSOLUTE int_debug_break = 0x03000000		; Break point
-
-ABSOLUTE int_debug_panic = 0x030b0000		; Panic driver
-
-
-ABSOLUTE int_test_1 = 0x04000000		; Test 1 complete
-ABSOLUTE int_test_2 = 0x04010000		; Test 2 complete
-ABSOLUTE int_test_3 = 0x04020000		; Test 3 complete
-
-
-; These should start with 0x05000000, with low bits incrementing for 
-; each one.
-
-
-						
-ABSOLUTE NCR53c7xx_msg_abort = 0	; Pointer to abort message
-ABSOLUTE NCR53c7xx_msg_reject = 0       ; Pointer to reject message
-ABSOLUTE NCR53c7xx_zero	= 0		; long with zero in it, use for source
-ABSOLUTE NCR53c7xx_sink = 0		; long to dump worthless data in
-ABSOLUTE NOP_insn = 0			; NOP instruction
-
-; Pointer to message, potentially multi-byte
-ABSOLUTE msg_buf = 0
-
-; Pointer to holding area for reselection information
-ABSOLUTE reselected_identify = 0
-ABSOLUTE reselected_tag = 0
-
-; Request sense command pointer, it's a 6 byte command, should
-; be constant for all commands since we always want 16 bytes of 
-; sense and we don't need to change any fields as we did under 
-; SCSI-I when we actually cared about the LUN field.
-;EXTERNAL NCR53c7xx_sense		; Request sense command
-
-
-; dsa_schedule  
-; PURPOSE : after a DISCONNECT message has been received, and pointers
-;	saved, insert the current DSA structure at the head of the 
-; 	disconnected queue and fall through to the scheduler.
-;
-; CALLS : OK
-;
-; INPUTS : dsa - current DSA structure, reconnect_dsa_head - list
-;	of disconnected commands
-;
-; MODIFIES : SCRATCH, reconnect_dsa_head
-; 
-; EXITS : always passes control to schedule
-
-ENTRY dsa_schedule
-dsa_schedule:
-
-
-
-
-;
-; Calculate the address of the next pointer within the DSA 
-; structure of the command that is currently disconnecting
-;
-    CALL dsa_to_scratch
-
-at 0x0000005a : */	0x88080000,0x00000938,
-/*
-    MOVE SCRATCH0 + dsa_next TO SCRATCH0
-
-at 0x0000005c : */	0x7e343000,0x00000000,
-/*
-    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY
-
-at 0x0000005e : */	0x7f350000,0x00000000,
-/*
-    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY
-
-at 0x00000060 : */	0x7f360000,0x00000000,
-/*
-    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY
-
-at 0x00000062 : */	0x7f370000,0x00000000,
-/*
-
-; Point the next field of this DSA structure at the current disconnected 
-; list
-    MOVE dmode_ncr_to_memory TO DMODE
-
-at 0x00000064 : */	0x78380000,0x00000000,
-/*
-    MOVE MEMORY 4, addr_scratch, dsa_schedule_insert + 8
-
-at 0x00000066 : */	0xc0000004,0x00000000,0x000001b4,
-/*
-    MOVE dmode_memory_to_memory TO DMODE
-
-at 0x00000069 : */	0x78380000,0x00000000,
-/*
-dsa_schedule_insert:
-    MOVE MEMORY 4, reconnect_dsa_head, 0 
-
-at 0x0000006b : */	0xc0000004,0x00000000,0x00000000,
-/*
-
-; And update the head pointer.
-    CALL dsa_to_scratch
-
-at 0x0000006e : */	0x88080000,0x00000938,
-/*
-    MOVE dmode_ncr_to_memory TO DMODE	
-
-at 0x00000070 : */	0x78380000,0x00000000,
-/*
-    MOVE MEMORY 4, addr_scratch, reconnect_dsa_head
-
-at 0x00000072 : */	0xc0000004,0x00000000,0x00000000,
-/*
-    MOVE dmode_memory_to_memory TO DMODE
-
-at 0x00000075 : */	0x78380000,0x00000000,
-/*
-
-
-    MOVE SCNTL2 & 0x7f TO SCNTL2
-
-at 0x00000077 : */	0x7c027f00,0x00000000,
-/*
-    CLEAR ACK
-
-at 0x00000079 : */	0x60000040,0x00000000,
-/*
-
-    WAIT DISCONNECT
-
-at 0x0000007b : */	0x48000000,0x00000000,
-/*
-
-
-
-
-
-
-    JUMP schedule
-
-at 0x0000007d : */	0x80080000,0x00000000,
-/*
-
-
-;
-; select
-;
-; PURPOSE : establish a nexus for the SCSI command referenced by DSA.
-;	On success, the current DSA structure is removed from the issue 
-;	queue.  Usually, this is entered as a fall-through from schedule,
-;	although the contingent allegiance handling code will write
-;	the select entry address to the DSP to restart a command as a 
-;	REQUEST SENSE.  A message is sent (usually IDENTIFY, although
-;	additional SDTR or WDTR messages may be sent).  COMMAND OUT
-;	is handled.
-;
-; INPUTS : DSA - SCSI command, issue_dsa_head
-;
-; CALLS : NOT OK
-;
-; MODIFIES : SCRATCH, issue_dsa_head
-;
-; EXITS : on reselection or selection, go to select_failed
-;	otherwise, RETURN so control is passed back to 
-;	dsa_begin.
-;
-
-ENTRY select
-select:
-
-
-
-
-
-
-
-
-
-
-
-
-    CLEAR TARGET
-
-at 0x0000007f : */	0x60000200,0x00000000,
-/*
-
-; XXX
-;
-; In effect, SELECTION operations are backgrounded, with execution
-; continuing until code which waits for REQ or a fatal interrupt is 
-; encountered.
-;
-; So, for more performance, we could overlap the code which removes 
-; the command from the NCRs issue queue with the selection, but 
-; at this point I don't want to deal with the error recovery.
-;
-
-
-    SELECT ATN FROM dsa_select, select_failed
-
-at 0x00000081 : */	0x4300003c,0x000007a4,
-/*
-    JUMP select_msgout, WHEN MSG_OUT
-
-at 0x00000083 : */	0x860b0000,0x00000214,
-/*
-ENTRY select_msgout
-select_msgout:
-    MOVE FROM dsa_msgout, WHEN MSG_OUT
-
-at 0x00000085 : */	0x1e000000,0x00000040,
-/*
-
-
-
-
-
-
-
-
-
-
-   RETURN
-
-at 0x00000087 : */	0x90080000,0x00000000,
-/*
-
-; 
-; select_done
-; 
-; PURPOSE: continue on to normal data transfer; called as the exit 
-;	point from dsa_begin.
-;
-; INPUTS: dsa
-;
-; CALLS: OK
-;
-;
-
-select_done:
-
-
-
-
-
-
-
-; After a successful selection, we should get either a CMD phase or 
-; some transfer request negotiation message.
-
-    JUMP cmdout, WHEN CMD
-
-at 0x00000089 : */	0x820b0000,0x00000244,
-/*
-    INT int_err_unexpected_phase, WHEN NOT MSG_IN 
-
-at 0x0000008b : */	0x9f030000,0x00000000,
-/*
-
-select_msg_in:
-    CALL msg_in, WHEN MSG_IN
-
-at 0x0000008d : */	0x8f0b0000,0x00000404,
-/*
-    JUMP select_msg_in, WHEN MSG_IN
-
-at 0x0000008f : */	0x870b0000,0x00000234,
-/*
-
-cmdout:
-    INT int_err_unexpected_phase, WHEN NOT CMD
-
-at 0x00000091 : */	0x9a030000,0x00000000,
-/*
-
-
-
-ENTRY cmdout_cmdout
-cmdout_cmdout:
-
-    MOVE FROM dsa_cmdout, WHEN CMD
-
-at 0x00000093 : */	0x1a000000,0x00000048,
-/*
-
-
-
-
-;
-; data_transfer  
-; other_out
-; other_in
-; other_transfer
-;
-; PURPOSE : handle the main data transfer for a SCSI command in 
-;	several parts.  In the first part, data_transfer, DATA_IN
-;	and DATA_OUT phases are allowed, with the user provided
-;	code (usually dynamically generated based on the scatter/gather
-;	list associated with a SCSI command) called to handle these 
-;	phases.
-;
-;	After control has passed to one of the user provided 
-;	DATA_IN or DATA_OUT routines, back calls are made to 
-;	other_transfer_in or other_transfer_out to handle non-DATA IN
-;	and DATA OUT phases respectively, with the state of the active
-;	data pointer being preserved in TEMP.
-;
-;	On completion, the user code passes control to other_transfer
-;	which causes DATA_IN and DATA_OUT to result in unexpected_phase
-;	interrupts so that data overruns may be trapped.
-;
-; INPUTS : DSA - SCSI command
-;
-; CALLS : OK in data_transfer_start, not ok in other_out and other_in, ok in
-;	other_transfer
-;
-; MODIFIES : SCRATCH
-;
-; EXITS : if STATUS IN is detected, signifying command completion,
-;	the NCR jumps to command_complete.  If MSG IN occurs, a 
-;	CALL is made to msg_in.  Otherwise, other_transfer runs in 
-;	an infinite loop.
-;	
-
-ENTRY data_transfer
-data_transfer:
-    JUMP cmdout_cmdout, WHEN CMD
-
-at 0x00000095 : */	0x820b0000,0x0000024c,
-/*
-    CALL msg_in, WHEN MSG_IN
-
-at 0x00000097 : */	0x8f0b0000,0x00000404,
-/*
-    INT int_err_unexpected_phase, WHEN MSG_OUT
-
-at 0x00000099 : */	0x9e0b0000,0x00000000,
-/*
-    JUMP do_dataout, WHEN DATA_OUT
-
-at 0x0000009b : */	0x800b0000,0x0000028c,
-/*
-    JUMP do_datain, WHEN DATA_IN
-
-at 0x0000009d : */	0x810b0000,0x000002e4,
-/*
-    JUMP command_complete, WHEN STATUS
-
-at 0x0000009f : */	0x830b0000,0x0000060c,
-/*
-    JUMP data_transfer
-
-at 0x000000a1 : */	0x80080000,0x00000254,
-/*
-ENTRY end_data_transfer
-end_data_transfer:
-
-;
-; FIXME: On NCR53c700 and NCR53c700-66 chips, do_dataout/do_datain 
-; should be fixed up whenever the nexus changes so it can point to the 
-; correct routine for that command.
-;
-
-
-; Nasty jump to dsa->dataout
-do_dataout:
-    CALL dsa_to_scratch
-
-at 0x000000a3 : */	0x88080000,0x00000938,
-/*
-    MOVE SCRATCH0 + dsa_dataout TO SCRATCH0	
-
-at 0x000000a5 : */	0x7e345000,0x00000000,
-/*
-    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY 
-
-at 0x000000a7 : */	0x7f350000,0x00000000,
-/*
-    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY 
-
-at 0x000000a9 : */	0x7f360000,0x00000000,
-/*
-    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY 
-
-at 0x000000ab : */	0x7f370000,0x00000000,
-/*
-    MOVE dmode_ncr_to_memory TO DMODE
-
-at 0x000000ad : */	0x78380000,0x00000000,
-/*
-    MOVE MEMORY 4, addr_scratch, dataout_to_jump + 4
-
-at 0x000000af : */	0xc0000004,0x00000000,0x000002d4,
-/*
-    MOVE dmode_memory_to_memory TO DMODE
-
-at 0x000000b2 : */	0x78380000,0x00000000,
-/*
-dataout_to_jump:
-    MOVE MEMORY 4, 0, dataout_jump + 4 
-
-at 0x000000b4 : */	0xc0000004,0x00000000,0x000002e0,
-/*
-dataout_jump:
-    JUMP 0
-
-at 0x000000b7 : */	0x80080000,0x00000000,
-/*
-
-; Nasty jump to dsa->dsain
-do_datain:
-    CALL dsa_to_scratch
-
-at 0x000000b9 : */	0x88080000,0x00000938,
-/*
-    MOVE SCRATCH0 + dsa_datain TO SCRATCH0	
-
-at 0x000000bb : */	0x7e345400,0x00000000,
-/*
-    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY 
-
-at 0x000000bd : */	0x7f350000,0x00000000,
-/*
-    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY 
-
-at 0x000000bf : */	0x7f360000,0x00000000,
-/*
-    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY 
-
-at 0x000000c1 : */	0x7f370000,0x00000000,
-/*
-    MOVE dmode_ncr_to_memory TO DMODE
-
-at 0x000000c3 : */	0x78380000,0x00000000,
-/*
-    MOVE MEMORY 4, addr_scratch, datain_to_jump + 4
-
-at 0x000000c5 : */	0xc0000004,0x00000000,0x0000032c,
-/*
-    MOVE dmode_memory_to_memory TO DMODE		
-
-at 0x000000c8 : */	0x78380000,0x00000000,
-/*
-ENTRY datain_to_jump
-datain_to_jump:
-    MOVE MEMORY 4, 0, datain_jump + 4
-
-at 0x000000ca : */	0xc0000004,0x00000000,0x00000338,
-/*
-
-
-
-datain_jump:
-    JUMP 0
-
-at 0x000000cd : */	0x80080000,0x00000000,
-/*
-
-
-
-; Note that other_out and other_in loop until a non-data phase
-; is discovered, so we only execute return statements when we
-; can go on to the next data phase block move statement.
-
-ENTRY other_out
-other_out:
-
-
-
-    INT int_err_unexpected_phase, WHEN CMD
-
-at 0x000000cf : */	0x9a0b0000,0x00000000,
-/*
-    JUMP msg_in_restart, WHEN MSG_IN 
-
-at 0x000000d1 : */	0x870b0000,0x000003e4,
-/*
-    INT int_err_unexpected_phase, WHEN MSG_OUT
-
-at 0x000000d3 : */	0x9e0b0000,0x00000000,
-/*
-    INT int_err_unexpected_phase, WHEN DATA_IN
-
-at 0x000000d5 : */	0x990b0000,0x00000000,
-/*
-    JUMP command_complete, WHEN STATUS
-
-at 0x000000d7 : */	0x830b0000,0x0000060c,
-/*
-    JUMP other_out, WHEN NOT DATA_OUT
-
-at 0x000000d9 : */	0x80030000,0x0000033c,
-/*
-    RETURN
-
-at 0x000000db : */	0x90080000,0x00000000,
-/*
-
-ENTRY other_in
-other_in:
-
-
-
-    INT int_err_unexpected_phase, WHEN CMD
-
-at 0x000000dd : */	0x9a0b0000,0x00000000,
-/*
-    JUMP msg_in_restart, WHEN MSG_IN 
-
-at 0x000000df : */	0x870b0000,0x000003e4,
-/*
-    INT int_err_unexpected_phase, WHEN MSG_OUT
-
-at 0x000000e1 : */	0x9e0b0000,0x00000000,
-/*
-    INT int_err_unexpected_phase, WHEN DATA_OUT
-
-at 0x000000e3 : */	0x980b0000,0x00000000,
-/*
-    JUMP command_complete, WHEN STATUS
-
-at 0x000000e5 : */	0x830b0000,0x0000060c,
-/*
-    JUMP other_in, WHEN NOT DATA_IN
-
-at 0x000000e7 : */	0x81030000,0x00000374,
-/*
-    RETURN
-
-at 0x000000e9 : */	0x90080000,0x00000000,
-/*
-
-
-ENTRY other_transfer
-other_transfer:
-    INT int_err_unexpected_phase, WHEN CMD
-
-at 0x000000eb : */	0x9a0b0000,0x00000000,
-/*
-    CALL msg_in, WHEN MSG_IN
-
-at 0x000000ed : */	0x8f0b0000,0x00000404,
-/*
-    INT int_err_unexpected_phase, WHEN MSG_OUT
-
-at 0x000000ef : */	0x9e0b0000,0x00000000,
-/*
-    INT int_err_unexpected_phase, WHEN DATA_OUT
-
-at 0x000000f1 : */	0x980b0000,0x00000000,
-/*
-    INT int_err_unexpected_phase, WHEN DATA_IN
-
-at 0x000000f3 : */	0x990b0000,0x00000000,
-/*
-    JUMP command_complete, WHEN STATUS
-
-at 0x000000f5 : */	0x830b0000,0x0000060c,
-/*
-    JUMP other_transfer
-
-at 0x000000f7 : */	0x80080000,0x000003ac,
-/*
-
-;
-; msg_in_restart
-; msg_in
-; munge_msg
-;
-; PURPOSE : process messages from a target.  msg_in is called when the 
-;	caller hasn't read the first byte of the message.  munge_message
-;	is called when the caller has read the first byte of the message,
-;	and left it in SFBR.  msg_in_restart is called when the caller 
-;	hasn't read the first byte of the message, and wishes RETURN
-;	to transfer control back to the address of the conditional
-;	CALL instruction rather than to the instruction after it.
-;
-;	Various int_* interrupts are generated when the host system
-;	needs to intervene, as is the case with SDTR, WDTR, and
-;	INITIATE RECOVERY messages.
-;
-;	When the host system handles one of these interrupts,
-;	it can respond by reentering at reject_message, 
-;	which rejects the message and returns control to
-;	the caller of msg_in or munge_msg, accept_message
-;	which clears ACK and returns control, or reply_message
-;	which sends the message pointed to by the DSA 
-;	msgout_other table indirect field.
-;
-;	DISCONNECT messages are handled by moving the command
-;	to the reconnect_dsa_queue.
-;
-; INPUTS : DSA - SCSI COMMAND, SFBR - first byte of message (munge_msg
-;	only)
-;
-; CALLS : NO.  The TEMP register isn't backed up to allow nested calls.
-;
-; MODIFIES : SCRATCH, DSA on DISCONNECT
-;
-; EXITS : On receipt of SAVE DATA POINTER, RESTORE POINTERS,
-;	and normal return from message handlers running under
-;	Linux, control is returned to the caller.  Receipt
-;	of DISCONNECT messages pass control to dsa_schedule.
-;
-ENTRY msg_in_restart
-msg_in_restart:
-; XXX - hackish
-;
-; Since it's easier to debug changes to the statically 
-; compiled code, rather than the dynamically generated 
-; stuff, such as
-;
-; 	MOVE x, y, WHEN data_phase
-; 	CALL other_z, WHEN NOT data_phase
-; 	MOVE x, y, WHEN data_phase
-;
-; I'd like to have certain routines (notably the message handler)
-; restart on the conditional call rather than the next instruction.
-;
-; So, subtract 8 from the return address
-
-    MOVE TEMP0 + 0xf8 TO TEMP0
-
-at 0x000000f9 : */	0x7e1cf800,0x00000000,
-/*
-    MOVE TEMP1 + 0xff TO TEMP1 WITH CARRY
-
-at 0x000000fb : */	0x7f1dff00,0x00000000,
-/*
-    MOVE TEMP2 + 0xff TO TEMP2 WITH CARRY
-
-at 0x000000fd : */	0x7f1eff00,0x00000000,
-/*
-    MOVE TEMP3 + 0xff TO TEMP3 WITH CARRY
-
-at 0x000000ff : */	0x7f1fff00,0x00000000,
-/*
-
-ENTRY msg_in
-msg_in:
-    MOVE 1, msg_buf, WHEN MSG_IN
-
-at 0x00000101 : */	0x0f000001,0x00000000,
-/*
-
-munge_msg:
-    JUMP munge_extended, IF 0x01		; EXTENDED MESSAGE
-
-at 0x00000103 : */	0x800c0001,0x00000524,
-/*
-    JUMP munge_2, IF 0x20, AND MASK 0xdf	; two byte message
-
-at 0x00000105 : */	0x800cdf20,0x0000044c,
-/*
-;
-; XXX - I've seen a handful of broken SCSI devices which fail to issue
-; 	a SAVE POINTERS message before disconnecting in the middle of 
-; 	a transfer, assuming that the DATA POINTER will be implicitly 
-; 	restored.  
-;
-; Historically, I've often done an implicit save when the DISCONNECT
-; message is processed.  We may want to consider having the option of 
-; doing that here. 
-;
-    JUMP munge_save_data_pointer, IF 0x02	; SAVE DATA POINTER
-
-at 0x00000107 : */	0x800c0002,0x00000454,
-/*
-    JUMP munge_restore_pointers, IF 0x03	; RESTORE POINTERS 
-
-at 0x00000109 : */	0x800c0003,0x000004b8,
-/*
-    JUMP munge_disconnect, IF 0x04		; DISCONNECT
-
-at 0x0000010b : */	0x800c0004,0x0000051c,
-/*
-    INT int_msg_1, IF 0x07			; MESSAGE REJECT
-
-at 0x0000010d : */	0x980c0007,0x01020000,
-/*
-    INT int_msg_1, IF 0x0f			; INITIATE RECOVERY
-
-at 0x0000010f : */	0x980c000f,0x01020000,
-/*
-
-
-
-    JUMP reject_message
-
-at 0x00000111 : */	0x80080000,0x000005b4,
-/*
-
-munge_2:
-    JUMP reject_message
-
-at 0x00000113 : */	0x80080000,0x000005b4,
-/*
-;
-; The SCSI standard allows targets to recover from transient 
-; error conditions by backing up the data pointer with a 
-; RESTORE POINTERS message.  
-;	
-; So, we must save and restore the _residual_ code as well as 
-; the current instruction pointer.  Because of this messiness,
-; it is simpler to put dynamic code in the dsa for this and to
-; just do a simple jump down there. 
-;
-
-munge_save_data_pointer:
-    MOVE DSA0 + dsa_save_data_pointer TO SFBR
-
-at 0x00000115 : */	0x76100000,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH0
-
-at 0x00000117 : */	0x6a340000,0x00000000,
-/*
-    MOVE DSA1 + 0xff TO SFBR WITH CARRY
-
-at 0x00000119 : */	0x7711ff00,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH1
-
-at 0x0000011b : */	0x6a350000,0x00000000,
-/*
-    MOVE DSA2 + 0xff TO SFBR WITH CARRY 
-
-at 0x0000011d : */	0x7712ff00,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH2
-
-at 0x0000011f : */	0x6a360000,0x00000000,
-/*
-    MOVE DSA3 + 0xff TO SFBR WITH CARRY
-
-at 0x00000121 : */	0x7713ff00,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH3
-
-at 0x00000123 : */	0x6a370000,0x00000000,
-/*
-
-    MOVE dmode_ncr_to_memory TO DMODE
-
-at 0x00000125 : */	0x78380000,0x00000000,
-/*
-    MOVE MEMORY 4, addr_scratch, jump_dsa_save + 4
-
-at 0x00000127 : */	0xc0000004,0x00000000,0x000004b4,
-/*
-    MOVE dmode_memory_to_memory TO DMODE
-
-at 0x0000012a : */	0x78380000,0x00000000,
-/*
-jump_dsa_save:
-    JUMP 0
-
-at 0x0000012c : */	0x80080000,0x00000000,
-/*
-
-munge_restore_pointers:
-    MOVE DSA0 + dsa_restore_pointers TO SFBR
-
-at 0x0000012e : */	0x76100000,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH0
-
-at 0x00000130 : */	0x6a340000,0x00000000,
-/*
-    MOVE DSA1 + 0xff TO SFBR WITH CARRY
-
-at 0x00000132 : */	0x7711ff00,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH1
-
-at 0x00000134 : */	0x6a350000,0x00000000,
-/*
-    MOVE DSA2 + 0xff TO SFBR WITH CARRY
-
-at 0x00000136 : */	0x7712ff00,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH2
-
-at 0x00000138 : */	0x6a360000,0x00000000,
-/*
-    MOVE DSA3 + 0xff TO SFBR WITH CARRY
-
-at 0x0000013a : */	0x7713ff00,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH3
-
-at 0x0000013c : */	0x6a370000,0x00000000,
-/*
-
-    MOVE dmode_ncr_to_memory TO DMODE
-
-at 0x0000013e : */	0x78380000,0x00000000,
-/*
-    MOVE MEMORY 4, addr_scratch, jump_dsa_restore + 4
-
-at 0x00000140 : */	0xc0000004,0x00000000,0x00000518,
-/*
-    MOVE dmode_memory_to_memory TO DMODE
-
-at 0x00000143 : */	0x78380000,0x00000000,
-/*
-jump_dsa_restore:
-    JUMP 0
-
-at 0x00000145 : */	0x80080000,0x00000000,
-/*
-
-
-munge_disconnect:
-
-
-
-
-
-
-
-
-
- 
-
-
-
-
-
-
-    JUMP dsa_schedule
-
-at 0x00000147 : */	0x80080000,0x00000168,
-/*
-
-
-
-
-
-munge_extended:
-    CLEAR ACK
-
-at 0x00000149 : */	0x60000040,0x00000000,
-/*
-    INT int_err_unexpected_phase, WHEN NOT MSG_IN
-
-at 0x0000014b : */	0x9f030000,0x00000000,
-/*
-    MOVE 1, msg_buf + 1, WHEN MSG_IN
-
-at 0x0000014d : */	0x0f000001,0x00000001,
-/*
-    JUMP munge_extended_2, IF 0x02
-
-at 0x0000014f : */	0x800c0002,0x00000554,
-/*
-    JUMP munge_extended_3, IF 0x03 
-
-at 0x00000151 : */	0x800c0003,0x00000584,
-/*
-    JUMP reject_message
-
-at 0x00000153 : */	0x80080000,0x000005b4,
-/*
-
-munge_extended_2:
-    CLEAR ACK
-
-at 0x00000155 : */	0x60000040,0x00000000,
-/*
-    MOVE 1, msg_buf + 2, WHEN MSG_IN
-
-at 0x00000157 : */	0x0f000001,0x00000002,
-/*
-    JUMP reject_message, IF NOT 0x02	; Must be WDTR
-
-at 0x00000159 : */	0x80040002,0x000005b4,
-/*
-    CLEAR ACK
-
-at 0x0000015b : */	0x60000040,0x00000000,
-/*
-    MOVE 1, msg_buf + 3, WHEN MSG_IN
-
-at 0x0000015d : */	0x0f000001,0x00000003,
-/*
-    INT int_msg_wdtr
-
-at 0x0000015f : */	0x98080000,0x01000000,
-/*
-
-munge_extended_3:
-    CLEAR ACK
-
-at 0x00000161 : */	0x60000040,0x00000000,
-/*
-    MOVE 1, msg_buf + 2, WHEN MSG_IN
-
-at 0x00000163 : */	0x0f000001,0x00000002,
-/*
-    JUMP reject_message, IF NOT 0x01	; Must be SDTR
-
-at 0x00000165 : */	0x80040001,0x000005b4,
-/*
-    CLEAR ACK
-
-at 0x00000167 : */	0x60000040,0x00000000,
-/*
-    MOVE 2, msg_buf + 3, WHEN MSG_IN
-
-at 0x00000169 : */	0x0f000002,0x00000003,
-/*
-    INT int_msg_sdtr
-
-at 0x0000016b : */	0x98080000,0x01010000,
-/*
-
-ENTRY reject_message
-reject_message:
-    SET ATN
-
-at 0x0000016d : */	0x58000008,0x00000000,
-/*
-    CLEAR ACK
-
-at 0x0000016f : */	0x60000040,0x00000000,
-/*
-    MOVE 1, NCR53c7xx_msg_reject, WHEN MSG_OUT
-
-at 0x00000171 : */	0x0e000001,0x00000000,
-/*
-    RETURN
-
-at 0x00000173 : */	0x90080000,0x00000000,
-/*
-
-ENTRY accept_message
-accept_message:
-    CLEAR ATN
-
-at 0x00000175 : */	0x60000008,0x00000000,
-/*
-    CLEAR ACK
-
-at 0x00000177 : */	0x60000040,0x00000000,
-/*
-    RETURN
-
-at 0x00000179 : */	0x90080000,0x00000000,
-/*
-
-ENTRY respond_message
-respond_message:
-    SET ATN
-
-at 0x0000017b : */	0x58000008,0x00000000,
-/*
-    CLEAR ACK
-
-at 0x0000017d : */	0x60000040,0x00000000,
-/*
-    MOVE FROM dsa_msgout_other, WHEN MSG_OUT
-
-at 0x0000017f : */	0x1e000000,0x00000068,
-/*
-    RETURN
-
-at 0x00000181 : */	0x90080000,0x00000000,
-/*
-
-;
-; command_complete
-;
-; PURPOSE : handle command termination when STATUS IN is detected by reading
-;	a status byte followed by a command termination message. 
-;
-;	Normal termination results in an INTFLY instruction, and 
-;	the host system can pick out which command terminated by 
-;	examining the MESSAGE and STATUS buffers of all currently 
-;	executing commands;
-;
-;	Abnormal (CHECK_CONDITION) termination results in an
-;	int_err_check_condition interrupt so that a REQUEST SENSE
-;	command can be issued out-of-order so that no other command
-;	clears the contingent allegiance condition.
-;	
-;
-; INPUTS : DSA - command	
-;
-; CALLS : OK
-;
-; EXITS : On successful termination, control is passed to schedule.
-;	On abnormal termination, the user will usually modify the 
-;	DSA fields and corresponding buffers and return control
-;	to select.
-;
-
-ENTRY command_complete
-command_complete:
-    MOVE FROM dsa_status, WHEN STATUS
-
-at 0x00000183 : */	0x1b000000,0x00000060,
-/*
-
-    MOVE SFBR TO SCRATCH0		; Save status
-
-at 0x00000185 : */	0x6a340000,0x00000000,
-/*
-
-ENTRY command_complete_msgin
-command_complete_msgin:
-    MOVE FROM dsa_msgin, WHEN MSG_IN
-
-at 0x00000187 : */	0x1f000000,0x00000058,
-/*
-; Indicate that we should be expecting a disconnect
-    MOVE SCNTL2 & 0x7f TO SCNTL2
-
-at 0x00000189 : */	0x7c027f00,0x00000000,
-/*
-    CLEAR ACK
-
-at 0x0000018b : */	0x60000040,0x00000000,
-/*
-
-    WAIT DISCONNECT
-
-at 0x0000018d : */	0x48000000,0x00000000,
-/*
-
-;
-; The SCSI specification states that when a UNIT ATTENTION condition
-; is pending, as indicated by a CHECK CONDITION status message,
-; the target shall revert to asynchronous transfers.  Since
-; synchronous transfers parameters are maintained on a per INITIATOR/TARGET 
-; basis, and returning control to our scheduler could work on a command
-; running on another lun on that target using the old parameters, we must
-; interrupt the host processor to get them changed, or change them ourselves.
-;
-; Once SCSI-II tagged queueing is implemented, things will be even more
-; hairy, since contingent allegiance conditions exist on a per-target/lun
-; basis, and issuing a new command with a different tag would clear it.
-; In these cases, we must interrupt the host processor to get a request 
-; added to the HEAD of the queue with the request sense command, or we
-; must automatically issue the request sense command.
-
-
-
-
-
-    INTFLY
-
-at 0x0000018f : */	0x98180000,0x00000000,
-/*
-
-
-
-
-
-    JUMP schedule
-
-at 0x00000191 : */	0x80080000,0x00000000,
-/*
-command_failed:
-    INT int_err_check_condition
-
-at 0x00000193 : */	0x98080000,0x00030000,
-/*
-
-
-
-
-;
-; wait_reselect
-;
-; PURPOSE : This is essentially the idle routine, where control lands
-;	when there are no new processes to schedule.  wait_reselect
-;	waits for reselection, selection, and new commands.
-;
-;	When a successful reselection occurs, with the aid 
-;	of fixed up code in each DSA, wait_reselect walks the 
-;	reconnect_dsa_queue, asking each dsa if the target ID
-;	and LUN match its.
-;
-;	If a match is found, a call is made back to reselected_ok,
-;	which through the miracles of self modifying code, extracts
-;	the found DSA from the reconnect_dsa_queue and then 
-;	returns control to the DSAs thread of execution.
-;
-; INPUTS : NONE
-;
-; CALLS : OK
-;
-; MODIFIES : DSA,
-;
-; EXITS : On successful reselection, control is returned to the 
-;	DSA which called reselected_ok.  If the WAIT RESELECT
-;	was interrupted by a new commands arrival signaled by 
-;	SIG_P, control is passed to schedule.  If the NCR is 
-;	selected, the host system is interrupted with an 
-;	int_err_selected which is usually responded to by
-;	setting DSP to the target_abort address.
-
-ENTRY wait_reselect
-wait_reselect:
-
-
-
-
-
-
-    WAIT RESELECT wait_reselect_failed
-
-at 0x00000195 : */	0x50000000,0x0000076c,
-/*
-
-reselected:
-
-
-
-    CLEAR TARGET
-
-at 0x00000197 : */	0x60000200,0x00000000,
-/*
-    MOVE dmode_memory_to_memory TO DMODE
-
-at 0x00000199 : */	0x78380000,0x00000000,
-/*
-    ; Read all data needed to reestablish the nexus - 
-    MOVE 1, reselected_identify, WHEN MSG_IN
-
-at 0x0000019b : */	0x0f000001,0x00000000,
-/*
-    ; We used to CLEAR ACK here.
-
-
-
-
-
-    ; Point DSA at the current head of the disconnected queue.
-    MOVE dmode_memory_to_ncr  TO DMODE
-
-at 0x0000019d : */	0x78380000,0x00000000,
-/*
-    MOVE MEMORY 4, reconnect_dsa_head, addr_scratch
-
-at 0x0000019f : */	0xc0000004,0x00000000,0x00000000,
-/*
-    MOVE dmode_memory_to_memory TO DMODE
-
-at 0x000001a2 : */	0x78380000,0x00000000,
-/*
-    CALL scratch_to_dsa
-
-at 0x000001a4 : */	0x88080000,0x00000980,
-/*
-
-    ; Fix the update-next pointer so that the reconnect_dsa_head
-    ; pointer is the one that will be updated if this DSA is a hit 
-    ; and we remove it from the queue.
-
-    MOVE MEMORY 4, addr_reconnect_dsa_head, reselected_ok + 8
-
-at 0x000001a6 : */	0xc0000004,0x00000000,0x00000758,
-/*
-
-ENTRY reselected_check_next
-reselected_check_next:
-
-
-
-    ; Check for a NULL pointer.
-    MOVE DSA0 TO SFBR
-
-at 0x000001a9 : */	0x72100000,0x00000000,
-/*
-    JUMP reselected_not_end, IF NOT 0
-
-at 0x000001ab : */	0x80040000,0x000006ec,
-/*
-    MOVE DSA1 TO SFBR
-
-at 0x000001ad : */	0x72110000,0x00000000,
-/*
-    JUMP reselected_not_end, IF NOT 0
-
-at 0x000001af : */	0x80040000,0x000006ec,
-/*
-    MOVE DSA2 TO SFBR
-
-at 0x000001b1 : */	0x72120000,0x00000000,
-/*
-    JUMP reselected_not_end, IF NOT 0
-
-at 0x000001b3 : */	0x80040000,0x000006ec,
-/*
-    MOVE DSA3 TO SFBR
-
-at 0x000001b5 : */	0x72130000,0x00000000,
-/*
-    JUMP reselected_not_end, IF NOT 0
-
-at 0x000001b7 : */	0x80040000,0x000006ec,
-/*
-    INT int_err_unexpected_reselect
-
-at 0x000001b9 : */	0x98080000,0x00020000,
-/*
-
-reselected_not_end:
-    ;
-    ; XXX the ALU is only eight bits wide, and the assembler
-    ; wont do the dirt work for us.  As long as dsa_check_reselect
-    ; is negative, we need to sign extend with 1 bits to the full
-    ; 32 bit width of the address.
-    ;
-    ; A potential work around would be to have a known alignment 
-    ; of the DSA structure such that the base address plus 
-    ; dsa_check_reselect doesn't require carrying from bytes 
-    ; higher than the LSB.
-    ;
-
-    MOVE DSA0 TO SFBR
-
-at 0x000001bb : */	0x72100000,0x00000000,
-/*
-    MOVE SFBR + dsa_check_reselect TO SCRATCH0
-
-at 0x000001bd : */	0x6e340000,0x00000000,
-/*
-    MOVE DSA1 TO SFBR
-
-at 0x000001bf : */	0x72110000,0x00000000,
-/*
-    MOVE SFBR + 0xff TO SCRATCH1 WITH CARRY
-
-at 0x000001c1 : */	0x6f35ff00,0x00000000,
-/*
-    MOVE DSA2 TO SFBR
-
-at 0x000001c3 : */	0x72120000,0x00000000,
-/*
-    MOVE SFBR + 0xff TO SCRATCH2 WITH CARRY
-
-at 0x000001c5 : */	0x6f36ff00,0x00000000,
-/*
-    MOVE DSA3 TO SFBR
-
-at 0x000001c7 : */	0x72130000,0x00000000,
-/*
-    MOVE SFBR + 0xff TO SCRATCH3 WITH CARRY
-
-at 0x000001c9 : */	0x6f37ff00,0x00000000,
-/*
-
-    MOVE dmode_ncr_to_memory TO DMODE
-
-at 0x000001cb : */	0x78380000,0x00000000,
-/*
-    MOVE MEMORY 4, addr_scratch, reselected_check + 4
-
-at 0x000001cd : */	0xc0000004,0x00000000,0x0000074c,
-/*
-    MOVE dmode_memory_to_memory TO DMODE
-
-at 0x000001d0 : */	0x78380000,0x00000000,
-/*
-reselected_check:
-    JUMP 0
-
-at 0x000001d2 : */	0x80080000,0x00000000,
-/*
-
-
-;
-;
-ENTRY reselected_ok
-reselected_ok:
-    MOVE MEMORY 4, 0, 0				; Patched : first word
-
-at 0x000001d4 : */	0xc0000004,0x00000000,0x00000000,
-/*
-						; 	is address of 
-						;       successful dsa_next
-						; Second word is last 
-						;	unsuccessful dsa_next,
-						;	starting with 
-						;       dsa_reconnect_head
-    ; We used to CLEAR ACK here.
-
-
-
-
-
-
-    RETURN					; Return control to where
-
-at 0x000001d7 : */	0x90080000,0x00000000,
-/*
-
-
-
-
-selected:
-    INT int_err_selected;
-
-at 0x000001d9 : */	0x98080000,0x00010000,
-/*
-
-;
-; A select or reselect failure can be caused by one of two conditions : 
-; 1.  SIG_P was set.  This will be the case if the user has written
-;	a new value to a previously NULL head of the issue queue.
-;
-; 2.  The NCR53c810 was selected or reselected by another device.
-;
-; 3.  The bus was already busy since we were selected or reselected
-;	before starting the command.
-
-wait_reselect_failed:
-
-
-
-; Check selected bit.  
-    MOVE SIST0 & 0x20 TO SFBR
-
-at 0x000001db : */	0x74422000,0x00000000,
-/*
-    JUMP selected, IF 0x20
-
-at 0x000001dd : */	0x800c0020,0x00000764,
-/*
-; Reading CTEST2 clears the SIG_P bit in the ISTAT register.
-    MOVE CTEST2 & 0x40 TO SFBR	
-
-at 0x000001df : */	0x741a4000,0x00000000,
-/*
-    JUMP schedule, IF 0x40
-
-at 0x000001e1 : */	0x800c0040,0x00000000,
-/*
-; Check connected bit.  
-; FIXME: this needs to change if we support target mode
-    MOVE ISTAT & 0x08 TO SFBR
-
-at 0x000001e3 : */	0x74140800,0x00000000,
-/*
-    JUMP reselected, IF 0x08
-
-at 0x000001e5 : */	0x800c0008,0x0000065c,
-/*
-; FIXME : Something bogus happened, and we shouldn't fail silently.
-
-
-
-    INT int_debug_panic
-
-at 0x000001e7 : */	0x98080000,0x030b0000,
-/*
-
-
-
-select_failed:
-
-
-
-; Otherwise, mask the selected and reselected bits off SIST0
-    MOVE SIST0 & 0x30 TO SFBR
-
-at 0x000001e9 : */	0x74423000,0x00000000,
-/*
-    JUMP selected, IF 0x20
-
-at 0x000001eb : */	0x800c0020,0x00000764,
-/*
-    JUMP reselected, IF 0x10 
-
-at 0x000001ed : */	0x800c0010,0x0000065c,
-/*
-; If SIGP is set, the user just gave us another command, and
-; we should restart or return to the scheduler.
-; Reading CTEST2 clears the SIG_P bit in the ISTAT register.
-    MOVE CTEST2 & 0x40 TO SFBR	
-
-at 0x000001ef : */	0x741a4000,0x00000000,
-/*
-    JUMP select, IF 0x40
-
-at 0x000001f1 : */	0x800c0040,0x000001fc,
-/*
-; Check connected bit.  
-; FIXME: this needs to change if we support target mode
-; FIXME: is this really necessary? 
-    MOVE ISTAT & 0x08 TO SFBR
-
-at 0x000001f3 : */	0x74140800,0x00000000,
-/*
-    JUMP reselected, IF 0x08
-
-at 0x000001f5 : */	0x800c0008,0x0000065c,
-/*
-; FIXME : Something bogus happened, and we shouldn't fail silently.
-
-
-
-    INT int_debug_panic
-
-at 0x000001f7 : */	0x98080000,0x030b0000,
-/*
-
-
-;
-; test_1
-; test_2
-;
-; PURPOSE : run some verification tests on the NCR.  test_1
-;	copies test_src to test_dest and interrupts the host
-;	processor, testing for cache coherency and interrupt
-; 	problems in the processes.
-;
-;	test_2 runs a command with offsets relative to the 
-;	DSA on entry, and is useful for miscellaneous experimentation.
-;
-
-; Verify that interrupts are working correctly and that we don't 
-; have a cache invalidation problem.
-
-ABSOLUTE test_src = 0, test_dest = 0
-ENTRY test_1
-test_1:
-    MOVE MEMORY 4, test_src, test_dest
-
-at 0x000001f9 : */	0xc0000004,0x00000000,0x00000000,
-/*
-    INT int_test_1
-
-at 0x000001fc : */	0x98080000,0x04000000,
-/*
-
-;
-; Run arbitrary commands, with test code establishing a DSA
-;
- 
-ENTRY test_2
-test_2:
-    CLEAR TARGET
-
-at 0x000001fe : */	0x60000200,0x00000000,
-/*
-    SELECT ATN FROM 0, test_2_fail
-
-at 0x00000200 : */	0x43000000,0x00000850,
-/*
-    JUMP test_2_msgout, WHEN MSG_OUT
-
-at 0x00000202 : */	0x860b0000,0x00000810,
-/*
-ENTRY test_2_msgout
-test_2_msgout:
-    MOVE FROM 8, WHEN MSG_OUT
-
-at 0x00000204 : */	0x1e000000,0x00000008,
-/*
-    MOVE FROM 16, WHEN CMD 
-
-at 0x00000206 : */	0x1a000000,0x00000010,
-/*
-    MOVE FROM 24, WHEN DATA_IN
-
-at 0x00000208 : */	0x19000000,0x00000018,
-/*
-    MOVE FROM 32, WHEN STATUS
-
-at 0x0000020a : */	0x1b000000,0x00000020,
-/*
-    MOVE FROM 40, WHEN MSG_IN
-
-at 0x0000020c : */	0x1f000000,0x00000028,
-/*
-    MOVE SCNTL2 & 0x7f TO SCNTL2
-
-at 0x0000020e : */	0x7c027f00,0x00000000,
-/*
-    CLEAR ACK
-
-at 0x00000210 : */	0x60000040,0x00000000,
-/*
-    WAIT DISCONNECT
-
-at 0x00000212 : */	0x48000000,0x00000000,
-/*
-test_2_fail:
-    INT int_test_2
-
-at 0x00000214 : */	0x98080000,0x04010000,
-/*
-
-ENTRY debug_break
-debug_break:
-    INT int_debug_break
-
-at 0x00000216 : */	0x98080000,0x03000000,
-/*
-
-;
-; initiator_abort
-; target_abort
-;
-; PURPOSE : Abort the currently established nexus from with initiator
-;	or target mode.
-;
-;  
-
-ENTRY target_abort
-target_abort:
-    SET TARGET
-
-at 0x00000218 : */	0x58000200,0x00000000,
-/*
-    DISCONNECT
-
-at 0x0000021a : */	0x48000000,0x00000000,
-/*
-    CLEAR TARGET
-
-at 0x0000021c : */	0x60000200,0x00000000,
-/*
-    JUMP schedule
-
-at 0x0000021e : */	0x80080000,0x00000000,
-/*
-    
-ENTRY initiator_abort
-initiator_abort:
-    SET ATN
-
-at 0x00000220 : */	0x58000008,0x00000000,
-/*
-;
-; The SCSI-I specification says that targets may go into MSG out at 
-; their leisure upon receipt of the ATN single.  On all versions of the 
-; specification, we can't change phases until REQ transitions true->false, 
-; so we need to sink/source one byte of data to allow the transition.
-;
-; For the sake of safety, we'll only source one byte of data in all 
-; cases, but to accommodate the SCSI-I dain bramage, we'll sink an  
-; arbitrary number of bytes.
-    JUMP spew_cmd, WHEN CMD
-
-at 0x00000222 : */	0x820b0000,0x000008b8,
-/*
-    JUMP eat_msgin, WHEN MSG_IN
-
-at 0x00000224 : */	0x870b0000,0x000008c8,
-/*
-    JUMP eat_datain, WHEN DATA_IN
-
-at 0x00000226 : */	0x810b0000,0x000008f8,
-/*
-    JUMP eat_status, WHEN STATUS
-
-at 0x00000228 : */	0x830b0000,0x000008e0,
-/*
-    JUMP spew_dataout, WHEN DATA_OUT
-
-at 0x0000022a : */	0x800b0000,0x00000910,
-/*
-    JUMP sated
-
-at 0x0000022c : */	0x80080000,0x00000918,
-/*
-spew_cmd:
-    MOVE 1, NCR53c7xx_zero, WHEN CMD
-
-at 0x0000022e : */	0x0a000001,0x00000000,
-/*
-    JUMP sated
-
-at 0x00000230 : */	0x80080000,0x00000918,
-/*
-eat_msgin:
-    MOVE 1, NCR53c7xx_sink, WHEN MSG_IN
-
-at 0x00000232 : */	0x0f000001,0x00000000,
-/*
-    JUMP eat_msgin, WHEN MSG_IN
-
-at 0x00000234 : */	0x870b0000,0x000008c8,
-/*
-    JUMP sated
-
-at 0x00000236 : */	0x80080000,0x00000918,
-/*
-eat_status:
-    MOVE 1, NCR53c7xx_sink, WHEN STATUS
-
-at 0x00000238 : */	0x0b000001,0x00000000,
-/*
-    JUMP eat_status, WHEN STATUS
-
-at 0x0000023a : */	0x830b0000,0x000008e0,
-/*
-    JUMP sated
-
-at 0x0000023c : */	0x80080000,0x00000918,
-/*
-eat_datain:
-    MOVE 1, NCR53c7xx_sink, WHEN DATA_IN
-
-at 0x0000023e : */	0x09000001,0x00000000,
-/*
-    JUMP eat_datain, WHEN DATA_IN
-
-at 0x00000240 : */	0x810b0000,0x000008f8,
-/*
-    JUMP sated
-
-at 0x00000242 : */	0x80080000,0x00000918,
-/*
-spew_dataout:
-    MOVE 1, NCR53c7xx_zero, WHEN DATA_OUT
-
-at 0x00000244 : */	0x08000001,0x00000000,
-/*
-sated:
-    MOVE SCNTL2 & 0x7f TO SCNTL2
-
-at 0x00000246 : */	0x7c027f00,0x00000000,
-/*
-    MOVE 1, NCR53c7xx_msg_abort, WHEN MSG_OUT
-
-at 0x00000248 : */	0x0e000001,0x00000000,
-/*
-    WAIT DISCONNECT
-
-at 0x0000024a : */	0x48000000,0x00000000,
-/*
-    INT int_norm_aborted
-
-at 0x0000024c : */	0x98080000,0x02040000,
-/*
-
-;
-; dsa_to_scratch
-; scratch_to_dsa
-;
-; PURPOSE :
-; 	The NCR chips cannot do a move memory instruction with the DSA register 
-; 	as the source or destination.  So, we provide a couple of subroutines
-; 	that let us switch between the DSA register and scratch register.
-;
-; 	Memory moves to/from the DSPS  register also don't work, but we 
-; 	don't use them.
-;
-;
-
- 
-dsa_to_scratch:
-    MOVE DSA0 TO SFBR
-
-at 0x0000024e : */	0x72100000,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH0
-
-at 0x00000250 : */	0x6a340000,0x00000000,
-/*
-    MOVE DSA1 TO SFBR
-
-at 0x00000252 : */	0x72110000,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH1
-
-at 0x00000254 : */	0x6a350000,0x00000000,
-/*
-    MOVE DSA2 TO SFBR
-
-at 0x00000256 : */	0x72120000,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH2
-
-at 0x00000258 : */	0x6a360000,0x00000000,
-/*
-    MOVE DSA3 TO SFBR
-
-at 0x0000025a : */	0x72130000,0x00000000,
-/*
-    MOVE SFBR TO SCRATCH3
-
-at 0x0000025c : */	0x6a370000,0x00000000,
-/*
-    RETURN
-
-at 0x0000025e : */	0x90080000,0x00000000,
-/*
-
-scratch_to_dsa:
-    MOVE SCRATCH0 TO SFBR
-
-at 0x00000260 : */	0x72340000,0x00000000,
-/*
-    MOVE SFBR TO DSA0
-
-at 0x00000262 : */	0x6a100000,0x00000000,
-/*
-    MOVE SCRATCH1 TO SFBR
-
-at 0x00000264 : */	0x72350000,0x00000000,
-/*
-    MOVE SFBR TO DSA1
-
-at 0x00000266 : */	0x6a110000,0x00000000,
-/*
-    MOVE SCRATCH2 TO SFBR
-
-at 0x00000268 : */	0x72360000,0x00000000,
-/*
-    MOVE SFBR TO DSA2
-
-at 0x0000026a : */	0x6a120000,0x00000000,
-/*
-    MOVE SCRATCH3 TO SFBR
-
-at 0x0000026c : */	0x72370000,0x00000000,
-/*
-    MOVE SFBR TO DSA3
-
-at 0x0000026e : */	0x6a130000,0x00000000,
-/*
-    RETURN
-
-at 0x00000270 : */	0x90080000,0x00000000,
-};
-
-#define A_NCR53c7xx_msg_abort	0x00000000
-static u32 A_NCR53c7xx_msg_abort_used[] __attribute((unused)) = {
-	0x00000249,
-};
-
-#define A_NCR53c7xx_msg_reject	0x00000000
-static u32 A_NCR53c7xx_msg_reject_used[] __attribute((unused)) = {
-	0x00000172,
-};
-
-#define A_NCR53c7xx_sink	0x00000000
-static u32 A_NCR53c7xx_sink_used[] __attribute((unused)) = {
-	0x00000233,
-	0x00000239,
-	0x0000023f,
-};
-
-#define A_NCR53c7xx_zero	0x00000000
-static u32 A_NCR53c7xx_zero_used[] __attribute((unused)) = {
-	0x0000022f,
-	0x00000245,
-};
-
-#define A_NOP_insn	0x00000000
-static u32 A_NOP_insn_used[] __attribute((unused)) = {
-	0x00000010,
-};
-
-#define A_addr_reconnect_dsa_head	0x00000000
-static u32 A_addr_reconnect_dsa_head_used[] __attribute((unused)) = {
-	0x000001a7,
-};
-
-#define A_addr_scratch	0x00000000
-static u32 A_addr_scratch_used[] __attribute((unused)) = {
-	0x00000004,
-	0x0000001b,
-	0x00000046,
-	0x00000067,
-	0x00000073,
-	0x000000b0,
-	0x000000c6,
-	0x00000128,
-	0x00000141,
-	0x000001a1,
-	0x000001ce,
-};
-
-#define A_addr_temp	0x00000000
-static u32 A_addr_temp_used[] __attribute((unused)) = {
-	0x00000025,
-	0x00000034,
-};
-
-#define A_dmode_memory_to_memory	0x00000000
-static u32 A_dmode_memory_to_memory_used[] __attribute((unused)) = {
-	0x00000005,
-	0x0000001c,
-	0x00000027,
-	0x00000035,
-	0x00000047,
-	0x00000069,
-	0x00000075,
-	0x000000b2,
-	0x000000c8,
-	0x0000012a,
-	0x00000143,
-	0x00000199,
-	0x000001a2,
-	0x000001d0,
-};
-
-#define A_dmode_memory_to_ncr	0x00000000
-static u32 A_dmode_memory_to_ncr_used[] __attribute((unused)) = {
-	0x00000000,
-	0x00000017,
-	0x00000030,
-	0x00000042,
-	0x0000019d,
-};
-
-#define A_dmode_ncr_to_memory	0x00000000
-static u32 A_dmode_ncr_to_memory_used[] __attribute((unused)) = {
-	0x00000022,
-	0x00000064,
-	0x00000070,
-	0x000000ad,
-	0x000000c3,
-	0x00000125,
-	0x0000013e,
-	0x000001cb,
-};
-
-#define A_dsa_check_reselect	0x00000000
-static u32 A_dsa_check_reselect_used[] __attribute((unused)) = {
-	0x000001bd,
-};
-
-#define A_dsa_cmdout	0x00000048
-static u32 A_dsa_cmdout_used[] __attribute((unused)) = {
-	0x00000094,
-};
-
-#define A_dsa_cmnd	0x00000038
-static u32 A_dsa_cmnd_used[] __attribute((unused)) = {
-};
-
-#define A_dsa_datain	0x00000054
-static u32 A_dsa_datain_used[] __attribute((unused)) = {
-	0x000000bb,
-};
-
-#define A_dsa_dataout	0x00000050
-static u32 A_dsa_dataout_used[] __attribute((unused)) = {
-	0x000000a5,
-};
-
-#define A_dsa_end	0x00000070
-static u32 A_dsa_end_used[] __attribute((unused)) = {
-};
-
-#define A_dsa_fields_start	0x00000000
-static u32 A_dsa_fields_start_used[] __attribute((unused)) = {
-};
-
-#define A_dsa_msgin	0x00000058
-static u32 A_dsa_msgin_used[] __attribute((unused)) = {
-	0x00000188,
-};
-
-#define A_dsa_msgout	0x00000040
-static u32 A_dsa_msgout_used[] __attribute((unused)) = {
-	0x00000086,
-};
-
-#define A_dsa_msgout_other	0x00000068
-static u32 A_dsa_msgout_other_used[] __attribute((unused)) = {
-	0x00000180,
-};
-
-#define A_dsa_next	0x00000030
-static u32 A_dsa_next_used[] __attribute((unused)) = {
-	0x0000005c,
-};
-
-#define A_dsa_restore_pointers	0x00000000
-static u32 A_dsa_restore_pointers_used[] __attribute((unused)) = {
-	0x0000012e,
-};
-
-#define A_dsa_save_data_pointer	0x00000000
-static u32 A_dsa_save_data_pointer_used[] __attribute((unused)) = {
-	0x00000115,
-};
-
-#define A_dsa_select	0x0000003c
-static u32 A_dsa_select_used[] __attribute((unused)) = {
-	0x00000081,
-};
-
-#define A_dsa_status	0x00000060
-static u32 A_dsa_status_used[] __attribute((unused)) = {
-	0x00000184,
-};
-
-#define A_dsa_temp_addr_array_value	0x00000000
-static u32 A_dsa_temp_addr_array_value_used[] __attribute((unused)) = {
-};
-
-#define A_dsa_temp_addr_dsa_value	0x00000000
-static u32 A_dsa_temp_addr_dsa_value_used[] __attribute((unused)) = {
-	0x00000003,
-};
-
-#define A_dsa_temp_addr_new_value	0x00000000
-static u32 A_dsa_temp_addr_new_value_used[] __attribute((unused)) = {
-};
-
-#define A_dsa_temp_addr_next	0x00000000
-static u32 A_dsa_temp_addr_next_used[] __attribute((unused)) = {
-	0x00000015,
-	0x0000004e,
-};
-
-#define A_dsa_temp_addr_residual	0x00000000
-static u32 A_dsa_temp_addr_residual_used[] __attribute((unused)) = {
-	0x0000002a,
-	0x00000039,
-};
-
-#define A_dsa_temp_addr_saved_pointer	0x00000000
-static u32 A_dsa_temp_addr_saved_pointer_used[] __attribute((unused)) = {
-	0x00000026,
-	0x00000033,
-};
-
-#define A_dsa_temp_addr_saved_residual	0x00000000
-static u32 A_dsa_temp_addr_saved_residual_used[] __attribute((unused)) = {
-	0x0000002b,
-	0x00000038,
-};
-
-#define A_dsa_temp_lun	0x00000000
-static u32 A_dsa_temp_lun_used[] __attribute((unused)) = {
-	0x0000004b,
-};
-
-#define A_dsa_temp_next	0x00000000
-static u32 A_dsa_temp_next_used[] __attribute((unused)) = {
-	0x0000001a,
-};
-
-#define A_dsa_temp_sync	0x00000000
-static u32 A_dsa_temp_sync_used[] __attribute((unused)) = {
-	0x00000053,
-};
-
-#define A_dsa_temp_target	0x00000000
-static u32 A_dsa_temp_target_used[] __attribute((unused)) = {
-	0x00000040,
-};
-
-#define A_int_debug_break	0x03000000
-static u32 A_int_debug_break_used[] __attribute((unused)) = {
-	0x00000217,
-};
-
-#define A_int_debug_panic	0x030b0000
-static u32 A_int_debug_panic_used[] __attribute((unused)) = {
-	0x000001e8,
-	0x000001f8,
-};
-
-#define A_int_err_check_condition	0x00030000
-static u32 A_int_err_check_condition_used[] __attribute((unused)) = {
-	0x00000194,
-};
-
-#define A_int_err_no_phase	0x00040000
-static u32 A_int_err_no_phase_used[] __attribute((unused)) = {
-};
-
-#define A_int_err_selected	0x00010000
-static u32 A_int_err_selected_used[] __attribute((unused)) = {
-	0x000001da,
-};
-
-#define A_int_err_unexpected_phase	0x00000000
-static u32 A_int_err_unexpected_phase_used[] __attribute((unused)) = {
-	0x0000008c,
-	0x00000092,
-	0x0000009a,
-	0x000000d0,
-	0x000000d4,
-	0x000000d6,
-	0x000000de,
-	0x000000e2,
-	0x000000e4,
-	0x000000ec,
-	0x000000f0,
-	0x000000f2,
-	0x000000f4,
-	0x0000014c,
-};
-
-#define A_int_err_unexpected_reselect	0x00020000
-static u32 A_int_err_unexpected_reselect_used[] __attribute((unused)) = {
-	0x000001ba,
-};
-
-#define A_int_msg_1	0x01020000
-static u32 A_int_msg_1_used[] __attribute((unused)) = {
-	0x0000010e,
-	0x00000110,
-};
-
-#define A_int_msg_sdtr	0x01010000
-static u32 A_int_msg_sdtr_used[] __attribute((unused)) = {
-	0x0000016c,
-};
-
-#define A_int_msg_wdtr	0x01000000
-static u32 A_int_msg_wdtr_used[] __attribute((unused)) = {
-	0x00000160,
-};
-
-#define A_int_norm_aborted	0x02040000
-static u32 A_int_norm_aborted_used[] __attribute((unused)) = {
-	0x0000024d,
-};
-
-#define A_int_norm_command_complete	0x02020000
-static u32 A_int_norm_command_complete_used[] __attribute((unused)) = {
-};
-
-#define A_int_norm_disconnected	0x02030000
-static u32 A_int_norm_disconnected_used[] __attribute((unused)) = {
-};
-
-#define A_int_norm_reselect_complete	0x02010000
-static u32 A_int_norm_reselect_complete_used[] __attribute((unused)) = {
-};
-
-#define A_int_norm_reset	0x02050000
-static u32 A_int_norm_reset_used[] __attribute((unused)) = {
-};
-
-#define A_int_norm_select_complete	0x02000000
-static u32 A_int_norm_select_complete_used[] __attribute((unused)) = {
-};
-
-#define A_int_test_1	0x04000000
-static u32 A_int_test_1_used[] __attribute((unused)) = {
-	0x000001fd,
-};
-
-#define A_int_test_2	0x04010000
-static u32 A_int_test_2_used[] __attribute((unused)) = {
-	0x00000215,
-};
-
-#define A_int_test_3	0x04020000
-static u32 A_int_test_3_used[] __attribute((unused)) = {
-};
-
-#define A_msg_buf	0x00000000
-static u32 A_msg_buf_used[] __attribute((unused)) = {
-	0x00000102,
-	0x0000014e,
-	0x00000158,
-	0x0000015e,
-	0x00000164,
-	0x0000016a,
-};
-
-#define A_reconnect_dsa_head	0x00000000
-static u32 A_reconnect_dsa_head_used[] __attribute((unused)) = {
-	0x0000006c,
-	0x00000074,
-	0x000001a0,
-};
-
-#define A_reselected_identify	0x00000000
-static u32 A_reselected_identify_used[] __attribute((unused)) = {
-	0x00000045,
-	0x0000019c,
-};
-
-#define A_reselected_tag	0x00000000
-static u32 A_reselected_tag_used[] __attribute((unused)) = {
-};
-
-#define A_schedule	0x00000000
-static u32 A_schedule_used[] __attribute((unused)) = {
-	0x0000007e,
-	0x00000192,
-	0x000001e2,
-	0x0000021f,
-};
-
-#define A_test_dest	0x00000000
-static u32 A_test_dest_used[] __attribute((unused)) = {
-	0x000001fb,
-};
-
-#define A_test_src	0x00000000
-static u32 A_test_src_used[] __attribute((unused)) = {
-	0x000001fa,
-};
-
-#define Ent_accept_message	0x000005d4
-#define Ent_cmdout_cmdout	0x0000024c
-#define Ent_command_complete	0x0000060c
-#define Ent_command_complete_msgin	0x0000061c
-#define Ent_data_transfer	0x00000254
-#define Ent_datain_to_jump	0x00000328
-#define Ent_debug_break	0x00000858
-#define Ent_dsa_code_begin	0x00000000
-#define Ent_dsa_code_check_reselect	0x000000f8
-#define Ent_dsa_code_fix_jump	0x0000003c
-#define Ent_dsa_code_restore_pointers	0x000000c0
-#define Ent_dsa_code_save_data_pointer	0x00000088
-#define Ent_dsa_code_template	0x00000000
-#define Ent_dsa_code_template_end	0x00000168
-#define Ent_dsa_schedule	0x00000168
-#define Ent_dsa_zero	0x00000168
-#define Ent_end_data_transfer	0x0000028c
-#define Ent_initiator_abort	0x00000880
-#define Ent_msg_in	0x00000404
-#define Ent_msg_in_restart	0x000003e4
-#define Ent_other_in	0x00000374
-#define Ent_other_out	0x0000033c
-#define Ent_other_transfer	0x000003ac
-#define Ent_reject_message	0x000005b4
-#define Ent_reselected_check_next	0x000006a4
-#define Ent_reselected_ok	0x00000750
-#define Ent_respond_message	0x000005ec
-#define Ent_select	0x000001fc
-#define Ent_select_msgout	0x00000214
-#define Ent_target_abort	0x00000860
-#define Ent_test_1	0x000007e4
-#define Ent_test_2	0x000007f8
-#define Ent_test_2_msgout	0x00000810
-#define Ent_wait_reselect	0x00000654
-static u32 LABELPATCHES[] __attribute((unused)) = {
-	0x00000008,
-	0x0000000a,
-	0x00000013,
-	0x00000016,
-	0x0000001f,
-	0x00000021,
-	0x0000004f,
-	0x00000051,
-	0x0000005b,
-	0x00000068,
-	0x0000006f,
-	0x00000082,
-	0x00000084,
-	0x0000008a,
-	0x0000008e,
-	0x00000090,
-	0x00000096,
-	0x00000098,
-	0x0000009c,
-	0x0000009e,
-	0x000000a0,
-	0x000000a2,
-	0x000000a4,
-	0x000000b1,
-	0x000000b6,
-	0x000000ba,
-	0x000000c7,
-	0x000000cc,
-	0x000000d2,
-	0x000000d8,
-	0x000000da,
-	0x000000e0,
-	0x000000e6,
-	0x000000e8,
-	0x000000ee,
-	0x000000f6,
-	0x000000f8,
-	0x00000104,
-	0x00000106,
-	0x00000108,
-	0x0000010a,
-	0x0000010c,
-	0x00000112,
-	0x00000114,
-	0x00000129,
-	0x00000142,
-	0x00000148,
-	0x00000150,
-	0x00000152,
-	0x00000154,
-	0x0000015a,
-	0x00000166,
-	0x00000196,
-	0x000001a5,
-	0x000001a8,
-	0x000001ac,
-	0x000001b0,
-	0x000001b4,
-	0x000001b8,
-	0x000001cf,
-	0x000001de,
-	0x000001e6,
-	0x000001ec,
-	0x000001ee,
-	0x000001f2,
-	0x000001f6,
-	0x00000201,
-	0x00000203,
-	0x00000223,
-	0x00000225,
-	0x00000227,
-	0x00000229,
-	0x0000022b,
-	0x0000022d,
-	0x00000231,
-	0x00000235,
-	0x00000237,
-	0x0000023b,
-	0x0000023d,
-	0x00000241,
-	0x00000243,
-};
-
-static struct {
-	u32	offset;
-	void		*address;
-} EXTERNAL_PATCHES[] __attribute((unused)) = {
-};
-
-static u32 INSTRUCTIONS __attribute((unused))	= 301;
-static u32 PATCHES __attribute((unused))	= 81;
-static u32 EXTERNAL_PATCHES_LEN __attribute((unused))	= 0;
diff -Nru a/drivers/scsi/53c8xx_d.h_shipped b/drivers/scsi/53c8xx_d.h_shipped
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/scsi/53c8xx_d.h_shipped	Thu Jun 20 15:54:00 2002
@@ -0,0 +1,2678 @@
+/* DO NOT EDIT - Generated automatically by script_asm.pl */
+static u32 SCRIPT[] = {
+/*
+
+
+; NCR 53c810 driver, main script
+; Sponsored by 
+;	iX Multiuser Multitasking Magazine
+;	hm@ix.de
+;
+; Copyright 1993, 1994, 1995 Drew Eckhardt
+;      Visionary Computing 
+;      (Unix and Linux consulting and custom programming)
+;      drew@PoohSticks.ORG
+;      +1 (303) 786-7975
+;
+; TolerANT and SCSI SCRIPTS are registered trademarks of NCR Corporation.
+;
+; PRE-ALPHA
+;
+; For more information, please consult 
+;
+; NCR 53C810
+; PCI-SCSI I/O Processor
+; Data Manual
+;
+; NCR 53C710 
+; SCSI I/O Processor
+; Programmers Guide
+;
+; NCR Microelectronics
+; 1635 Aeroplaza Drive
+; Colorado Springs, CO 80916
+; 1+ (719) 578-3400
+;
+; Toll free literature number
+; +1 (800) 334-5454
+;
+; IMPORTANT : This code is self modifying due to the limitations of 
+;	the NCR53c7,8xx series chips.  Persons debugging this code with
+;	the remote debugger should take this into account, and NOT set
+;	breakpoints in modified instructions.
+;
+; Design:
+; The NCR53c7,8xx family of SCSI chips are busmasters with an onboard 
+; microcontroller using a simple instruction set.   
+;
+; So, to minimize the effects of interrupt latency, and to maximize 
+; throughput, this driver offloads the practical maximum amount 
+; of processing to the SCSI chip while still maintaining a common
+; structure.
+;
+; Where tradeoffs were needed between efficiency on the older
+; chips and the newer NCR53c800 series, the NCR53c800 series 
+; was chosen.
+;
+; While the NCR53c700 and NCR53c700-66 lacked the facilities to fully
+; automate SCSI transfers without host processor intervention, this 
+; isn't the case with the NCR53c710 and newer chips which allow 
+;
+; - reads and writes to the internal registers from within the SCSI
+; 	scripts, allowing the SCSI SCRIPTS(tm) code to save processor
+; 	state so that multiple threads of execution are possible, and also
+; 	provide an ALU for loop control, etc.
+; 
+; - table indirect addressing for some instructions. This allows 
+;	pointers to be located relative to the DSA ((Data Structure
+;	Address) register.
+;
+; These features make it possible to implement a mailbox style interface,
+; where the same piece of code is run to handle I/O for multiple threads
+; at once minimizing our need to relocate code.  Since the NCR53c700/
+; NCR53c800 series have a unique combination of features, making a 
+; a standard ingoing/outgoing mailbox system, costly, I've modified it.
+;
+; - Mailboxes are a mixture of code and data.  This lets us greatly
+; 	simplify the NCR53c810 code and do things that would otherwise
+;	not be possible.
+;
+; The saved data pointer is now implemented as follows :
+;
+; 	Control flow has been architected such that if control reaches
+;	munge_save_data_pointer, on a restore pointers message or 
+;	reconnection, a jump to the address formerly in the TEMP register
+;	will allow the SCSI command to resume execution.
+;
+
+;
+; Note : the DSA structures must be aligned on 32 bit boundaries,
+; since the source and destination of MOVE MEMORY instructions 
+; must share the same alignment and this is the alignment of the
+; NCR registers.
+;
+
+ABSOLUTE dsa_temp_lun = 0		; Patch to lun for current dsa
+ABSOLUTE dsa_temp_next = 0		; Patch to dsa next for current dsa
+ABSOLUTE dsa_temp_addr_next = 0		; Patch to address of dsa next address 
+					; 	for current dsa
+ABSOLUTE dsa_temp_sync = 0		; Patch to address of per-target
+					;	sync routine
+ABSOLUTE dsa_temp_target = 0		; Patch to id for current dsa
+ABSOLUTE dsa_temp_addr_saved_pointer = 0; Patch to address of per-command
+					; 	saved data pointer
+ABSOLUTE dsa_temp_addr_residual = 0	; Patch to address of per-command
+					;	current residual code
+ABSOLUTE dsa_temp_addr_saved_residual = 0; Patch to address of per-command
+					; saved residual code
+ABSOLUTE dsa_temp_addr_new_value = 0	; Address of value for JUMP operand
+ABSOLUTE dsa_temp_addr_array_value = 0 	; Address to copy to
+ABSOLUTE dsa_temp_addr_dsa_value = 0	; Address of this DSA value
+
+;
+; Once a device has initiated reselection, we need to compare it 
+; against the singly linked list of commands which have disconnected
+; and are pending reselection.  These commands are maintained in 
+; an unordered singly linked list of DSA structures, through the
+; DSA pointers at their 'centers' headed by the reconnect_dsa_head
+; pointer.
+; 
+; To avoid complications in removing commands from the list,
+; I minimize the amount of expensive (at eight operations per
+; addition @ 500-600ns each) pointer operations which must
+; be done in the NCR driver by precomputing them on the 
+; host processor during dsa structure generation.
+;
+; The fixed-up per DSA code knows how to recognize the nexus
+; associated with the corresponding SCSI command, and modifies
+; the source and destination pointers for the MOVE MEMORY 
+; instruction which is executed when reselected_ok is called
+; to remove the command from the list.  Similarly, DSA is 
+; loaded with the address of the next DSA structure and
+; reselected_check_next is called if a failure occurs.
+;
+; Perhaps more concisely, the net effect of the mess is 
+;
+; for (dsa = reconnect_dsa_head, dest = &reconnect_dsa_head, 
+;     src = NULL; dsa; dest = &dsa->next, dsa = dsa->next) {
+; 	src = &dsa->next;
+; 	if (target_id == dsa->id && target_lun == dsa->lun) {
+; 		*dest = *src;
+; 		break;
+;         }	
+; }
+;
+; if (!dsa)
+;           error (int_err_unexpected_reselect);
+; else  
+;     longjmp (dsa->jump_resume, 0);
+;
+; 	
+
+
+; Define DSA structure used for mailboxes
+ENTRY dsa_code_template
+dsa_code_template:
+ENTRY dsa_code_begin
+dsa_code_begin:
+	MOVE dmode_memory_to_ncr TO DMODE
+
+at 0x00000000 : */	0x78380000,0x00000000,
+/*
+	MOVE MEMORY 4, dsa_temp_addr_dsa_value, addr_scratch
+
+at 0x00000002 : */	0xc0000004,0x00000000,0x00000000,
+/*
+	MOVE dmode_memory_to_memory TO DMODE
+
+at 0x00000005 : */	0x78380000,0x00000000,
+/*
+	CALL scratch_to_dsa
+
+at 0x00000007 : */	0x88080000,0x00000980,
+/*
+	CALL select
+
+at 0x00000009 : */	0x88080000,0x000001fc,
+/*
+; Handle the phase mismatch which may have resulted from the 
+; MOVE FROM dsa_msgout if we returned here.  The CLEAR ATN 
+; may or may not be necessary, and we should update script_asm.pl
+; to handle multiple pieces.
+    CLEAR ATN
+
+at 0x0000000b : */	0x60000008,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x0000000d : */	0x60000040,0x00000000,
+/*
+
+; Replace second operand with address of JUMP instruction dest operand
+; in schedule table for this DSA.  Becomes dsa_jump_dest in 53c7,8xx.c.
+ENTRY dsa_code_fix_jump
+dsa_code_fix_jump:
+	MOVE MEMORY 4, NOP_insn, 0
+
+at 0x0000000f : */	0xc0000004,0x00000000,0x00000000,
+/*
+	JUMP select_done
+
+at 0x00000012 : */	0x80080000,0x00000224,
+/*
+
+; wrong_dsa loads the DSA register with the value of the dsa_next
+; field.
+;
+wrong_dsa:
+;		Patch the MOVE MEMORY INSTRUCTION such that 
+;		the destination address is the address of the OLD 
+;		next pointer.
+;
+	MOVE MEMORY 4, dsa_temp_addr_next, reselected_ok + 8
+
+at 0x00000014 : */	0xc0000004,0x00000000,0x00000758,
+/*
+	MOVE dmode_memory_to_ncr TO DMODE	
+
+at 0x00000017 : */	0x78380000,0x00000000,
+/*
+;
+; 	Move the _contents_ of the next pointer into the DSA register as 
+;	the next I_T_L or I_T_L_Q tupple to check against the established
+;	nexus.
+;
+	MOVE MEMORY 4, dsa_temp_next, addr_scratch
+
+at 0x00000019 : */	0xc0000004,0x00000000,0x00000000,
+/*
+	MOVE dmode_memory_to_memory TO DMODE
+
+at 0x0000001c : */	0x78380000,0x00000000,
+/*
+	CALL scratch_to_dsa
+
+at 0x0000001e : */	0x88080000,0x00000980,
+/*
+	JUMP reselected_check_next
+
+at 0x00000020 : */	0x80080000,0x000006a4,
+/*
+
+ABSOLUTE dsa_save_data_pointer = 0
+ENTRY dsa_code_save_data_pointer
+dsa_code_save_data_pointer:
+    	MOVE dmode_ncr_to_memory TO DMODE
+
+at 0x00000022 : */	0x78380000,0x00000000,
+/*
+    	MOVE MEMORY 4, addr_temp, dsa_temp_addr_saved_pointer
+
+at 0x00000024 : */	0xc0000004,0x00000000,0x00000000,
+/*
+    	MOVE dmode_memory_to_memory TO DMODE
+
+at 0x00000027 : */	0x78380000,0x00000000,
+/*
+; HARD CODED : 24 bytes needs to agree with 53c7,8xx.h
+    	MOVE MEMORY 24, dsa_temp_addr_residual, dsa_temp_addr_saved_residual
+
+at 0x00000029 : */	0xc0000018,0x00000000,0x00000000,
+/*
+        CLEAR ACK
+
+at 0x0000002c : */	0x60000040,0x00000000,
+/*
+
+
+
+    	RETURN
+
+at 0x0000002e : */	0x90080000,0x00000000,
+/*
+ABSOLUTE dsa_restore_pointers = 0
+ENTRY dsa_code_restore_pointers
+dsa_code_restore_pointers:
+    	MOVE dmode_memory_to_ncr TO DMODE
+
+at 0x00000030 : */	0x78380000,0x00000000,
+/*
+    	MOVE MEMORY 4, dsa_temp_addr_saved_pointer, addr_temp
+
+at 0x00000032 : */	0xc0000004,0x00000000,0x00000000,
+/*
+    	MOVE dmode_memory_to_memory TO DMODE
+
+at 0x00000035 : */	0x78380000,0x00000000,
+/*
+; HARD CODED : 24 bytes needs to agree with 53c7,8xx.h
+    	MOVE MEMORY 24, dsa_temp_addr_saved_residual, dsa_temp_addr_residual
+
+at 0x00000037 : */	0xc0000018,0x00000000,0x00000000,
+/*
+        CLEAR ACK
+
+at 0x0000003a : */	0x60000040,0x00000000,
+/*
+
+
+
+    	RETURN
+
+at 0x0000003c : */	0x90080000,0x00000000,
+/*
+
+ABSOLUTE dsa_check_reselect = 0
+; dsa_check_reselect determines whether or not the current target and
+; lun match the current DSA
+ENTRY dsa_code_check_reselect
+dsa_code_check_reselect:
+	MOVE SSID TO SFBR		; SSID contains 3 bit target ID
+
+at 0x0000003e : */	0x720a0000,0x00000000,
+/*
+; FIXME : we need to accommodate bit fielded and binary here for '7xx/'8xx chips
+	JUMP REL (wrong_dsa), IF NOT dsa_temp_target, AND MASK 0xf8
+
+at 0x00000040 : */	0x8084f800,0x00ffff48,
+/*
+;
+; Hack - move to scratch first, since SFBR is not writeable
+; 	via the CPU and hence a MOVE MEMORY instruction.
+;
+	MOVE dmode_memory_to_ncr TO DMODE
+
+at 0x00000042 : */	0x78380000,0x00000000,
+/*
+	MOVE MEMORY 1, reselected_identify, addr_scratch
+
+at 0x00000044 : */	0xc0000001,0x00000000,0x00000000,
+/*
+	MOVE dmode_memory_to_memory TO DMODE
+
+at 0x00000047 : */	0x78380000,0x00000000,
+/*
+	MOVE SCRATCH0 TO SFBR
+
+at 0x00000049 : */	0x72340000,0x00000000,
+/*
+; FIXME : we need to accommodate bit fielded and binary here for '7xx/'8xx chips
+	JUMP REL (wrong_dsa), IF NOT dsa_temp_lun, AND MASK 0xf8
+
+at 0x0000004b : */	0x8084f800,0x00ffff1c,
+/*
+;		Patch the MOVE MEMORY INSTRUCTION such that
+;		the source address is the address of this dsa's
+;		next pointer.
+	MOVE MEMORY 4, dsa_temp_addr_next, reselected_ok + 4
+
+at 0x0000004d : */	0xc0000004,0x00000000,0x00000754,
+/*
+	CALL reselected_ok
+
+at 0x00000050 : */	0x88080000,0x00000750,
+/*
+	CALL dsa_temp_sync	
+
+at 0x00000052 : */	0x88080000,0x00000000,
+/*
+; Release ACK on the IDENTIFY message _after_ we've set the synchronous 
+; transfer parameters! 
+	CLEAR ACK
+
+at 0x00000054 : */	0x60000040,0x00000000,
+/*
+; Implicitly restore pointers on reselection, so a RETURN
+; will transfer control back to the right spot.
+    	CALL REL (dsa_code_restore_pointers)
+
+at 0x00000056 : */	0x88880000,0x00ffff60,
+/*
+    	RETURN
+
+at 0x00000058 : */	0x90080000,0x00000000,
+/*
+ENTRY dsa_zero
+dsa_zero:
+ENTRY dsa_code_template_end
+dsa_code_template_end:
+
+; Perform sanity check for dsa_fields_start == dsa_code_template_end - 
+; dsa_zero, puke.
+
+ABSOLUTE dsa_fields_start =  0	; Sanity marker
+				; 	pad 48 bytes (fix this RSN)
+ABSOLUTE dsa_next = 48		; len 4 Next DSA
+ 				; del 4 Previous DSA address
+ABSOLUTE dsa_cmnd = 56		; len 4 Scsi_Cmnd * for this thread.
+ABSOLUTE dsa_select = 60	; len 4 Device ID, Period, Offset for 
+			 	;	table indirect select
+ABSOLUTE dsa_msgout = 64	; len 8 table indirect move parameter for 
+				;       select message
+ABSOLUTE dsa_cmdout = 72	; len 8 table indirect move parameter for 
+				;	command
+ABSOLUTE dsa_dataout = 80	; len 4 code pointer for dataout
+ABSOLUTE dsa_datain = 84	; len 4 code pointer for datain
+ABSOLUTE dsa_msgin = 88		; len 8 table indirect move for msgin
+ABSOLUTE dsa_status = 96 	; len 8 table indirect move for status byte
+ABSOLUTE dsa_msgout_other = 104	; len 8 table indirect for normal message out
+				; (Synchronous transfer negotiation, etc).
+ABSOLUTE dsa_end = 112
+
+ABSOLUTE schedule = 0 		; Array of JUMP dsa_begin or JUMP (next),
+				; terminated by a call to JUMP wait_reselect
+
+; Linked lists of DSA structures
+ABSOLUTE reconnect_dsa_head = 0	; Link list of DSAs which can reconnect
+ABSOLUTE addr_reconnect_dsa_head = 0 ; Address of variable containing
+				; address of reconnect_dsa_head
+
+; These select the source and destination of a MOVE MEMORY instruction
+ABSOLUTE dmode_memory_to_memory = 0x0
+ABSOLUTE dmode_memory_to_ncr = 0x0
+ABSOLUTE dmode_ncr_to_memory = 0x0
+
+ABSOLUTE addr_scratch = 0x0
+ABSOLUTE addr_temp = 0x0
+
+
+; Interrupts - 
+; MSB indicates type
+; 0	handle error condition
+; 1 	handle message 
+; 2 	handle normal condition
+; 3	debugging interrupt
+; 4 	testing interrupt 
+; Next byte indicates specific error
+
+; XXX not yet implemented, I'm not sure if I want to - 
+; Next byte indicates the routine the error occurred in
+; The LSB indicates the specific place the error occurred
+ 
+ABSOLUTE int_err_unexpected_phase = 0x00000000	; Unexpected phase encountered
+ABSOLUTE int_err_selected = 0x00010000		; SELECTED (nee RESELECTED)
+ABSOLUTE int_err_unexpected_reselect = 0x00020000 
+ABSOLUTE int_err_check_condition = 0x00030000	
+ABSOLUTE int_err_no_phase = 0x00040000
+ABSOLUTE int_msg_wdtr = 0x01000000		; WDTR message received
+ABSOLUTE int_msg_sdtr = 0x01010000		; SDTR received
+ABSOLUTE int_msg_1 = 0x01020000			; single byte special message
+						; received
+
+ABSOLUTE int_norm_select_complete = 0x02000000	; Select complete, reprogram
+						; registers.
+ABSOLUTE int_norm_reselect_complete = 0x02010000	; Nexus established
+ABSOLUTE int_norm_command_complete = 0x02020000 ; Command complete
+ABSOLUTE int_norm_disconnected = 0x02030000	; Disconnected 
+ABSOLUTE int_norm_aborted =0x02040000		; Aborted *dsa
+ABSOLUTE int_norm_reset = 0x02050000		; Generated BUS reset.
+ABSOLUTE int_debug_break = 0x03000000		; Break point
+
+ABSOLUTE int_debug_panic = 0x030b0000		; Panic driver
+
+
+ABSOLUTE int_test_1 = 0x04000000		; Test 1 complete
+ABSOLUTE int_test_2 = 0x04010000		; Test 2 complete
+ABSOLUTE int_test_3 = 0x04020000		; Test 3 complete
+
+
+; These should start with 0x05000000, with low bits incrementing for 
+; each one.
+
+
+						
+ABSOLUTE NCR53c7xx_msg_abort = 0	; Pointer to abort message
+ABSOLUTE NCR53c7xx_msg_reject = 0       ; Pointer to reject message
+ABSOLUTE NCR53c7xx_zero	= 0		; long with zero in it, use for source
+ABSOLUTE NCR53c7xx_sink = 0		; long to dump worthless data in
+ABSOLUTE NOP_insn = 0			; NOP instruction
+
+; Pointer to message, potentially multi-byte
+ABSOLUTE msg_buf = 0
+
+; Pointer to holding area for reselection information
+ABSOLUTE reselected_identify = 0
+ABSOLUTE reselected_tag = 0
+
+; Request sense command pointer, it's a 6 byte command, should
+; be constant for all commands since we always want 16 bytes of 
+; sense and we don't need to change any fields as we did under 
+; SCSI-I when we actually cared about the LUN field.
+;EXTERNAL NCR53c7xx_sense		; Request sense command
+
+
+; dsa_schedule  
+; PURPOSE : after a DISCONNECT message has been received, and pointers
+;	saved, insert the current DSA structure at the head of the 
+; 	disconnected queue and fall through to the scheduler.
+;
+; CALLS : OK
+;
+; INPUTS : dsa - current DSA structure, reconnect_dsa_head - list
+;	of disconnected commands
+;
+; MODIFIES : SCRATCH, reconnect_dsa_head
+; 
+; EXITS : always passes control to schedule
+
+ENTRY dsa_schedule
+dsa_schedule:
+
+
+
+
+;
+; Calculate the address of the next pointer within the DSA 
+; structure of the command that is currently disconnecting
+;
+    CALL dsa_to_scratch
+
+at 0x0000005a : */	0x88080000,0x00000938,
+/*
+    MOVE SCRATCH0 + dsa_next TO SCRATCH0
+
+at 0x0000005c : */	0x7e343000,0x00000000,
+/*
+    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY
+
+at 0x0000005e : */	0x7f350000,0x00000000,
+/*
+    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY
+
+at 0x00000060 : */	0x7f360000,0x00000000,
+/*
+    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY
+
+at 0x00000062 : */	0x7f370000,0x00000000,
+/*
+
+; Point the next field of this DSA structure at the current disconnected 
+; list
+    MOVE dmode_ncr_to_memory TO DMODE
+
+at 0x00000064 : */	0x78380000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, dsa_schedule_insert + 8
+
+at 0x00000066 : */	0xc0000004,0x00000000,0x000001b4,
+/*
+    MOVE dmode_memory_to_memory TO DMODE
+
+at 0x00000069 : */	0x78380000,0x00000000,
+/*
+dsa_schedule_insert:
+    MOVE MEMORY 4, reconnect_dsa_head, 0 
+
+at 0x0000006b : */	0xc0000004,0x00000000,0x00000000,
+/*
+
+; And update the head pointer.
+    CALL dsa_to_scratch
+
+at 0x0000006e : */	0x88080000,0x00000938,
+/*
+    MOVE dmode_ncr_to_memory TO DMODE	
+
+at 0x00000070 : */	0x78380000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, reconnect_dsa_head
+
+at 0x00000072 : */	0xc0000004,0x00000000,0x00000000,
+/*
+    MOVE dmode_memory_to_memory TO DMODE
+
+at 0x00000075 : */	0x78380000,0x00000000,
+/*
+
+
+    MOVE SCNTL2 & 0x7f TO SCNTL2
+
+at 0x00000077 : */	0x7c027f00,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x00000079 : */	0x60000040,0x00000000,
+/*
+
+    WAIT DISCONNECT
+
+at 0x0000007b : */	0x48000000,0x00000000,
+/*
+
+
+
+
+
+
+    JUMP schedule
+
+at 0x0000007d : */	0x80080000,0x00000000,
+/*
+
+
+;
+; select
+;
+; PURPOSE : establish a nexus for the SCSI command referenced by DSA.
+;	On success, the current DSA structure is removed from the issue 
+;	queue.  Usually, this is entered as a fall-through from schedule,
+;	although the contingent allegiance handling code will write
+;	the select entry address to the DSP to restart a command as a 
+;	REQUEST SENSE.  A message is sent (usually IDENTIFY, although
+;	additional SDTR or WDTR messages may be sent).  COMMAND OUT
+;	is handled.
+;
+; INPUTS : DSA - SCSI command, issue_dsa_head
+;
+; CALLS : NOT OK
+;
+; MODIFIES : SCRATCH, issue_dsa_head
+;
+; EXITS : on reselection or selection, go to select_failed
+;	otherwise, RETURN so control is passed back to 
+;	dsa_begin.
+;
+
+ENTRY select
+select:
+
+
+
+
+
+
+
+
+
+
+
+
+    CLEAR TARGET
+
+at 0x0000007f : */	0x60000200,0x00000000,
+/*
+
+; XXX
+;
+; In effect, SELECTION operations are backgrounded, with execution
+; continuing until code which waits for REQ or a fatal interrupt is 
+; encountered.
+;
+; So, for more performance, we could overlap the code which removes 
+; the command from the NCRs issue queue with the selection, but 
+; at this point I don't want to deal with the error recovery.
+;
+
+
+    SELECT ATN FROM dsa_select, select_failed
+
+at 0x00000081 : */	0x4300003c,0x000007a4,
+/*
+    JUMP select_msgout, WHEN MSG_OUT
+
+at 0x00000083 : */	0x860b0000,0x00000214,
+/*
+ENTRY select_msgout
+select_msgout:
+    MOVE FROM dsa_msgout, WHEN MSG_OUT
+
+at 0x00000085 : */	0x1e000000,0x00000040,
+/*
+
+
+
+
+
+
+
+
+
+
+   RETURN
+
+at 0x00000087 : */	0x90080000,0x00000000,
+/*
+
+; 
+; select_done
+; 
+; PURPOSE: continue on to normal data transfer; called as the exit 
+;	point from dsa_begin.
+;
+; INPUTS: dsa
+;
+; CALLS: OK
+;
+;
+
+select_done:
+
+
+
+
+
+
+
+; After a successful selection, we should get either a CMD phase or 
+; some transfer request negotiation message.
+
+    JUMP cmdout, WHEN CMD
+
+at 0x00000089 : */	0x820b0000,0x00000244,
+/*
+    INT int_err_unexpected_phase, WHEN NOT MSG_IN 
+
+at 0x0000008b : */	0x9f030000,0x00000000,
+/*
+
+select_msg_in:
+    CALL msg_in, WHEN MSG_IN
+
+at 0x0000008d : */	0x8f0b0000,0x00000404,
+/*
+    JUMP select_msg_in, WHEN MSG_IN
+
+at 0x0000008f : */	0x870b0000,0x00000234,
+/*
+
+cmdout:
+    INT int_err_unexpected_phase, WHEN NOT CMD
+
+at 0x00000091 : */	0x9a030000,0x00000000,
+/*
+
+
+
+ENTRY cmdout_cmdout
+cmdout_cmdout:
+
+    MOVE FROM dsa_cmdout, WHEN CMD
+
+at 0x00000093 : */	0x1a000000,0x00000048,
+/*
+
+
+
+
+;
+; data_transfer  
+; other_out
+; other_in
+; other_transfer
+;
+; PURPOSE : handle the main data transfer for a SCSI command in 
+;	several parts.  In the first part, data_transfer, DATA_IN
+;	and DATA_OUT phases are allowed, with the user provided
+;	code (usually dynamically generated based on the scatter/gather
+;	list associated with a SCSI command) called to handle these 
+;	phases.
+;
+;	After control has passed to one of the user provided 
+;	DATA_IN or DATA_OUT routines, back calls are made to 
+;	other_transfer_in or other_transfer_out to handle non-DATA IN
+;	and DATA OUT phases respectively, with the state of the active
+;	data pointer being preserved in TEMP.
+;
+;	On completion, the user code passes control to other_transfer
+;	which causes DATA_IN and DATA_OUT to result in unexpected_phase
+;	interrupts so that data overruns may be trapped.
+;
+; INPUTS : DSA - SCSI command
+;
+; CALLS : OK in data_transfer_start, not ok in other_out and other_in, ok in
+;	other_transfer
+;
+; MODIFIES : SCRATCH
+;
+; EXITS : if STATUS IN is detected, signifying command completion,
+;	the NCR jumps to command_complete.  If MSG IN occurs, a 
+;	CALL is made to msg_in.  Otherwise, other_transfer runs in 
+;	an infinite loop.
+;	
+
+ENTRY data_transfer
+data_transfer:
+    JUMP cmdout_cmdout, WHEN CMD
+
+at 0x00000095 : */	0x820b0000,0x0000024c,
+/*
+    CALL msg_in, WHEN MSG_IN
+
+at 0x00000097 : */	0x8f0b0000,0x00000404,
+/*
+    INT int_err_unexpected_phase, WHEN MSG_OUT
+
+at 0x00000099 : */	0x9e0b0000,0x00000000,
+/*
+    JUMP do_dataout, WHEN DATA_OUT
+
+at 0x0000009b : */	0x800b0000,0x0000028c,
+/*
+    JUMP do_datain, WHEN DATA_IN
+
+at 0x0000009d : */	0x810b0000,0x000002e4,
+/*
+    JUMP command_complete, WHEN STATUS
+
+at 0x0000009f : */	0x830b0000,0x0000060c,
+/*
+    JUMP data_transfer
+
+at 0x000000a1 : */	0x80080000,0x00000254,
+/*
+ENTRY end_data_transfer
+end_data_transfer:
+
+;
+; FIXME: On NCR53c700 and NCR53c700-66 chips, do_dataout/do_datain 
+; should be fixed up whenever the nexus changes so it can point to the 
+; correct routine for that command.
+;
+
+
+; Nasty jump to dsa->dataout
+do_dataout:
+    CALL dsa_to_scratch
+
+at 0x000000a3 : */	0x88080000,0x00000938,
+/*
+    MOVE SCRATCH0 + dsa_dataout TO SCRATCH0	
+
+at 0x000000a5 : */	0x7e345000,0x00000000,
+/*
+    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY 
+
+at 0x000000a7 : */	0x7f350000,0x00000000,
+/*
+    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY 
+
+at 0x000000a9 : */	0x7f360000,0x00000000,
+/*
+    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY 
+
+at 0x000000ab : */	0x7f370000,0x00000000,
+/*
+    MOVE dmode_ncr_to_memory TO DMODE
+
+at 0x000000ad : */	0x78380000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, dataout_to_jump + 4
+
+at 0x000000af : */	0xc0000004,0x00000000,0x000002d4,
+/*
+    MOVE dmode_memory_to_memory TO DMODE
+
+at 0x000000b2 : */	0x78380000,0x00000000,
+/*
+dataout_to_jump:
+    MOVE MEMORY 4, 0, dataout_jump + 4 
+
+at 0x000000b4 : */	0xc0000004,0x00000000,0x000002e0,
+/*
+dataout_jump:
+    JUMP 0
+
+at 0x000000b7 : */	0x80080000,0x00000000,
+/*
+
+; Nasty jump to dsa->dsain
+do_datain:
+    CALL dsa_to_scratch
+
+at 0x000000b9 : */	0x88080000,0x00000938,
+/*
+    MOVE SCRATCH0 + dsa_datain TO SCRATCH0	
+
+at 0x000000bb : */	0x7e345400,0x00000000,
+/*
+    MOVE SCRATCH1 + 0 TO SCRATCH1 WITH CARRY 
+
+at 0x000000bd : */	0x7f350000,0x00000000,
+/*
+    MOVE SCRATCH2 + 0 TO SCRATCH2 WITH CARRY 
+
+at 0x000000bf : */	0x7f360000,0x00000000,
+/*
+    MOVE SCRATCH3 + 0 TO SCRATCH3 WITH CARRY 
+
+at 0x000000c1 : */	0x7f370000,0x00000000,
+/*
+    MOVE dmode_ncr_to_memory TO DMODE
+
+at 0x000000c3 : */	0x78380000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, datain_to_jump + 4
+
+at 0x000000c5 : */	0xc0000004,0x00000000,0x0000032c,
+/*
+    MOVE dmode_memory_to_memory TO DMODE		
+
+at 0x000000c8 : */	0x78380000,0x00000000,
+/*
+ENTRY datain_to_jump
+datain_to_jump:
+    MOVE MEMORY 4, 0, datain_jump + 4
+
+at 0x000000ca : */	0xc0000004,0x00000000,0x00000338,
+/*
+
+
+
+datain_jump:
+    JUMP 0
+
+at 0x000000cd : */	0x80080000,0x00000000,
+/*
+
+
+
+; Note that other_out and other_in loop until a non-data phase
+; is discovered, so we only execute return statements when we
+; can go on to the next data phase block move statement.
+
+ENTRY other_out
+other_out:
+
+
+
+    INT int_err_unexpected_phase, WHEN CMD
+
+at 0x000000cf : */	0x9a0b0000,0x00000000,
+/*
+    JUMP msg_in_restart, WHEN MSG_IN 
+
+at 0x000000d1 : */	0x870b0000,0x000003e4,
+/*
+    INT int_err_unexpected_phase, WHEN MSG_OUT
+
+at 0x000000d3 : */	0x9e0b0000,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN DATA_IN
+
+at 0x000000d5 : */	0x990b0000,0x00000000,
+/*
+    JUMP command_complete, WHEN STATUS
+
+at 0x000000d7 : */	0x830b0000,0x0000060c,
+/*
+    JUMP other_out, WHEN NOT DATA_OUT
+
+at 0x000000d9 : */	0x80030000,0x0000033c,
+/*
+    RETURN
+
+at 0x000000db : */	0x90080000,0x00000000,
+/*
+
+ENTRY other_in
+other_in:
+
+
+
+    INT int_err_unexpected_phase, WHEN CMD
+
+at 0x000000dd : */	0x9a0b0000,0x00000000,
+/*
+    JUMP msg_in_restart, WHEN MSG_IN 
+
+at 0x000000df : */	0x870b0000,0x000003e4,
+/*
+    INT int_err_unexpected_phase, WHEN MSG_OUT
+
+at 0x000000e1 : */	0x9e0b0000,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN DATA_OUT
+
+at 0x000000e3 : */	0x980b0000,0x00000000,
+/*
+    JUMP command_complete, WHEN STATUS
+
+at 0x000000e5 : */	0x830b0000,0x0000060c,
+/*
+    JUMP other_in, WHEN NOT DATA_IN
+
+at 0x000000e7 : */	0x81030000,0x00000374,
+/*
+    RETURN
+
+at 0x000000e9 : */	0x90080000,0x00000000,
+/*
+
+
+ENTRY other_transfer
+other_transfer:
+    INT int_err_unexpected_phase, WHEN CMD
+
+at 0x000000eb : */	0x9a0b0000,0x00000000,
+/*
+    CALL msg_in, WHEN MSG_IN
+
+at 0x000000ed : */	0x8f0b0000,0x00000404,
+/*
+    INT int_err_unexpected_phase, WHEN MSG_OUT
+
+at 0x000000ef : */	0x9e0b0000,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN DATA_OUT
+
+at 0x000000f1 : */	0x980b0000,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN DATA_IN
+
+at 0x000000f3 : */	0x990b0000,0x00000000,
+/*
+    JUMP command_complete, WHEN STATUS
+
+at 0x000000f5 : */	0x830b0000,0x0000060c,
+/*
+    JUMP other_transfer
+
+at 0x000000f7 : */	0x80080000,0x000003ac,
+/*
+
+;
+; msg_in_restart
+; msg_in
+; munge_msg
+;
+; PURPOSE : process messages from a target.  msg_in is called when the 
+;	caller hasn't read the first byte of the message.  munge_message
+;	is called when the caller has read the first byte of the message,
+;	and left it in SFBR.  msg_in_restart is called when the caller 
+;	hasn't read the first byte of the message, and wishes RETURN
+;	to transfer control back to the address of the conditional
+;	CALL instruction rather than to the instruction after it.
+;
+;	Various int_* interrupts are generated when the host system
+;	needs to intervene, as is the case with SDTR, WDTR, and
+;	INITIATE RECOVERY messages.
+;
+;	When the host system handles one of these interrupts,
+;	it can respond by reentering at reject_message, 
+;	which rejects the message and returns control to
+;	the caller of msg_in or munge_msg, accept_message
+;	which clears ACK and returns control, or reply_message
+;	which sends the message pointed to by the DSA 
+;	msgout_other table indirect field.
+;
+;	DISCONNECT messages are handled by moving the command
+;	to the reconnect_dsa_queue.
+;
+; INPUTS : DSA - SCSI COMMAND, SFBR - first byte of message (munge_msg
+;	only)
+;
+; CALLS : NO.  The TEMP register isn't backed up to allow nested calls.
+;
+; MODIFIES : SCRATCH, DSA on DISCONNECT
+;
+; EXITS : On receipt of SAVE DATA POINTER, RESTORE POINTERS,
+;	and normal return from message handlers running under
+;	Linux, control is returned to the caller.  Receipt
+;	of DISCONNECT messages pass control to dsa_schedule.
+;
+ENTRY msg_in_restart
+msg_in_restart:
+; XXX - hackish
+;
+; Since it's easier to debug changes to the statically 
+; compiled code, rather than the dynamically generated 
+; stuff, such as
+;
+; 	MOVE x, y, WHEN data_phase
+; 	CALL other_z, WHEN NOT data_phase
+; 	MOVE x, y, WHEN data_phase
+;
+; I'd like to have certain routines (notably the message handler)
+; restart on the conditional call rather than the next instruction.
+;
+; So, subtract 8 from the return address
+
+    MOVE TEMP0 + 0xf8 TO TEMP0
+
+at 0x000000f9 : */	0x7e1cf800,0x00000000,
+/*
+    MOVE TEMP1 + 0xff TO TEMP1 WITH CARRY
+
+at 0x000000fb : */	0x7f1dff00,0x00000000,
+/*
+    MOVE TEMP2 + 0xff TO TEMP2 WITH CARRY
+
+at 0x000000fd : */	0x7f1eff00,0x00000000,
+/*
+    MOVE TEMP3 + 0xff TO TEMP3 WITH CARRY
+
+at 0x000000ff : */	0x7f1fff00,0x00000000,
+/*
+
+ENTRY msg_in
+msg_in:
+    MOVE 1, msg_buf, WHEN MSG_IN
+
+at 0x00000101 : */	0x0f000001,0x00000000,
+/*
+
+munge_msg:
+    JUMP munge_extended, IF 0x01		; EXTENDED MESSAGE
+
+at 0x00000103 : */	0x800c0001,0x00000524,
+/*
+    JUMP munge_2, IF 0x20, AND MASK 0xdf	; two byte message
+
+at 0x00000105 : */	0x800cdf20,0x0000044c,
+/*
+;
+; XXX - I've seen a handful of broken SCSI devices which fail to issue
+; 	a SAVE POINTERS message before disconnecting in the middle of 
+; 	a transfer, assuming that the DATA POINTER will be implicitly 
+; 	restored.  
+;
+; Historically, I've often done an implicit save when the DISCONNECT
+; message is processed.  We may want to consider having the option of 
+; doing that here. 
+;
+    JUMP munge_save_data_pointer, IF 0x02	; SAVE DATA POINTER
+
+at 0x00000107 : */	0x800c0002,0x00000454,
+/*
+    JUMP munge_restore_pointers, IF 0x03	; RESTORE POINTERS 
+
+at 0x00000109 : */	0x800c0003,0x000004b8,
+/*
+    JUMP munge_disconnect, IF 0x04		; DISCONNECT
+
+at 0x0000010b : */	0x800c0004,0x0000051c,
+/*
+    INT int_msg_1, IF 0x07			; MESSAGE REJECT
+
+at 0x0000010d : */	0x980c0007,0x01020000,
+/*
+    INT int_msg_1, IF 0x0f			; INITIATE RECOVERY
+
+at 0x0000010f : */	0x980c000f,0x01020000,
+/*
+
+
+
+    JUMP reject_message
+
+at 0x00000111 : */	0x80080000,0x000005b4,
+/*
+
+munge_2:
+    JUMP reject_message
+
+at 0x00000113 : */	0x80080000,0x000005b4,
+/*
+;
+; The SCSI standard allows targets to recover from transient 
+; error conditions by backing up the data pointer with a 
+; RESTORE POINTERS message.  
+;	
+; So, we must save and restore the _residual_ code as well as 
+; the current instruction pointer.  Because of this messiness,
+; it is simpler to put dynamic code in the dsa for this and to
+; just do a simple jump down there. 
+;
+
+munge_save_data_pointer:
+    MOVE DSA0 + dsa_save_data_pointer TO SFBR
+
+at 0x00000115 : */	0x76100000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH0
+
+at 0x00000117 : */	0x6a340000,0x00000000,
+/*
+    MOVE DSA1 + 0xff TO SFBR WITH CARRY
+
+at 0x00000119 : */	0x7711ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH1
+
+at 0x0000011b : */	0x6a350000,0x00000000,
+/*
+    MOVE DSA2 + 0xff TO SFBR WITH CARRY 
+
+at 0x0000011d : */	0x7712ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH2
+
+at 0x0000011f : */	0x6a360000,0x00000000,
+/*
+    MOVE DSA3 + 0xff TO SFBR WITH CARRY
+
+at 0x00000121 : */	0x7713ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH3
+
+at 0x00000123 : */	0x6a370000,0x00000000,
+/*
+
+    MOVE dmode_ncr_to_memory TO DMODE
+
+at 0x00000125 : */	0x78380000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, jump_dsa_save + 4
+
+at 0x00000127 : */	0xc0000004,0x00000000,0x000004b4,
+/*
+    MOVE dmode_memory_to_memory TO DMODE
+
+at 0x0000012a : */	0x78380000,0x00000000,
+/*
+jump_dsa_save:
+    JUMP 0
+
+at 0x0000012c : */	0x80080000,0x00000000,
+/*
+
+munge_restore_pointers:
+    MOVE DSA0 + dsa_restore_pointers TO SFBR
+
+at 0x0000012e : */	0x76100000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH0
+
+at 0x00000130 : */	0x6a340000,0x00000000,
+/*
+    MOVE DSA1 + 0xff TO SFBR WITH CARRY
+
+at 0x00000132 : */	0x7711ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH1
+
+at 0x00000134 : */	0x6a350000,0x00000000,
+/*
+    MOVE DSA2 + 0xff TO SFBR WITH CARRY
+
+at 0x00000136 : */	0x7712ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH2
+
+at 0x00000138 : */	0x6a360000,0x00000000,
+/*
+    MOVE DSA3 + 0xff TO SFBR WITH CARRY
+
+at 0x0000013a : */	0x7713ff00,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH3
+
+at 0x0000013c : */	0x6a370000,0x00000000,
+/*
+
+    MOVE dmode_ncr_to_memory TO DMODE
+
+at 0x0000013e : */	0x78380000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, jump_dsa_restore + 4
+
+at 0x00000140 : */	0xc0000004,0x00000000,0x00000518,
+/*
+    MOVE dmode_memory_to_memory TO DMODE
+
+at 0x00000143 : */	0x78380000,0x00000000,
+/*
+jump_dsa_restore:
+    JUMP 0
+
+at 0x00000145 : */	0x80080000,0x00000000,
+/*
+
+
+munge_disconnect:
+
+
+
+
+
+
+
+
+
+ 
+
+
+
+
+
+
+    JUMP dsa_schedule
+
+at 0x00000147 : */	0x80080000,0x00000168,
+/*
+
+
+
+
+
+munge_extended:
+    CLEAR ACK
+
+at 0x00000149 : */	0x60000040,0x00000000,
+/*
+    INT int_err_unexpected_phase, WHEN NOT MSG_IN
+
+at 0x0000014b : */	0x9f030000,0x00000000,
+/*
+    MOVE 1, msg_buf + 1, WHEN MSG_IN
+
+at 0x0000014d : */	0x0f000001,0x00000001,
+/*
+    JUMP munge_extended_2, IF 0x02
+
+at 0x0000014f : */	0x800c0002,0x00000554,
+/*
+    JUMP munge_extended_3, IF 0x03 
+
+at 0x00000151 : */	0x800c0003,0x00000584,
+/*
+    JUMP reject_message
+
+at 0x00000153 : */	0x80080000,0x000005b4,
+/*
+
+munge_extended_2:
+    CLEAR ACK
+
+at 0x00000155 : */	0x60000040,0x00000000,
+/*
+    MOVE 1, msg_buf + 2, WHEN MSG_IN
+
+at 0x00000157 : */	0x0f000001,0x00000002,
+/*
+    JUMP reject_message, IF NOT 0x02	; Must be WDTR
+
+at 0x00000159 : */	0x80040002,0x000005b4,
+/*
+    CLEAR ACK
+
+at 0x0000015b : */	0x60000040,0x00000000,
+/*
+    MOVE 1, msg_buf + 3, WHEN MSG_IN
+
+at 0x0000015d : */	0x0f000001,0x00000003,
+/*
+    INT int_msg_wdtr
+
+at 0x0000015f : */	0x98080000,0x01000000,
+/*
+
+munge_extended_3:
+    CLEAR ACK
+
+at 0x00000161 : */	0x60000040,0x00000000,
+/*
+    MOVE 1, msg_buf + 2, WHEN MSG_IN
+
+at 0x00000163 : */	0x0f000001,0x00000002,
+/*
+    JUMP reject_message, IF NOT 0x01	; Must be SDTR
+
+at 0x00000165 : */	0x80040001,0x000005b4,
+/*
+    CLEAR ACK
+
+at 0x00000167 : */	0x60000040,0x00000000,
+/*
+    MOVE 2, msg_buf + 3, WHEN MSG_IN
+
+at 0x00000169 : */	0x0f000002,0x00000003,
+/*
+    INT int_msg_sdtr
+
+at 0x0000016b : */	0x98080000,0x01010000,
+/*
+
+ENTRY reject_message
+reject_message:
+    SET ATN
+
+at 0x0000016d : */	0x58000008,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x0000016f : */	0x60000040,0x00000000,
+/*
+    MOVE 1, NCR53c7xx_msg_reject, WHEN MSG_OUT
+
+at 0x00000171 : */	0x0e000001,0x00000000,
+/*
+    RETURN
+
+at 0x00000173 : */	0x90080000,0x00000000,
+/*
+
+ENTRY accept_message
+accept_message:
+    CLEAR ATN
+
+at 0x00000175 : */	0x60000008,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x00000177 : */	0x60000040,0x00000000,
+/*
+    RETURN
+
+at 0x00000179 : */	0x90080000,0x00000000,
+/*
+
+ENTRY respond_message
+respond_message:
+    SET ATN
+
+at 0x0000017b : */	0x58000008,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x0000017d : */	0x60000040,0x00000000,
+/*
+    MOVE FROM dsa_msgout_other, WHEN MSG_OUT
+
+at 0x0000017f : */	0x1e000000,0x00000068,
+/*
+    RETURN
+
+at 0x00000181 : */	0x90080000,0x00000000,
+/*
+
+;
+; command_complete
+;
+; PURPOSE : handle command termination when STATUS IN is detected by reading
+;	a status byte followed by a command termination message. 
+;
+;	Normal termination results in an INTFLY instruction, and 
+;	the host system can pick out which command terminated by 
+;	examining the MESSAGE and STATUS buffers of all currently 
+;	executing commands;
+;
+;	Abnormal (CHECK_CONDITION) termination results in an
+;	int_err_check_condition interrupt so that a REQUEST SENSE
+;	command can be issued out-of-order so that no other command
+;	clears the contingent allegiance condition.
+;	
+;
+; INPUTS : DSA - command	
+;
+; CALLS : OK
+;
+; EXITS : On successful termination, control is passed to schedule.
+;	On abnormal termination, the user will usually modify the 
+;	DSA fields and corresponding buffers and return control
+;	to select.
+;
+
+ENTRY command_complete
+command_complete:
+    MOVE FROM dsa_status, WHEN STATUS
+
+at 0x00000183 : */	0x1b000000,0x00000060,
+/*
+
+    MOVE SFBR TO SCRATCH0		; Save status
+
+at 0x00000185 : */	0x6a340000,0x00000000,
+/*
+
+ENTRY command_complete_msgin
+command_complete_msgin:
+    MOVE FROM dsa_msgin, WHEN MSG_IN
+
+at 0x00000187 : */	0x1f000000,0x00000058,
+/*
+; Indicate that we should be expecting a disconnect
+    MOVE SCNTL2 & 0x7f TO SCNTL2
+
+at 0x00000189 : */	0x7c027f00,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x0000018b : */	0x60000040,0x00000000,
+/*
+
+    WAIT DISCONNECT
+
+at 0x0000018d : */	0x48000000,0x00000000,
+/*
+
+;
+; The SCSI specification states that when a UNIT ATTENTION condition
+; is pending, as indicated by a CHECK CONDITION status message,
+; the target shall revert to asynchronous transfers.  Since
+; synchronous transfers parameters are maintained on a per INITIATOR/TARGET 
+; basis, and returning control to our scheduler could work on a command
+; running on another lun on that target using the old parameters, we must
+; interrupt the host processor to get them changed, or change them ourselves.
+;
+; Once SCSI-II tagged queueing is implemented, things will be even more
+; hairy, since contingent allegiance conditions exist on a per-target/lun
+; basis, and issuing a new command with a different tag would clear it.
+; In these cases, we must interrupt the host processor to get a request 
+; added to the HEAD of the queue with the request sense command, or we
+; must automatically issue the request sense command.
+
+
+
+
+
+    INTFLY
+
+at 0x0000018f : */	0x98180000,0x00000000,
+/*
+
+
+
+
+
+    JUMP schedule
+
+at 0x00000191 : */	0x80080000,0x00000000,
+/*
+command_failed:
+    INT int_err_check_condition
+
+at 0x00000193 : */	0x98080000,0x00030000,
+/*
+
+
+
+
+;
+; wait_reselect
+;
+; PURPOSE : This is essentially the idle routine, where control lands
+;	when there are no new processes to schedule.  wait_reselect
+;	waits for reselection, selection, and new commands.
+;
+;	When a successful reselection occurs, with the aid 
+;	of fixed up code in each DSA, wait_reselect walks the 
+;	reconnect_dsa_queue, asking each dsa if the target ID
+;	and LUN match its.
+;
+;	If a match is found, a call is made back to reselected_ok,
+;	which through the miracles of self modifying code, extracts
+;	the found DSA from the reconnect_dsa_queue and then 
+;	returns control to the DSAs thread of execution.
+;
+; INPUTS : NONE
+;
+; CALLS : OK
+;
+; MODIFIES : DSA,
+;
+; EXITS : On successful reselection, control is returned to the 
+;	DSA which called reselected_ok.  If the WAIT RESELECT
+;	was interrupted by a new commands arrival signaled by 
+;	SIG_P, control is passed to schedule.  If the NCR is 
+;	selected, the host system is interrupted with an 
+;	int_err_selected which is usually responded to by
+;	setting DSP to the target_abort address.
+
+ENTRY wait_reselect
+wait_reselect:
+
+
+
+
+
+
+    WAIT RESELECT wait_reselect_failed
+
+at 0x00000195 : */	0x50000000,0x0000076c,
+/*
+
+reselected:
+
+
+
+    CLEAR TARGET
+
+at 0x00000197 : */	0x60000200,0x00000000,
+/*
+    MOVE dmode_memory_to_memory TO DMODE
+
+at 0x00000199 : */	0x78380000,0x00000000,
+/*
+    ; Read all data needed to reestablish the nexus - 
+    MOVE 1, reselected_identify, WHEN MSG_IN
+
+at 0x0000019b : */	0x0f000001,0x00000000,
+/*
+    ; We used to CLEAR ACK here.
+
+
+
+
+
+    ; Point DSA at the current head of the disconnected queue.
+    MOVE dmode_memory_to_ncr  TO DMODE
+
+at 0x0000019d : */	0x78380000,0x00000000,
+/*
+    MOVE MEMORY 4, reconnect_dsa_head, addr_scratch
+
+at 0x0000019f : */	0xc0000004,0x00000000,0x00000000,
+/*
+    MOVE dmode_memory_to_memory TO DMODE
+
+at 0x000001a2 : */	0x78380000,0x00000000,
+/*
+    CALL scratch_to_dsa
+
+at 0x000001a4 : */	0x88080000,0x00000980,
+/*
+
+    ; Fix the update-next pointer so that the reconnect_dsa_head
+    ; pointer is the one that will be updated if this DSA is a hit 
+    ; and we remove it from the queue.
+
+    MOVE MEMORY 4, addr_reconnect_dsa_head, reselected_ok + 8
+
+at 0x000001a6 : */	0xc0000004,0x00000000,0x00000758,
+/*
+
+ENTRY reselected_check_next
+reselected_check_next:
+
+
+
+    ; Check for a NULL pointer.
+    MOVE DSA0 TO SFBR
+
+at 0x000001a9 : */	0x72100000,0x00000000,
+/*
+    JUMP reselected_not_end, IF NOT 0
+
+at 0x000001ab : */	0x80040000,0x000006ec,
+/*
+    MOVE DSA1 TO SFBR
+
+at 0x000001ad : */	0x72110000,0x00000000,
+/*
+    JUMP reselected_not_end, IF NOT 0
+
+at 0x000001af : */	0x80040000,0x000006ec,
+/*
+    MOVE DSA2 TO SFBR
+
+at 0x000001b1 : */	0x72120000,0x00000000,
+/*
+    JUMP reselected_not_end, IF NOT 0
+
+at 0x000001b3 : */	0x80040000,0x000006ec,
+/*
+    MOVE DSA3 TO SFBR
+
+at 0x000001b5 : */	0x72130000,0x00000000,
+/*
+    JUMP reselected_not_end, IF NOT 0
+
+at 0x000001b7 : */	0x80040000,0x000006ec,
+/*
+    INT int_err_unexpected_reselect
+
+at 0x000001b9 : */	0x98080000,0x00020000,
+/*
+
+reselected_not_end:
+    ;
+    ; XXX the ALU is only eight bits wide, and the assembler
+    ; wont do the dirt work for us.  As long as dsa_check_reselect
+    ; is negative, we need to sign extend with 1 bits to the full
+    ; 32 bit width of the address.
+    ;
+    ; A potential work around would be to have a known alignment 
+    ; of the DSA structure such that the base address plus 
+    ; dsa_check_reselect doesn't require carrying from bytes 
+    ; higher than the LSB.
+    ;
+
+    MOVE DSA0 TO SFBR
+
+at 0x000001bb : */	0x72100000,0x00000000,
+/*
+    MOVE SFBR + dsa_check_reselect TO SCRATCH0
+
+at 0x000001bd : */	0x6e340000,0x00000000,
+/*
+    MOVE DSA1 TO SFBR
+
+at 0x000001bf : */	0x72110000,0x00000000,
+/*
+    MOVE SFBR + 0xff TO SCRATCH1 WITH CARRY
+
+at 0x000001c1 : */	0x6f35ff00,0x00000000,
+/*
+    MOVE DSA2 TO SFBR
+
+at 0x000001c3 : */	0x72120000,0x00000000,
+/*
+    MOVE SFBR + 0xff TO SCRATCH2 WITH CARRY
+
+at 0x000001c5 : */	0x6f36ff00,0x00000000,
+/*
+    MOVE DSA3 TO SFBR
+
+at 0x000001c7 : */	0x72130000,0x00000000,
+/*
+    MOVE SFBR + 0xff TO SCRATCH3 WITH CARRY
+
+at 0x000001c9 : */	0x6f37ff00,0x00000000,
+/*
+
+    MOVE dmode_ncr_to_memory TO DMODE
+
+at 0x000001cb : */	0x78380000,0x00000000,
+/*
+    MOVE MEMORY 4, addr_scratch, reselected_check + 4
+
+at 0x000001cd : */	0xc0000004,0x00000000,0x0000074c,
+/*
+    MOVE dmode_memory_to_memory TO DMODE
+
+at 0x000001d0 : */	0x78380000,0x00000000,
+/*
+reselected_check:
+    JUMP 0
+
+at 0x000001d2 : */	0x80080000,0x00000000,
+/*
+
+
+;
+;
+ENTRY reselected_ok
+reselected_ok:
+    MOVE MEMORY 4, 0, 0				; Patched : first word
+
+at 0x000001d4 : */	0xc0000004,0x00000000,0x00000000,
+/*
+						; 	is address of 
+						;       successful dsa_next
+						; Second word is last 
+						;	unsuccessful dsa_next,
+						;	starting with 
+						;       dsa_reconnect_head
+    ; We used to CLEAR ACK here.
+
+
+
+
+
+
+    RETURN					; Return control to where
+
+at 0x000001d7 : */	0x90080000,0x00000000,
+/*
+
+
+
+
+selected:
+    INT int_err_selected;
+
+at 0x000001d9 : */	0x98080000,0x00010000,
+/*
+
+;
+; A select or reselect failure can be caused by one of two conditions : 
+; 1.  SIG_P was set.  This will be the case if the user has written
+;	a new value to a previously NULL head of the issue queue.
+;
+; 2.  The NCR53c810 was selected or reselected by another device.
+;
+; 3.  The bus was already busy since we were selected or reselected
+;	before starting the command.
+
+wait_reselect_failed:
+
+
+
+; Check selected bit.  
+    MOVE SIST0 & 0x20 TO SFBR
+
+at 0x000001db : */	0x74422000,0x00000000,
+/*
+    JUMP selected, IF 0x20
+
+at 0x000001dd : */	0x800c0020,0x00000764,
+/*
+; Reading CTEST2 clears the SIG_P bit in the ISTAT register.
+    MOVE CTEST2 & 0x40 TO SFBR	
+
+at 0x000001df : */	0x741a4000,0x00000000,
+/*
+    JUMP schedule, IF 0x40
+
+at 0x000001e1 : */	0x800c0040,0x00000000,
+/*
+; Check connected bit.  
+; FIXME: this needs to change if we support target mode
+    MOVE ISTAT & 0x08 TO SFBR
+
+at 0x000001e3 : */	0x74140800,0x00000000,
+/*
+    JUMP reselected, IF 0x08
+
+at 0x000001e5 : */	0x800c0008,0x0000065c,
+/*
+; FIXME : Something bogus happened, and we shouldn't fail silently.
+
+
+
+    INT int_debug_panic
+
+at 0x000001e7 : */	0x98080000,0x030b0000,
+/*
+
+
+
+select_failed:
+
+
+
+; Otherwise, mask the selected and reselected bits off SIST0
+    MOVE SIST0 & 0x30 TO SFBR
+
+at 0x000001e9 : */	0x74423000,0x00000000,
+/*
+    JUMP selected, IF 0x20
+
+at 0x000001eb : */	0x800c0020,0x00000764,
+/*
+    JUMP reselected, IF 0x10 
+
+at 0x000001ed : */	0x800c0010,0x0000065c,
+/*
+; If SIGP is set, the user just gave us another command, and
+; we should restart or return to the scheduler.
+; Reading CTEST2 clears the SIG_P bit in the ISTAT register.
+    MOVE CTEST2 & 0x40 TO SFBR	
+
+at 0x000001ef : */	0x741a4000,0x00000000,
+/*
+    JUMP select, IF 0x40
+
+at 0x000001f1 : */	0x800c0040,0x000001fc,
+/*
+; Check connected bit.  
+; FIXME: this needs to change if we support target mode
+; FIXME: is this really necessary? 
+    MOVE ISTAT & 0x08 TO SFBR
+
+at 0x000001f3 : */	0x74140800,0x00000000,
+/*
+    JUMP reselected, IF 0x08
+
+at 0x000001f5 : */	0x800c0008,0x0000065c,
+/*
+; FIXME : Something bogus happened, and we shouldn't fail silently.
+
+
+
+    INT int_debug_panic
+
+at 0x000001f7 : */	0x98080000,0x030b0000,
+/*
+
+
+;
+; test_1
+; test_2
+;
+; PURPOSE : run some verification tests on the NCR.  test_1
+;	copies test_src to test_dest and interrupts the host
+;	processor, testing for cache coherency and interrupt
+; 	problems in the processes.
+;
+;	test_2 runs a command with offsets relative to the 
+;	DSA on entry, and is useful for miscellaneous experimentation.
+;
+
+; Verify that interrupts are working correctly and that we don't 
+; have a cache invalidation problem.
+
+ABSOLUTE test_src = 0, test_dest = 0
+ENTRY test_1
+test_1:
+    MOVE MEMORY 4, test_src, test_dest
+
+at 0x000001f9 : */	0xc0000004,0x00000000,0x00000000,
+/*
+    INT int_test_1
+
+at 0x000001fc : */	0x98080000,0x04000000,
+/*
+
+;
+; Run arbitrary commands, with test code establishing a DSA
+;
+ 
+ENTRY test_2
+test_2:
+    CLEAR TARGET
+
+at 0x000001fe : */	0x60000200,0x00000000,
+/*
+    SELECT ATN FROM 0, test_2_fail
+
+at 0x00000200 : */	0x43000000,0x00000850,
+/*
+    JUMP test_2_msgout, WHEN MSG_OUT
+
+at 0x00000202 : */	0x860b0000,0x00000810,
+/*
+ENTRY test_2_msgout
+test_2_msgout:
+    MOVE FROM 8, WHEN MSG_OUT
+
+at 0x00000204 : */	0x1e000000,0x00000008,
+/*
+    MOVE FROM 16, WHEN CMD 
+
+at 0x00000206 : */	0x1a000000,0x00000010,
+/*
+    MOVE FROM 24, WHEN DATA_IN
+
+at 0x00000208 : */	0x19000000,0x00000018,
+/*
+    MOVE FROM 32, WHEN STATUS
+
+at 0x0000020a : */	0x1b000000,0x00000020,
+/*
+    MOVE FROM 40, WHEN MSG_IN
+
+at 0x0000020c : */	0x1f000000,0x00000028,
+/*
+    MOVE SCNTL2 & 0x7f TO SCNTL2
+
+at 0x0000020e : */	0x7c027f00,0x00000000,
+/*
+    CLEAR ACK
+
+at 0x00000210 : */	0x60000040,0x00000000,
+/*
+    WAIT DISCONNECT
+
+at 0x00000212 : */	0x48000000,0x00000000,
+/*
+test_2_fail:
+    INT int_test_2
+
+at 0x00000214 : */	0x98080000,0x04010000,
+/*
+
+ENTRY debug_break
+debug_break:
+    INT int_debug_break
+
+at 0x00000216 : */	0x98080000,0x03000000,
+/*
+
+;
+; initiator_abort
+; target_abort
+;
+; PURPOSE : Abort the currently established nexus from with initiator
+;	or target mode.
+;
+;  
+
+ENTRY target_abort
+target_abort:
+    SET TARGET
+
+at 0x00000218 : */	0x58000200,0x00000000,
+/*
+    DISCONNECT
+
+at 0x0000021a : */	0x48000000,0x00000000,
+/*
+    CLEAR TARGET
+
+at 0x0000021c : */	0x60000200,0x00000000,
+/*
+    JUMP schedule
+
+at 0x0000021e : */	0x80080000,0x00000000,
+/*
+    
+ENTRY initiator_abort
+initiator_abort:
+    SET ATN
+
+at 0x00000220 : */	0x58000008,0x00000000,
+/*
+;
+; The SCSI-I specification says that targets may go into MSG out at 
+; their leisure upon receipt of the ATN single.  On all versions of the 
+; specification, we can't change phases until REQ transitions true->false, 
+; so we need to sink/source one byte of data to allow the transition.
+;
+; For the sake of safety, we'll only source one byte of data in all 
+; cases, but to accommodate the SCSI-I dain bramage, we'll sink an  
+; arbitrary number of bytes.
+    JUMP spew_cmd, WHEN CMD
+
+at 0x00000222 : */	0x820b0000,0x000008b8,
+/*
+    JUMP eat_msgin, WHEN MSG_IN
+
+at 0x00000224 : */	0x870b0000,0x000008c8,
+/*
+    JUMP eat_datain, WHEN DATA_IN
+
+at 0x00000226 : */	0x810b0000,0x000008f8,
+/*
+    JUMP eat_status, WHEN STATUS
+
+at 0x00000228 : */	0x830b0000,0x000008e0,
+/*
+    JUMP spew_dataout, WHEN DATA_OUT
+
+at 0x0000022a : */	0x800b0000,0x00000910,
+/*
+    JUMP sated
+
+at 0x0000022c : */	0x80080000,0x00000918,
+/*
+spew_cmd:
+    MOVE 1, NCR53c7xx_zero, WHEN CMD
+
+at 0x0000022e : */	0x0a000001,0x00000000,
+/*
+    JUMP sated
+
+at 0x00000230 : */	0x80080000,0x00000918,
+/*
+eat_msgin:
+    MOVE 1, NCR53c7xx_sink, WHEN MSG_IN
+
+at 0x00000232 : */	0x0f000001,0x00000000,
+/*
+    JUMP eat_msgin, WHEN MSG_IN
+
+at 0x00000234 : */	0x870b0000,0x000008c8,
+/*
+    JUMP sated
+
+at 0x00000236 : */	0x80080000,0x00000918,
+/*
+eat_status:
+    MOVE 1, NCR53c7xx_sink, WHEN STATUS
+
+at 0x00000238 : */	0x0b000001,0x00000000,
+/*
+    JUMP eat_status, WHEN STATUS
+
+at 0x0000023a : */	0x830b0000,0x000008e0,
+/*
+    JUMP sated
+
+at 0x0000023c : */	0x80080000,0x00000918,
+/*
+eat_datain:
+    MOVE 1, NCR53c7xx_sink, WHEN DATA_IN
+
+at 0x0000023e : */	0x09000001,0x00000000,
+/*
+    JUMP eat_datain, WHEN DATA_IN
+
+at 0x00000240 : */	0x810b0000,0x000008f8,
+/*
+    JUMP sated
+
+at 0x00000242 : */	0x80080000,0x00000918,
+/*
+spew_dataout:
+    MOVE 1, NCR53c7xx_zero, WHEN DATA_OUT
+
+at 0x00000244 : */	0x08000001,0x00000000,
+/*
+sated:
+    MOVE SCNTL2 & 0x7f TO SCNTL2
+
+at 0x00000246 : */	0x7c027f00,0x00000000,
+/*
+    MOVE 1, NCR53c7xx_msg_abort, WHEN MSG_OUT
+
+at 0x00000248 : */	0x0e000001,0x00000000,
+/*
+    WAIT DISCONNECT
+
+at 0x0000024a : */	0x48000000,0x00000000,
+/*
+    INT int_norm_aborted
+
+at 0x0000024c : */	0x98080000,0x02040000,
+/*
+
+;
+; dsa_to_scratch
+; scratch_to_dsa
+;
+; PURPOSE :
+; 	The NCR chips cannot do a move memory instruction with the DSA register 
+; 	as the source or destination.  So, we provide a couple of subroutines
+; 	that let us switch between the DSA register and scratch register.
+;
+; 	Memory moves to/from the DSPS  register also don't work, but we 
+; 	don't use them.
+;
+;
+
+ 
+dsa_to_scratch:
+    MOVE DSA0 TO SFBR
+
+at 0x0000024e : */	0x72100000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH0
+
+at 0x00000250 : */	0x6a340000,0x00000000,
+/*
+    MOVE DSA1 TO SFBR
+
+at 0x00000252 : */	0x72110000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH1
+
+at 0x00000254 : */	0x6a350000,0x00000000,
+/*
+    MOVE DSA2 TO SFBR
+
+at 0x00000256 : */	0x72120000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH2
+
+at 0x00000258 : */	0x6a360000,0x00000000,
+/*
+    MOVE DSA3 TO SFBR
+
+at 0x0000025a : */	0x72130000,0x00000000,
+/*
+    MOVE SFBR TO SCRATCH3
+
+at 0x0000025c : */	0x6a370000,0x00000000,
+/*
+    RETURN
+
+at 0x0000025e : */	0x90080000,0x00000000,
+/*
+
+scratch_to_dsa:
+    MOVE SCRATCH0 TO SFBR
+
+at 0x00000260 : */	0x72340000,0x00000000,
+/*
+    MOVE SFBR TO DSA0
+
+at 0x00000262 : */	0x6a100000,0x00000000,
+/*
+    MOVE SCRATCH1 TO SFBR
+
+at 0x00000264 : */	0x72350000,0x00000000,
+/*
+    MOVE SFBR TO DSA1
+
+at 0x00000266 : */	0x6a110000,0x00000000,
+/*
+    MOVE SCRATCH2 TO SFBR
+
+at 0x00000268 : */	0x72360000,0x00000000,
+/*
+    MOVE SFBR TO DSA2
+
+at 0x0000026a : */	0x6a120000,0x00000000,
+/*
+    MOVE SCRATCH3 TO SFBR
+
+at 0x0000026c : */	0x72370000,0x00000000,
+/*
+    MOVE SFBR TO DSA3
+
+at 0x0000026e : */	0x6a130000,0x00000000,
+/*
+    RETURN
+
+at 0x00000270 : */	0x90080000,0x00000000,
+};
+
+#define A_NCR53c7xx_msg_abort	0x00000000
+static u32 A_NCR53c7xx_msg_abort_used[] __attribute((unused)) = {
+	0x00000249,
+};
+
+#define A_NCR53c7xx_msg_reject	0x00000000
+static u32 A_NCR53c7xx_msg_reject_used[] __attribute((unused)) = {
+	0x00000172,
+};
+
+#define A_NCR53c7xx_sink	0x00000000
+static u32 A_NCR53c7xx_sink_used[] __attribute((unused)) = {
+	0x00000233,
+	0x00000239,
+	0x0000023f,
+};
+
+#define A_NCR53c7xx_zero	0x00000000
+static u32 A_NCR53c7xx_zero_used[] __attribute((unused)) = {
+	0x0000022f,
+	0x00000245,
+};
+
+#define A_NOP_insn	0x00000000
+static u32 A_NOP_insn_used[] __attribute((unused)) = {
+	0x00000010,
+};
+
+#define A_addr_reconnect_dsa_head	0x00000000
+static u32 A_addr_reconnect_dsa_head_used[] __attribute((unused)) = {
+	0x000001a7,
+};
+
+#define A_addr_scratch	0x00000000
+static u32 A_addr_scratch_used[] __attribute((unused)) = {
+	0x00000004,
+	0x0000001b,
+	0x00000046,
+	0x00000067,
+	0x00000073,
+	0x000000b0,
+	0x000000c6,
+	0x00000128,
+	0x00000141,
+	0x000001a1,
+	0x000001ce,
+};
+
+#define A_addr_temp	0x00000000
+static u32 A_addr_temp_used[] __attribute((unused)) = {
+	0x00000025,
+	0x00000034,
+};
+
+#define A_dmode_memory_to_memory	0x00000000
+static u32 A_dmode_memory_to_memory_used[] __attribute((unused)) = {
+	0x00000005,
+	0x0000001c,
+	0x00000027,
+	0x00000035,
+	0x00000047,
+	0x00000069,
+	0x00000075,
+	0x000000b2,
+	0x000000c8,
+	0x0000012a,
+	0x00000143,
+	0x00000199,
+	0x000001a2,
+	0x000001d0,
+};
+
+#define A_dmode_memory_to_ncr	0x00000000
+static u32 A_dmode_memory_to_ncr_used[] __attribute((unused)) = {
+	0x00000000,
+	0x00000017,
+	0x00000030,
+	0x00000042,
+	0x0000019d,
+};
+
+#define A_dmode_ncr_to_memory	0x00000000
+static u32 A_dmode_ncr_to_memory_used[] __attribute((unused)) = {
+	0x00000022,
+	0x00000064,
+	0x00000070,
+	0x000000ad,
+	0x000000c3,
+	0x00000125,
+	0x0000013e,
+	0x000001cb,
+};
+
+#define A_dsa_check_reselect	0x00000000
+static u32 A_dsa_check_reselect_used[] __attribute((unused)) = {
+	0x000001bd,
+};
+
+#define A_dsa_cmdout	0x00000048
+static u32 A_dsa_cmdout_used[] __attribute((unused)) = {
+	0x00000094,
+};
+
+#define A_dsa_cmnd	0x00000038
+static u32 A_dsa_cmnd_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_datain	0x00000054
+static u32 A_dsa_datain_used[] __attribute((unused)) = {
+	0x000000bb,
+};
+
+#define A_dsa_dataout	0x00000050
+static u32 A_dsa_dataout_used[] __attribute((unused)) = {
+	0x000000a5,
+};
+
+#define A_dsa_end	0x00000070
+static u32 A_dsa_end_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_fields_start	0x00000000
+static u32 A_dsa_fields_start_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_msgin	0x00000058
+static u32 A_dsa_msgin_used[] __attribute((unused)) = {
+	0x00000188,
+};
+
+#define A_dsa_msgout	0x00000040
+static u32 A_dsa_msgout_used[] __attribute((unused)) = {
+	0x00000086,
+};
+
+#define A_dsa_msgout_other	0x00000068
+static u32 A_dsa_msgout_other_used[] __attribute((unused)) = {
+	0x00000180,
+};
+
+#define A_dsa_next	0x00000030
+static u32 A_dsa_next_used[] __attribute((unused)) = {
+	0x0000005c,
+};
+
+#define A_dsa_restore_pointers	0x00000000
+static u32 A_dsa_restore_pointers_used[] __attribute((unused)) = {
+	0x0000012e,
+};
+
+#define A_dsa_save_data_pointer	0x00000000
+static u32 A_dsa_save_data_pointer_used[] __attribute((unused)) = {
+	0x00000115,
+};
+
+#define A_dsa_select	0x0000003c
+static u32 A_dsa_select_used[] __attribute((unused)) = {
+	0x00000081,
+};
+
+#define A_dsa_status	0x00000060
+static u32 A_dsa_status_used[] __attribute((unused)) = {
+	0x00000184,
+};
+
+#define A_dsa_temp_addr_array_value	0x00000000
+static u32 A_dsa_temp_addr_array_value_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_temp_addr_dsa_value	0x00000000
+static u32 A_dsa_temp_addr_dsa_value_used[] __attribute((unused)) = {
+	0x00000003,
+};
+
+#define A_dsa_temp_addr_new_value	0x00000000
+static u32 A_dsa_temp_addr_new_value_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_temp_addr_next	0x00000000
+static u32 A_dsa_temp_addr_next_used[] __attribute((unused)) = {
+	0x00000015,
+	0x0000004e,
+};
+
+#define A_dsa_temp_addr_residual	0x00000000
+static u32 A_dsa_temp_addr_residual_used[] __attribute((unused)) = {
+	0x0000002a,
+	0x00000039,
+};
+
+#define A_dsa_temp_addr_saved_pointer	0x00000000
+static u32 A_dsa_temp_addr_saved_pointer_used[] __attribute((unused)) = {
+	0x00000026,
+	0x00000033,
+};
+
+#define A_dsa_temp_addr_saved_residual	0x00000000
+static u32 A_dsa_temp_addr_saved_residual_used[] __attribute((unused)) = {
+	0x0000002b,
+	0x00000038,
+};
+
+#define A_dsa_temp_lun	0x00000000
+static u32 A_dsa_temp_lun_used[] __attribute((unused)) = {
+	0x0000004b,
+};
+
+#define A_dsa_temp_next	0x00000000
+static u32 A_dsa_temp_next_used[] __attribute((unused)) = {
+	0x0000001a,
+};
+
+#define A_dsa_temp_sync	0x00000000
+static u32 A_dsa_temp_sync_used[] __attribute((unused)) = {
+	0x00000053,
+};
+
+#define A_dsa_temp_target	0x00000000
+static u32 A_dsa_temp_target_used[] __attribute((unused)) = {
+	0x00000040,
+};
+
+#define A_int_debug_break	0x03000000
+static u32 A_int_debug_break_used[] __attribute((unused)) = {
+	0x00000217,
+};
+
+#define A_int_debug_panic	0x030b0000
+static u32 A_int_debug_panic_used[] __attribute((unused)) = {
+	0x000001e8,
+	0x000001f8,
+};
+
+#define A_int_err_check_condition	0x00030000
+static u32 A_int_err_check_condition_used[] __attribute((unused)) = {
+	0x00000194,
+};
+
+#define A_int_err_no_phase	0x00040000
+static u32 A_int_err_no_phase_used[] __attribute((unused)) = {
+};
+
+#define A_int_err_selected	0x00010000
+static u32 A_int_err_selected_used[] __attribute((unused)) = {
+	0x000001da,
+};
+
+#define A_int_err_unexpected_phase	0x00000000
+static u32 A_int_err_unexpected_phase_used[] __attribute((unused)) = {
+	0x0000008c,
+	0x00000092,
+	0x0000009a,
+	0x000000d0,
+	0x000000d4,
+	0x000000d6,
+	0x000000de,
+	0x000000e2,
+	0x000000e4,
+	0x000000ec,
+	0x000000f0,
+	0x000000f2,
+	0x000000f4,
+	0x0000014c,
+};
+
+#define A_int_err_unexpected_reselect	0x00020000
+static u32 A_int_err_unexpected_reselect_used[] __attribute((unused)) = {
+	0x000001ba,
+};
+
+#define A_int_msg_1	0x01020000
+static u32 A_int_msg_1_used[] __attribute((unused)) = {
+	0x0000010e,
+	0x00000110,
+};
+
+#define A_int_msg_sdtr	0x01010000
+static u32 A_int_msg_sdtr_used[] __attribute((unused)) = {
+	0x0000016c,
+};
+
+#define A_int_msg_wdtr	0x01000000
+static u32 A_int_msg_wdtr_used[] __attribute((unused)) = {
+	0x00000160,
+};
+
+#define A_int_norm_aborted	0x02040000
+static u32 A_int_norm_aborted_used[] __attribute((unused)) = {
+	0x0000024d,
+};
+
+#define A_int_norm_command_complete	0x02020000
+static u32 A_int_norm_command_complete_used[] __attribute((unused)) = {
+};
+
+#define A_int_norm_disconnected	0x02030000
+static u32 A_int_norm_disconnected_used[] __attribute((unused)) = {
+};
+
+#define A_int_norm_reselect_complete	0x02010000
+static u32 A_int_norm_reselect_complete_used[] __attribute((unused)) = {
+};
+
+#define A_int_norm_reset	0x02050000
+static u32 A_int_norm_reset_used[] __attribute((unused)) = {
+};
+
+#define A_int_norm_select_complete	0x02000000
+static u32 A_int_norm_select_complete_used[] __attribute((unused)) = {
+};
+
+#define A_int_test_1	0x04000000
+static u32 A_int_test_1_used[] __attribute((unused)) = {
+	0x000001fd,
+};
+
+#define A_int_test_2	0x04010000
+static u32 A_int_test_2_used[] __attribute((unused)) = {
+	0x00000215,
+};
+
+#define A_int_test_3	0x04020000
+static u32 A_int_test_3_used[] __attribute((unused)) = {
+};
+
+#define A_msg_buf	0x00000000
+static u32 A_msg_buf_used[] __attribute((unused)) = {
+	0x00000102,
+	0x0000014e,
+	0x00000158,
+	0x0000015e,
+	0x00000164,
+	0x0000016a,
+};
+
+#define A_reconnect_dsa_head	0x00000000
+static u32 A_reconnect_dsa_head_used[] __attribute((unused)) = {
+	0x0000006c,
+	0x00000074,
+	0x000001a0,
+};
+
+#define A_reselected_identify	0x00000000
+static u32 A_reselected_identify_used[] __attribute((unused)) = {
+	0x00000045,
+	0x0000019c,
+};
+
+#define A_reselected_tag	0x00000000
+static u32 A_reselected_tag_used[] __attribute((unused)) = {
+};
+
+#define A_schedule	0x00000000
+static u32 A_schedule_used[] __attribute((unused)) = {
+	0x0000007e,
+	0x00000192,
+	0x000001e2,
+	0x0000021f,
+};
+
+#define A_test_dest	0x00000000
+static u32 A_test_dest_used[] __attribute((unused)) = {
+	0x000001fb,
+};
+
+#define A_test_src	0x00000000
+static u32 A_test_src_used[] __attribute((unused)) = {
+	0x000001fa,
+};
+
+#define Ent_accept_message	0x000005d4
+#define Ent_cmdout_cmdout	0x0000024c
+#define Ent_command_complete	0x0000060c
+#define Ent_command_complete_msgin	0x0000061c
+#define Ent_data_transfer	0x00000254
+#define Ent_datain_to_jump	0x00000328
+#define Ent_debug_break	0x00000858
+#define Ent_dsa_code_begin	0x00000000
+#define Ent_dsa_code_check_reselect	0x000000f8
+#define Ent_dsa_code_fix_jump	0x0000003c
+#define Ent_dsa_code_restore_pointers	0x000000c0
+#define Ent_dsa_code_save_data_pointer	0x00000088
+#define Ent_dsa_code_template	0x00000000
+#define Ent_dsa_code_template_end	0x00000168
+#define Ent_dsa_schedule	0x00000168
+#define Ent_dsa_zero	0x00000168
+#define Ent_end_data_transfer	0x0000028c
+#define Ent_initiator_abort	0x00000880
+#define Ent_msg_in	0x00000404
+#define Ent_msg_in_restart	0x000003e4
+#define Ent_other_in	0x00000374
+#define Ent_other_out	0x0000033c
+#define Ent_other_transfer	0x000003ac
+#define Ent_reject_message	0x000005b4
+#define Ent_reselected_check_next	0x000006a4
+#define Ent_reselected_ok	0x00000750
+#define Ent_respond_message	0x000005ec
+#define Ent_select	0x000001fc
+#define Ent_select_msgout	0x00000214
+#define Ent_target_abort	0x00000860
+#define Ent_test_1	0x000007e4
+#define Ent_test_2	0x000007f8
+#define Ent_test_2_msgout	0x00000810
+#define Ent_wait_reselect	0x00000654
+static u32 LABELPATCHES[] __attribute((unused)) = {
+	0x00000008,
+	0x0000000a,
+	0x00000013,
+	0x00000016,
+	0x0000001f,
+	0x00000021,
+	0x0000004f,
+	0x00000051,
+	0x0000005b,
+	0x00000068,
+	0x0000006f,
+	0x00000082,
+	0x00000084,
+	0x0000008a,
+	0x0000008e,
+	0x00000090,
+	0x00000096,
+	0x00000098,
+	0x0000009c,
+	0x0000009e,
+	0x000000a0,
+	0x000000a2,
+	0x000000a4,
+	0x000000b1,
+	0x000000b6,
+	0x000000ba,
+	0x000000c7,
+	0x000000cc,
+	0x000000d2,
+	0x000000d8,
+	0x000000da,
+	0x000000e0,
+	0x000000e6,
+	0x000000e8,
+	0x000000ee,
+	0x000000f6,
+	0x000000f8,
+	0x00000104,
+	0x00000106,
+	0x00000108,
+	0x0000010a,
+	0x0000010c,
+	0x00000112,
+	0x00000114,
+	0x00000129,
+	0x00000142,
+	0x00000148,
+	0x00000150,
+	0x00000152,
+	0x00000154,
+	0x0000015a,
+	0x00000166,
+	0x00000196,
+	0x000001a5,
+	0x000001a8,
+	0x000001ac,
+	0x000001b0,
+	0x000001b4,
+	0x000001b8,
+	0x000001cf,
+	0x000001de,
+	0x000001e6,
+	0x000001ec,
+	0x000001ee,
+	0x000001f2,
+	0x000001f6,
+	0x00000201,
+	0x00000203,
+	0x00000223,
+	0x00000225,
+	0x00000227,
+	0x00000229,
+	0x0000022b,
+	0x0000022d,
+	0x00000231,
+	0x00000235,
+	0x00000237,
+	0x0000023b,
+	0x0000023d,
+	0x00000241,
+	0x00000243,
+};
+
+static struct {
+	u32	offset;
+	void		*address;
+} EXTERNAL_PATCHES[] __attribute((unused)) = {
+};
+
+static u32 INSTRUCTIONS __attribute((unused))	= 301;
+static u32 PATCHES __attribute((unused))	= 81;
+static u32 EXTERNAL_PATCHES_LEN __attribute((unused))	= 0;
diff -Nru a/drivers/scsi/53c8xx_u.h b/drivers/scsi/53c8xx_u.h
--- a/drivers/scsi/53c8xx_u.h	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,97 +0,0 @@
-#undef A_NCR53c7xx_msg_abort
-#undef A_NCR53c7xx_msg_reject
-#undef A_NCR53c7xx_sink
-#undef A_NCR53c7xx_zero
-#undef A_NOP_insn
-#undef A_addr_reconnect_dsa_head
-#undef A_addr_scratch
-#undef A_addr_temp
-#undef A_dmode_memory_to_memory
-#undef A_dmode_memory_to_ncr
-#undef A_dmode_ncr_to_memory
-#undef A_dsa_check_reselect
-#undef A_dsa_cmdout
-#undef A_dsa_cmnd
-#undef A_dsa_datain
-#undef A_dsa_dataout
-#undef A_dsa_end
-#undef A_dsa_fields_start
-#undef A_dsa_msgin
-#undef A_dsa_msgout
-#undef A_dsa_msgout_other
-#undef A_dsa_next
-#undef A_dsa_restore_pointers
-#undef A_dsa_save_data_pointer
-#undef A_dsa_select
-#undef A_dsa_status
-#undef A_dsa_temp_addr_array_value
-#undef A_dsa_temp_addr_dsa_value
-#undef A_dsa_temp_addr_new_value
-#undef A_dsa_temp_addr_next
-#undef A_dsa_temp_addr_residual
-#undef A_dsa_temp_addr_saved_pointer
-#undef A_dsa_temp_addr_saved_residual
-#undef A_dsa_temp_lun
-#undef A_dsa_temp_next
-#undef A_dsa_temp_sync
-#undef A_dsa_temp_target
-#undef A_int_debug_break
-#undef A_int_debug_panic
-#undef A_int_err_check_condition
-#undef A_int_err_no_phase
-#undef A_int_err_selected
-#undef A_int_err_unexpected_phase
-#undef A_int_err_unexpected_reselect
-#undef A_int_msg_1
-#undef A_int_msg_sdtr
-#undef A_int_msg_wdtr
-#undef A_int_norm_aborted
-#undef A_int_norm_command_complete
-#undef A_int_norm_disconnected
-#undef A_int_norm_reselect_complete
-#undef A_int_norm_reset
-#undef A_int_norm_select_complete
-#undef A_int_test_1
-#undef A_int_test_2
-#undef A_int_test_3
-#undef A_msg_buf
-#undef A_reconnect_dsa_head
-#undef A_reselected_identify
-#undef A_reselected_tag
-#undef A_schedule
-#undef A_test_dest
-#undef A_test_src
-#undef Ent_accept_message
-#undef Ent_cmdout_cmdout
-#undef Ent_command_complete
-#undef Ent_command_complete_msgin
-#undef Ent_data_transfer
-#undef Ent_datain_to_jump
-#undef Ent_debug_break
-#undef Ent_dsa_code_begin
-#undef Ent_dsa_code_check_reselect
-#undef Ent_dsa_code_fix_jump
-#undef Ent_dsa_code_restore_pointers
-#undef Ent_dsa_code_save_data_pointer
-#undef Ent_dsa_code_template
-#undef Ent_dsa_code_template_end
-#undef Ent_dsa_schedule
-#undef Ent_dsa_zero
-#undef Ent_end_data_transfer
-#undef Ent_initiator_abort
-#undef Ent_msg_in
-#undef Ent_msg_in_restart
-#undef Ent_other_in
-#undef Ent_other_out
-#undef Ent_other_transfer
-#undef Ent_reject_message
-#undef Ent_reselected_check_next
-#undef Ent_reselected_ok
-#undef Ent_respond_message
-#undef Ent_select
-#undef Ent_select_msgout
-#undef Ent_target_abort
-#undef Ent_test_1
-#undef Ent_test_2
-#undef Ent_test_2_msgout
-#undef Ent_wait_reselect
diff -Nru a/drivers/scsi/53c8xx_u.h_shipped b/drivers/scsi/53c8xx_u.h_shipped
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/scsi/53c8xx_u.h_shipped	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,97 @@
+#undef A_NCR53c7xx_msg_abort
+#undef A_NCR53c7xx_msg_reject
+#undef A_NCR53c7xx_sink
+#undef A_NCR53c7xx_zero
+#undef A_NOP_insn
+#undef A_addr_reconnect_dsa_head
+#undef A_addr_scratch
+#undef A_addr_temp
+#undef A_dmode_memory_to_memory
+#undef A_dmode_memory_to_ncr
+#undef A_dmode_ncr_to_memory
+#undef A_dsa_check_reselect
+#undef A_dsa_cmdout
+#undef A_dsa_cmnd
+#undef A_dsa_datain
+#undef A_dsa_dataout
+#undef A_dsa_end
+#undef A_dsa_fields_start
+#undef A_dsa_msgin
+#undef A_dsa_msgout
+#undef A_dsa_msgout_other
+#undef A_dsa_next
+#undef A_dsa_restore_pointers
+#undef A_dsa_save_data_pointer
+#undef A_dsa_select
+#undef A_dsa_status
+#undef A_dsa_temp_addr_array_value
+#undef A_dsa_temp_addr_dsa_value
+#undef A_dsa_temp_addr_new_value
+#undef A_dsa_temp_addr_next
+#undef A_dsa_temp_addr_residual
+#undef A_dsa_temp_addr_saved_pointer
+#undef A_dsa_temp_addr_saved_residual
+#undef A_dsa_temp_lun
+#undef A_dsa_temp_next
+#undef A_dsa_temp_sync
+#undef A_dsa_temp_target
+#undef A_int_debug_break
+#undef A_int_debug_panic
+#undef A_int_err_check_condition
+#undef A_int_err_no_phase
+#undef A_int_err_selected
+#undef A_int_err_unexpected_phase
+#undef A_int_err_unexpected_reselect
+#undef A_int_msg_1
+#undef A_int_msg_sdtr
+#undef A_int_msg_wdtr
+#undef A_int_norm_aborted
+#undef A_int_norm_command_complete
+#undef A_int_norm_disconnected
+#undef A_int_norm_reselect_complete
+#undef A_int_norm_reset
+#undef A_int_norm_select_complete
+#undef A_int_test_1
+#undef A_int_test_2
+#undef A_int_test_3
+#undef A_msg_buf
+#undef A_reconnect_dsa_head
+#undef A_reselected_identify
+#undef A_reselected_tag
+#undef A_schedule
+#undef A_test_dest
+#undef A_test_src
+#undef Ent_accept_message
+#undef Ent_cmdout_cmdout
+#undef Ent_command_complete
+#undef Ent_command_complete_msgin
+#undef Ent_data_transfer
+#undef Ent_datain_to_jump
+#undef Ent_debug_break
+#undef Ent_dsa_code_begin
+#undef Ent_dsa_code_check_reselect
+#undef Ent_dsa_code_fix_jump
+#undef Ent_dsa_code_restore_pointers
+#undef Ent_dsa_code_save_data_pointer
+#undef Ent_dsa_code_template
+#undef Ent_dsa_code_template_end
+#undef Ent_dsa_schedule
+#undef Ent_dsa_zero
+#undef Ent_end_data_transfer
+#undef Ent_initiator_abort
+#undef Ent_msg_in
+#undef Ent_msg_in_restart
+#undef Ent_other_in
+#undef Ent_other_out
+#undef Ent_other_transfer
+#undef Ent_reject_message
+#undef Ent_reselected_check_next
+#undef Ent_reselected_ok
+#undef Ent_respond_message
+#undef Ent_select
+#undef Ent_select_msgout
+#undef Ent_target_abort
+#undef Ent_test_1
+#undef Ent_test_2
+#undef Ent_test_2_msgout
+#undef Ent_wait_reselect
diff -Nru a/drivers/scsi/Config.in b/drivers/scsi/Config.in
--- a/drivers/scsi/Config.in	Thu Jun 20 15:54:01 2002
+++ b/drivers/scsi/Config.in	Thu Jun 20 15:54:01 2002
@@ -10,7 +10,7 @@
 
 dep_tristate '  SCSI OnStream SC-x0 tape support' CONFIG_CHR_DEV_OSST $CONFIG_SCSI
 
-dep_tristate '  SCSI CD-ROM support' CONFIG_BLK_DEV_SR $CONFIG_SCSI
+dep_tristate '  SCSI CDROM support' CONFIG_BLK_DEV_SR $CONFIG_SCSI
 
 if [ "$CONFIG_BLK_DEV_SR" != "n" ]; then
    bool '    Enable vendor-specific extensions (for SCSI CDROM)' CONFIG_BLK_DEV_SR_VENDOR
diff -Nru a/drivers/scsi/Makefile b/drivers/scsi/Makefile
--- a/drivers/scsi/Makefile	Thu Jun 20 15:54:00 2002
+++ b/drivers/scsi/Makefile	Thu Jun 20 15:54:00 2002
@@ -131,42 +131,32 @@
 
 include $(TOPDIR)/Rules.make
 
-53c8xx_d.h: 53c7,8xx.scr script_asm.pl
-	ln -sf 53c7,8xx.scr fake8.c
-	$(CPP) $(CPPFLAGS) -traditional -DCHIP=810 fake8.c | grep -v '^#' | $(PERL) script_asm.pl 
-	mv script.h 53c8xx_d.h
-	mv scriptu.h 53c8xx_u.h
-	rm fake8.c
+$(obj)/53c7,8xx.o: $(obj)/53c8xx_d.h $(obj)/53c8xx_u.h
+$(obj)/53c7xx.o:   $(obj)/53c7xx_d.h $(obj)/53c7xx_u.h
+$(obj)/sim710.o:   $(obj)/sim710_d.h
+$(obj)/53c700.o $(MODVERDIR)/53c700.ver: $(obj)/53c700_d.h
 
-53c8xx_u.h: 53c8xx_d.h
+# If you want to play with the firmware, uncomment
+# GENERATE_FIRMWARE := 1
 
-53c7,8xx.o: 53c8xx_u.h
+ifdef GENERATE_FIRMWARE
 
-53c7xx_d.h: 53c7xx.scr script_asm.pl
-	ln -sf 53c7xx.scr fake7.c
-	$(CPP) $(CPPFLAGS) -traditional -DCHIP=710 fake7.c | grep -v '^#' | $(PERL) -s script_asm.pl -ncr7x0_family
-	mv script.h 53c7xx_d.h
-	mv scriptu.h 53c7xx_u.h
-	rm fake7.c
+$(obj)/53c8xx_d.h: $(src)/53c7,8xx.scr $(src)/script_asm.pl
+	$(CPP) -traditional -DCHIP=810 - < $< | grep -v '^#' | $(PERL) $(src)/script_asm.pl $@ $(@:_d.h=_u.h)
 
-53c7xx_u.h: 53c7xx_d.h
+$(obj)/53c8xx_u.h: $(obj)/53c8xx_d.h
 
-53c7xx.o : 53c7xx_d.h
+$(obj)/53c7xx_d.h: $(src)/53c7xx.scr $(src)/script_asm.pl
+	$(CPP) -traditional -DCHIP=710 - < $< | grep -v '^#' | $(PERL) -s $(src)/script_asm.pl -ncr7x0_family $@ $(@:_d.h=_u.h)
 
-sim710_d.h: sim710.scr script_asm.pl
-	ln -sf sim710.scr fake7.c
-	$(CPP) $(CPPFLAGS) -traditional -DCHIP=710 fake7.c | grep -v '^#' | $(PERL) -s script_asm.pl -ncr7x0_family
-	mv script.h sim710_d.h
-	mv scriptu.h sim710_u.h
-	rm fake7.c
+$(obj)/53c7xx_u.h: $(obj)/53c7xx_d.h
 
-sim710_u.h: sim710_d.h
+$(obj)/sim710_d.h: $(src)/sim710.scr $(src)/script_asm.pl
+	$(CPP) -traditional -DCHIP=710 - < $< | grep -v '^#' | $(PERL) -s $(src)/script_asm.pl -ncr7x0_family $@ $(@:_d.h=_u.h)
 
-sim710.o : sim710_d.h
+$(obj)/sim710_u.h: $(obj)/sim710_d.h
 
-53c700_d.h: 53c700.scr script_asm.pl
-	$(PERL) -s script_asm.pl -ncr7x0_family < 53c700.scr
-	rm -f scriptu.h
-	mv script.h 53c700_d.h
+$(obj)/53c700_d.h: $(src)/53c700.scr $(src)/script_asm.pl
+	$(PERL) -s $(src)/script_asm.pl -ncr7x0_family $@ $(@:_d.h=_u.h) < $<
 
-53c700.o: 53c700_d.h
+endif
\ No newline at end of file
diff -Nru a/drivers/scsi/aic7xxx/Makefile b/drivers/scsi/aic7xxx/Makefile
--- a/drivers/scsi/aic7xxx/Makefile	Thu Jun 20 15:54:01 2002
+++ b/drivers/scsi/aic7xxx/Makefile	Thu Jun 20 15:54:01 2002
@@ -24,21 +24,20 @@
 
 # Dependencies for generated files need to be listed explicitly
 
-aic7xxx_core.o: aic7xxx_seq.h
+$(obj)/aic7xxx_core.o: $(obj)/aic7xxx_seq.h
 
-$(aic7xxx-objs): aic7xxx_reg.h
+$(addprefix $(obj)/,$(aic7xxx-objs)): $(obj)/aic7xxx_reg.h
 
 ifeq ($(CONFIG_AIC7XXX_BUILD_FIRMWARE),y)
 
-aic7xxx_seq.h aic7xxx_reg.h: aic7xxx.seq aic7xxx.reg aicasm/aicasm
-	aicasm/aicasm -I. -r aic7xxx_reg.h -o aic7xxx_seq.h aic7xxx.seq
+$(obj)/aic7xxx_seq.h $(obj)/aic7xxx_reg.h: $(src)/aic7xxx.seq \
+					   $(src)/aic7xxx.reg \
+					   $(obj)/aicasm/aicasm
+	$(obj)/aicasm/aicasm -I. -r $(obj)/aic7xxx_reg.h \
+				 -o $(obj)/aic7xxx_seq.h $(src)/aic7xxx.seq
 
-else
-
-aic7xxx_seq.h aic7xxx_reg.h: %.h : shipped_%.h
-	cp $< $@
+$(obj)/aicasm/aicasm: $(src)/aicasm/*.[chyl]
+	$(MAKE) -C $(src)/aicasm
 
 endif
 
-aicasm/aicasm: aicasm/*.[chyl]
-	$(MAKE) -C aicasm
diff -Nru a/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped b/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/scsi/aic7xxx/aic7xxx_reg.h_shipped	Thu Jun 20 15:54:00 2002
@@ -0,0 +1,716 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id$
+ * $Id$
+ */
+
+#define	SCSISEQ         		0x00
+#define		TEMODE          	0x80
+#define		SCSIRSTO        	0x01
+
+#define	SXFRCTL0        		0x01
+#define		DFON            	0x80
+#define		DFPEXP          	0x40
+#define		FAST20          	0x20
+#define		CLRSTCNT        	0x10
+#define		SPIOEN          	0x08
+#define		SCAMEN          	0x04
+#define		CLRCHN          	0x02
+
+#define	SXFRCTL1        		0x02
+#define		BITBUCKET       	0x80
+#define		SWRAPEN         	0x40
+#define		STIMESEL        	0x18
+#define		ENSTIMER        	0x04
+#define		ACTNEGEN        	0x02
+#define		STPWEN          	0x01
+
+#define	SCSISIGO        		0x03
+#define		CDO             	0x80
+#define		IOO             	0x40
+#define		MSGO            	0x20
+#define		ATNO            	0x10
+#define		SELO            	0x08
+#define		BSYO            	0x04
+#define		REQO            	0x02
+#define		ACKO            	0x01
+
+#define	SCSISIGI        		0x03
+#define		P_DATAIN_DT     	0x60
+#define		P_DATAOUT_DT    	0x20
+#define		ATNI            	0x10
+#define		SELI            	0x08
+#define		BSYI            	0x04
+#define		REQI            	0x02
+#define		ACKI            	0x01
+
+#define	SCSIRATE        		0x04
+#define		WIDEXFER        	0x80
+#define		SXFR            	0x70
+#define		ENABLE_CRC      	0x40
+#define		SINGLE_EDGE     	0x10
+#define		SOFS            	0x0f
+#define		SXFR_ULTRA2     	0x0f
+
+#define	SCSIID          		0x05
+#define	SCSIOFFSET      		0x05
+#define		SOFS_ULTRA2     	0x7f
+
+#define	SCSIDATL        		0x06
+
+#define	SCSIDATH        		0x07
+
+#define	STCNT           		0x08
+
+#define	OPTIONMODE      		0x08
+#define		AUTORATEEN      	0x80
+#define		AUTOACKEN       	0x40
+#define		ATNMGMNTEN      	0x20
+#define		BUSFREEREV      	0x10
+#define		EXPPHASEDIS     	0x08
+#define		SCSIDATL_IMGEN  	0x04
+#define		OPTIONMODE_DEFAULTS	0x03
+#define		AUTO_MSGOUT_DE  	0x02
+#define		DIS_MSGIN_DUALEDGE	0x01
+
+#define	TARGCRCCNT      		0x0a
+
+#define	CLRSINT0        		0x0b
+#define		CLRSELDO        	0x40
+#define		CLRSELDI        	0x20
+#define		CLRSELINGO      	0x10
+#define		CLRIOERR        	0x08
+#define		CLRSWRAP        	0x08
+#define		CLRSPIORDY      	0x02
+
+#define	SSTAT0          		0x0b
+#define		TARGET          	0x80
+#define		SELDO           	0x40
+#define		SELDI           	0x20
+#define		SELINGO         	0x10
+#define		SWRAP           	0x08
+#define		IOERR           	0x08
+#define		SDONE           	0x04
+#define		SPIORDY         	0x02
+#define		DMADONE         	0x01
+
+#define	CLRSINT1        		0x0c
+#define		CLRSELTIMEO     	0x80
+#define		CLRATNO         	0x40
+#define		CLRSCSIRSTI     	0x20
+#define		CLRBUSFREE      	0x08
+#define		CLRSCSIPERR     	0x04
+#define		CLRPHASECHG     	0x02
+#define		CLRREQINIT      	0x01
+
+#define	SSTAT1          		0x0c
+#define		SELTO           	0x80
+#define		ATNTARG         	0x40
+#define		SCSIRSTI        	0x20
+#define		PHASEMIS        	0x10
+#define		BUSFREE         	0x08
+#define		SCSIPERR        	0x04
+#define		PHASECHG        	0x02
+#define		REQINIT         	0x01
+
+#define	SSTAT2          		0x0d
+#define		OVERRUN         	0x80
+#define		SHVALID         	0x40
+#define		SFCNT           	0x1f
+#define		EXP_ACTIVE      	0x10
+#define		CRCVALERR       	0x08
+#define		CRCENDERR       	0x04
+#define		CRCREQERR       	0x02
+#define		DUAL_EDGE_ERR   	0x01
+
+#define	SSTAT3          		0x0e
+#define		SCSICNT         	0xf0
+#define		U2OFFCNT        	0x7f
+#define		OFFCNT          	0x0f
+
+#define	SCSIID_ULTRA2   		0x0f
+
+#define	SIMODE0         		0x10
+#define		ENSELDO         	0x40
+#define		ENSELDI         	0x20
+#define		ENSELINGO       	0x10
+#define		ENIOERR         	0x08
+#define		ENSWRAP         	0x08
+#define		ENSDONE         	0x04
+#define		ENSPIORDY       	0x02
+#define		ENDMADONE       	0x01
+
+#define	SIMODE1         		0x11
+#define		ENSELTIMO       	0x80
+#define		ENATNTARG       	0x40
+#define		ENSCSIRST       	0x20
+#define		ENPHASEMIS      	0x10
+#define		ENBUSFREE       	0x08
+#define		ENSCSIPERR      	0x04
+#define		ENPHASECHG      	0x02
+#define		ENREQINIT       	0x01
+
+#define	SCSIBUSL        		0x12
+
+#define	SCSIBUSH        		0x13
+
+#define	SHADDR          		0x14
+
+#define	SELTIMER        		0x18
+#define	TARGIDIN        		0x18
+#define		STAGE6          	0x20
+#define		STAGE5          	0x10
+#define		STAGE4          	0x08
+#define		STAGE3          	0x04
+#define		STAGE2          	0x02
+#define		STAGE1          	0x01
+
+#define	SELID           		0x19
+#define		SELID_MASK      	0xf0
+#define		ONEBIT          	0x08
+
+#define	SCAMCTL         		0x1a
+#define		ENSCAMSELO      	0x80
+#define		CLRSCAMSELID    	0x40
+#define		ALTSTIM         	0x20
+#define		DFLTTID         	0x10
+#define		SCAMLVL         	0x03
+
+#define	TARGID          		0x1b
+
+#define	SPIOCAP         		0x1b
+#define		SOFT1           	0x80
+#define		SOFT0           	0x40
+#define		SOFTCMDEN       	0x20
+#define		HAS_BRDCTL      	0x10
+#define		SEEPROM         	0x08
+#define		EEPROM          	0x04
+#define		ROM             	0x02
+#define		SSPIOCPS        	0x01
+
+#define	BRDCTL          		0x1d
+#define		BRDDAT7         	0x80
+#define		BRDDAT6         	0x40
+#define		BRDDAT5         	0x20
+#define		BRDDAT4         	0x10
+#define		BRDSTB          	0x10
+#define		BRDDAT3         	0x08
+#define		BRDCS           	0x08
+#define		BRDDAT2         	0x04
+#define		BRDRW           	0x04
+#define		BRDRW_ULTRA2    	0x02
+#define		BRDCTL1         	0x02
+#define		BRDCTL0         	0x01
+#define		BRDSTB_ULTRA2   	0x01
+
+#define	SEECTL          		0x1e
+#define		EXTARBACK       	0x80
+#define		EXTARBREQ       	0x40
+#define		SEEMS           	0x20
+#define		SEERDY          	0x10
+#define		SEECS           	0x08
+#define		SEECK           	0x04
+#define		SEEDO           	0x02
+#define		SEEDI           	0x01
+
+#define	SBLKCTL         		0x1f
+#define		DIAGLEDEN       	0x80
+#define		DIAGLEDON       	0x40
+#define		AUTOFLUSHDIS    	0x20
+#define		ENAB40          	0x08
+#define		SELBUSB         	0x08
+#define		ENAB20          	0x04
+#define		SELWIDE         	0x02
+#define		XCVR            	0x01
+
+#define	BUSY_TARGETS    		0x20
+#define	TARG_SCSIRATE   		0x20
+
+#define	SRAM_BASE       		0x20
+
+#define	ULTRA_ENB       		0x30
+#define	CMDSIZE_TABLE   		0x30
+
+#define	DISC_DSB        		0x32
+
+#define	CMDSIZE_TABLE_TAIL		0x34
+
+#define	MWI_RESIDUAL    		0x38
+
+#define	NEXT_QUEUED_SCB 		0x39
+
+#define	MSG_OUT         		0x3a
+
+#define	DMAPARAMS       		0x3b
+#define		PRELOADEN       	0x80
+#define		WIDEODD         	0x40
+#define		SCSIEN          	0x20
+#define		SDMAEN          	0x10
+#define		SDMAENACK       	0x10
+#define		HDMAEN          	0x08
+#define		HDMAENACK       	0x08
+#define		DIRECTION       	0x04
+#define		FIFOFLUSH       	0x02
+#define		FIFORESET       	0x01
+
+#define	SEQ_FLAGS       		0x3c
+#define		IDENTIFY_SEEN   	0x80
+#define		TARGET_CMD_IS_TAGGED	0x40
+#define		DPHASE          	0x20
+#define		TARG_CMD_PENDING	0x10
+#define		CMDPHASE_PENDING	0x08
+#define		DPHASE_PENDING  	0x04
+#define		SPHASE_PENDING  	0x02
+#define		NO_DISCONNECT   	0x01
+
+#define	SAVED_SCSIID    		0x3d
+
+#define	SAVED_LUN       		0x3e
+
+#define	LASTPHASE       		0x3f
+#define		P_MESGIN        	0xe0
+#define		PHASE_MASK      	0xe0
+#define		P_STATUS        	0xc0
+#define		P_MESGOUT       	0xa0
+#define		P_COMMAND       	0x80
+#define		CDI             	0x80
+#define		P_DATAIN        	0x40
+#define		IOI             	0x40
+#define		MSGI            	0x20
+#define		P_BUSFREE       	0x01
+#define		P_DATAOUT       	0x00
+
+#define	WAITING_SCBH    		0x40
+
+#define	DISCONNECTED_SCBH		0x41
+
+#define	FREE_SCBH       		0x42
+
+#define	COMPLETE_SCBH   		0x43
+
+#define	HSCB_ADDR       		0x44
+
+#define	SHARED_DATA_ADDR		0x48
+
+#define	KERNEL_QINPOS   		0x4c
+
+#define	QINPOS          		0x4d
+
+#define	QOUTPOS         		0x4e
+
+#define	KERNEL_TQINPOS  		0x4f
+
+#define	TQINPOS         		0x50
+
+#define	ARG_1           		0x51
+#define	RETURN_1        		0x51
+#define		SEND_MSG        	0x80
+#define		SEND_SENSE      	0x40
+#define		SEND_REJ        	0x20
+#define		MSGOUT_PHASEMIS 	0x10
+#define		EXIT_MSG_LOOP   	0x08
+#define		CONT_MSG_LOOP   	0x04
+#define		CONT_TARG_SESSION	0x02
+
+#define	ARG_2           		0x52
+#define	RETURN_2        		0x52
+
+#define	LAST_MSG        		0x53
+
+#define	SCSISEQ_TEMPLATE		0x54
+#define		ENSELO          	0x40
+#define		ENSELI          	0x20
+#define		ENRSELI         	0x10
+#define		ENAUTOATNO      	0x08
+#define		ENAUTOATNI      	0x04
+#define		ENAUTOATNP      	0x02
+
+#define	DATA_COUNT_ODD  		0x55
+
+#define	INITIATOR_TAG   		0x56
+
+#define	SEQ_FLAGS2      		0x57
+#define		TARGET_MSG_PENDING	0x02
+#define		SCB_DMA         	0x01
+
+#define	SCSICONF        		0x5a
+#define		TERM_ENB        	0x80
+#define		RESET_SCSI      	0x40
+#define		ENSPCHK         	0x20
+#define		HWSCSIID        	0x0f
+#define		HSCSIID         	0x07
+
+#define	INTDEF          		0x5c
+#define		EDGE_TRIG       	0x80
+#define		VECTOR          	0x0f
+
+#define	HOSTCONF        		0x5d
+
+#define	HA_274_BIOSCTRL 		0x5f
+#define		BIOSDISABLED    	0x30
+#define		BIOSMODE        	0x30
+#define		CHANNEL_B_PRIMARY	0x08
+
+#define	SEQCTL          		0x60
+#define		PERRORDIS       	0x80
+#define		PAUSEDIS        	0x40
+#define		FAILDIS         	0x20
+#define		FASTMODE        	0x10
+#define		BRKADRINTEN     	0x08
+#define		STEP            	0x04
+#define		SEQRESET        	0x02
+#define		LOADRAM         	0x01
+
+#define	SEQRAM          		0x61
+
+#define	SEQADDR0        		0x62
+
+#define	SEQADDR1        		0x63
+#define		SEQADDR1_MASK   	0x01
+
+#define	ACCUM           		0x64
+
+#define	SINDEX          		0x65
+
+#define	DINDEX          		0x66
+
+#define	ALLONES         		0x69
+
+#define	ALLZEROS        		0x6a
+
+#define	NONE            		0x6a
+
+#define	FLAGS           		0x6b
+#define		ZERO            	0x02
+#define		CARRY           	0x01
+
+#define	SINDIR          		0x6c
+
+#define	DINDIR          		0x6d
+
+#define	FUNCTION1       		0x6e
+
+#define	STACK           		0x6f
+
+#define	TARG_OFFSET     		0x70
+
+#define	BCTL            		0x84
+#define		ACE             	0x08
+#define		ENABLE          	0x01
+
+#define	DSCOMMAND0      		0x84
+#define		CACHETHEN       	0x80
+#define		DPARCKEN        	0x40
+#define		MPARCKEN        	0x20
+#define		EXTREQLCK       	0x10
+#define		INTSCBRAMSEL    	0x08
+#define		RAMPS           	0x04
+#define		USCBSIZE32      	0x02
+#define		CIOPARCKEN      	0x01
+
+#define	BUSTIME         		0x85
+#define		BOFF            	0xf0
+#define		BON             	0x0f
+
+#define	DSCOMMAND1      		0x85
+#define		DSLATT          	0xfc
+#define		HADDLDSEL1      	0x02
+#define		HADDLDSEL0      	0x01
+
+#define	BUSSPD          		0x86
+#define		DFTHRSH         	0xc0
+#define		DFTHRSH_75      	0x80
+#define		STBOFF          	0x38
+#define		STBON           	0x07
+
+#define	HS_MAILBOX      		0x86
+#define		HOST_MAILBOX    	0xf0
+#define		HOST_TQINPOS    	0x80
+#define		SEQ_MAILBOX     	0x0f
+
+#define	DSPCISTATUS     		0x86
+#define		DFTHRSH_100     	0xc0
+
+#define	HCNTRL          		0x87
+#define		POWRDN          	0x40
+#define		SWINT           	0x10
+#define		IRQMS           	0x08
+#define		PAUSE           	0x04
+#define		INTEN           	0x02
+#define		CHIPRST         	0x01
+#define		CHIPRSTACK      	0x01
+
+#define	HADDR           		0x88
+
+#define	HCNT            		0x8c
+
+#define	SCBPTR          		0x90
+
+#define	INTSTAT         		0x91
+#define		SEQINT_MASK     	0xf1
+#define		OUT_OF_RANGE    	0xe1
+#define		NO_FREE_SCB     	0xd1
+#define		SCB_MISMATCH    	0xc1
+#define		MISSED_BUSFREE  	0xb1
+#define		MKMSG_FAILED    	0xa1
+#define		DATA_OVERRUN    	0x91
+#define		PERR_DETECTED   	0x81
+#define		BAD_STATUS      	0x71
+#define		HOST_MSG_LOOP   	0x61
+#define		PDATA_REINIT    	0x51
+#define		IGN_WIDE_RES    	0x41
+#define		NO_MATCH        	0x31
+#define		NO_IDENT        	0x21
+#define		SEND_REJECT     	0x11
+#define		INT_PEND        	0x0f
+#define		BRKADRINT       	0x08
+#define		SCSIINT         	0x04
+#define		CMDCMPLT        	0x02
+#define		BAD_PHASE       	0x01
+#define		SEQINT          	0x01
+
+#define	CLRINT          		0x92
+#define		CLRPARERR       	0x10
+#define		CLRBRKADRINT    	0x08
+#define		CLRSCSIINT      	0x04
+#define		CLRCMDINT       	0x02
+#define		CLRSEQINT       	0x01
+
+#define	ERROR           		0x92
+#define		CIOPARERR       	0x80
+#define		PCIERRSTAT      	0x40
+#define		MPARERR         	0x20
+#define		DPARERR         	0x10
+#define		SQPARERR        	0x08
+#define		ILLOPCODE       	0x04
+#define		ILLSADDR        	0x02
+#define		ILLHADDR        	0x01
+
+#define	DFCNTRL         		0x93
+
+#define	DFSTATUS        		0x94
+#define		PRELOAD_AVAIL   	0x80
+#define		DFCACHETH       	0x40
+#define		FIFOQWDEMP      	0x20
+#define		MREQPEND        	0x10
+#define		HDONE           	0x08
+#define		DFTHRESH        	0x04
+#define		FIFOFULL        	0x02
+#define		FIFOEMP         	0x01
+
+#define	DFWADDR         		0x95
+
+#define	DFRADDR         		0x97
+
+#define	DFDAT           		0x99
+
+#define	SCBCNT          		0x9a
+#define		SCBAUTO         	0x80
+#define		SCBCNT_MASK     	0x1f
+
+#define	QINFIFO         		0x9b
+
+#define	QINCNT          		0x9c
+
+#define	QOUTFIFO        		0x9d
+
+#define	CRCCONTROL1     		0x9d
+#define		CRCONSEEN       	0x80
+#define		CRCVALCHKEN     	0x40
+#define		CRCENDCHKEN     	0x20
+#define		CRCREQCHKEN     	0x10
+#define		TARGCRCENDEN    	0x08
+#define		TARGCRCCNTEN    	0x04
+
+#define	QOUTCNT         		0x9e
+
+#define	SCSIPHASE       		0x9e
+#define		STATUS_PHASE    	0x20
+#define		COMMAND_PHASE   	0x10
+#define		MSG_IN_PHASE    	0x08
+#define		MSG_OUT_PHASE   	0x04
+#define		DATA_PHASE_MASK 	0x03
+#define		DATA_IN_PHASE   	0x02
+#define		DATA_OUT_PHASE  	0x01
+
+#define	SFUNCT          		0x9f
+#define		ALT_MODE        	0x80
+
+#define	SCB_BASE        		0xa0
+
+#define	SCB_CDB_PTR     		0xa0
+#define	SCB_RESIDUAL_DATACNT		0xa0
+#define	SCB_CDB_STORE   		0xa0
+
+#define	SCB_RESIDUAL_SGPTR		0xa4
+
+#define	SCB_SCSI_STATUS 		0xa8
+
+#define	SCB_TARGET_PHASES		0xa9
+
+#define	SCB_TARGET_DATA_DIR		0xaa
+
+#define	SCB_TARGET_ITAG 		0xab
+
+#define	SCB_DATAPTR     		0xac
+
+#define	SCB_DATACNT     		0xb0
+#define		SG_LAST_SEG     	0x80
+#define		SG_HIGH_ADDR_BITS	0x7f
+
+#define	SCB_SGPTR       		0xb4
+#define		SG_RESID_VALID  	0x04
+#define		SG_FULL_RESID   	0x02
+#define		SG_LIST_NULL    	0x01
+
+#define	SCB_CONTROL     		0xb8
+#define		TARGET_SCB      	0x80
+#define		DISCENB         	0x40
+#define		TAG_ENB         	0x20
+#define		MK_MESSAGE      	0x10
+#define		ULTRAENB        	0x08
+#define		DISCONNECTED    	0x04
+#define		SCB_TAG_TYPE    	0x03
+
+#define	SCB_SCSIID      		0xb9
+#define		TID             	0xf0
+#define		TWIN_CHNLB      	0x80
+#define		TWIN_TID        	0x70
+#define		OID             	0x0f
+
+#define	SCB_LUN         		0xba
+#define		LID             	0xff
+
+#define	SCB_TAG         		0xbb
+
+#define	SCB_CDB_LEN     		0xbc
+
+#define	SCB_SCSIRATE    		0xbd
+
+#define	SCB_SCSIOFFSET  		0xbe
+
+#define	SCB_NEXT        		0xbf
+
+#define	SCB_64_SPARE    		0xc0
+
+#define	SEECTL_2840     		0xc0
+#define		CS_2840         	0x04
+#define		CK_2840         	0x02
+#define		DO_2840         	0x01
+
+#define	STATUS_2840     		0xc1
+#define		EEPROM_TF       	0x80
+#define		BIOS_SEL        	0x60
+#define		ADSEL           	0x1e
+#define		DI_2840         	0x01
+
+#define	SCB_64_BTT      		0xd0
+
+#define	CCHADDR         		0xe0
+
+#define	CCHCNT          		0xe8
+
+#define	CCSGRAM         		0xe9
+
+#define	CCSGADDR        		0xea
+
+#define	CCSGCTL         		0xeb
+#define		CCSGDONE        	0x80
+#define		CCSGEN          	0x08
+#define		SG_FETCH_NEEDED 	0x02
+#define		CCSGRESET       	0x01
+
+#define	CCSCBRAM        		0xec
+
+#define	CCSCBADDR       		0xed
+
+#define	CCSCBCTL        		0xee
+#define		CCSCBDONE       	0x80
+#define		ARRDONE         	0x40
+#define		CCARREN         	0x10
+#define		CCSCBEN         	0x08
+#define		CCSCBDIR        	0x04
+#define		CCSCBRESET      	0x01
+
+#define	CCSCBCNT        		0xef
+
+#define	SCBBADDR        		0xf0
+
+#define	CCSCBPTR        		0xf1
+
+#define	HNSCB_QOFF      		0xf4
+
+#define	SNSCB_QOFF      		0xf6
+
+#define	SDSCB_QOFF      		0xf8
+
+#define	QOFF_CTLSTA     		0xfa
+#define		SCB_AVAIL       	0x40
+#define		SNSCB_ROLLOVER  	0x20
+#define		SDSCB_ROLLOVER  	0x10
+#define		SCB_QSIZE       	0x07
+#define		SCB_QSIZE_256   	0x06
+
+#define	DFF_THRSH       		0xfb
+#define		WR_DFTHRSH      	0x70
+#define		WR_DFTHRSH_MAX  	0x70
+#define		WR_DFTHRSH_90   	0x60
+#define		WR_DFTHRSH_85   	0x50
+#define		WR_DFTHRSH_75   	0x40
+#define		WR_DFTHRSH_63   	0x30
+#define		WR_DFTHRSH_50   	0x20
+#define		WR_DFTHRSH_25   	0x10
+#define		RD_DFTHRSH      	0x07
+#define		RD_DFTHRSH_MAX  	0x07
+#define		RD_DFTHRSH_90   	0x06
+#define		RD_DFTHRSH_85   	0x05
+#define		RD_DFTHRSH_75   	0x04
+#define		RD_DFTHRSH_63   	0x03
+#define		RD_DFTHRSH_50   	0x02
+#define		RD_DFTHRSH_25   	0x01
+#define		RD_DFTHRSH_MIN  	0x00
+#define		WR_DFTHRSH_MIN  	0x00
+
+#define	SG_CACHE_SHADOW 		0xfc
+#define		SG_ADDR_MASK    	0xf8
+#define		ODD_SEG         	0x04
+#define		LAST_SEG        	0x02
+#define		LAST_SEG_DONE   	0x01
+
+#define	SG_CACHE_PRE    		0xfc
+
+
+#define	MAX_OFFSET_ULTRA2	0x7f
+#define	MAX_OFFSET_16BIT	0x08
+#define	BUS_8_BIT	0x00
+#define	TARGET_CMD_CMPLT	0xfe
+#define	STATUS_QUEUE_FULL	0x28
+#define	STATUS_BUSY	0x08
+#define	MAX_OFFSET_8BIT	0x0f
+#define	BUS_32_BIT	0x02
+#define	CCSGADDR_MAX	0x80
+#define	TID_SHIFT	0x04
+#define	SCB_DOWNLOAD_SIZE_64	0x30
+#define	HOST_MAILBOX_SHIFT	0x04
+#define	CMD_GROUP_CODE_SHIFT	0x05
+#define	CCSGRAM_MAXSEGS	0x10
+#define	SCB_LIST_NULL	0xff
+#define	SG_SIZEOF	0x08
+#define	SCB_DOWNLOAD_SIZE	0x20
+#define	SEQ_MAILBOX_SHIFT	0x00
+#define	TARGET_DATA_IN	0x01
+#define	HOST_MSG	0xff
+#define	BUS_16_BIT	0x01
+#define	SCB_UPLOAD_SIZE	0x20
+
+
+/* Downloaded Constant Definitions */
+#define	INVERTED_CACHESIZE_MASK	0x03
+#define	SG_PREFETCH_ADDR_MASK	0x06
+#define	SG_PREFETCH_ALIGN_MASK	0x05
+#define	QOUTFIFO_OFFSET	0x00
+#define	SG_PREFETCH_CNT	0x04
+#define	CACHESIZE_MASK	0x02
+#define	QINFIFO_OFFSET	0x01
diff -Nru a/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped b/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/scsi/aic7xxx/aic7xxx_seq.h_shipped	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,1299 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id$
+ * $Id$
+ */
+static uint8_t seqprog[] = {
+	0xb2, 0x00, 0x00, 0x08,
+	0xf7, 0x11, 0x22, 0x08,
+	0x00, 0x65, 0xe0, 0x59,
+	0xf7, 0x01, 0x02, 0x08,
+	0xff, 0x6a, 0x24, 0x08,
+	0x40, 0x00, 0x40, 0x68,
+	0x08, 0x1f, 0x3e, 0x10,
+	0x40, 0x00, 0x40, 0x68,
+	0xff, 0x40, 0x3c, 0x60,
+	0x08, 0x1f, 0x3e, 0x10,
+	0x60, 0x0b, 0x42, 0x68,
+	0x40, 0xfa, 0x12, 0x78,
+	0x01, 0x4d, 0xc8, 0x30,
+	0x00, 0x4c, 0x12, 0x70,
+	0x01, 0x39, 0xa2, 0x30,
+	0x00, 0x6a, 0xb2, 0x5e,
+	0x01, 0x51, 0x20, 0x31,
+	0x01, 0x57, 0xae, 0x00,
+	0x0d, 0x6a, 0x76, 0x00,
+	0x00, 0x51, 0x04, 0x5e,
+	0x01, 0x51, 0xc8, 0x30,
+	0x00, 0x39, 0xc8, 0x60,
+	0x00, 0xbb, 0x30, 0x70,
+	0xc1, 0x6a, 0xca, 0x5e,
+	0x01, 0xbf, 0x72, 0x30,
+	0x01, 0x40, 0x7e, 0x31,
+	0x01, 0x90, 0x80, 0x30,
+	0x01, 0xf6, 0xd4, 0x30,
+	0x01, 0x4d, 0x9a, 0x18,
+	0xfe, 0x57, 0xae, 0x08,
+	0x01, 0x40, 0x20, 0x31,
+	0x00, 0x65, 0xcc, 0x58,
+	0x60, 0x0b, 0x40, 0x78,
+	0x08, 0x6a, 0x18, 0x00,
+	0x08, 0x11, 0x22, 0x00,
+	0x60, 0x0b, 0x00, 0x78,
+	0x40, 0x0b, 0xfc, 0x68,
+	0x80, 0x0b, 0xb6, 0x78,
+	0x20, 0x6a, 0x16, 0x00,
+	0xa4, 0x6a, 0x06, 0x00,
+	0x08, 0x3c, 0x78, 0x00,
+	0x01, 0x50, 0xc8, 0x30,
+	0xe0, 0x6a, 0xcc, 0x00,
+	0x48, 0x6a, 0xee, 0x5d,
+	0x01, 0x6a, 0xdc, 0x01,
+	0x88, 0x6a, 0xcc, 0x00,
+	0x48, 0x6a, 0xee, 0x5d,
+	0x01, 0x6a, 0x26, 0x01,
+	0xf0, 0x19, 0x7a, 0x08,
+	0x0f, 0x18, 0xc8, 0x08,
+	0x0f, 0x0f, 0xc8, 0x08,
+	0x0f, 0x05, 0xc8, 0x08,
+	0x00, 0x3d, 0x7a, 0x00,
+	0x08, 0x1f, 0x6e, 0x78,
+	0x80, 0x3d, 0x7a, 0x00,
+	0x01, 0x3d, 0xd8, 0x31,
+	0x01, 0x3d, 0x32, 0x31,
+	0x10, 0x03, 0x46, 0x79,
+	0x00, 0x65, 0xf4, 0x58,
+	0x80, 0x66, 0xae, 0x78,
+	0x01, 0x66, 0xd8, 0x31,
+	0x01, 0x66, 0x32, 0x31,
+	0x3f, 0x66, 0x7c, 0x08,
+	0x40, 0x66, 0x82, 0x68,
+	0x01, 0x3c, 0x78, 0x00,
+	0x10, 0x03, 0x9e, 0x78,
+	0x00, 0x65, 0xf4, 0x58,
+	0xe0, 0x66, 0xc8, 0x18,
+	0x00, 0x65, 0xaa, 0x50,
+	0xdd, 0x66, 0xc8, 0x18,
+	0x00, 0x65, 0xaa, 0x48,
+	0x01, 0x66, 0xd8, 0x31,
+	0x01, 0x66, 0x32, 0x31,
+	0x10, 0x03, 0x46, 0x79,
+	0x00, 0x65, 0xf4, 0x58,
+	0x01, 0x66, 0xd8, 0x31,
+	0x01, 0x66, 0x32, 0x31,
+	0x01, 0x66, 0xac, 0x30,
+	0x40, 0x3c, 0x78, 0x00,
+	0xff, 0x6a, 0xd8, 0x01,
+	0xff, 0x6a, 0x32, 0x01,
+	0x90, 0x3c, 0x78, 0x00,
+	0x02, 0x57, 0x3a, 0x69,
+	0x10, 0x03, 0x38, 0x69,
+	0x00, 0x65, 0x1e, 0x41,
+	0x02, 0x57, 0xae, 0x00,
+	0x00, 0x65, 0x9e, 0x40,
+	0x61, 0x6a, 0xca, 0x5e,
+	0x08, 0x51, 0x1e, 0x71,
+	0x02, 0x0b, 0xb2, 0x78,
+	0x00, 0x65, 0xae, 0x40,
+	0x1a, 0x01, 0x02, 0x00,
+	0xf0, 0x19, 0x7a, 0x08,
+	0x0f, 0x0f, 0xc8, 0x08,
+	0x0f, 0x05, 0xc8, 0x08,
+	0x00, 0x3d, 0x7a, 0x00,
+	0x08, 0x1f, 0xc4, 0x78,
+	0x80, 0x3d, 0x7a, 0x00,
+	0x20, 0x6a, 0x16, 0x00,
+	0x00, 0x65, 0xc0, 0x41,
+	0x00, 0x65, 0xa4, 0x5e,
+	0x00, 0x65, 0x12, 0x40,
+	0x20, 0x11, 0xd2, 0x68,
+	0x20, 0x6a, 0x18, 0x00,
+	0x20, 0x11, 0x22, 0x00,
+	0xf7, 0x1f, 0xca, 0x08,
+	0x80, 0xb9, 0xd8, 0x78,
+	0x08, 0x65, 0xca, 0x00,
+	0x01, 0x65, 0x3e, 0x30,
+	0x01, 0xb9, 0x1e, 0x30,
+	0x7f, 0xb9, 0x0a, 0x08,
+	0x01, 0xb9, 0x0a, 0x30,
+	0x01, 0x54, 0xca, 0x30,
+	0x80, 0xb8, 0xe6, 0x78,
+	0x80, 0x65, 0xca, 0x00,
+	0x01, 0x65, 0x00, 0x34,
+	0x01, 0x54, 0x00, 0x34,
+	0x1a, 0x01, 0x02, 0x00,
+	0x08, 0xb8, 0xf0, 0x78,
+	0x20, 0x01, 0x02, 0x00,
+	0x02, 0xbd, 0x08, 0x34,
+	0x01, 0xbd, 0x08, 0x34,
+	0x08, 0x01, 0x02, 0x00,
+	0x02, 0x0b, 0xf6, 0x78,
+	0xf7, 0x01, 0x02, 0x08,
+	0x01, 0x06, 0xcc, 0x34,
+	0xb2, 0x00, 0x00, 0x08,
+	0x40, 0x6a, 0x16, 0x00,
+	0x01, 0x40, 0x20, 0x31,
+	0x01, 0xbf, 0x80, 0x30,
+	0x01, 0xb9, 0x7a, 0x30,
+	0x01, 0xba, 0x7c, 0x30,
+	0x00, 0x65, 0xea, 0x58,
+	0x80, 0x0b, 0xbc, 0x79,
+	0xe4, 0x6a, 0x60, 0x5d,
+	0x80, 0xba, 0x76, 0x5d,
+	0x20, 0xb8, 0x16, 0x79,
+	0x20, 0x6a, 0x76, 0x5d,
+	0x00, 0xab, 0x76, 0x5d,
+	0x01, 0xa9, 0x78, 0x30,
+	0x10, 0xb8, 0x1e, 0x79,
+	0xe4, 0x6a, 0x60, 0x5d,
+	0x00, 0x65, 0xae, 0x40,
+	0x10, 0x03, 0x36, 0x69,
+	0x08, 0x3c, 0x52, 0x69,
+	0x04, 0x3c, 0x8a, 0x69,
+	0x02, 0x3c, 0x90, 0x69,
+	0x01, 0x3c, 0x3c, 0x79,
+	0x01, 0x6a, 0xa2, 0x30,
+	0x00, 0x65, 0x9c, 0x59,
+	0x04, 0x51, 0x2c, 0x61,
+	0x00, 0x6a, 0xb2, 0x5e,
+	0x0d, 0x6a, 0x76, 0x00,
+	0x00, 0xbb, 0x04, 0x5e,
+	0x00, 0x65, 0x16, 0x41,
+	0xa4, 0x6a, 0x06, 0x00,
+	0x00, 0x65, 0xf4, 0x58,
+	0x00, 0x65, 0xae, 0x40,
+	0xe4, 0x6a, 0x60, 0x5d,
+	0x20, 0x3c, 0x42, 0x79,
+	0x02, 0x6a, 0x76, 0x5d,
+	0x04, 0x6a, 0x76, 0x5d,
+	0x01, 0x03, 0x44, 0x69,
+	0xf7, 0x11, 0x22, 0x08,
+	0xff, 0x6a, 0x24, 0x08,
+	0xff, 0x6a, 0x06, 0x08,
+	0x01, 0x6a, 0x7e, 0x00,
+	0x00, 0x65, 0x9c, 0x59,
+	0x00, 0x65, 0x04, 0x40,
+	0x80, 0x86, 0xc8, 0x08,
+	0x01, 0x4f, 0xc8, 0x30,
+	0x00, 0x50, 0x64, 0x61,
+	0xc4, 0x6a, 0x60, 0x5d,
+	0x40, 0x3c, 0x60, 0x79,
+	0x28, 0x6a, 0x76, 0x5d,
+	0x00, 0x65, 0x44, 0x41,
+	0x08, 0x6a, 0x76, 0x5d,
+	0x00, 0x65, 0x44, 0x41,
+	0x84, 0x6a, 0x60, 0x5d,
+	0x00, 0x65, 0xf4, 0x58,
+	0x01, 0x66, 0xc8, 0x30,
+	0x01, 0x64, 0xd8, 0x31,
+	0x01, 0x64, 0x32, 0x31,
+	0x5b, 0x64, 0xc8, 0x28,
+	0x30, 0x64, 0xca, 0x18,
+	0x01, 0x6c, 0xc8, 0x30,
+	0xff, 0x64, 0x86, 0x79,
+	0x08, 0x01, 0x02, 0x00,
+	0x02, 0x0b, 0x78, 0x79,
+	0x01, 0x64, 0x7e, 0x61,
+	0xf7, 0x01, 0x02, 0x08,
+	0x01, 0x06, 0xd8, 0x31,
+	0x01, 0x06, 0x32, 0x31,
+	0xff, 0x64, 0xc8, 0x18,
+	0xff, 0x64, 0x78, 0x69,
+	0xf7, 0x3c, 0x78, 0x08,
+	0x00, 0x65, 0x1e, 0x41,
+	0x40, 0xaa, 0x7e, 0x10,
+	0x04, 0xaa, 0x60, 0x5d,
+	0x00, 0x65, 0x52, 0x42,
+	0xc4, 0x6a, 0x60, 0x5d,
+	0xc0, 0x6a, 0x7e, 0x00,
+	0x00, 0xa8, 0x76, 0x5d,
+	0xe4, 0x6a, 0x06, 0x00,
+	0x00, 0x6a, 0x76, 0x5d,
+	0x00, 0x65, 0x44, 0x41,
+	0x10, 0x3c, 0xa0, 0x69,
+	0x00, 0xbb, 0x80, 0x44,
+	0x18, 0x6a, 0xda, 0x01,
+	0x01, 0x69, 0xd8, 0x31,
+	0x1c, 0x6a, 0xd0, 0x01,
+	0x09, 0xee, 0xdc, 0x01,
+	0x80, 0xee, 0xa8, 0x79,
+	0xff, 0x6a, 0xdc, 0x09,
+	0x01, 0x93, 0x26, 0x01,
+	0x03, 0x6a, 0x2a, 0x01,
+	0x01, 0x69, 0x32, 0x31,
+	0x1c, 0x6a, 0xd2, 0x5d,
+	0x0a, 0x93, 0x26, 0x01,
+	0x00, 0x65, 0x9a, 0x5e,
+	0x01, 0x50, 0xa0, 0x18,
+	0x02, 0x6a, 0x22, 0x05,
+	0x80, 0x6a, 0x74, 0x00,
+	0x80, 0x3c, 0x78, 0x00,
+	0x00, 0x65, 0xca, 0x5d,
+	0x01, 0x3f, 0xc8, 0x30,
+	0xbf, 0x64, 0x52, 0x7a,
+	0x80, 0x64, 0xa6, 0x73,
+	0xa0, 0x64, 0x04, 0x74,
+	0xc0, 0x64, 0xf8, 0x73,
+	0xe0, 0x64, 0x34, 0x74,
+	0x01, 0x6a, 0xca, 0x5e,
+	0x00, 0x65, 0xc0, 0x41,
+	0xf7, 0x11, 0x22, 0x08,
+	0x01, 0x06, 0xd4, 0x30,
+	0xff, 0x6a, 0x24, 0x08,
+	0xf7, 0x01, 0x02, 0x08,
+	0x09, 0x0c, 0xda, 0x79,
+	0x08, 0x0c, 0x04, 0x68,
+	0xb1, 0x6a, 0xca, 0x5e,
+	0xff, 0x6a, 0x26, 0x09,
+	0x12, 0x01, 0x02, 0x00,
+	0x02, 0x6a, 0x08, 0x30,
+	0xff, 0x6a, 0x08, 0x08,
+	0xdf, 0x01, 0x02, 0x08,
+	0x01, 0x6a, 0x7e, 0x00,
+	0xff, 0x6a, 0x78, 0x0c,
+	0xff, 0x6a, 0xc8, 0x08,
+	0x08, 0xa4, 0x48, 0x19,
+	0x00, 0xa5, 0x4a, 0x21,
+	0x00, 0xa6, 0x4c, 0x21,
+	0x00, 0xa7, 0x4e, 0x25,
+	0x08, 0xeb, 0xce, 0x7e,
+	0x80, 0xeb, 0xfa, 0x79,
+	0xff, 0x6a, 0xd6, 0x09,
+	0x08, 0xeb, 0xfe, 0x69,
+	0xff, 0x6a, 0xd4, 0x0c,
+	0x80, 0xa3, 0xce, 0x6e,
+	0x88, 0xeb, 0x14, 0x72,
+	0x08, 0xeb, 0xce, 0x6e,
+	0x04, 0xea, 0x18, 0xe2,
+	0x08, 0xee, 0xce, 0x6e,
+	0x04, 0x6a, 0xd0, 0x81,
+	0x05, 0xa4, 0xc0, 0x89,
+	0x03, 0xa5, 0xc2, 0x31,
+	0x09, 0x6a, 0xd6, 0x05,
+	0x00, 0x65, 0xfc, 0x59,
+	0x06, 0xa4, 0xd4, 0x89,
+	0x80, 0x94, 0xce, 0x7e,
+	0x07, 0xe9, 0x10, 0x31,
+	0x01, 0x8c, 0x20, 0x7a,
+	0x01, 0x55, 0xaa, 0x10,
+	0x01, 0xe9, 0x46, 0x31,
+	0x00, 0xa3, 0xac, 0x5e,
+	0x00, 0x65, 0xee, 0x59,
+	0x01, 0xa4, 0xca, 0x30,
+	0x01, 0x55, 0x2c, 0x7a,
+	0x04, 0x65, 0xca, 0x00,
+	0x80, 0xa3, 0x30, 0x7a,
+	0x02, 0x65, 0xca, 0x00,
+	0x01, 0x65, 0xf8, 0x31,
+	0x80, 0x93, 0x26, 0x01,
+	0xff, 0x6a, 0xd4, 0x0c,
+	0x01, 0x8c, 0xc8, 0x30,
+	0x00, 0x88, 0xc8, 0x18,
+	0x02, 0x64, 0xc8, 0x88,
+	0xff, 0x64, 0xce, 0x7e,
+	0xff, 0x8d, 0x46, 0x6a,
+	0xff, 0x8e, 0x46, 0x6a,
+	0x03, 0x8c, 0xd4, 0x98,
+	0x00, 0x65, 0xce, 0x56,
+	0x01, 0x64, 0x70, 0x30,
+	0xff, 0x64, 0xc8, 0x10,
+	0x01, 0x64, 0xc8, 0x18,
+	0x00, 0x8c, 0x18, 0x19,
+	0xff, 0x8d, 0x1a, 0x21,
+	0xff, 0x8e, 0x1c, 0x25,
+	0x80, 0x3c, 0x56, 0x6a,
+	0x21, 0x6a, 0xca, 0x46,
+	0xa8, 0x6a, 0x76, 0x00,
+	0x79, 0x6a, 0x76, 0x00,
+	0x40, 0x3f, 0x5e, 0x6a,
+	0x04, 0x3b, 0x76, 0x00,
+	0x04, 0x6a, 0xd4, 0x81,
+	0x20, 0x3c, 0x66, 0x7a,
+	0x51, 0x6a, 0xca, 0x5e,
+	0x00, 0x65, 0x80, 0x42,
+	0x20, 0x3c, 0x78, 0x00,
+	0x00, 0xb3, 0xac, 0x5e,
+	0x07, 0xac, 0x10, 0x31,
+	0x05, 0xb3, 0x46, 0x31,
+	0x88, 0x6a, 0xcc, 0x00,
+	0xac, 0x6a, 0xe0, 0x5d,
+	0xa3, 0x6a, 0xcc, 0x00,
+	0xb3, 0x6a, 0xe4, 0x5d,
+	0x00, 0x65, 0x36, 0x5a,
+	0xfd, 0xa4, 0x48, 0x09,
+	0x01, 0x8c, 0xaa, 0x08,
+	0x03, 0x8c, 0x10, 0x30,
+	0x00, 0x65, 0xd8, 0x5d,
+	0x01, 0xa4, 0x92, 0x7a,
+	0x04, 0x3b, 0x76, 0x08,
+	0x01, 0x3b, 0x26, 0x31,
+	0x80, 0x02, 0x04, 0x00,
+	0x10, 0x0c, 0x88, 0x7a,
+	0x03, 0x9e, 0x8a, 0x6a,
+	0x7f, 0x02, 0x04, 0x08,
+	0x91, 0x6a, 0xca, 0x5e,
+	0x00, 0x65, 0xc0, 0x41,
+	0x01, 0xa4, 0xca, 0x30,
+	0x80, 0xa3, 0x98, 0x7a,
+	0x02, 0x65, 0xca, 0x00,
+	0x01, 0x55, 0x9c, 0x7a,
+	0x04, 0x65, 0xca, 0x00,
+	0x01, 0x65, 0xf8, 0x31,
+	0x01, 0x3b, 0x26, 0x31,
+	0x00, 0x65, 0x02, 0x5a,
+	0x01, 0xfc, 0xaa, 0x6a,
+	0x80, 0x0b, 0xa0, 0x6a,
+	0x10, 0x0c, 0xa0, 0x7a,
+	0x20, 0x93, 0xa0, 0x6a,
+	0x02, 0x93, 0x26, 0x01,
+	0x02, 0xfc, 0xb4, 0x7a,
+	0x40, 0x0d, 0xce, 0x6a,
+	0x01, 0xa4, 0x48, 0x01,
+	0x00, 0x65, 0xce, 0x42,
+	0x40, 0x0d, 0xba, 0x6a,
+	0x00, 0x65, 0x02, 0x5a,
+	0x00, 0x65, 0xac, 0x42,
+	0x80, 0xfc, 0xc4, 0x7a,
+	0x80, 0xa4, 0xc4, 0x6a,
+	0xff, 0xa5, 0x4a, 0x19,
+	0xff, 0xa6, 0x4c, 0x21,
+	0xff, 0xa7, 0x4e, 0x21,
+	0xf8, 0xfc, 0x48, 0x09,
+	0xff, 0x6a, 0xaa, 0x08,
+	0x04, 0xfc, 0xcc, 0x7a,
+	0x01, 0x55, 0xaa, 0x00,
+	0xff, 0x6a, 0x46, 0x09,
+	0x04, 0x3b, 0xe6, 0x6a,
+	0x02, 0x93, 0x26, 0x01,
+	0x01, 0x94, 0xd0, 0x7a,
+	0x01, 0x94, 0xd0, 0x7a,
+	0x01, 0x94, 0xd0, 0x7a,
+	0x01, 0x94, 0xd0, 0x7a,
+	0x01, 0x94, 0xd0, 0x7a,
+	0x01, 0xa4, 0xe4, 0x7a,
+	0x01, 0xfc, 0xde, 0x7a,
+	0x01, 0x94, 0xe6, 0x6a,
+	0x00, 0x65, 0x80, 0x42,
+	0x01, 0x94, 0xe4, 0x7a,
+	0x10, 0x94, 0xe6, 0x6a,
+	0xd7, 0x93, 0x26, 0x09,
+	0x28, 0x93, 0xea, 0x6a,
+	0x01, 0x85, 0x0a, 0x01,
+	0x02, 0xfc, 0xf2, 0x6a,
+	0x01, 0x14, 0x46, 0x31,
+	0xff, 0x6a, 0x10, 0x09,
+	0xfe, 0x85, 0x0a, 0x09,
+	0xff, 0x38, 0x00, 0x6b,
+	0x80, 0xa3, 0x00, 0x7b,
+	0x80, 0x0b, 0xfe, 0x7a,
+	0x04, 0x3b, 0x00, 0x7b,
+	0xbf, 0x3b, 0x76, 0x08,
+	0x01, 0x3b, 0x26, 0x31,
+	0x00, 0x65, 0x02, 0x5a,
+	0x01, 0x0b, 0x0e, 0x6b,
+	0x10, 0x0c, 0x02, 0x7b,
+	0x04, 0x93, 0x0c, 0x6b,
+	0x01, 0x94, 0x0a, 0x7b,
+	0x10, 0x94, 0x0c, 0x6b,
+	0xc7, 0x93, 0x26, 0x09,
+	0x01, 0x99, 0xd4, 0x30,
+	0x38, 0x93, 0x10, 0x6b,
+	0xff, 0x08, 0x62, 0x6b,
+	0xff, 0x09, 0x62, 0x6b,
+	0xff, 0x0a, 0x62, 0x6b,
+	0xff, 0x38, 0x2c, 0x7b,
+	0x04, 0x14, 0x10, 0x31,
+	0x01, 0x38, 0x18, 0x31,
+	0x02, 0x6a, 0x1a, 0x31,
+	0x88, 0x6a, 0xcc, 0x00,
+	0x14, 0x6a, 0xe6, 0x5d,
+	0x00, 0x38, 0xd2, 0x5d,
+	0xff, 0x6a, 0x70, 0x08,
+	0x00, 0x65, 0x58, 0x43,
+	0x80, 0xa3, 0x32, 0x7b,
+	0x01, 0xa4, 0x48, 0x01,
+	0x00, 0x65, 0x62, 0x43,
+	0x08, 0xeb, 0x38, 0x7b,
+	0x00, 0x65, 0x02, 0x5a,
+	0x08, 0xeb, 0x34, 0x6b,
+	0x07, 0xe9, 0x10, 0x31,
+	0x01, 0xe9, 0xca, 0x30,
+	0x01, 0x65, 0x46, 0x31,
+	0x00, 0x6a, 0xac, 0x5e,
+	0x88, 0x6a, 0xcc, 0x00,
+	0xa4, 0x6a, 0xe6, 0x5d,
+	0x08, 0x6a, 0xd2, 0x5d,
+	0x0d, 0x93, 0x26, 0x01,
+	0x00, 0x65, 0x9a, 0x5e,
+	0x88, 0x6a, 0xcc, 0x00,
+	0x00, 0x65, 0x7c, 0x5e,
+	0x01, 0x99, 0x46, 0x31,
+	0x00, 0xa3, 0xac, 0x5e,
+	0x01, 0x88, 0x10, 0x31,
+	0x00, 0x65, 0x36, 0x5a,
+	0x00, 0x65, 0xee, 0x59,
+	0x03, 0x8c, 0x10, 0x30,
+	0x00, 0x65, 0xd8, 0x5d,
+	0x01, 0x8c, 0x60, 0x7b,
+	0x01, 0x55, 0xaa, 0x10,
+	0x80, 0x0b, 0x80, 0x6a,
+	0x80, 0x0b, 0x6a, 0x6b,
+	0x01, 0x0c, 0x64, 0x7b,
+	0x10, 0x0c, 0x80, 0x7a,
+	0x03, 0x9e, 0x80, 0x6a,
+	0x00, 0x65, 0xf8, 0x59,
+	0x00, 0x6a, 0xac, 0x5e,
+	0x01, 0xa4, 0x8a, 0x6b,
+	0xff, 0x38, 0x80, 0x7b,
+	0x01, 0x38, 0xc8, 0x30,
+	0x00, 0x08, 0x40, 0x19,
+	0xff, 0x6a, 0xc8, 0x08,
+	0x00, 0x09, 0x42, 0x21,
+	0x00, 0x0a, 0x44, 0x21,
+	0xff, 0x6a, 0x70, 0x08,
+	0x00, 0x65, 0x82, 0x43,
+	0x03, 0x08, 0x40, 0x31,
+	0x03, 0x08, 0x40, 0x31,
+	0x01, 0x08, 0x40, 0x31,
+	0x01, 0x09, 0x42, 0x31,
+	0x01, 0x0a, 0x44, 0x31,
+	0xfd, 0xb4, 0x68, 0x09,
+	0x12, 0x01, 0x02, 0x00,
+	0x12, 0x01, 0x02, 0x00,
+	0x04, 0x3c, 0xc0, 0x79,
+	0xfb, 0x3c, 0x78, 0x08,
+	0x04, 0x93, 0x1e, 0x79,
+	0x01, 0x0c, 0x96, 0x6b,
+	0x01, 0x55, 0x1e, 0x79,
+	0x80, 0x04, 0x1e, 0x79,
+	0xe4, 0x6a, 0x60, 0x5d,
+	0x23, 0x6a, 0x76, 0x5d,
+	0x01, 0x6a, 0x76, 0x5d,
+	0x00, 0x65, 0x1e, 0x41,
+	0x00, 0x65, 0xc0, 0x41,
+	0x80, 0x3c, 0xaa, 0x6b,
+	0x21, 0x6a, 0xca, 0x46,
+	0x01, 0xbc, 0x18, 0x31,
+	0x02, 0x6a, 0x1a, 0x31,
+	0x02, 0x6a, 0xf8, 0x01,
+	0x01, 0xbc, 0x10, 0x30,
+	0x02, 0x6a, 0x12, 0x30,
+	0x01, 0xbc, 0x10, 0x30,
+	0xff, 0x6a, 0x12, 0x08,
+	0xff, 0x6a, 0x14, 0x08,
+	0xf3, 0xbc, 0xd4, 0x18,
+	0xa0, 0x6a, 0xd0, 0x53,
+	0x04, 0xa0, 0x10, 0x31,
+	0xac, 0x6a, 0x26, 0x01,
+	0x04, 0xa0, 0x10, 0x31,
+	0x03, 0x08, 0x18, 0x31,
+	0x88, 0x6a, 0xcc, 0x00,
+	0xa0, 0x6a, 0xe6, 0x5d,
+	0x00, 0xbc, 0xd2, 0x5d,
+	0x3d, 0x6a, 0x26, 0x01,
+	0x00, 0x65, 0xe8, 0x43,
+	0xff, 0x6a, 0x10, 0x09,
+	0xa4, 0x6a, 0x26, 0x01,
+	0x0c, 0xa0, 0x32, 0x31,
+	0x05, 0x6a, 0x26, 0x01,
+	0x35, 0x6a, 0x26, 0x01,
+	0x0c, 0xa0, 0x32, 0x31,
+	0x36, 0x6a, 0x26, 0x01,
+	0x02, 0x93, 0x26, 0x01,
+	0x35, 0x6a, 0x26, 0x01,
+	0x00, 0x65, 0x8e, 0x5e,
+	0x00, 0x65, 0x8e, 0x5e,
+	0x02, 0x93, 0x26, 0x01,
+	0x04, 0x0b, 0xec, 0x6b,
+	0x10, 0x0c, 0xe8, 0x7b,
+	0x01, 0x03, 0xec, 0x6b,
+	0x20, 0x93, 0xe8, 0x6b,
+	0xc7, 0x93, 0x26, 0x09,
+	0x38, 0x93, 0xf2, 0x6b,
+	0x10, 0x01, 0x02, 0x00,
+	0x00, 0x65, 0xc0, 0x41,
+	0x80, 0x3c, 0xfc, 0x6b,
+	0x21, 0x6a, 0xca, 0x46,
+	0x01, 0x06, 0x50, 0x31,
+	0x00, 0x65, 0xc0, 0x41,
+	0x10, 0x3f, 0x06, 0x00,
+	0x10, 0x6a, 0x06, 0x00,
+	0x01, 0x3a, 0xca, 0x30,
+	0x80, 0x65, 0x20, 0x64,
+	0x10, 0xb8, 0x44, 0x6c,
+	0xc0, 0xba, 0xca, 0x00,
+	0x40, 0xb8, 0x10, 0x6c,
+	0xbf, 0x65, 0xca, 0x08,
+	0x20, 0xb8, 0x24, 0x7c,
+	0x01, 0x65, 0x0c, 0x30,
+	0x00, 0x65, 0xca, 0x5d,
+	0xa0, 0x3f, 0x2c, 0x64,
+	0x23, 0xb8, 0x0c, 0x08,
+	0x00, 0x65, 0xca, 0x5d,
+	0xa0, 0x3f, 0x2c, 0x64,
+	0x00, 0xbb, 0x24, 0x44,
+	0xff, 0x65, 0x24, 0x64,
+	0x00, 0x65, 0x44, 0x44,
+	0x40, 0x6a, 0x18, 0x00,
+	0x01, 0x65, 0x0c, 0x30,
+	0x00, 0x65, 0xca, 0x5d,
+	0xa0, 0x3f, 0x00, 0x74,
+	0x40, 0x6a, 0x18, 0x00,
+	0x01, 0x3a, 0xa6, 0x30,
+	0x08, 0x6a, 0x74, 0x00,
+	0x00, 0x65, 0xc0, 0x41,
+	0x64, 0x6a, 0x5a, 0x5d,
+	0x80, 0x64, 0xca, 0x6c,
+	0x04, 0x64, 0x90, 0x74,
+	0x02, 0x64, 0x9e, 0x74,
+	0x00, 0x6a, 0x60, 0x74,
+	0x03, 0x64, 0xbc, 0x74,
+	0x23, 0x64, 0x4c, 0x74,
+	0x08, 0x64, 0x5c, 0x74,
+	0x61, 0x6a, 0xca, 0x5e,
+	0x00, 0x65, 0xca, 0x5d,
+	0x08, 0x51, 0xc2, 0x71,
+	0x00, 0x65, 0x44, 0x44,
+	0x80, 0x04, 0x5a, 0x7c,
+	0x51, 0x6a, 0x50, 0x5d,
+	0x01, 0x51, 0x5a, 0x64,
+	0x01, 0xa4, 0x56, 0x7c,
+	0x01, 0x55, 0x5c, 0x7c,
+	0x41, 0x6a, 0xca, 0x5e,
+	0x00, 0x65, 0x5c, 0x44,
+	0x07, 0x6a, 0x46, 0x5d,
+	0x01, 0x06, 0xd4, 0x30,
+	0x00, 0x65, 0xc0, 0x41,
+	0x10, 0xb8, 0x64, 0x7c,
+	0xa1, 0x6a, 0xca, 0x5e,
+	0x01, 0xb4, 0x6a, 0x6c,
+	0x02, 0xb4, 0x6c, 0x6c,
+	0x01, 0xa4, 0x6c, 0x7c,
+	0xff, 0xa8, 0x7c, 0x7c,
+	0x04, 0xb4, 0x68, 0x01,
+	0x01, 0x6a, 0x76, 0x00,
+	0x00, 0xbb, 0x04, 0x5e,
+	0xff, 0xa8, 0x7c, 0x7c,
+	0x71, 0x6a, 0xca, 0x5e,
+	0x40, 0x51, 0x7c, 0x64,
+	0x00, 0x65, 0xa4, 0x5e,
+	0x00, 0x65, 0xd2, 0x41,
+	0x00, 0xbb, 0x80, 0x5c,
+	0x00, 0x65, 0xd2, 0x41,
+	0x00, 0x65, 0xa4, 0x5e,
+	0x01, 0x65, 0xa2, 0x30,
+	0x01, 0xf8, 0xc8, 0x30,
+	0x01, 0x4e, 0xc8, 0x30,
+	0x00, 0x6a, 0xa8, 0xdd,
+	0x00, 0x51, 0xba, 0x5d,
+	0x01, 0x4e, 0x9c, 0x18,
+	0x02, 0x6a, 0x22, 0x05,
+	0x04, 0xb8, 0x70, 0x01,
+	0x00, 0x65, 0xc6, 0x5e,
+	0x20, 0xb8, 0xd2, 0x69,
+	0x01, 0xbb, 0xa2, 0x30,
+	0x01, 0xba, 0x7c, 0x30,
+	0x00, 0xb9, 0xc0, 0x5c,
+	0x00, 0x65, 0xd2, 0x41,
+	0x01, 0x06, 0xd4, 0x30,
+	0x20, 0x3c, 0xc0, 0x79,
+	0x20, 0x3c, 0x5c, 0x7c,
+	0x01, 0xa4, 0xac, 0x7c,
+	0x01, 0xb4, 0x68, 0x01,
+	0x00, 0x65, 0xc0, 0x41,
+	0x00, 0x65, 0x5c, 0x44,
+	0x04, 0x14, 0x58, 0x31,
+	0x01, 0x06, 0xd4, 0x30,
+	0x08, 0xa0, 0x60, 0x31,
+	0xac, 0x6a, 0xcc, 0x00,
+	0x14, 0x6a, 0xe6, 0x5d,
+	0x01, 0x06, 0xd4, 0x30,
+	0xa0, 0x6a, 0xde, 0x5d,
+	0x00, 0x65, 0xc0, 0x41,
+	0xdf, 0x3c, 0x78, 0x08,
+	0x00, 0x65, 0x5c, 0x44,
+	0x4c, 0x65, 0xcc, 0x28,
+	0x01, 0x3e, 0x20, 0x31,
+	0xd0, 0x66, 0xcc, 0x18,
+	0x20, 0x66, 0xcc, 0x18,
+	0x01, 0x51, 0xda, 0x34,
+	0x4c, 0x3d, 0xca, 0x28,
+	0x3f, 0x64, 0x7c, 0x08,
+	0xd0, 0x65, 0xca, 0x18,
+	0x01, 0x3e, 0x20, 0x31,
+	0x30, 0x65, 0xd4, 0x18,
+	0x00, 0x65, 0xd8, 0x4c,
+	0xe1, 0x6a, 0x22, 0x01,
+	0xff, 0x6a, 0xd4, 0x08,
+	0x20, 0x65, 0xd4, 0x18,
+	0x00, 0x65, 0xe0, 0x54,
+	0xe1, 0x6a, 0x22, 0x01,
+	0xff, 0x6a, 0xd4, 0x08,
+	0x20, 0x65, 0xca, 0x18,
+	0xe0, 0x65, 0xd4, 0x18,
+	0x00, 0x65, 0xea, 0x4c,
+	0xe1, 0x6a, 0x22, 0x01,
+	0xff, 0x6a, 0xd4, 0x08,
+	0xd0, 0x65, 0xd4, 0x18,
+	0x00, 0x65, 0xf2, 0x54,
+	0xe1, 0x6a, 0x22, 0x01,
+	0xff, 0x6a, 0xd4, 0x08,
+	0x01, 0x6c, 0xa2, 0x30,
+	0xff, 0x51, 0x04, 0x75,
+	0x00, 0x51, 0x80, 0x5d,
+	0x01, 0x51, 0x20, 0x31,
+	0x00, 0x65, 0x26, 0x45,
+	0x01, 0xba, 0xc8, 0x30,
+	0x00, 0x3e, 0x26, 0x75,
+	0x00, 0x65, 0xa2, 0x5e,
+	0x80, 0x3c, 0x78, 0x00,
+	0x01, 0x06, 0xd4, 0x30,
+	0x00, 0x65, 0xca, 0x5d,
+	0x01, 0x3c, 0x78, 0x00,
+	0xe0, 0x3f, 0x42, 0x65,
+	0x02, 0x3c, 0x78, 0x00,
+	0x20, 0x12, 0x42, 0x65,
+	0x51, 0x6a, 0x50, 0x5d,
+	0x00, 0x51, 0x80, 0x5d,
+	0x51, 0x6a, 0x50, 0x5d,
+	0x01, 0x51, 0x20, 0x31,
+	0x04, 0x3c, 0x78, 0x00,
+	0x01, 0xb9, 0xc8, 0x30,
+	0x00, 0x3d, 0x40, 0x65,
+	0x08, 0x3c, 0x78, 0x00,
+	0x01, 0xba, 0xc8, 0x30,
+	0x00, 0x3e, 0x40, 0x65,
+	0x10, 0x3c, 0x78, 0x00,
+	0x04, 0xb8, 0x40, 0x7d,
+	0xfb, 0xb8, 0x70, 0x09,
+	0x20, 0xb8, 0x36, 0x6d,
+	0x01, 0x90, 0xc8, 0x30,
+	0xff, 0x6a, 0xa2, 0x00,
+	0x00, 0x3d, 0xc0, 0x5c,
+	0x01, 0x64, 0x20, 0x31,
+	0x80, 0x6a, 0x78, 0x00,
+	0x00, 0x65, 0xec, 0x58,
+	0x10, 0xb8, 0x5c, 0x7c,
+	0xff, 0x6a, 0x46, 0x5d,
+	0x00, 0x65, 0x5c, 0x44,
+	0x00, 0x65, 0xa2, 0x5e,
+	0x31, 0x6a, 0xca, 0x5e,
+	0x00, 0x65, 0x5c, 0x44,
+	0x10, 0x3f, 0x06, 0x00,
+	0x10, 0x6a, 0x06, 0x00,
+	0x01, 0x65, 0x74, 0x34,
+	0x81, 0x6a, 0xca, 0x5e,
+	0x00, 0x65, 0x52, 0x45,
+	0x01, 0x06, 0xd4, 0x30,
+	0x01, 0x0c, 0x52, 0x7d,
+	0x04, 0x0c, 0x4c, 0x6d,
+	0xe0, 0x03, 0x7e, 0x08,
+	0xe0, 0x3f, 0xc0, 0x61,
+	0x01, 0x65, 0xcc, 0x30,
+	0x01, 0x12, 0xda, 0x34,
+	0x01, 0x06, 0xd4, 0x34,
+	0x01, 0x03, 0x60, 0x6d,
+	0x40, 0x03, 0xcc, 0x08,
+	0x01, 0x65, 0x06, 0x30,
+	0x40, 0x65, 0xc8, 0x08,
+	0x00, 0x66, 0x6e, 0x75,
+	0x40, 0x65, 0x6e, 0x7d,
+	0x00, 0x65, 0x6e, 0x5d,
+	0xff, 0x6a, 0xd4, 0x08,
+	0xff, 0x6a, 0xd4, 0x08,
+	0xff, 0x6a, 0xd4, 0x08,
+	0xff, 0x6a, 0xd4, 0x0c,
+	0x08, 0x01, 0x02, 0x00,
+	0x02, 0x0b, 0x78, 0x7d,
+	0x01, 0x65, 0x0c, 0x30,
+	0x02, 0x0b, 0x7c, 0x7d,
+	0xf7, 0x01, 0x02, 0x0c,
+	0x01, 0x65, 0xc8, 0x30,
+	0xff, 0x41, 0xa0, 0x75,
+	0x01, 0x41, 0x20, 0x31,
+	0xff, 0x6a, 0xa4, 0x00,
+	0x00, 0x65, 0x90, 0x45,
+	0xff, 0xbf, 0xa0, 0x75,
+	0x01, 0x90, 0xa4, 0x30,
+	0x01, 0xbf, 0x20, 0x31,
+	0x00, 0xbb, 0x8a, 0x65,
+	0xff, 0x52, 0x9e, 0x75,
+	0x01, 0xbf, 0xcc, 0x30,
+	0x01, 0x90, 0xca, 0x30,
+	0x01, 0x52, 0x20, 0x31,
+	0x01, 0x66, 0x7e, 0x31,
+	0x01, 0x65, 0x20, 0x35,
+	0x01, 0xbf, 0x82, 0x34,
+	0x01, 0x64, 0xa2, 0x30,
+	0x00, 0x6a, 0xb2, 0x5e,
+	0x0d, 0x6a, 0x76, 0x00,
+	0x00, 0x51, 0x04, 0x46,
+	0x01, 0x65, 0xa4, 0x30,
+	0xe0, 0x6a, 0xcc, 0x00,
+	0x48, 0x6a, 0xf8, 0x5d,
+	0x01, 0x6a, 0xd0, 0x01,
+	0x01, 0x6a, 0xdc, 0x05,
+	0x88, 0x6a, 0xcc, 0x00,
+	0x48, 0x6a, 0xf8, 0x5d,
+	0x01, 0x6a, 0xd2, 0x5d,
+	0x01, 0x6a, 0x26, 0x05,
+	0x01, 0x65, 0xd8, 0x31,
+	0x09, 0xee, 0xdc, 0x01,
+	0x80, 0xee, 0xbe, 0x7d,
+	0xff, 0x6a, 0xdc, 0x0d,
+	0x01, 0x65, 0x32, 0x31,
+	0x0a, 0x93, 0x26, 0x01,
+	0x00, 0x65, 0x9a, 0x46,
+	0x81, 0x6a, 0xca, 0x5e,
+	0x01, 0x0c, 0xca, 0x7d,
+	0x04, 0x0c, 0xc8, 0x6d,
+	0xe0, 0x03, 0x06, 0x08,
+	0xe0, 0x03, 0x7e, 0x0c,
+	0x01, 0x65, 0x18, 0x31,
+	0xff, 0x6a, 0x1a, 0x09,
+	0xff, 0x6a, 0x1c, 0x0d,
+	0x01, 0x8c, 0x10, 0x30,
+	0x01, 0x8d, 0x12, 0x30,
+	0x01, 0x8e, 0x14, 0x34,
+	0x01, 0x6c, 0xda, 0x30,
+	0x01, 0x6c, 0xda, 0x30,
+	0x01, 0x6c, 0xda, 0x30,
+	0x01, 0x6c, 0xda, 0x30,
+	0x01, 0x6c, 0xda, 0x30,
+	0x01, 0x6c, 0xda, 0x30,
+	0x01, 0x6c, 0xda, 0x30,
+	0x01, 0x6c, 0xda, 0x34,
+	0x3d, 0x64, 0xa4, 0x28,
+	0x55, 0x64, 0xc8, 0x28,
+	0x00, 0x65, 0xf8, 0x45,
+	0x2e, 0x64, 0xa4, 0x28,
+	0x66, 0x64, 0xc8, 0x28,
+	0x00, 0x6c, 0xda, 0x18,
+	0x01, 0x52, 0xc8, 0x30,
+	0x00, 0x6c, 0xda, 0x20,
+	0xff, 0x6a, 0xc8, 0x08,
+	0x00, 0x6c, 0xda, 0x20,
+	0x00, 0x6c, 0xda, 0x24,
+	0x01, 0x65, 0xc8, 0x30,
+	0xe0, 0x6a, 0xcc, 0x00,
+	0x44, 0x6a, 0xf4, 0x5d,
+	0x01, 0x90, 0xe2, 0x31,
+	0x04, 0x3b, 0x18, 0x7e,
+	0x30, 0x6a, 0xd0, 0x01,
+	0x20, 0x6a, 0xd0, 0x01,
+	0x1d, 0x6a, 0xdc, 0x01,
+	0xdc, 0xee, 0x14, 0x66,
+	0x00, 0x65, 0x30, 0x46,
+	0x20, 0x6a, 0xd0, 0x01,
+	0x01, 0x6a, 0xdc, 0x01,
+	0x20, 0xa0, 0xd8, 0x31,
+	0x09, 0xee, 0xdc, 0x01,
+	0x80, 0xee, 0x20, 0x7e,
+	0x11, 0x6a, 0xdc, 0x01,
+	0x50, 0xee, 0x24, 0x66,
+	0x20, 0x6a, 0xd0, 0x01,
+	0x09, 0x6a, 0xdc, 0x01,
+	0x88, 0xee, 0x2a, 0x66,
+	0x19, 0x6a, 0xdc, 0x01,
+	0xd8, 0xee, 0x2e, 0x66,
+	0xff, 0x6a, 0xdc, 0x09,
+	0x18, 0xee, 0x32, 0x6e,
+	0xff, 0x6a, 0xd4, 0x0c,
+	0x88, 0x6a, 0xcc, 0x00,
+	0x44, 0x6a, 0xf4, 0x5d,
+	0x20, 0x6a, 0xd2, 0x5d,
+	0x01, 0x3b, 0x26, 0x31,
+	0x04, 0x3b, 0x4c, 0x6e,
+	0xa0, 0x6a, 0xca, 0x00,
+	0x20, 0x65, 0xc8, 0x18,
+	0x00, 0x65, 0x8a, 0x5e,
+	0x00, 0x65, 0x44, 0x66,
+	0x0a, 0x93, 0x26, 0x01,
+	0x00, 0x65, 0x9a, 0x46,
+	0xa0, 0x6a, 0xcc, 0x00,
+	0xff, 0x6a, 0xc8, 0x08,
+	0x20, 0x94, 0x50, 0x6e,
+	0x10, 0x94, 0x52, 0x6e,
+	0x08, 0x94, 0x6c, 0x6e,
+	0x08, 0x94, 0x6c, 0x6e,
+	0x08, 0x94, 0x6c, 0x6e,
+	0xff, 0x8c, 0xc8, 0x10,
+	0xc1, 0x64, 0xc8, 0x18,
+	0xf8, 0x64, 0xc8, 0x08,
+	0x01, 0x99, 0xda, 0x30,
+	0x00, 0x66, 0x60, 0x66,
+	0xc0, 0x66, 0x9c, 0x76,
+	0x60, 0x66, 0xc8, 0x18,
+	0x3d, 0x64, 0xc8, 0x28,
+	0x00, 0x65, 0x50, 0x46,
+	0xf7, 0x93, 0x26, 0x09,
+	0x08, 0x93, 0x6e, 0x6e,
+	0x00, 0x62, 0xc4, 0x18,
+	0x00, 0x65, 0x9a, 0x5e,
+	0x00, 0x65, 0x7a, 0x5e,
+	0x00, 0x65, 0x7a, 0x5e,
+	0x00, 0x65, 0x7a, 0x5e,
+	0x01, 0x99, 0xda, 0x30,
+	0x01, 0x99, 0xda, 0x30,
+	0x01, 0x99, 0xda, 0x30,
+	0x01, 0x99, 0xda, 0x30,
+	0x01, 0x99, 0xda, 0x30,
+	0x01, 0x99, 0xda, 0x30,
+	0x01, 0x99, 0xda, 0x30,
+	0x01, 0x99, 0xda, 0x34,
+	0x01, 0x6c, 0x32, 0x31,
+	0x01, 0x6c, 0x32, 0x31,
+	0x01, 0x6c, 0x32, 0x31,
+	0x01, 0x6c, 0x32, 0x31,
+	0x01, 0x6c, 0x32, 0x31,
+	0x01, 0x6c, 0x32, 0x31,
+	0x01, 0x6c, 0x32, 0x31,
+	0x01, 0x6c, 0x32, 0x35,
+	0x08, 0x94, 0x9a, 0x7e,
+	0xf7, 0x93, 0x26, 0x09,
+	0x08, 0x93, 0x9e, 0x6e,
+	0xff, 0x6a, 0xd4, 0x0c,
+	0x04, 0xb8, 0xc6, 0x6e,
+	0x01, 0x42, 0x7e, 0x31,
+	0xff, 0x6a, 0x76, 0x01,
+	0x01, 0x90, 0x84, 0x34,
+	0xff, 0x6a, 0x76, 0x05,
+	0x01, 0x85, 0x0a, 0x01,
+	0x7f, 0x65, 0x10, 0x09,
+	0xfe, 0x85, 0x0a, 0x0d,
+	0xff, 0x42, 0xc2, 0x66,
+	0xff, 0x41, 0xba, 0x66,
+	0xd1, 0x6a, 0xca, 0x5e,
+	0xff, 0x6a, 0xca, 0x04,
+	0x01, 0x41, 0x20, 0x31,
+	0x01, 0xbf, 0x82, 0x30,
+	0x01, 0x6a, 0x76, 0x00,
+	0x00, 0xbb, 0x04, 0x46,
+	0x01, 0x42, 0x20, 0x31,
+	0x01, 0xbf, 0x84, 0x34,
+	0x01, 0x41, 0x7e, 0x31,
+	0x01, 0x90, 0x82, 0x34,
+	0x01, 0x65, 0x22, 0x31,
+	0xff, 0x6a, 0xd4, 0x08,
+	0xff, 0x6a, 0xd4, 0x0c
+};
+
+static int ahc_patch23_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch23_func(struct ahc_softc *ahc)
+{
+	return ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0);
+}
+
+static int ahc_patch22_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch22_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_CMD_CHAN) == 0);
+}
+
+static int ahc_patch21_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch21_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_QUEUE_REGS) == 0);
+}
+
+static int ahc_patch20_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch20_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_WIDE) != 0);
+}
+
+static int ahc_patch19_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch19_func(struct ahc_softc *ahc)
+{
+	return ((ahc->flags & AHC_SCB_BTT) != 0);
+}
+
+static int ahc_patch18_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch18_func(struct ahc_softc *ahc)
+{
+	return ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0);
+}
+
+static int ahc_patch17_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch17_func(struct ahc_softc *ahc)
+{
+	return ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0);
+}
+
+static int ahc_patch16_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch16_func(struct ahc_softc *ahc)
+{
+	return ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0);
+}
+
+static int ahc_patch15_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch15_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_ULTRA2) == 0);
+}
+
+static int ahc_patch14_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch14_func(struct ahc_softc *ahc)
+{
+	return ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0);
+}
+
+static int ahc_patch13_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch13_func(struct ahc_softc *ahc)
+{
+	return ((ahc->flags & AHC_39BIT_ADDRESSING) != 0);
+}
+
+static int ahc_patch12_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch12_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_HS_MAILBOX) != 0);
+}
+
+static int ahc_patch11_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch11_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_ULTRA) != 0);
+}
+
+static int ahc_patch10_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch10_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_MULTI_TID) != 0);
+}
+
+static int ahc_patch9_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch9_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_CMD_CHAN) != 0);
+}
+
+static int ahc_patch8_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch8_func(struct ahc_softc *ahc)
+{
+	return ((ahc->flags & AHC_INITIATORROLE) != 0);
+}
+
+static int ahc_patch7_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch7_func(struct ahc_softc *ahc)
+{
+	return ((ahc->flags & AHC_TARGETROLE) != 0);
+}
+
+static int ahc_patch6_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch6_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_DT) == 0);
+}
+
+static int ahc_patch5_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch5_func(struct ahc_softc *ahc)
+{
+	return ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0);
+}
+
+static int ahc_patch4_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch4_func(struct ahc_softc *ahc)
+{
+	return ((ahc->flags & AHC_PAGESCBS) != 0);
+}
+
+static int ahc_patch3_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch3_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_QUEUE_REGS) != 0);
+}
+
+static int ahc_patch2_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch2_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_TWIN) != 0);
+}
+
+static int ahc_patch1_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch1_func(struct ahc_softc *ahc)
+{
+	return ((ahc->features & AHC_ULTRA2) != 0);
+}
+
+static int ahc_patch0_func(struct ahc_softc *ahc);
+
+static int
+ahc_patch0_func(struct ahc_softc *ahc)
+{
+	return (0);
+}
+
+typedef int patch_func_t (struct ahc_softc *);
+struct patch {
+	patch_func_t	*patch_func;
+	uint32_t	begin	   :10,
+			skip_instr :10,
+			skip_patch :12;
+} patches[] = {
+	{ ahc_patch1_func, 4, 1, 1 },
+	{ ahc_patch2_func, 6, 2, 1 },
+	{ ahc_patch2_func, 9, 1, 1 },
+	{ ahc_patch3_func, 11, 1, 2 },
+	{ ahc_patch0_func, 12, 2, 1 },
+	{ ahc_patch4_func, 15, 1, 2 },
+	{ ahc_patch0_func, 16, 1, 1 },
+	{ ahc_patch5_func, 22, 2, 1 },
+	{ ahc_patch3_func, 27, 1, 2 },
+	{ ahc_patch0_func, 28, 1, 1 },
+	{ ahc_patch6_func, 34, 1, 1 },
+	{ ahc_patch7_func, 37, 54, 19 },
+	{ ahc_patch8_func, 37, 1, 1 },
+	{ ahc_patch9_func, 42, 3, 2 },
+	{ ahc_patch0_func, 45, 3, 1 },
+	{ ahc_patch10_func, 49, 1, 2 },
+	{ ahc_patch0_func, 50, 2, 3 },
+	{ ahc_patch1_func, 50, 1, 2 },
+	{ ahc_patch0_func, 51, 1, 1 },
+	{ ahc_patch2_func, 53, 2, 1 },
+	{ ahc_patch9_func, 55, 1, 2 },
+	{ ahc_patch0_func, 56, 1, 1 },
+	{ ahc_patch9_func, 60, 1, 2 },
+	{ ahc_patch0_func, 61, 1, 1 },
+	{ ahc_patch9_func, 71, 1, 2 },
+	{ ahc_patch0_func, 72, 1, 1 },
+	{ ahc_patch9_func, 75, 1, 2 },
+	{ ahc_patch0_func, 76, 1, 1 },
+	{ ahc_patch9_func, 79, 1, 2 },
+	{ ahc_patch0_func, 80, 1, 1 },
+	{ ahc_patch8_func, 91, 9, 4 },
+	{ ahc_patch1_func, 93, 1, 2 },
+	{ ahc_patch0_func, 94, 1, 1 },
+	{ ahc_patch2_func, 96, 2, 1 },
+	{ ahc_patch2_func, 105, 4, 1 },
+	{ ahc_patch1_func, 109, 1, 2 },
+	{ ahc_patch0_func, 110, 2, 3 },
+	{ ahc_patch2_func, 110, 1, 2 },
+	{ ahc_patch0_func, 111, 1, 1 },
+	{ ahc_patch7_func, 112, 4, 2 },
+	{ ahc_patch0_func, 116, 1, 1 },
+	{ ahc_patch11_func, 118, 2, 1 },
+	{ ahc_patch1_func, 120, 1, 2 },
+	{ ahc_patch0_func, 121, 1, 1 },
+	{ ahc_patch7_func, 122, 4, 1 },
+	{ ahc_patch7_func, 133, 89, 11 },
+	{ ahc_patch4_func, 151, 1, 1 },
+	{ ahc_patch1_func, 164, 1, 1 },
+	{ ahc_patch12_func, 169, 1, 2 },
+	{ ahc_patch0_func, 170, 1, 1 },
+	{ ahc_patch9_func, 181, 1, 2 },
+	{ ahc_patch0_func, 182, 1, 1 },
+	{ ahc_patch9_func, 191, 1, 2 },
+	{ ahc_patch0_func, 192, 1, 1 },
+	{ ahc_patch9_func, 208, 6, 2 },
+	{ ahc_patch0_func, 214, 6, 1 },
+	{ ahc_patch8_func, 222, 18, 2 },
+	{ ahc_patch1_func, 235, 1, 1 },
+	{ ahc_patch1_func, 242, 1, 2 },
+	{ ahc_patch0_func, 243, 2, 2 },
+	{ ahc_patch11_func, 244, 1, 1 },
+	{ ahc_patch9_func, 252, 31, 3 },
+	{ ahc_patch1_func, 268, 14, 2 },
+	{ ahc_patch13_func, 273, 1, 1 },
+	{ ahc_patch14_func, 283, 14, 1 },
+	{ ahc_patch1_func, 299, 1, 2 },
+	{ ahc_patch0_func, 300, 1, 1 },
+	{ ahc_patch9_func, 303, 1, 1 },
+	{ ahc_patch13_func, 308, 1, 1 },
+	{ ahc_patch9_func, 309, 2, 2 },
+	{ ahc_patch0_func, 311, 4, 1 },
+	{ ahc_patch14_func, 315, 1, 1 },
+	{ ahc_patch15_func, 318, 2, 3 },
+	{ ahc_patch9_func, 318, 1, 2 },
+	{ ahc_patch0_func, 319, 1, 1 },
+	{ ahc_patch6_func, 324, 1, 2 },
+	{ ahc_patch0_func, 325, 1, 1 },
+	{ ahc_patch1_func, 329, 50, 11 },
+	{ ahc_patch6_func, 338, 2, 4 },
+	{ ahc_patch7_func, 338, 1, 1 },
+	{ ahc_patch8_func, 339, 1, 1 },
+	{ ahc_patch0_func, 340, 1, 1 },
+	{ ahc_patch16_func, 341, 1, 1 },
+	{ ahc_patch6_func, 360, 6, 3 },
+	{ ahc_patch16_func, 360, 5, 1 },
+	{ ahc_patch0_func, 366, 5, 1 },
+	{ ahc_patch13_func, 374, 5, 1 },
+	{ ahc_patch0_func, 379, 54, 17 },
+	{ ahc_patch14_func, 379, 1, 1 },
+	{ ahc_patch7_func, 381, 2, 2 },
+	{ ahc_patch17_func, 382, 1, 1 },
+	{ ahc_patch9_func, 385, 1, 1 },
+	{ ahc_patch18_func, 392, 1, 1 },
+	{ ahc_patch14_func, 397, 9, 3 },
+	{ ahc_patch9_func, 398, 3, 2 },
+	{ ahc_patch0_func, 401, 3, 1 },
+	{ ahc_patch9_func, 409, 6, 2 },
+	{ ahc_patch0_func, 415, 9, 2 },
+	{ ahc_patch13_func, 415, 1, 1 },
+	{ ahc_patch13_func, 424, 2, 1 },
+	{ ahc_patch14_func, 426, 1, 1 },
+	{ ahc_patch9_func, 428, 1, 2 },
+	{ ahc_patch0_func, 429, 1, 1 },
+	{ ahc_patch7_func, 432, 1, 1 },
+	{ ahc_patch7_func, 433, 1, 1 },
+	{ ahc_patch8_func, 434, 3, 3 },
+	{ ahc_patch6_func, 435, 1, 2 },
+	{ ahc_patch0_func, 436, 1, 1 },
+	{ ahc_patch9_func, 437, 1, 1 },
+	{ ahc_patch15_func, 438, 1, 2 },
+	{ ahc_patch13_func, 438, 1, 1 },
+	{ ahc_patch14_func, 440, 9, 4 },
+	{ ahc_patch9_func, 440, 1, 1 },
+	{ ahc_patch9_func, 447, 2, 1 },
+	{ ahc_patch0_func, 449, 4, 3 },
+	{ ahc_patch9_func, 449, 1, 2 },
+	{ ahc_patch0_func, 450, 3, 1 },
+	{ ahc_patch1_func, 454, 2, 1 },
+	{ ahc_patch7_func, 456, 10, 2 },
+	{ ahc_patch0_func, 466, 1, 1 },
+	{ ahc_patch8_func, 467, 109, 23 },
+	{ ahc_patch1_func, 469, 3, 2 },
+	{ ahc_patch0_func, 472, 5, 3 },
+	{ ahc_patch9_func, 472, 2, 2 },
+	{ ahc_patch0_func, 474, 3, 1 },
+	{ ahc_patch1_func, 479, 2, 2 },
+	{ ahc_patch0_func, 481, 6, 3 },
+	{ ahc_patch9_func, 481, 2, 2 },
+	{ ahc_patch0_func, 483, 3, 1 },
+	{ ahc_patch1_func, 489, 2, 2 },
+	{ ahc_patch0_func, 491, 9, 7 },
+	{ ahc_patch9_func, 491, 5, 6 },
+	{ ahc_patch19_func, 491, 1, 2 },
+	{ ahc_patch0_func, 492, 1, 1 },
+	{ ahc_patch19_func, 494, 1, 2 },
+	{ ahc_patch0_func, 495, 1, 1 },
+	{ ahc_patch0_func, 496, 4, 1 },
+	{ ahc_patch6_func, 500, 3, 2 },
+	{ ahc_patch0_func, 503, 1, 1 },
+	{ ahc_patch1_func, 506, 1, 1 },
+	{ ahc_patch6_func, 512, 1, 2 },
+	{ ahc_patch0_func, 513, 1, 1 },
+	{ ahc_patch20_func, 550, 7, 1 },
+	{ ahc_patch3_func, 578, 1, 2 },
+	{ ahc_patch0_func, 579, 1, 1 },
+	{ ahc_patch21_func, 582, 1, 1 },
+	{ ahc_patch8_func, 584, 104, 33 },
+	{ ahc_patch4_func, 585, 1, 1 },
+	{ ahc_patch1_func, 591, 2, 2 },
+	{ ahc_patch0_func, 593, 1, 1 },
+	{ ahc_patch1_func, 596, 1, 2 },
+	{ ahc_patch0_func, 597, 1, 1 },
+	{ ahc_patch9_func, 598, 3, 3 },
+	{ ahc_patch15_func, 599, 1, 1 },
+	{ ahc_patch0_func, 601, 4, 1 },
+	{ ahc_patch19_func, 609, 2, 2 },
+	{ ahc_patch0_func, 611, 1, 1 },
+	{ ahc_patch19_func, 615, 10, 3 },
+	{ ahc_patch5_func, 617, 8, 1 },
+	{ ahc_patch0_func, 625, 9, 2 },
+	{ ahc_patch5_func, 626, 8, 1 },
+	{ ahc_patch4_func, 636, 1, 2 },
+	{ ahc_patch0_func, 637, 1, 1 },
+	{ ahc_patch19_func, 638, 1, 2 },
+	{ ahc_patch0_func, 639, 3, 2 },
+	{ ahc_patch4_func, 641, 1, 1 },
+	{ ahc_patch5_func, 642, 1, 1 },
+	{ ahc_patch5_func, 645, 1, 1 },
+	{ ahc_patch5_func, 647, 1, 1 },
+	{ ahc_patch4_func, 649, 2, 2 },
+	{ ahc_patch0_func, 651, 2, 1 },
+	{ ahc_patch5_func, 653, 1, 1 },
+	{ ahc_patch5_func, 656, 1, 1 },
+	{ ahc_patch5_func, 659, 1, 1 },
+	{ ahc_patch19_func, 663, 1, 1 },
+	{ ahc_patch19_func, 666, 1, 1 },
+	{ ahc_patch4_func, 672, 1, 1 },
+	{ ahc_patch6_func, 675, 1, 2 },
+	{ ahc_patch0_func, 676, 1, 1 },
+	{ ahc_patch7_func, 688, 16, 1 },
+	{ ahc_patch4_func, 704, 20, 1 },
+	{ ahc_patch9_func, 725, 4, 2 },
+	{ ahc_patch0_func, 729, 4, 1 },
+	{ ahc_patch9_func, 733, 4, 2 },
+	{ ahc_patch0_func, 737, 3, 1 },
+	{ ahc_patch6_func, 743, 1, 1 },
+	{ ahc_patch22_func, 745, 14, 1 },
+	{ ahc_patch7_func, 759, 3, 1 },
+	{ ahc_patch9_func, 771, 24, 8 },
+	{ ahc_patch19_func, 775, 1, 2 },
+	{ ahc_patch0_func, 776, 1, 1 },
+	{ ahc_patch15_func, 781, 4, 2 },
+	{ ahc_patch0_func, 785, 7, 3 },
+	{ ahc_patch23_func, 785, 5, 2 },
+	{ ahc_patch0_func, 790, 2, 1 },
+	{ ahc_patch0_func, 795, 42, 3 },
+	{ ahc_patch18_func, 807, 18, 2 },
+	{ ahc_patch0_func, 825, 1, 1 },
+	{ ahc_patch4_func, 849, 1, 1 },
+	{ ahc_patch4_func, 850, 3, 2 },
+	{ ahc_patch0_func, 853, 1, 1 },
+	{ ahc_patch13_func, 854, 3, 1 },
+	{ ahc_patch4_func, 857, 12, 1 }
+};
+struct cs {
+	u_int16_t	begin;
+	u_int16_t	end;
+} critical_sections[] = {
+	{ 11, 18 },
+	{ 21, 30 },
+	{ 704, 720 },
+	{ 850, 853 },
+	{ 857, 863 },
+	{ 865, 867 },
+	{ 867, 869 }
+};
+const int num_critical_sections = sizeof(critical_sections)
+				 / sizeof(*critical_sections);
diff -Nru a/drivers/scsi/aic7xxx/shipped_aic7xxx_reg.h b/drivers/scsi/aic7xxx/shipped_aic7xxx_reg.h
--- a/drivers/scsi/aic7xxx/shipped_aic7xxx_reg.h	Thu Jun 20 15:54:00 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,716 +0,0 @@
-/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
- * $Id$
- * $Id$
- */
-
-#define	SCSISEQ         		0x00
-#define		TEMODE          	0x80
-#define		SCSIRSTO        	0x01
-
-#define	SXFRCTL0        		0x01
-#define		DFON            	0x80
-#define		DFPEXP          	0x40
-#define		FAST20          	0x20
-#define		CLRSTCNT        	0x10
-#define		SPIOEN          	0x08
-#define		SCAMEN          	0x04
-#define		CLRCHN          	0x02
-
-#define	SXFRCTL1        		0x02
-#define		BITBUCKET       	0x80
-#define		SWRAPEN         	0x40
-#define		STIMESEL        	0x18
-#define		ENSTIMER        	0x04
-#define		ACTNEGEN        	0x02
-#define		STPWEN          	0x01
-
-#define	SCSISIGO        		0x03
-#define		CDO             	0x80
-#define		IOO             	0x40
-#define		MSGO            	0x20
-#define		ATNO            	0x10
-#define		SELO            	0x08
-#define		BSYO            	0x04
-#define		REQO            	0x02
-#define		ACKO            	0x01
-
-#define	SCSISIGI        		0x03
-#define		P_DATAIN_DT     	0x60
-#define		P_DATAOUT_DT    	0x20
-#define		ATNI            	0x10
-#define		SELI            	0x08
-#define		BSYI            	0x04
-#define		REQI            	0x02
-#define		ACKI            	0x01
-
-#define	SCSIRATE        		0x04
-#define		WIDEXFER        	0x80
-#define		SXFR            	0x70
-#define		ENABLE_CRC      	0x40
-#define		SINGLE_EDGE     	0x10
-#define		SOFS            	0x0f
-#define		SXFR_ULTRA2     	0x0f
-
-#define	SCSIID          		0x05
-#define	SCSIOFFSET      		0x05
-#define		SOFS_ULTRA2     	0x7f
-
-#define	SCSIDATL        		0x06
-
-#define	SCSIDATH        		0x07
-
-#define	STCNT           		0x08
-
-#define	OPTIONMODE      		0x08
-#define		AUTORATEEN      	0x80
-#define		AUTOACKEN       	0x40
-#define		ATNMGMNTEN      	0x20
-#define		BUSFREEREV      	0x10
-#define		EXPPHASEDIS     	0x08
-#define		SCSIDATL_IMGEN  	0x04
-#define		OPTIONMODE_DEFAULTS	0x03
-#define		AUTO_MSGOUT_DE  	0x02
-#define		DIS_MSGIN_DUALEDGE	0x01
-
-#define	TARGCRCCNT      		0x0a
-
-#define	CLRSINT0        		0x0b
-#define		CLRSELDO        	0x40
-#define		CLRSELDI        	0x20
-#define		CLRSELINGO      	0x10
-#define		CLRIOERR        	0x08
-#define		CLRSWRAP        	0x08
-#define		CLRSPIORDY      	0x02
-
-#define	SSTAT0          		0x0b
-#define		TARGET          	0x80
-#define		SELDO           	0x40
-#define		SELDI           	0x20
-#define		SELINGO         	0x10
-#define		SWRAP           	0x08
-#define		IOERR           	0x08
-#define		SDONE           	0x04
-#define		SPIORDY         	0x02
-#define		DMADONE         	0x01
-
-#define	CLRSINT1        		0x0c
-#define		CLRSELTIMEO     	0x80
-#define		CLRATNO         	0x40
-#define		CLRSCSIRSTI     	0x20
-#define		CLRBUSFREE      	0x08
-#define		CLRSCSIPERR     	0x04
-#define		CLRPHASECHG     	0x02
-#define		CLRREQINIT      	0x01
-
-#define	SSTAT1          		0x0c
-#define		SELTO           	0x80
-#define		ATNTARG         	0x40
-#define		SCSIRSTI        	0x20
-#define		PHASEMIS        	0x10
-#define		BUSFREE         	0x08
-#define		SCSIPERR        	0x04
-#define		PHASECHG        	0x02
-#define		REQINIT         	0x01
-
-#define	SSTAT2          		0x0d
-#define		OVERRUN         	0x80
-#define		SHVALID         	0x40
-#define		SFCNT           	0x1f
-#define		EXP_ACTIVE      	0x10
-#define		CRCVALERR       	0x08
-#define		CRCENDERR       	0x04
-#define		CRCREQERR       	0x02
-#define		DUAL_EDGE_ERR   	0x01
-
-#define	SSTAT3          		0x0e
-#define		SCSICNT         	0xf0
-#define		U2OFFCNT        	0x7f
-#define		OFFCNT          	0x0f
-
-#define	SCSIID_ULTRA2   		0x0f
-
-#define	SIMODE0         		0x10
-#define		ENSELDO         	0x40
-#define		ENSELDI         	0x20
-#define		ENSELINGO       	0x10
-#define		ENIOERR         	0x08
-#define		ENSWRAP         	0x08
-#define		ENSDONE         	0x04
-#define		ENSPIORDY       	0x02
-#define		ENDMADONE       	0x01
-
-#define	SIMODE1         		0x11
-#define		ENSELTIMO       	0x80
-#define		ENATNTARG       	0x40
-#define		ENSCSIRST       	0x20
-#define		ENPHASEMIS      	0x10
-#define		ENBUSFREE       	0x08
-#define		ENSCSIPERR      	0x04
-#define		ENPHASECHG      	0x02
-#define		ENREQINIT       	0x01
-
-#define	SCSIBUSL        		0x12
-
-#define	SCSIBUSH        		0x13
-
-#define	SHADDR          		0x14
-
-#define	SELTIMER        		0x18
-#define	TARGIDIN        		0x18
-#define		STAGE6          	0x20
-#define		STAGE5          	0x10
-#define		STAGE4          	0x08
-#define		STAGE3          	0x04
-#define		STAGE2          	0x02
-#define		STAGE1          	0x01
-
-#define	SELID           		0x19
-#define		SELID_MASK      	0xf0
-#define		ONEBIT          	0x08
-
-#define	SCAMCTL         		0x1a
-#define		ENSCAMSELO      	0x80
-#define		CLRSCAMSELID    	0x40
-#define		ALTSTIM         	0x20
-#define		DFLTTID         	0x10
-#define		SCAMLVL         	0x03
-
-#define	TARGID          		0x1b
-
-#define	SPIOCAP         		0x1b
-#define		SOFT1           	0x80
-#define		SOFT0           	0x40
-#define		SOFTCMDEN       	0x20
-#define		HAS_BRDCTL      	0x10
-#define		SEEPROM         	0x08
-#define		EEPROM          	0x04
-#define		ROM             	0x02
-#define		SSPIOCPS        	0x01
-
-#define	BRDCTL          		0x1d
-#define		BRDDAT7         	0x80
-#define		BRDDAT6         	0x40
-#define		BRDDAT5         	0x20
-#define		BRDDAT4         	0x10
-#define		BRDSTB          	0x10
-#define		BRDDAT3         	0x08
-#define		BRDCS           	0x08
-#define		BRDDAT2         	0x04
-#define		BRDRW           	0x04
-#define		BRDRW_ULTRA2    	0x02
-#define		BRDCTL1         	0x02
-#define		BRDCTL0         	0x01
-#define		BRDSTB_ULTRA2   	0x01
-
-#define	SEECTL          		0x1e
-#define		EXTARBACK       	0x80
-#define		EXTARBREQ       	0x40
-#define		SEEMS           	0x20
-#define		SEERDY          	0x10
-#define		SEECS           	0x08
-#define		SEECK           	0x04
-#define		SEEDO           	0x02
-#define		SEEDI           	0x01
-
-#define	SBLKCTL         		0x1f
-#define		DIAGLEDEN       	0x80
-#define		DIAGLEDON       	0x40
-#define		AUTOFLUSHDIS    	0x20
-#define		ENAB40          	0x08
-#define		SELBUSB         	0x08
-#define		ENAB20          	0x04
-#define		SELWIDE         	0x02
-#define		XCVR            	0x01
-
-#define	BUSY_TARGETS    		0x20
-#define	TARG_SCSIRATE   		0x20
-
-#define	SRAM_BASE       		0x20
-
-#define	ULTRA_ENB       		0x30
-#define	CMDSIZE_TABLE   		0x30
-
-#define	DISC_DSB        		0x32
-
-#define	CMDSIZE_TABLE_TAIL		0x34
-
-#define	MWI_RESIDUAL    		0x38
-
-#define	NEXT_QUEUED_SCB 		0x39
-
-#define	MSG_OUT         		0x3a
-
-#define	DMAPARAMS       		0x3b
-#define		PRELOADEN       	0x80
-#define		WIDEODD         	0x40
-#define		SCSIEN          	0x20
-#define		SDMAEN          	0x10
-#define		SDMAENACK       	0x10
-#define		HDMAEN          	0x08
-#define		HDMAENACK       	0x08
-#define		DIRECTION       	0x04
-#define		FIFOFLUSH       	0x02
-#define		FIFORESET       	0x01
-
-#define	SEQ_FLAGS       		0x3c
-#define		IDENTIFY_SEEN   	0x80
-#define		TARGET_CMD_IS_TAGGED	0x40
-#define		DPHASE          	0x20
-#define		TARG_CMD_PENDING	0x10
-#define		CMDPHASE_PENDING	0x08
-#define		DPHASE_PENDING  	0x04
-#define		SPHASE_PENDING  	0x02
-#define		NO_DISCONNECT   	0x01
-
-#define	SAVED_SCSIID    		0x3d
-
-#define	SAVED_LUN       		0x3e
-
-#define	LASTPHASE       		0x3f
-#define		P_MESGIN        	0xe0
-#define		PHASE_MASK      	0xe0
-#define		P_STATUS        	0xc0
-#define		P_MESGOUT       	0xa0
-#define		P_COMMAND       	0x80
-#define		CDI             	0x80
-#define		P_DATAIN        	0x40
-#define		IOI             	0x40
-#define		MSGI            	0x20
-#define		P_BUSFREE       	0x01
-#define		P_DATAOUT       	0x00
-
-#define	WAITING_SCBH    		0x40
-
-#define	DISCONNECTED_SCBH		0x41
-
-#define	FREE_SCBH       		0x42
-
-#define	COMPLETE_SCBH   		0x43
-
-#define	HSCB_ADDR       		0x44
-
-#define	SHARED_DATA_ADDR		0x48
-
-#define	KERNEL_QINPOS   		0x4c
-
-#define	QINPOS          		0x4d
-
-#define	QOUTPOS         		0x4e
-
-#define	KERNEL_TQINPOS  		0x4f
-
-#define	TQINPOS         		0x50
-
-#define	ARG_1           		0x51
-#define	RETURN_1        		0x51
-#define		SEND_MSG        	0x80
-#define		SEND_SENSE      	0x40
-#define		SEND_REJ        	0x20
-#define		MSGOUT_PHASEMIS 	0x10
-#define		EXIT_MSG_LOOP   	0x08
-#define		CONT_MSG_LOOP   	0x04
-#define		CONT_TARG_SESSION	0x02
-
-#define	ARG_2           		0x52
-#define	RETURN_2        		0x52
-
-#define	LAST_MSG        		0x53
-
-#define	SCSISEQ_TEMPLATE		0x54
-#define		ENSELO          	0x40
-#define		ENSELI          	0x20
-#define		ENRSELI         	0x10
-#define		ENAUTOATNO      	0x08
-#define		ENAUTOATNI      	0x04
-#define		ENAUTOATNP      	0x02
-
-#define	DATA_COUNT_ODD  		0x55
-
-#define	INITIATOR_TAG   		0x56
-
-#define	SEQ_FLAGS2      		0x57
-#define		TARGET_MSG_PENDING	0x02
-#define		SCB_DMA         	0x01
-
-#define	SCSICONF        		0x5a
-#define		TERM_ENB        	0x80
-#define		RESET_SCSI      	0x40
-#define		ENSPCHK         	0x20
-#define		HWSCSIID        	0x0f
-#define		HSCSIID         	0x07
-
-#define	INTDEF          		0x5c
-#define		EDGE_TRIG       	0x80
-#define		VECTOR          	0x0f
-
-#define	HOSTCONF        		0x5d
-
-#define	HA_274_BIOSCTRL 		0x5f
-#define		BIOSDISABLED    	0x30
-#define		BIOSMODE        	0x30
-#define		CHANNEL_B_PRIMARY	0x08
-
-#define	SEQCTL          		0x60
-#define		PERRORDIS       	0x80
-#define		PAUSEDIS        	0x40
-#define		FAILDIS         	0x20
-#define		FASTMODE        	0x10
-#define		BRKADRINTEN     	0x08
-#define		STEP            	0x04
-#define		SEQRESET        	0x02
-#define		LOADRAM         	0x01
-
-#define	SEQRAM          		0x61
-
-#define	SEQADDR0        		0x62
-
-#define	SEQADDR1        		0x63
-#define		SEQADDR1_MASK   	0x01
-
-#define	ACCUM           		0x64
-
-#define	SINDEX          		0x65
-
-#define	DINDEX          		0x66
-
-#define	ALLONES         		0x69
-
-#define	ALLZEROS        		0x6a
-
-#define	NONE            		0x6a
-
-#define	FLAGS           		0x6b
-#define		ZERO            	0x02
-#define		CARRY           	0x01
-
-#define	SINDIR          		0x6c
-
-#define	DINDIR          		0x6d
-
-#define	FUNCTION1       		0x6e
-
-#define	STACK           		0x6f
-
-#define	TARG_OFFSET     		0x70
-
-#define	BCTL            		0x84
-#define		ACE             	0x08
-#define		ENABLE          	0x01
-
-#define	DSCOMMAND0      		0x84
-#define		CACHETHEN       	0x80
-#define		DPARCKEN        	0x40
-#define		MPARCKEN        	0x20
-#define		EXTREQLCK       	0x10
-#define		INTSCBRAMSEL    	0x08
-#define		RAMPS           	0x04
-#define		USCBSIZE32      	0x02
-#define		CIOPARCKEN      	0x01
-
-#define	BUSTIME         		0x85
-#define		BOFF            	0xf0
-#define		BON             	0x0f
-
-#define	DSCOMMAND1      		0x85
-#define		DSLATT          	0xfc
-#define		HADDLDSEL1      	0x02
-#define		HADDLDSEL0      	0x01
-
-#define	BUSSPD          		0x86
-#define		DFTHRSH         	0xc0
-#define		DFTHRSH_75      	0x80
-#define		STBOFF          	0x38
-#define		STBON           	0x07
-
-#define	HS_MAILBOX      		0x86
-#define		HOST_MAILBOX    	0xf0
-#define		HOST_TQINPOS    	0x80
-#define		SEQ_MAILBOX     	0x0f
-
-#define	DSPCISTATUS     		0x86
-#define		DFTHRSH_100     	0xc0
-
-#define	HCNTRL          		0x87
-#define		POWRDN          	0x40
-#define		SWINT           	0x10
-#define		IRQMS           	0x08
-#define		PAUSE           	0x04
-#define		INTEN           	0x02
-#define		CHIPRST         	0x01
-#define		CHIPRSTACK      	0x01
-
-#define	HADDR           		0x88
-
-#define	HCNT            		0x8c
-
-#define	SCBPTR          		0x90
-
-#define	INTSTAT         		0x91
-#define		SEQINT_MASK     	0xf1
-#define		OUT_OF_RANGE    	0xe1
-#define		NO_FREE_SCB     	0xd1
-#define		SCB_MISMATCH    	0xc1
-#define		MISSED_BUSFREE  	0xb1
-#define		MKMSG_FAILED    	0xa1
-#define		DATA_OVERRUN    	0x91
-#define		PERR_DETECTED   	0x81
-#define		BAD_STATUS      	0x71
-#define		HOST_MSG_LOOP   	0x61
-#define		PDATA_REINIT    	0x51
-#define		IGN_WIDE_RES    	0x41
-#define		NO_MATCH        	0x31
-#define		NO_IDENT        	0x21
-#define		SEND_REJECT     	0x11
-#define		INT_PEND        	0x0f
-#define		BRKADRINT       	0x08
-#define		SCSIINT         	0x04
-#define		CMDCMPLT        	0x02
-#define		BAD_PHASE       	0x01
-#define		SEQINT          	0x01
-
-#define	CLRINT          		0x92
-#define		CLRPARERR       	0x10
-#define		CLRBRKADRINT    	0x08
-#define		CLRSCSIINT      	0x04
-#define		CLRCMDINT       	0x02
-#define		CLRSEQINT       	0x01
-
-#define	ERROR           		0x92
-#define		CIOPARERR       	0x80
-#define		PCIERRSTAT      	0x40
-#define		MPARERR         	0x20
-#define		DPARERR         	0x10
-#define		SQPARERR        	0x08
-#define		ILLOPCODE       	0x04
-#define		ILLSADDR        	0x02
-#define		ILLHADDR        	0x01
-
-#define	DFCNTRL         		0x93
-
-#define	DFSTATUS        		0x94
-#define		PRELOAD_AVAIL   	0x80
-#define		DFCACHETH       	0x40
-#define		FIFOQWDEMP      	0x20
-#define		MREQPEND        	0x10
-#define		HDONE           	0x08
-#define		DFTHRESH        	0x04
-#define		FIFOFULL        	0x02
-#define		FIFOEMP         	0x01
-
-#define	DFWADDR         		0x95
-
-#define	DFRADDR         		0x97
-
-#define	DFDAT           		0x99
-
-#define	SCBCNT          		0x9a
-#define		SCBAUTO         	0x80
-#define		SCBCNT_MASK     	0x1f
-
-#define	QINFIFO         		0x9b
-
-#define	QINCNT          		0x9c
-
-#define	QOUTFIFO        		0x9d
-
-#define	CRCCONTROL1     		0x9d
-#define		CRCONSEEN       	0x80
-#define		CRCVALCHKEN     	0x40
-#define		CRCENDCHKEN     	0x20
-#define		CRCREQCHKEN     	0x10
-#define		TARGCRCENDEN    	0x08
-#define		TARGCRCCNTEN    	0x04
-
-#define	QOUTCNT         		0x9e
-
-#define	SCSIPHASE       		0x9e
-#define		STATUS_PHASE    	0x20
-#define		COMMAND_PHASE   	0x10
-#define		MSG_IN_PHASE    	0x08
-#define		MSG_OUT_PHASE   	0x04
-#define		DATA_PHASE_MASK 	0x03
-#define		DATA_IN_PHASE   	0x02
-#define		DATA_OUT_PHASE  	0x01
-
-#define	SFUNCT          		0x9f
-#define		ALT_MODE        	0x80
-
-#define	SCB_BASE        		0xa0
-
-#define	SCB_CDB_PTR     		0xa0
-#define	SCB_RESIDUAL_DATACNT		0xa0
-#define	SCB_CDB_STORE   		0xa0
-
-#define	SCB_RESIDUAL_SGPTR		0xa4
-
-#define	SCB_SCSI_STATUS 		0xa8
-
-#define	SCB_TARGET_PHASES		0xa9
-
-#define	SCB_TARGET_DATA_DIR		0xaa
-
-#define	SCB_TARGET_ITAG 		0xab
-
-#define	SCB_DATAPTR     		0xac
-
-#define	SCB_DATACNT     		0xb0
-#define		SG_LAST_SEG     	0x80
-#define		SG_HIGH_ADDR_BITS	0x7f
-
-#define	SCB_SGPTR       		0xb4
-#define		SG_RESID_VALID  	0x04
-#define		SG_FULL_RESID   	0x02
-#define		SG_LIST_NULL    	0x01
-
-#define	SCB_CONTROL     		0xb8
-#define		TARGET_SCB      	0x80
-#define		DISCENB         	0x40
-#define		TAG_ENB         	0x20
-#define		MK_MESSAGE      	0x10
-#define		ULTRAENB        	0x08
-#define		DISCONNECTED    	0x04
-#define		SCB_TAG_TYPE    	0x03
-
-#define	SCB_SCSIID      		0xb9
-#define		TID             	0xf0
-#define		TWIN_CHNLB      	0x80
-#define		TWIN_TID        	0x70
-#define		OID             	0x0f
-
-#define	SCB_LUN         		0xba
-#define		LID             	0xff
-
-#define	SCB_TAG         		0xbb
-
-#define	SCB_CDB_LEN     		0xbc
-
-#define	SCB_SCSIRATE    		0xbd
-
-#define	SCB_SCSIOFFSET  		0xbe
-
-#define	SCB_NEXT        		0xbf
-
-#define	SCB_64_SPARE    		0xc0
-
-#define	SEECTL_2840     		0xc0
-#define		CS_2840         	0x04
-#define		CK_2840         	0x02
-#define		DO_2840         	0x01
-
-#define	STATUS_2840     		0xc1
-#define		EEPROM_TF       	0x80
-#define		BIOS_SEL        	0x60
-#define		ADSEL           	0x1e
-#define		DI_2840         	0x01
-
-#define	SCB_64_BTT      		0xd0
-
-#define	CCHADDR         		0xe0
-
-#define	CCHCNT          		0xe8
-
-#define	CCSGRAM         		0xe9
-
-#define	CCSGADDR        		0xea
-
-#define	CCSGCTL         		0xeb
-#define		CCSGDONE        	0x80
-#define		CCSGEN          	0x08
-#define		SG_FETCH_NEEDED 	0x02
-#define		CCSGRESET       	0x01
-
-#define	CCSCBRAM        		0xec
-
-#define	CCSCBADDR       		0xed
-
-#define	CCSCBCTL        		0xee
-#define		CCSCBDONE       	0x80
-#define		ARRDONE         	0x40
-#define		CCARREN         	0x10
-#define		CCSCBEN         	0x08
-#define		CCSCBDIR        	0x04
-#define		CCSCBRESET      	0x01
-
-#define	CCSCBCNT        		0xef
-
-#define	SCBBADDR        		0xf0
-
-#define	CCSCBPTR        		0xf1
-
-#define	HNSCB_QOFF      		0xf4
-
-#define	SNSCB_QOFF      		0xf6
-
-#define	SDSCB_QOFF      		0xf8
-
-#define	QOFF_CTLSTA     		0xfa
-#define		SCB_AVAIL       	0x40
-#define		SNSCB_ROLLOVER  	0x20
-#define		SDSCB_ROLLOVER  	0x10
-#define		SCB_QSIZE       	0x07
-#define		SCB_QSIZE_256   	0x06
-
-#define	DFF_THRSH       		0xfb
-#define		WR_DFTHRSH      	0x70
-#define		WR_DFTHRSH_MAX  	0x70
-#define		WR_DFTHRSH_90   	0x60
-#define		WR_DFTHRSH_85   	0x50
-#define		WR_DFTHRSH_75   	0x40
-#define		WR_DFTHRSH_63   	0x30
-#define		WR_DFTHRSH_50   	0x20
-#define		WR_DFTHRSH_25   	0x10
-#define		RD_DFTHRSH      	0x07
-#define		RD_DFTHRSH_MAX  	0x07
-#define		RD_DFTHRSH_90   	0x06
-#define		RD_DFTHRSH_85   	0x05
-#define		RD_DFTHRSH_75   	0x04
-#define		RD_DFTHRSH_63   	0x03
-#define		RD_DFTHRSH_50   	0x02
-#define		RD_DFTHRSH_25   	0x01
-#define		RD_DFTHRSH_MIN  	0x00
-#define		WR_DFTHRSH_MIN  	0x00
-
-#define	SG_CACHE_SHADOW 		0xfc
-#define		SG_ADDR_MASK    	0xf8
-#define		ODD_SEG         	0x04
-#define		LAST_SEG        	0x02
-#define		LAST_SEG_DONE   	0x01
-
-#define	SG_CACHE_PRE    		0xfc
-
-
-#define	MAX_OFFSET_ULTRA2	0x7f
-#define	MAX_OFFSET_16BIT	0x08
-#define	BUS_8_BIT	0x00
-#define	TARGET_CMD_CMPLT	0xfe
-#define	STATUS_QUEUE_FULL	0x28
-#define	STATUS_BUSY	0x08
-#define	MAX_OFFSET_8BIT	0x0f
-#define	BUS_32_BIT	0x02
-#define	CCSGADDR_MAX	0x80
-#define	TID_SHIFT	0x04
-#define	SCB_DOWNLOAD_SIZE_64	0x30
-#define	HOST_MAILBOX_SHIFT	0x04
-#define	CMD_GROUP_CODE_SHIFT	0x05
-#define	CCSGRAM_MAXSEGS	0x10
-#define	SCB_LIST_NULL	0xff
-#define	SG_SIZEOF	0x08
-#define	SCB_DOWNLOAD_SIZE	0x20
-#define	SEQ_MAILBOX_SHIFT	0x00
-#define	TARGET_DATA_IN	0x01
-#define	HOST_MSG	0xff
-#define	BUS_16_BIT	0x01
-#define	SCB_UPLOAD_SIZE	0x20
-
-
-/* Downloaded Constant Definitions */
-#define	INVERTED_CACHESIZE_MASK	0x03
-#define	SG_PREFETCH_ADDR_MASK	0x06
-#define	SG_PREFETCH_ALIGN_MASK	0x05
-#define	QOUTFIFO_OFFSET	0x00
-#define	SG_PREFETCH_CNT	0x04
-#define	CACHESIZE_MASK	0x02
-#define	QINFIFO_OFFSET	0x01
diff -Nru a/drivers/scsi/aic7xxx/shipped_aic7xxx_seq.h b/drivers/scsi/aic7xxx/shipped_aic7xxx_seq.h
--- a/drivers/scsi/aic7xxx/shipped_aic7xxx_seq.h	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,1299 +0,0 @@
-/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
- * $Id$
- * $Id$
- */
-static uint8_t seqprog[] = {
-	0xb2, 0x00, 0x00, 0x08,
-	0xf7, 0x11, 0x22, 0x08,
-	0x00, 0x65, 0xe0, 0x59,
-	0xf7, 0x01, 0x02, 0x08,
-	0xff, 0x6a, 0x24, 0x08,
-	0x40, 0x00, 0x40, 0x68,
-	0x08, 0x1f, 0x3e, 0x10,
-	0x40, 0x00, 0x40, 0x68,
-	0xff, 0x40, 0x3c, 0x60,
-	0x08, 0x1f, 0x3e, 0x10,
-	0x60, 0x0b, 0x42, 0x68,
-	0x40, 0xfa, 0x12, 0x78,
-	0x01, 0x4d, 0xc8, 0x30,
-	0x00, 0x4c, 0x12, 0x70,
-	0x01, 0x39, 0xa2, 0x30,
-	0x00, 0x6a, 0xb2, 0x5e,
-	0x01, 0x51, 0x20, 0x31,
-	0x01, 0x57, 0xae, 0x00,
-	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0x51, 0x04, 0x5e,
-	0x01, 0x51, 0xc8, 0x30,
-	0x00, 0x39, 0xc8, 0x60,
-	0x00, 0xbb, 0x30, 0x70,
-	0xc1, 0x6a, 0xca, 0x5e,
-	0x01, 0xbf, 0x72, 0x30,
-	0x01, 0x40, 0x7e, 0x31,
-	0x01, 0x90, 0x80, 0x30,
-	0x01, 0xf6, 0xd4, 0x30,
-	0x01, 0x4d, 0x9a, 0x18,
-	0xfe, 0x57, 0xae, 0x08,
-	0x01, 0x40, 0x20, 0x31,
-	0x00, 0x65, 0xcc, 0x58,
-	0x60, 0x0b, 0x40, 0x78,
-	0x08, 0x6a, 0x18, 0x00,
-	0x08, 0x11, 0x22, 0x00,
-	0x60, 0x0b, 0x00, 0x78,
-	0x40, 0x0b, 0xfc, 0x68,
-	0x80, 0x0b, 0xb6, 0x78,
-	0x20, 0x6a, 0x16, 0x00,
-	0xa4, 0x6a, 0x06, 0x00,
-	0x08, 0x3c, 0x78, 0x00,
-	0x01, 0x50, 0xc8, 0x30,
-	0xe0, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xee, 0x5d,
-	0x01, 0x6a, 0xdc, 0x01,
-	0x88, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xee, 0x5d,
-	0x01, 0x6a, 0x26, 0x01,
-	0xf0, 0x19, 0x7a, 0x08,
-	0x0f, 0x18, 0xc8, 0x08,
-	0x0f, 0x0f, 0xc8, 0x08,
-	0x0f, 0x05, 0xc8, 0x08,
-	0x00, 0x3d, 0x7a, 0x00,
-	0x08, 0x1f, 0x6e, 0x78,
-	0x80, 0x3d, 0x7a, 0x00,
-	0x01, 0x3d, 0xd8, 0x31,
-	0x01, 0x3d, 0x32, 0x31,
-	0x10, 0x03, 0x46, 0x79,
-	0x00, 0x65, 0xf4, 0x58,
-	0x80, 0x66, 0xae, 0x78,
-	0x01, 0x66, 0xd8, 0x31,
-	0x01, 0x66, 0x32, 0x31,
-	0x3f, 0x66, 0x7c, 0x08,
-	0x40, 0x66, 0x82, 0x68,
-	0x01, 0x3c, 0x78, 0x00,
-	0x10, 0x03, 0x9e, 0x78,
-	0x00, 0x65, 0xf4, 0x58,
-	0xe0, 0x66, 0xc8, 0x18,
-	0x00, 0x65, 0xaa, 0x50,
-	0xdd, 0x66, 0xc8, 0x18,
-	0x00, 0x65, 0xaa, 0x48,
-	0x01, 0x66, 0xd8, 0x31,
-	0x01, 0x66, 0x32, 0x31,
-	0x10, 0x03, 0x46, 0x79,
-	0x00, 0x65, 0xf4, 0x58,
-	0x01, 0x66, 0xd8, 0x31,
-	0x01, 0x66, 0x32, 0x31,
-	0x01, 0x66, 0xac, 0x30,
-	0x40, 0x3c, 0x78, 0x00,
-	0xff, 0x6a, 0xd8, 0x01,
-	0xff, 0x6a, 0x32, 0x01,
-	0x90, 0x3c, 0x78, 0x00,
-	0x02, 0x57, 0x3a, 0x69,
-	0x10, 0x03, 0x38, 0x69,
-	0x00, 0x65, 0x1e, 0x41,
-	0x02, 0x57, 0xae, 0x00,
-	0x00, 0x65, 0x9e, 0x40,
-	0x61, 0x6a, 0xca, 0x5e,
-	0x08, 0x51, 0x1e, 0x71,
-	0x02, 0x0b, 0xb2, 0x78,
-	0x00, 0x65, 0xae, 0x40,
-	0x1a, 0x01, 0x02, 0x00,
-	0xf0, 0x19, 0x7a, 0x08,
-	0x0f, 0x0f, 0xc8, 0x08,
-	0x0f, 0x05, 0xc8, 0x08,
-	0x00, 0x3d, 0x7a, 0x00,
-	0x08, 0x1f, 0xc4, 0x78,
-	0x80, 0x3d, 0x7a, 0x00,
-	0x20, 0x6a, 0x16, 0x00,
-	0x00, 0x65, 0xc0, 0x41,
-	0x00, 0x65, 0xa4, 0x5e,
-	0x00, 0x65, 0x12, 0x40,
-	0x20, 0x11, 0xd2, 0x68,
-	0x20, 0x6a, 0x18, 0x00,
-	0x20, 0x11, 0x22, 0x00,
-	0xf7, 0x1f, 0xca, 0x08,
-	0x80, 0xb9, 0xd8, 0x78,
-	0x08, 0x65, 0xca, 0x00,
-	0x01, 0x65, 0x3e, 0x30,
-	0x01, 0xb9, 0x1e, 0x30,
-	0x7f, 0xb9, 0x0a, 0x08,
-	0x01, 0xb9, 0x0a, 0x30,
-	0x01, 0x54, 0xca, 0x30,
-	0x80, 0xb8, 0xe6, 0x78,
-	0x80, 0x65, 0xca, 0x00,
-	0x01, 0x65, 0x00, 0x34,
-	0x01, 0x54, 0x00, 0x34,
-	0x1a, 0x01, 0x02, 0x00,
-	0x08, 0xb8, 0xf0, 0x78,
-	0x20, 0x01, 0x02, 0x00,
-	0x02, 0xbd, 0x08, 0x34,
-	0x01, 0xbd, 0x08, 0x34,
-	0x08, 0x01, 0x02, 0x00,
-	0x02, 0x0b, 0xf6, 0x78,
-	0xf7, 0x01, 0x02, 0x08,
-	0x01, 0x06, 0xcc, 0x34,
-	0xb2, 0x00, 0x00, 0x08,
-	0x40, 0x6a, 0x16, 0x00,
-	0x01, 0x40, 0x20, 0x31,
-	0x01, 0xbf, 0x80, 0x30,
-	0x01, 0xb9, 0x7a, 0x30,
-	0x01, 0xba, 0x7c, 0x30,
-	0x00, 0x65, 0xea, 0x58,
-	0x80, 0x0b, 0xbc, 0x79,
-	0xe4, 0x6a, 0x60, 0x5d,
-	0x80, 0xba, 0x76, 0x5d,
-	0x20, 0xb8, 0x16, 0x79,
-	0x20, 0x6a, 0x76, 0x5d,
-	0x00, 0xab, 0x76, 0x5d,
-	0x01, 0xa9, 0x78, 0x30,
-	0x10, 0xb8, 0x1e, 0x79,
-	0xe4, 0x6a, 0x60, 0x5d,
-	0x00, 0x65, 0xae, 0x40,
-	0x10, 0x03, 0x36, 0x69,
-	0x08, 0x3c, 0x52, 0x69,
-	0x04, 0x3c, 0x8a, 0x69,
-	0x02, 0x3c, 0x90, 0x69,
-	0x01, 0x3c, 0x3c, 0x79,
-	0x01, 0x6a, 0xa2, 0x30,
-	0x00, 0x65, 0x9c, 0x59,
-	0x04, 0x51, 0x2c, 0x61,
-	0x00, 0x6a, 0xb2, 0x5e,
-	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0xbb, 0x04, 0x5e,
-	0x00, 0x65, 0x16, 0x41,
-	0xa4, 0x6a, 0x06, 0x00,
-	0x00, 0x65, 0xf4, 0x58,
-	0x00, 0x65, 0xae, 0x40,
-	0xe4, 0x6a, 0x60, 0x5d,
-	0x20, 0x3c, 0x42, 0x79,
-	0x02, 0x6a, 0x76, 0x5d,
-	0x04, 0x6a, 0x76, 0x5d,
-	0x01, 0x03, 0x44, 0x69,
-	0xf7, 0x11, 0x22, 0x08,
-	0xff, 0x6a, 0x24, 0x08,
-	0xff, 0x6a, 0x06, 0x08,
-	0x01, 0x6a, 0x7e, 0x00,
-	0x00, 0x65, 0x9c, 0x59,
-	0x00, 0x65, 0x04, 0x40,
-	0x80, 0x86, 0xc8, 0x08,
-	0x01, 0x4f, 0xc8, 0x30,
-	0x00, 0x50, 0x64, 0x61,
-	0xc4, 0x6a, 0x60, 0x5d,
-	0x40, 0x3c, 0x60, 0x79,
-	0x28, 0x6a, 0x76, 0x5d,
-	0x00, 0x65, 0x44, 0x41,
-	0x08, 0x6a, 0x76, 0x5d,
-	0x00, 0x65, 0x44, 0x41,
-	0x84, 0x6a, 0x60, 0x5d,
-	0x00, 0x65, 0xf4, 0x58,
-	0x01, 0x66, 0xc8, 0x30,
-	0x01, 0x64, 0xd8, 0x31,
-	0x01, 0x64, 0x32, 0x31,
-	0x5b, 0x64, 0xc8, 0x28,
-	0x30, 0x64, 0xca, 0x18,
-	0x01, 0x6c, 0xc8, 0x30,
-	0xff, 0x64, 0x86, 0x79,
-	0x08, 0x01, 0x02, 0x00,
-	0x02, 0x0b, 0x78, 0x79,
-	0x01, 0x64, 0x7e, 0x61,
-	0xf7, 0x01, 0x02, 0x08,
-	0x01, 0x06, 0xd8, 0x31,
-	0x01, 0x06, 0x32, 0x31,
-	0xff, 0x64, 0xc8, 0x18,
-	0xff, 0x64, 0x78, 0x69,
-	0xf7, 0x3c, 0x78, 0x08,
-	0x00, 0x65, 0x1e, 0x41,
-	0x40, 0xaa, 0x7e, 0x10,
-	0x04, 0xaa, 0x60, 0x5d,
-	0x00, 0x65, 0x52, 0x42,
-	0xc4, 0x6a, 0x60, 0x5d,
-	0xc0, 0x6a, 0x7e, 0x00,
-	0x00, 0xa8, 0x76, 0x5d,
-	0xe4, 0x6a, 0x06, 0x00,
-	0x00, 0x6a, 0x76, 0x5d,
-	0x00, 0x65, 0x44, 0x41,
-	0x10, 0x3c, 0xa0, 0x69,
-	0x00, 0xbb, 0x80, 0x44,
-	0x18, 0x6a, 0xda, 0x01,
-	0x01, 0x69, 0xd8, 0x31,
-	0x1c, 0x6a, 0xd0, 0x01,
-	0x09, 0xee, 0xdc, 0x01,
-	0x80, 0xee, 0xa8, 0x79,
-	0xff, 0x6a, 0xdc, 0x09,
-	0x01, 0x93, 0x26, 0x01,
-	0x03, 0x6a, 0x2a, 0x01,
-	0x01, 0x69, 0x32, 0x31,
-	0x1c, 0x6a, 0xd2, 0x5d,
-	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0x9a, 0x5e,
-	0x01, 0x50, 0xa0, 0x18,
-	0x02, 0x6a, 0x22, 0x05,
-	0x80, 0x6a, 0x74, 0x00,
-	0x80, 0x3c, 0x78, 0x00,
-	0x00, 0x65, 0xca, 0x5d,
-	0x01, 0x3f, 0xc8, 0x30,
-	0xbf, 0x64, 0x52, 0x7a,
-	0x80, 0x64, 0xa6, 0x73,
-	0xa0, 0x64, 0x04, 0x74,
-	0xc0, 0x64, 0xf8, 0x73,
-	0xe0, 0x64, 0x34, 0x74,
-	0x01, 0x6a, 0xca, 0x5e,
-	0x00, 0x65, 0xc0, 0x41,
-	0xf7, 0x11, 0x22, 0x08,
-	0x01, 0x06, 0xd4, 0x30,
-	0xff, 0x6a, 0x24, 0x08,
-	0xf7, 0x01, 0x02, 0x08,
-	0x09, 0x0c, 0xda, 0x79,
-	0x08, 0x0c, 0x04, 0x68,
-	0xb1, 0x6a, 0xca, 0x5e,
-	0xff, 0x6a, 0x26, 0x09,
-	0x12, 0x01, 0x02, 0x00,
-	0x02, 0x6a, 0x08, 0x30,
-	0xff, 0x6a, 0x08, 0x08,
-	0xdf, 0x01, 0x02, 0x08,
-	0x01, 0x6a, 0x7e, 0x00,
-	0xff, 0x6a, 0x78, 0x0c,
-	0xff, 0x6a, 0xc8, 0x08,
-	0x08, 0xa4, 0x48, 0x19,
-	0x00, 0xa5, 0x4a, 0x21,
-	0x00, 0xa6, 0x4c, 0x21,
-	0x00, 0xa7, 0x4e, 0x25,
-	0x08, 0xeb, 0xce, 0x7e,
-	0x80, 0xeb, 0xfa, 0x79,
-	0xff, 0x6a, 0xd6, 0x09,
-	0x08, 0xeb, 0xfe, 0x69,
-	0xff, 0x6a, 0xd4, 0x0c,
-	0x80, 0xa3, 0xce, 0x6e,
-	0x88, 0xeb, 0x14, 0x72,
-	0x08, 0xeb, 0xce, 0x6e,
-	0x04, 0xea, 0x18, 0xe2,
-	0x08, 0xee, 0xce, 0x6e,
-	0x04, 0x6a, 0xd0, 0x81,
-	0x05, 0xa4, 0xc0, 0x89,
-	0x03, 0xa5, 0xc2, 0x31,
-	0x09, 0x6a, 0xd6, 0x05,
-	0x00, 0x65, 0xfc, 0x59,
-	0x06, 0xa4, 0xd4, 0x89,
-	0x80, 0x94, 0xce, 0x7e,
-	0x07, 0xe9, 0x10, 0x31,
-	0x01, 0x8c, 0x20, 0x7a,
-	0x01, 0x55, 0xaa, 0x10,
-	0x01, 0xe9, 0x46, 0x31,
-	0x00, 0xa3, 0xac, 0x5e,
-	0x00, 0x65, 0xee, 0x59,
-	0x01, 0xa4, 0xca, 0x30,
-	0x01, 0x55, 0x2c, 0x7a,
-	0x04, 0x65, 0xca, 0x00,
-	0x80, 0xa3, 0x30, 0x7a,
-	0x02, 0x65, 0xca, 0x00,
-	0x01, 0x65, 0xf8, 0x31,
-	0x80, 0x93, 0x26, 0x01,
-	0xff, 0x6a, 0xd4, 0x0c,
-	0x01, 0x8c, 0xc8, 0x30,
-	0x00, 0x88, 0xc8, 0x18,
-	0x02, 0x64, 0xc8, 0x88,
-	0xff, 0x64, 0xce, 0x7e,
-	0xff, 0x8d, 0x46, 0x6a,
-	0xff, 0x8e, 0x46, 0x6a,
-	0x03, 0x8c, 0xd4, 0x98,
-	0x00, 0x65, 0xce, 0x56,
-	0x01, 0x64, 0x70, 0x30,
-	0xff, 0x64, 0xc8, 0x10,
-	0x01, 0x64, 0xc8, 0x18,
-	0x00, 0x8c, 0x18, 0x19,
-	0xff, 0x8d, 0x1a, 0x21,
-	0xff, 0x8e, 0x1c, 0x25,
-	0x80, 0x3c, 0x56, 0x6a,
-	0x21, 0x6a, 0xca, 0x46,
-	0xa8, 0x6a, 0x76, 0x00,
-	0x79, 0x6a, 0x76, 0x00,
-	0x40, 0x3f, 0x5e, 0x6a,
-	0x04, 0x3b, 0x76, 0x00,
-	0x04, 0x6a, 0xd4, 0x81,
-	0x20, 0x3c, 0x66, 0x7a,
-	0x51, 0x6a, 0xca, 0x5e,
-	0x00, 0x65, 0x80, 0x42,
-	0x20, 0x3c, 0x78, 0x00,
-	0x00, 0xb3, 0xac, 0x5e,
-	0x07, 0xac, 0x10, 0x31,
-	0x05, 0xb3, 0x46, 0x31,
-	0x88, 0x6a, 0xcc, 0x00,
-	0xac, 0x6a, 0xe0, 0x5d,
-	0xa3, 0x6a, 0xcc, 0x00,
-	0xb3, 0x6a, 0xe4, 0x5d,
-	0x00, 0x65, 0x36, 0x5a,
-	0xfd, 0xa4, 0x48, 0x09,
-	0x01, 0x8c, 0xaa, 0x08,
-	0x03, 0x8c, 0x10, 0x30,
-	0x00, 0x65, 0xd8, 0x5d,
-	0x01, 0xa4, 0x92, 0x7a,
-	0x04, 0x3b, 0x76, 0x08,
-	0x01, 0x3b, 0x26, 0x31,
-	0x80, 0x02, 0x04, 0x00,
-	0x10, 0x0c, 0x88, 0x7a,
-	0x03, 0x9e, 0x8a, 0x6a,
-	0x7f, 0x02, 0x04, 0x08,
-	0x91, 0x6a, 0xca, 0x5e,
-	0x00, 0x65, 0xc0, 0x41,
-	0x01, 0xa4, 0xca, 0x30,
-	0x80, 0xa3, 0x98, 0x7a,
-	0x02, 0x65, 0xca, 0x00,
-	0x01, 0x55, 0x9c, 0x7a,
-	0x04, 0x65, 0xca, 0x00,
-	0x01, 0x65, 0xf8, 0x31,
-	0x01, 0x3b, 0x26, 0x31,
-	0x00, 0x65, 0x02, 0x5a,
-	0x01, 0xfc, 0xaa, 0x6a,
-	0x80, 0x0b, 0xa0, 0x6a,
-	0x10, 0x0c, 0xa0, 0x7a,
-	0x20, 0x93, 0xa0, 0x6a,
-	0x02, 0x93, 0x26, 0x01,
-	0x02, 0xfc, 0xb4, 0x7a,
-	0x40, 0x0d, 0xce, 0x6a,
-	0x01, 0xa4, 0x48, 0x01,
-	0x00, 0x65, 0xce, 0x42,
-	0x40, 0x0d, 0xba, 0x6a,
-	0x00, 0x65, 0x02, 0x5a,
-	0x00, 0x65, 0xac, 0x42,
-	0x80, 0xfc, 0xc4, 0x7a,
-	0x80, 0xa4, 0xc4, 0x6a,
-	0xff, 0xa5, 0x4a, 0x19,
-	0xff, 0xa6, 0x4c, 0x21,
-	0xff, 0xa7, 0x4e, 0x21,
-	0xf8, 0xfc, 0x48, 0x09,
-	0xff, 0x6a, 0xaa, 0x08,
-	0x04, 0xfc, 0xcc, 0x7a,
-	0x01, 0x55, 0xaa, 0x00,
-	0xff, 0x6a, 0x46, 0x09,
-	0x04, 0x3b, 0xe6, 0x6a,
-	0x02, 0x93, 0x26, 0x01,
-	0x01, 0x94, 0xd0, 0x7a,
-	0x01, 0x94, 0xd0, 0x7a,
-	0x01, 0x94, 0xd0, 0x7a,
-	0x01, 0x94, 0xd0, 0x7a,
-	0x01, 0x94, 0xd0, 0x7a,
-	0x01, 0xa4, 0xe4, 0x7a,
-	0x01, 0xfc, 0xde, 0x7a,
-	0x01, 0x94, 0xe6, 0x6a,
-	0x00, 0x65, 0x80, 0x42,
-	0x01, 0x94, 0xe4, 0x7a,
-	0x10, 0x94, 0xe6, 0x6a,
-	0xd7, 0x93, 0x26, 0x09,
-	0x28, 0x93, 0xea, 0x6a,
-	0x01, 0x85, 0x0a, 0x01,
-	0x02, 0xfc, 0xf2, 0x6a,
-	0x01, 0x14, 0x46, 0x31,
-	0xff, 0x6a, 0x10, 0x09,
-	0xfe, 0x85, 0x0a, 0x09,
-	0xff, 0x38, 0x00, 0x6b,
-	0x80, 0xa3, 0x00, 0x7b,
-	0x80, 0x0b, 0xfe, 0x7a,
-	0x04, 0x3b, 0x00, 0x7b,
-	0xbf, 0x3b, 0x76, 0x08,
-	0x01, 0x3b, 0x26, 0x31,
-	0x00, 0x65, 0x02, 0x5a,
-	0x01, 0x0b, 0x0e, 0x6b,
-	0x10, 0x0c, 0x02, 0x7b,
-	0x04, 0x93, 0x0c, 0x6b,
-	0x01, 0x94, 0x0a, 0x7b,
-	0x10, 0x94, 0x0c, 0x6b,
-	0xc7, 0x93, 0x26, 0x09,
-	0x01, 0x99, 0xd4, 0x30,
-	0x38, 0x93, 0x10, 0x6b,
-	0xff, 0x08, 0x62, 0x6b,
-	0xff, 0x09, 0x62, 0x6b,
-	0xff, 0x0a, 0x62, 0x6b,
-	0xff, 0x38, 0x2c, 0x7b,
-	0x04, 0x14, 0x10, 0x31,
-	0x01, 0x38, 0x18, 0x31,
-	0x02, 0x6a, 0x1a, 0x31,
-	0x88, 0x6a, 0xcc, 0x00,
-	0x14, 0x6a, 0xe6, 0x5d,
-	0x00, 0x38, 0xd2, 0x5d,
-	0xff, 0x6a, 0x70, 0x08,
-	0x00, 0x65, 0x58, 0x43,
-	0x80, 0xa3, 0x32, 0x7b,
-	0x01, 0xa4, 0x48, 0x01,
-	0x00, 0x65, 0x62, 0x43,
-	0x08, 0xeb, 0x38, 0x7b,
-	0x00, 0x65, 0x02, 0x5a,
-	0x08, 0xeb, 0x34, 0x6b,
-	0x07, 0xe9, 0x10, 0x31,
-	0x01, 0xe9, 0xca, 0x30,
-	0x01, 0x65, 0x46, 0x31,
-	0x00, 0x6a, 0xac, 0x5e,
-	0x88, 0x6a, 0xcc, 0x00,
-	0xa4, 0x6a, 0xe6, 0x5d,
-	0x08, 0x6a, 0xd2, 0x5d,
-	0x0d, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0x9a, 0x5e,
-	0x88, 0x6a, 0xcc, 0x00,
-	0x00, 0x65, 0x7c, 0x5e,
-	0x01, 0x99, 0x46, 0x31,
-	0x00, 0xa3, 0xac, 0x5e,
-	0x01, 0x88, 0x10, 0x31,
-	0x00, 0x65, 0x36, 0x5a,
-	0x00, 0x65, 0xee, 0x59,
-	0x03, 0x8c, 0x10, 0x30,
-	0x00, 0x65, 0xd8, 0x5d,
-	0x01, 0x8c, 0x60, 0x7b,
-	0x01, 0x55, 0xaa, 0x10,
-	0x80, 0x0b, 0x80, 0x6a,
-	0x80, 0x0b, 0x6a, 0x6b,
-	0x01, 0x0c, 0x64, 0x7b,
-	0x10, 0x0c, 0x80, 0x7a,
-	0x03, 0x9e, 0x80, 0x6a,
-	0x00, 0x65, 0xf8, 0x59,
-	0x00, 0x6a, 0xac, 0x5e,
-	0x01, 0xa4, 0x8a, 0x6b,
-	0xff, 0x38, 0x80, 0x7b,
-	0x01, 0x38, 0xc8, 0x30,
-	0x00, 0x08, 0x40, 0x19,
-	0xff, 0x6a, 0xc8, 0x08,
-	0x00, 0x09, 0x42, 0x21,
-	0x00, 0x0a, 0x44, 0x21,
-	0xff, 0x6a, 0x70, 0x08,
-	0x00, 0x65, 0x82, 0x43,
-	0x03, 0x08, 0x40, 0x31,
-	0x03, 0x08, 0x40, 0x31,
-	0x01, 0x08, 0x40, 0x31,
-	0x01, 0x09, 0x42, 0x31,
-	0x01, 0x0a, 0x44, 0x31,
-	0xfd, 0xb4, 0x68, 0x09,
-	0x12, 0x01, 0x02, 0x00,
-	0x12, 0x01, 0x02, 0x00,
-	0x04, 0x3c, 0xc0, 0x79,
-	0xfb, 0x3c, 0x78, 0x08,
-	0x04, 0x93, 0x1e, 0x79,
-	0x01, 0x0c, 0x96, 0x6b,
-	0x01, 0x55, 0x1e, 0x79,
-	0x80, 0x04, 0x1e, 0x79,
-	0xe4, 0x6a, 0x60, 0x5d,
-	0x23, 0x6a, 0x76, 0x5d,
-	0x01, 0x6a, 0x76, 0x5d,
-	0x00, 0x65, 0x1e, 0x41,
-	0x00, 0x65, 0xc0, 0x41,
-	0x80, 0x3c, 0xaa, 0x6b,
-	0x21, 0x6a, 0xca, 0x46,
-	0x01, 0xbc, 0x18, 0x31,
-	0x02, 0x6a, 0x1a, 0x31,
-	0x02, 0x6a, 0xf8, 0x01,
-	0x01, 0xbc, 0x10, 0x30,
-	0x02, 0x6a, 0x12, 0x30,
-	0x01, 0xbc, 0x10, 0x30,
-	0xff, 0x6a, 0x12, 0x08,
-	0xff, 0x6a, 0x14, 0x08,
-	0xf3, 0xbc, 0xd4, 0x18,
-	0xa0, 0x6a, 0xd0, 0x53,
-	0x04, 0xa0, 0x10, 0x31,
-	0xac, 0x6a, 0x26, 0x01,
-	0x04, 0xa0, 0x10, 0x31,
-	0x03, 0x08, 0x18, 0x31,
-	0x88, 0x6a, 0xcc, 0x00,
-	0xa0, 0x6a, 0xe6, 0x5d,
-	0x00, 0xbc, 0xd2, 0x5d,
-	0x3d, 0x6a, 0x26, 0x01,
-	0x00, 0x65, 0xe8, 0x43,
-	0xff, 0x6a, 0x10, 0x09,
-	0xa4, 0x6a, 0x26, 0x01,
-	0x0c, 0xa0, 0x32, 0x31,
-	0x05, 0x6a, 0x26, 0x01,
-	0x35, 0x6a, 0x26, 0x01,
-	0x0c, 0xa0, 0x32, 0x31,
-	0x36, 0x6a, 0x26, 0x01,
-	0x02, 0x93, 0x26, 0x01,
-	0x35, 0x6a, 0x26, 0x01,
-	0x00, 0x65, 0x8e, 0x5e,
-	0x00, 0x65, 0x8e, 0x5e,
-	0x02, 0x93, 0x26, 0x01,
-	0x04, 0x0b, 0xec, 0x6b,
-	0x10, 0x0c, 0xe8, 0x7b,
-	0x01, 0x03, 0xec, 0x6b,
-	0x20, 0x93, 0xe8, 0x6b,
-	0xc7, 0x93, 0x26, 0x09,
-	0x38, 0x93, 0xf2, 0x6b,
-	0x10, 0x01, 0x02, 0x00,
-	0x00, 0x65, 0xc0, 0x41,
-	0x80, 0x3c, 0xfc, 0x6b,
-	0x21, 0x6a, 0xca, 0x46,
-	0x01, 0x06, 0x50, 0x31,
-	0x00, 0x65, 0xc0, 0x41,
-	0x10, 0x3f, 0x06, 0x00,
-	0x10, 0x6a, 0x06, 0x00,
-	0x01, 0x3a, 0xca, 0x30,
-	0x80, 0x65, 0x20, 0x64,
-	0x10, 0xb8, 0x44, 0x6c,
-	0xc0, 0xba, 0xca, 0x00,
-	0x40, 0xb8, 0x10, 0x6c,
-	0xbf, 0x65, 0xca, 0x08,
-	0x20, 0xb8, 0x24, 0x7c,
-	0x01, 0x65, 0x0c, 0x30,
-	0x00, 0x65, 0xca, 0x5d,
-	0xa0, 0x3f, 0x2c, 0x64,
-	0x23, 0xb8, 0x0c, 0x08,
-	0x00, 0x65, 0xca, 0x5d,
-	0xa0, 0x3f, 0x2c, 0x64,
-	0x00, 0xbb, 0x24, 0x44,
-	0xff, 0x65, 0x24, 0x64,
-	0x00, 0x65, 0x44, 0x44,
-	0x40, 0x6a, 0x18, 0x00,
-	0x01, 0x65, 0x0c, 0x30,
-	0x00, 0x65, 0xca, 0x5d,
-	0xa0, 0x3f, 0x00, 0x74,
-	0x40, 0x6a, 0x18, 0x00,
-	0x01, 0x3a, 0xa6, 0x30,
-	0x08, 0x6a, 0x74, 0x00,
-	0x00, 0x65, 0xc0, 0x41,
-	0x64, 0x6a, 0x5a, 0x5d,
-	0x80, 0x64, 0xca, 0x6c,
-	0x04, 0x64, 0x90, 0x74,
-	0x02, 0x64, 0x9e, 0x74,
-	0x00, 0x6a, 0x60, 0x74,
-	0x03, 0x64, 0xbc, 0x74,
-	0x23, 0x64, 0x4c, 0x74,
-	0x08, 0x64, 0x5c, 0x74,
-	0x61, 0x6a, 0xca, 0x5e,
-	0x00, 0x65, 0xca, 0x5d,
-	0x08, 0x51, 0xc2, 0x71,
-	0x00, 0x65, 0x44, 0x44,
-	0x80, 0x04, 0x5a, 0x7c,
-	0x51, 0x6a, 0x50, 0x5d,
-	0x01, 0x51, 0x5a, 0x64,
-	0x01, 0xa4, 0x56, 0x7c,
-	0x01, 0x55, 0x5c, 0x7c,
-	0x41, 0x6a, 0xca, 0x5e,
-	0x00, 0x65, 0x5c, 0x44,
-	0x07, 0x6a, 0x46, 0x5d,
-	0x01, 0x06, 0xd4, 0x30,
-	0x00, 0x65, 0xc0, 0x41,
-	0x10, 0xb8, 0x64, 0x7c,
-	0xa1, 0x6a, 0xca, 0x5e,
-	0x01, 0xb4, 0x6a, 0x6c,
-	0x02, 0xb4, 0x6c, 0x6c,
-	0x01, 0xa4, 0x6c, 0x7c,
-	0xff, 0xa8, 0x7c, 0x7c,
-	0x04, 0xb4, 0x68, 0x01,
-	0x01, 0x6a, 0x76, 0x00,
-	0x00, 0xbb, 0x04, 0x5e,
-	0xff, 0xa8, 0x7c, 0x7c,
-	0x71, 0x6a, 0xca, 0x5e,
-	0x40, 0x51, 0x7c, 0x64,
-	0x00, 0x65, 0xa4, 0x5e,
-	0x00, 0x65, 0xd2, 0x41,
-	0x00, 0xbb, 0x80, 0x5c,
-	0x00, 0x65, 0xd2, 0x41,
-	0x00, 0x65, 0xa4, 0x5e,
-	0x01, 0x65, 0xa2, 0x30,
-	0x01, 0xf8, 0xc8, 0x30,
-	0x01, 0x4e, 0xc8, 0x30,
-	0x00, 0x6a, 0xa8, 0xdd,
-	0x00, 0x51, 0xba, 0x5d,
-	0x01, 0x4e, 0x9c, 0x18,
-	0x02, 0x6a, 0x22, 0x05,
-	0x04, 0xb8, 0x70, 0x01,
-	0x00, 0x65, 0xc6, 0x5e,
-	0x20, 0xb8, 0xd2, 0x69,
-	0x01, 0xbb, 0xa2, 0x30,
-	0x01, 0xba, 0x7c, 0x30,
-	0x00, 0xb9, 0xc0, 0x5c,
-	0x00, 0x65, 0xd2, 0x41,
-	0x01, 0x06, 0xd4, 0x30,
-	0x20, 0x3c, 0xc0, 0x79,
-	0x20, 0x3c, 0x5c, 0x7c,
-	0x01, 0xa4, 0xac, 0x7c,
-	0x01, 0xb4, 0x68, 0x01,
-	0x00, 0x65, 0xc0, 0x41,
-	0x00, 0x65, 0x5c, 0x44,
-	0x04, 0x14, 0x58, 0x31,
-	0x01, 0x06, 0xd4, 0x30,
-	0x08, 0xa0, 0x60, 0x31,
-	0xac, 0x6a, 0xcc, 0x00,
-	0x14, 0x6a, 0xe6, 0x5d,
-	0x01, 0x06, 0xd4, 0x30,
-	0xa0, 0x6a, 0xde, 0x5d,
-	0x00, 0x65, 0xc0, 0x41,
-	0xdf, 0x3c, 0x78, 0x08,
-	0x00, 0x65, 0x5c, 0x44,
-	0x4c, 0x65, 0xcc, 0x28,
-	0x01, 0x3e, 0x20, 0x31,
-	0xd0, 0x66, 0xcc, 0x18,
-	0x20, 0x66, 0xcc, 0x18,
-	0x01, 0x51, 0xda, 0x34,
-	0x4c, 0x3d, 0xca, 0x28,
-	0x3f, 0x64, 0x7c, 0x08,
-	0xd0, 0x65, 0xca, 0x18,
-	0x01, 0x3e, 0x20, 0x31,
-	0x30, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xd8, 0x4c,
-	0xe1, 0x6a, 0x22, 0x01,
-	0xff, 0x6a, 0xd4, 0x08,
-	0x20, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xe0, 0x54,
-	0xe1, 0x6a, 0x22, 0x01,
-	0xff, 0x6a, 0xd4, 0x08,
-	0x20, 0x65, 0xca, 0x18,
-	0xe0, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xea, 0x4c,
-	0xe1, 0x6a, 0x22, 0x01,
-	0xff, 0x6a, 0xd4, 0x08,
-	0xd0, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xf2, 0x54,
-	0xe1, 0x6a, 0x22, 0x01,
-	0xff, 0x6a, 0xd4, 0x08,
-	0x01, 0x6c, 0xa2, 0x30,
-	0xff, 0x51, 0x04, 0x75,
-	0x00, 0x51, 0x80, 0x5d,
-	0x01, 0x51, 0x20, 0x31,
-	0x00, 0x65, 0x26, 0x45,
-	0x01, 0xba, 0xc8, 0x30,
-	0x00, 0x3e, 0x26, 0x75,
-	0x00, 0x65, 0xa2, 0x5e,
-	0x80, 0x3c, 0x78, 0x00,
-	0x01, 0x06, 0xd4, 0x30,
-	0x00, 0x65, 0xca, 0x5d,
-	0x01, 0x3c, 0x78, 0x00,
-	0xe0, 0x3f, 0x42, 0x65,
-	0x02, 0x3c, 0x78, 0x00,
-	0x20, 0x12, 0x42, 0x65,
-	0x51, 0x6a, 0x50, 0x5d,
-	0x00, 0x51, 0x80, 0x5d,
-	0x51, 0x6a, 0x50, 0x5d,
-	0x01, 0x51, 0x20, 0x31,
-	0x04, 0x3c, 0x78, 0x00,
-	0x01, 0xb9, 0xc8, 0x30,
-	0x00, 0x3d, 0x40, 0x65,
-	0x08, 0x3c, 0x78, 0x00,
-	0x01, 0xba, 0xc8, 0x30,
-	0x00, 0x3e, 0x40, 0x65,
-	0x10, 0x3c, 0x78, 0x00,
-	0x04, 0xb8, 0x40, 0x7d,
-	0xfb, 0xb8, 0x70, 0x09,
-	0x20, 0xb8, 0x36, 0x6d,
-	0x01, 0x90, 0xc8, 0x30,
-	0xff, 0x6a, 0xa2, 0x00,
-	0x00, 0x3d, 0xc0, 0x5c,
-	0x01, 0x64, 0x20, 0x31,
-	0x80, 0x6a, 0x78, 0x00,
-	0x00, 0x65, 0xec, 0x58,
-	0x10, 0xb8, 0x5c, 0x7c,
-	0xff, 0x6a, 0x46, 0x5d,
-	0x00, 0x65, 0x5c, 0x44,
-	0x00, 0x65, 0xa2, 0x5e,
-	0x31, 0x6a, 0xca, 0x5e,
-	0x00, 0x65, 0x5c, 0x44,
-	0x10, 0x3f, 0x06, 0x00,
-	0x10, 0x6a, 0x06, 0x00,
-	0x01, 0x65, 0x74, 0x34,
-	0x81, 0x6a, 0xca, 0x5e,
-	0x00, 0x65, 0x52, 0x45,
-	0x01, 0x06, 0xd4, 0x30,
-	0x01, 0x0c, 0x52, 0x7d,
-	0x04, 0x0c, 0x4c, 0x6d,
-	0xe0, 0x03, 0x7e, 0x08,
-	0xe0, 0x3f, 0xc0, 0x61,
-	0x01, 0x65, 0xcc, 0x30,
-	0x01, 0x12, 0xda, 0x34,
-	0x01, 0x06, 0xd4, 0x34,
-	0x01, 0x03, 0x60, 0x6d,
-	0x40, 0x03, 0xcc, 0x08,
-	0x01, 0x65, 0x06, 0x30,
-	0x40, 0x65, 0xc8, 0x08,
-	0x00, 0x66, 0x6e, 0x75,
-	0x40, 0x65, 0x6e, 0x7d,
-	0x00, 0x65, 0x6e, 0x5d,
-	0xff, 0x6a, 0xd4, 0x08,
-	0xff, 0x6a, 0xd4, 0x08,
-	0xff, 0x6a, 0xd4, 0x08,
-	0xff, 0x6a, 0xd4, 0x0c,
-	0x08, 0x01, 0x02, 0x00,
-	0x02, 0x0b, 0x78, 0x7d,
-	0x01, 0x65, 0x0c, 0x30,
-	0x02, 0x0b, 0x7c, 0x7d,
-	0xf7, 0x01, 0x02, 0x0c,
-	0x01, 0x65, 0xc8, 0x30,
-	0xff, 0x41, 0xa0, 0x75,
-	0x01, 0x41, 0x20, 0x31,
-	0xff, 0x6a, 0xa4, 0x00,
-	0x00, 0x65, 0x90, 0x45,
-	0xff, 0xbf, 0xa0, 0x75,
-	0x01, 0x90, 0xa4, 0x30,
-	0x01, 0xbf, 0x20, 0x31,
-	0x00, 0xbb, 0x8a, 0x65,
-	0xff, 0x52, 0x9e, 0x75,
-	0x01, 0xbf, 0xcc, 0x30,
-	0x01, 0x90, 0xca, 0x30,
-	0x01, 0x52, 0x20, 0x31,
-	0x01, 0x66, 0x7e, 0x31,
-	0x01, 0x65, 0x20, 0x35,
-	0x01, 0xbf, 0x82, 0x34,
-	0x01, 0x64, 0xa2, 0x30,
-	0x00, 0x6a, 0xb2, 0x5e,
-	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0x51, 0x04, 0x46,
-	0x01, 0x65, 0xa4, 0x30,
-	0xe0, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xf8, 0x5d,
-	0x01, 0x6a, 0xd0, 0x01,
-	0x01, 0x6a, 0xdc, 0x05,
-	0x88, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xf8, 0x5d,
-	0x01, 0x6a, 0xd2, 0x5d,
-	0x01, 0x6a, 0x26, 0x05,
-	0x01, 0x65, 0xd8, 0x31,
-	0x09, 0xee, 0xdc, 0x01,
-	0x80, 0xee, 0xbe, 0x7d,
-	0xff, 0x6a, 0xdc, 0x0d,
-	0x01, 0x65, 0x32, 0x31,
-	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0x9a, 0x46,
-	0x81, 0x6a, 0xca, 0x5e,
-	0x01, 0x0c, 0xca, 0x7d,
-	0x04, 0x0c, 0xc8, 0x6d,
-	0xe0, 0x03, 0x06, 0x08,
-	0xe0, 0x03, 0x7e, 0x0c,
-	0x01, 0x65, 0x18, 0x31,
-	0xff, 0x6a, 0x1a, 0x09,
-	0xff, 0x6a, 0x1c, 0x0d,
-	0x01, 0x8c, 0x10, 0x30,
-	0x01, 0x8d, 0x12, 0x30,
-	0x01, 0x8e, 0x14, 0x34,
-	0x01, 0x6c, 0xda, 0x30,
-	0x01, 0x6c, 0xda, 0x30,
-	0x01, 0x6c, 0xda, 0x30,
-	0x01, 0x6c, 0xda, 0x30,
-	0x01, 0x6c, 0xda, 0x30,
-	0x01, 0x6c, 0xda, 0x30,
-	0x01, 0x6c, 0xda, 0x30,
-	0x01, 0x6c, 0xda, 0x34,
-	0x3d, 0x64, 0xa4, 0x28,
-	0x55, 0x64, 0xc8, 0x28,
-	0x00, 0x65, 0xf8, 0x45,
-	0x2e, 0x64, 0xa4, 0x28,
-	0x66, 0x64, 0xc8, 0x28,
-	0x00, 0x6c, 0xda, 0x18,
-	0x01, 0x52, 0xc8, 0x30,
-	0x00, 0x6c, 0xda, 0x20,
-	0xff, 0x6a, 0xc8, 0x08,
-	0x00, 0x6c, 0xda, 0x20,
-	0x00, 0x6c, 0xda, 0x24,
-	0x01, 0x65, 0xc8, 0x30,
-	0xe0, 0x6a, 0xcc, 0x00,
-	0x44, 0x6a, 0xf4, 0x5d,
-	0x01, 0x90, 0xe2, 0x31,
-	0x04, 0x3b, 0x18, 0x7e,
-	0x30, 0x6a, 0xd0, 0x01,
-	0x20, 0x6a, 0xd0, 0x01,
-	0x1d, 0x6a, 0xdc, 0x01,
-	0xdc, 0xee, 0x14, 0x66,
-	0x00, 0x65, 0x30, 0x46,
-	0x20, 0x6a, 0xd0, 0x01,
-	0x01, 0x6a, 0xdc, 0x01,
-	0x20, 0xa0, 0xd8, 0x31,
-	0x09, 0xee, 0xdc, 0x01,
-	0x80, 0xee, 0x20, 0x7e,
-	0x11, 0x6a, 0xdc, 0x01,
-	0x50, 0xee, 0x24, 0x66,
-	0x20, 0x6a, 0xd0, 0x01,
-	0x09, 0x6a, 0xdc, 0x01,
-	0x88, 0xee, 0x2a, 0x66,
-	0x19, 0x6a, 0xdc, 0x01,
-	0xd8, 0xee, 0x2e, 0x66,
-	0xff, 0x6a, 0xdc, 0x09,
-	0x18, 0xee, 0x32, 0x6e,
-	0xff, 0x6a, 0xd4, 0x0c,
-	0x88, 0x6a, 0xcc, 0x00,
-	0x44, 0x6a, 0xf4, 0x5d,
-	0x20, 0x6a, 0xd2, 0x5d,
-	0x01, 0x3b, 0x26, 0x31,
-	0x04, 0x3b, 0x4c, 0x6e,
-	0xa0, 0x6a, 0xca, 0x00,
-	0x20, 0x65, 0xc8, 0x18,
-	0x00, 0x65, 0x8a, 0x5e,
-	0x00, 0x65, 0x44, 0x66,
-	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0x9a, 0x46,
-	0xa0, 0x6a, 0xcc, 0x00,
-	0xff, 0x6a, 0xc8, 0x08,
-	0x20, 0x94, 0x50, 0x6e,
-	0x10, 0x94, 0x52, 0x6e,
-	0x08, 0x94, 0x6c, 0x6e,
-	0x08, 0x94, 0x6c, 0x6e,
-	0x08, 0x94, 0x6c, 0x6e,
-	0xff, 0x8c, 0xc8, 0x10,
-	0xc1, 0x64, 0xc8, 0x18,
-	0xf8, 0x64, 0xc8, 0x08,
-	0x01, 0x99, 0xda, 0x30,
-	0x00, 0x66, 0x60, 0x66,
-	0xc0, 0x66, 0x9c, 0x76,
-	0x60, 0x66, 0xc8, 0x18,
-	0x3d, 0x64, 0xc8, 0x28,
-	0x00, 0x65, 0x50, 0x46,
-	0xf7, 0x93, 0x26, 0x09,
-	0x08, 0x93, 0x6e, 0x6e,
-	0x00, 0x62, 0xc4, 0x18,
-	0x00, 0x65, 0x9a, 0x5e,
-	0x00, 0x65, 0x7a, 0x5e,
-	0x00, 0x65, 0x7a, 0x5e,
-	0x00, 0x65, 0x7a, 0x5e,
-	0x01, 0x99, 0xda, 0x30,
-	0x01, 0x99, 0xda, 0x30,
-	0x01, 0x99, 0xda, 0x30,
-	0x01, 0x99, 0xda, 0x30,
-	0x01, 0x99, 0xda, 0x30,
-	0x01, 0x99, 0xda, 0x30,
-	0x01, 0x99, 0xda, 0x30,
-	0x01, 0x99, 0xda, 0x34,
-	0x01, 0x6c, 0x32, 0x31,
-	0x01, 0x6c, 0x32, 0x31,
-	0x01, 0x6c, 0x32, 0x31,
-	0x01, 0x6c, 0x32, 0x31,
-	0x01, 0x6c, 0x32, 0x31,
-	0x01, 0x6c, 0x32, 0x31,
-	0x01, 0x6c, 0x32, 0x31,
-	0x01, 0x6c, 0x32, 0x35,
-	0x08, 0x94, 0x9a, 0x7e,
-	0xf7, 0x93, 0x26, 0x09,
-	0x08, 0x93, 0x9e, 0x6e,
-	0xff, 0x6a, 0xd4, 0x0c,
-	0x04, 0xb8, 0xc6, 0x6e,
-	0x01, 0x42, 0x7e, 0x31,
-	0xff, 0x6a, 0x76, 0x01,
-	0x01, 0x90, 0x84, 0x34,
-	0xff, 0x6a, 0x76, 0x05,
-	0x01, 0x85, 0x0a, 0x01,
-	0x7f, 0x65, 0x10, 0x09,
-	0xfe, 0x85, 0x0a, 0x0d,
-	0xff, 0x42, 0xc2, 0x66,
-	0xff, 0x41, 0xba, 0x66,
-	0xd1, 0x6a, 0xca, 0x5e,
-	0xff, 0x6a, 0xca, 0x04,
-	0x01, 0x41, 0x20, 0x31,
-	0x01, 0xbf, 0x82, 0x30,
-	0x01, 0x6a, 0x76, 0x00,
-	0x00, 0xbb, 0x04, 0x46,
-	0x01, 0x42, 0x20, 0x31,
-	0x01, 0xbf, 0x84, 0x34,
-	0x01, 0x41, 0x7e, 0x31,
-	0x01, 0x90, 0x82, 0x34,
-	0x01, 0x65, 0x22, 0x31,
-	0xff, 0x6a, 0xd4, 0x08,
-	0xff, 0x6a, 0xd4, 0x0c
-};
-
-static int ahc_patch23_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch23_func(struct ahc_softc *ahc)
-{
-	return ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0);
-}
-
-static int ahc_patch22_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch22_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_CMD_CHAN) == 0);
-}
-
-static int ahc_patch21_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch21_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_QUEUE_REGS) == 0);
-}
-
-static int ahc_patch20_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch20_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_WIDE) != 0);
-}
-
-static int ahc_patch19_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch19_func(struct ahc_softc *ahc)
-{
-	return ((ahc->flags & AHC_SCB_BTT) != 0);
-}
-
-static int ahc_patch18_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch18_func(struct ahc_softc *ahc)
-{
-	return ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0);
-}
-
-static int ahc_patch17_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch17_func(struct ahc_softc *ahc)
-{
-	return ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0);
-}
-
-static int ahc_patch16_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch16_func(struct ahc_softc *ahc)
-{
-	return ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0);
-}
-
-static int ahc_patch15_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch15_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_ULTRA2) == 0);
-}
-
-static int ahc_patch14_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch14_func(struct ahc_softc *ahc)
-{
-	return ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0);
-}
-
-static int ahc_patch13_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch13_func(struct ahc_softc *ahc)
-{
-	return ((ahc->flags & AHC_39BIT_ADDRESSING) != 0);
-}
-
-static int ahc_patch12_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch12_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_HS_MAILBOX) != 0);
-}
-
-static int ahc_patch11_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch11_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_ULTRA) != 0);
-}
-
-static int ahc_patch10_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch10_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_MULTI_TID) != 0);
-}
-
-static int ahc_patch9_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch9_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_CMD_CHAN) != 0);
-}
-
-static int ahc_patch8_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch8_func(struct ahc_softc *ahc)
-{
-	return ((ahc->flags & AHC_INITIATORROLE) != 0);
-}
-
-static int ahc_patch7_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch7_func(struct ahc_softc *ahc)
-{
-	return ((ahc->flags & AHC_TARGETROLE) != 0);
-}
-
-static int ahc_patch6_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch6_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_DT) == 0);
-}
-
-static int ahc_patch5_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch5_func(struct ahc_softc *ahc)
-{
-	return ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0);
-}
-
-static int ahc_patch4_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch4_func(struct ahc_softc *ahc)
-{
-	return ((ahc->flags & AHC_PAGESCBS) != 0);
-}
-
-static int ahc_patch3_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch3_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_QUEUE_REGS) != 0);
-}
-
-static int ahc_patch2_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch2_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_TWIN) != 0);
-}
-
-static int ahc_patch1_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch1_func(struct ahc_softc *ahc)
-{
-	return ((ahc->features & AHC_ULTRA2) != 0);
-}
-
-static int ahc_patch0_func(struct ahc_softc *ahc);
-
-static int
-ahc_patch0_func(struct ahc_softc *ahc)
-{
-	return (0);
-}
-
-typedef int patch_func_t (struct ahc_softc *);
-struct patch {
-	patch_func_t	*patch_func;
-	uint32_t	begin	   :10,
-			skip_instr :10,
-			skip_patch :12;
-} patches[] = {
-	{ ahc_patch1_func, 4, 1, 1 },
-	{ ahc_patch2_func, 6, 2, 1 },
-	{ ahc_patch2_func, 9, 1, 1 },
-	{ ahc_patch3_func, 11, 1, 2 },
-	{ ahc_patch0_func, 12, 2, 1 },
-	{ ahc_patch4_func, 15, 1, 2 },
-	{ ahc_patch0_func, 16, 1, 1 },
-	{ ahc_patch5_func, 22, 2, 1 },
-	{ ahc_patch3_func, 27, 1, 2 },
-	{ ahc_patch0_func, 28, 1, 1 },
-	{ ahc_patch6_func, 34, 1, 1 },
-	{ ahc_patch7_func, 37, 54, 19 },
-	{ ahc_patch8_func, 37, 1, 1 },
-	{ ahc_patch9_func, 42, 3, 2 },
-	{ ahc_patch0_func, 45, 3, 1 },
-	{ ahc_patch10_func, 49, 1, 2 },
-	{ ahc_patch0_func, 50, 2, 3 },
-	{ ahc_patch1_func, 50, 1, 2 },
-	{ ahc_patch0_func, 51, 1, 1 },
-	{ ahc_patch2_func, 53, 2, 1 },
-	{ ahc_patch9_func, 55, 1, 2 },
-	{ ahc_patch0_func, 56, 1, 1 },
-	{ ahc_patch9_func, 60, 1, 2 },
-	{ ahc_patch0_func, 61, 1, 1 },
-	{ ahc_patch9_func, 71, 1, 2 },
-	{ ahc_patch0_func, 72, 1, 1 },
-	{ ahc_patch9_func, 75, 1, 2 },
-	{ ahc_patch0_func, 76, 1, 1 },
-	{ ahc_patch9_func, 79, 1, 2 },
-	{ ahc_patch0_func, 80, 1, 1 },
-	{ ahc_patch8_func, 91, 9, 4 },
-	{ ahc_patch1_func, 93, 1, 2 },
-	{ ahc_patch0_func, 94, 1, 1 },
-	{ ahc_patch2_func, 96, 2, 1 },
-	{ ahc_patch2_func, 105, 4, 1 },
-	{ ahc_patch1_func, 109, 1, 2 },
-	{ ahc_patch0_func, 110, 2, 3 },
-	{ ahc_patch2_func, 110, 1, 2 },
-	{ ahc_patch0_func, 111, 1, 1 },
-	{ ahc_patch7_func, 112, 4, 2 },
-	{ ahc_patch0_func, 116, 1, 1 },
-	{ ahc_patch11_func, 118, 2, 1 },
-	{ ahc_patch1_func, 120, 1, 2 },
-	{ ahc_patch0_func, 121, 1, 1 },
-	{ ahc_patch7_func, 122, 4, 1 },
-	{ ahc_patch7_func, 133, 89, 11 },
-	{ ahc_patch4_func, 151, 1, 1 },
-	{ ahc_patch1_func, 164, 1, 1 },
-	{ ahc_patch12_func, 169, 1, 2 },
-	{ ahc_patch0_func, 170, 1, 1 },
-	{ ahc_patch9_func, 181, 1, 2 },
-	{ ahc_patch0_func, 182, 1, 1 },
-	{ ahc_patch9_func, 191, 1, 2 },
-	{ ahc_patch0_func, 192, 1, 1 },
-	{ ahc_patch9_func, 208, 6, 2 },
-	{ ahc_patch0_func, 214, 6, 1 },
-	{ ahc_patch8_func, 222, 18, 2 },
-	{ ahc_patch1_func, 235, 1, 1 },
-	{ ahc_patch1_func, 242, 1, 2 },
-	{ ahc_patch0_func, 243, 2, 2 },
-	{ ahc_patch11_func, 244, 1, 1 },
-	{ ahc_patch9_func, 252, 31, 3 },
-	{ ahc_patch1_func, 268, 14, 2 },
-	{ ahc_patch13_func, 273, 1, 1 },
-	{ ahc_patch14_func, 283, 14, 1 },
-	{ ahc_patch1_func, 299, 1, 2 },
-	{ ahc_patch0_func, 300, 1, 1 },
-	{ ahc_patch9_func, 303, 1, 1 },
-	{ ahc_patch13_func, 308, 1, 1 },
-	{ ahc_patch9_func, 309, 2, 2 },
-	{ ahc_patch0_func, 311, 4, 1 },
-	{ ahc_patch14_func, 315, 1, 1 },
-	{ ahc_patch15_func, 318, 2, 3 },
-	{ ahc_patch9_func, 318, 1, 2 },
-	{ ahc_patch0_func, 319, 1, 1 },
-	{ ahc_patch6_func, 324, 1, 2 },
-	{ ahc_patch0_func, 325, 1, 1 },
-	{ ahc_patch1_func, 329, 50, 11 },
-	{ ahc_patch6_func, 338, 2, 4 },
-	{ ahc_patch7_func, 338, 1, 1 },
-	{ ahc_patch8_func, 339, 1, 1 },
-	{ ahc_patch0_func, 340, 1, 1 },
-	{ ahc_patch16_func, 341, 1, 1 },
-	{ ahc_patch6_func, 360, 6, 3 },
-	{ ahc_patch16_func, 360, 5, 1 },
-	{ ahc_patch0_func, 366, 5, 1 },
-	{ ahc_patch13_func, 374, 5, 1 },
-	{ ahc_patch0_func, 379, 54, 17 },
-	{ ahc_patch14_func, 379, 1, 1 },
-	{ ahc_patch7_func, 381, 2, 2 },
-	{ ahc_patch17_func, 382, 1, 1 },
-	{ ahc_patch9_func, 385, 1, 1 },
-	{ ahc_patch18_func, 392, 1, 1 },
-	{ ahc_patch14_func, 397, 9, 3 },
-	{ ahc_patch9_func, 398, 3, 2 },
-	{ ahc_patch0_func, 401, 3, 1 },
-	{ ahc_patch9_func, 409, 6, 2 },
-	{ ahc_patch0_func, 415, 9, 2 },
-	{ ahc_patch13_func, 415, 1, 1 },
-	{ ahc_patch13_func, 424, 2, 1 },
-	{ ahc_patch14_func, 426, 1, 1 },
-	{ ahc_patch9_func, 428, 1, 2 },
-	{ ahc_patch0_func, 429, 1, 1 },
-	{ ahc_patch7_func, 432, 1, 1 },
-	{ ahc_patch7_func, 433, 1, 1 },
-	{ ahc_patch8_func, 434, 3, 3 },
-	{ ahc_patch6_func, 435, 1, 2 },
-	{ ahc_patch0_func, 436, 1, 1 },
-	{ ahc_patch9_func, 437, 1, 1 },
-	{ ahc_patch15_func, 438, 1, 2 },
-	{ ahc_patch13_func, 438, 1, 1 },
-	{ ahc_patch14_func, 440, 9, 4 },
-	{ ahc_patch9_func, 440, 1, 1 },
-	{ ahc_patch9_func, 447, 2, 1 },
-	{ ahc_patch0_func, 449, 4, 3 },
-	{ ahc_patch9_func, 449, 1, 2 },
-	{ ahc_patch0_func, 450, 3, 1 },
-	{ ahc_patch1_func, 454, 2, 1 },
-	{ ahc_patch7_func, 456, 10, 2 },
-	{ ahc_patch0_func, 466, 1, 1 },
-	{ ahc_patch8_func, 467, 109, 23 },
-	{ ahc_patch1_func, 469, 3, 2 },
-	{ ahc_patch0_func, 472, 5, 3 },
-	{ ahc_patch9_func, 472, 2, 2 },
-	{ ahc_patch0_func, 474, 3, 1 },
-	{ ahc_patch1_func, 479, 2, 2 },
-	{ ahc_patch0_func, 481, 6, 3 },
-	{ ahc_patch9_func, 481, 2, 2 },
-	{ ahc_patch0_func, 483, 3, 1 },
-	{ ahc_patch1_func, 489, 2, 2 },
-	{ ahc_patch0_func, 491, 9, 7 },
-	{ ahc_patch9_func, 491, 5, 6 },
-	{ ahc_patch19_func, 491, 1, 2 },
-	{ ahc_patch0_func, 492, 1, 1 },
-	{ ahc_patch19_func, 494, 1, 2 },
-	{ ahc_patch0_func, 495, 1, 1 },
-	{ ahc_patch0_func, 496, 4, 1 },
-	{ ahc_patch6_func, 500, 3, 2 },
-	{ ahc_patch0_func, 503, 1, 1 },
-	{ ahc_patch1_func, 506, 1, 1 },
-	{ ahc_patch6_func, 512, 1, 2 },
-	{ ahc_patch0_func, 513, 1, 1 },
-	{ ahc_patch20_func, 550, 7, 1 },
-	{ ahc_patch3_func, 578, 1, 2 },
-	{ ahc_patch0_func, 579, 1, 1 },
-	{ ahc_patch21_func, 582, 1, 1 },
-	{ ahc_patch8_func, 584, 104, 33 },
-	{ ahc_patch4_func, 585, 1, 1 },
-	{ ahc_patch1_func, 591, 2, 2 },
-	{ ahc_patch0_func, 593, 1, 1 },
-	{ ahc_patch1_func, 596, 1, 2 },
-	{ ahc_patch0_func, 597, 1, 1 },
-	{ ahc_patch9_func, 598, 3, 3 },
-	{ ahc_patch15_func, 599, 1, 1 },
-	{ ahc_patch0_func, 601, 4, 1 },
-	{ ahc_patch19_func, 609, 2, 2 },
-	{ ahc_patch0_func, 611, 1, 1 },
-	{ ahc_patch19_func, 615, 10, 3 },
-	{ ahc_patch5_func, 617, 8, 1 },
-	{ ahc_patch0_func, 625, 9, 2 },
-	{ ahc_patch5_func, 626, 8, 1 },
-	{ ahc_patch4_func, 636, 1, 2 },
-	{ ahc_patch0_func, 637, 1, 1 },
-	{ ahc_patch19_func, 638, 1, 2 },
-	{ ahc_patch0_func, 639, 3, 2 },
-	{ ahc_patch4_func, 641, 1, 1 },
-	{ ahc_patch5_func, 642, 1, 1 },
-	{ ahc_patch5_func, 645, 1, 1 },
-	{ ahc_patch5_func, 647, 1, 1 },
-	{ ahc_patch4_func, 649, 2, 2 },
-	{ ahc_patch0_func, 651, 2, 1 },
-	{ ahc_patch5_func, 653, 1, 1 },
-	{ ahc_patch5_func, 656, 1, 1 },
-	{ ahc_patch5_func, 659, 1, 1 },
-	{ ahc_patch19_func, 663, 1, 1 },
-	{ ahc_patch19_func, 666, 1, 1 },
-	{ ahc_patch4_func, 672, 1, 1 },
-	{ ahc_patch6_func, 675, 1, 2 },
-	{ ahc_patch0_func, 676, 1, 1 },
-	{ ahc_patch7_func, 688, 16, 1 },
-	{ ahc_patch4_func, 704, 20, 1 },
-	{ ahc_patch9_func, 725, 4, 2 },
-	{ ahc_patch0_func, 729, 4, 1 },
-	{ ahc_patch9_func, 733, 4, 2 },
-	{ ahc_patch0_func, 737, 3, 1 },
-	{ ahc_patch6_func, 743, 1, 1 },
-	{ ahc_patch22_func, 745, 14, 1 },
-	{ ahc_patch7_func, 759, 3, 1 },
-	{ ahc_patch9_func, 771, 24, 8 },
-	{ ahc_patch19_func, 775, 1, 2 },
-	{ ahc_patch0_func, 776, 1, 1 },
-	{ ahc_patch15_func, 781, 4, 2 },
-	{ ahc_patch0_func, 785, 7, 3 },
-	{ ahc_patch23_func, 785, 5, 2 },
-	{ ahc_patch0_func, 790, 2, 1 },
-	{ ahc_patch0_func, 795, 42, 3 },
-	{ ahc_patch18_func, 807, 18, 2 },
-	{ ahc_patch0_func, 825, 1, 1 },
-	{ ahc_patch4_func, 849, 1, 1 },
-	{ ahc_patch4_func, 850, 3, 2 },
-	{ ahc_patch0_func, 853, 1, 1 },
-	{ ahc_patch13_func, 854, 3, 1 },
-	{ ahc_patch4_func, 857, 12, 1 }
-};
-struct cs {
-	u_int16_t	begin;
-	u_int16_t	end;
-} critical_sections[] = {
-	{ 11, 18 },
-	{ 21, 30 },
-	{ 704, 720 },
-	{ 850, 853 },
-	{ 857, 863 },
-	{ 865, 867 },
-	{ 867, 869 }
-};
-const int num_critical_sections = sizeof(critical_sections)
-				 / sizeof(*critical_sections);
diff -Nru a/drivers/scsi/jazz_esp.c b/drivers/scsi/jazz_esp.c
--- a/drivers/scsi/jazz_esp.c	Thu Jun 20 15:54:00 2002
+++ b/drivers/scsi/jazz_esp.c	Thu Jun 20 15:54:00 2002
@@ -123,7 +123,7 @@
 	            esp->ehost);
 
 	/*
-	 * FIXME, look if the scsi id is availabe from NVRAM
+	 * FIXME, look if the scsi id is available from NVRAM
 	 */
 	esp->scsi_id = 7;
 		
diff -Nru a/drivers/scsi/script_asm.pl b/drivers/scsi/script_asm.pl
--- a/drivers/scsi/script_asm.pl	Thu Jun 20 15:54:01 2002
+++ b/drivers/scsi/script_asm.pl	Thu Jun 20 15:54:01 2002
@@ -53,7 +53,8 @@
 $debug_external = 0;	# Print external/forward reference messages
 $list_in_array = 1;	# Emit original SCRIPTS assembler in comments in
 			# script.h
-$prefix = '';		# define all arrays having this prefix so we 
+#$prefix;		# (set by perl -s)
+                        # define all arrays having this prefix so we 
 			# don't have name space collisions after 
 			# assembling this file in different ways for
 			# different host adapters
@@ -382,12 +383,10 @@
     }
 }
 
-# Parse command line 
-foreach $arg (@argv) {
-    if ($arg =~ /^-prefix\s*=\s*([_a-zA-Z][_a-zA-Z0-9]*)$/i) {
-	$prefix = $1
-    }
-}
+# Parse command line
+$output = shift;
+$outputu = shift;
+
     
 # Main loop
 while (<STDIN>) {
diff -Nru a/drivers/scsi/sim710_d.h b/drivers/scsi/sim710_d.h
--- a/drivers/scsi/sim710_d.h	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,2361 +0,0 @@
-/* DO NOT EDIT - Generated automatically by script_asm.pl */
-static u32 SCRIPT[] = {
-/*
-
-
-
-
-
-
-ABSOLUTE dsa_select  = 0
-ABSOLUTE dsa_msgout  = 8
-ABSOLUTE dsa_cmnd    = 16
-ABSOLUTE dsa_status  = 24
-ABSOLUTE dsa_msgin   = 32
-ABSOLUTE dsa_datain  = 40	
-ABSOLUTE dsa_dataout = 1064	
-ABSOLUTE dsa_size     = 2088
-
-ABSOLUTE reselected_identify = 0
-ABSOLUTE msgin_buf = 0
-
-
-
-ABSOLUTE int_bad_extmsg1a	= 0xab930000
-ABSOLUTE int_bad_extmsg1b	= 0xab930001
-ABSOLUTE int_bad_extmsg2a	= 0xab930002
-ABSOLUTE int_bad_extmsg2b	= 0xab930003
-ABSOLUTE int_bad_extmsg3a	= 0xab930004
-ABSOLUTE int_bad_extmsg3b	= 0xab930005
-ABSOLUTE int_bad_msg1		= 0xab930006
-ABSOLUTE int_bad_msg2		= 0xab930007
-ABSOLUTE int_bad_msg3		= 0xab930008
-ABSOLUTE int_cmd_bad_phase	= 0xab930009
-ABSOLUTE int_cmd_complete	= 0xab93000a
-ABSOLUTE int_data_bad_phase	= 0xab93000b
-ABSOLUTE int_msg_sdtr1		= 0xab93000c
-ABSOLUTE int_msg_sdtr2		= 0xab93000d
-ABSOLUTE int_msg_sdtr3		= 0xab93000e
-ABSOLUTE int_no_msgout1		= 0xab93000f
-ABSOLUTE int_no_msgout2		= 0xab930010
-ABSOLUTE int_no_msgout3		= 0xab930011
-ABSOLUTE int_not_cmd_complete	= 0xab930012
-ABSOLUTE int_sel_no_ident	= 0xab930013
-ABSOLUTE int_sel_not_cmd	= 0xab930014
-ABSOLUTE int_status_not_msgin	= 0xab930015
-ABSOLUTE int_resel_not_msgin	= 0xab930016
-ABSOLUTE int_reselected		= 0xab930017
-ABSOLUTE int_selected		= 0xab930018
-ABSOLUTE int_disc1		= 0xab930019
-ABSOLUTE int_disc2		= 0xab93001a
-ABSOLUTE int_disc3		= 0xab93001b
-ABSOLUTE int_not_rej		= 0xab93001c
-
-
-
-
-ABSOLUTE had_select	= 0x01
-ABSOLUTE had_msgout	= 0x02
-ABSOLUTE had_cmdout	= 0x04
-ABSOLUTE had_datain	= 0x08
-ABSOLUTE had_dataout	= 0x10
-ABSOLUTE had_status	= 0x20
-ABSOLUTE had_msgin	= 0x40
-ABSOLUTE had_extmsg	= 0x80
-
-
-
-
-
-
-ENTRY do_select
-do_select:
-	CLEAR TARGET
-
-at 0x00000000 : */	0x60000200,0x00000000,
-/*
-	MOVE SCRATCH0 & 0 TO SCRATCH0
-
-at 0x00000002 : */	0x7c340000,0x00000000,
-/*
-	; Enable selection timer
-	MOVE CTEST7 & 0xef TO CTEST7
-
-at 0x00000004 : */	0x7c1bef00,0x00000000,
-/*
-	SELECT ATN FROM dsa_select, reselect
-
-at 0x00000006 : */	0x43000000,0x00000c48,
-/*
-	JUMP get_status, WHEN STATUS
-
-at 0x00000008 : */	0x830b0000,0x000000a0,
-/*
-	; Disable selection timer
-	MOVE CTEST7 | 0x10 TO CTEST7
-
-at 0x0000000a : */	0x7a1b1000,0x00000000,
-/*
-	MOVE SCRATCH0 | had_select TO SCRATCH0
-
-at 0x0000000c : */	0x7a340100,0x00000000,
-/*
-	INT int_sel_no_ident, IF NOT MSG_OUT
-
-at 0x0000000e : */	0x9e020000,0xab930013,
-/*
-	MOVE SCRATCH0 | had_msgout TO SCRATCH0
-
-at 0x00000010 : */	0x7a340200,0x00000000,
-/*
-	MOVE FROM dsa_msgout, when MSG_OUT
-
-at 0x00000012 : */	0x1e000000,0x00000008,
-/*
-ENTRY done_ident
-done_ident:
-	JUMP get_status, IF STATUS
-
-at 0x00000014 : */	0x830a0000,0x000000a0,
-/*
-redo_msgin1:
-	JUMP get_msgin1, WHEN MSG_IN
-
-at 0x00000016 : */	0x870b0000,0x00000920,
-/*
-	INT int_sel_not_cmd, IF NOT CMD
-
-at 0x00000018 : */	0x9a020000,0xab930014,
-/*
-ENTRY resume_cmd
-resume_cmd:
-	MOVE SCRATCH0 | had_cmdout TO SCRATCH0
-
-at 0x0000001a : */	0x7a340400,0x00000000,
-/*
-	MOVE FROM dsa_cmnd, WHEN CMD
-
-at 0x0000001c : */	0x1a000000,0x00000010,
-/*
-ENTRY resume_pmm
-resume_pmm:
-redo_msgin2:
-	JUMP get_msgin2, WHEN MSG_IN
-
-at 0x0000001e : */	0x870b0000,0x00000a20,
-/*
-	JUMP get_status, IF STATUS
-
-at 0x00000020 : */	0x830a0000,0x000000a0,
-/*
-	JUMP input_data, IF DATA_IN
-
-at 0x00000022 : */	0x810a0000,0x000000e0,
-/*
-	JUMP output_data, IF DATA_OUT
-
-at 0x00000024 : */	0x800a0000,0x000004f8,
-/*
-	INT int_cmd_bad_phase
-
-at 0x00000026 : */	0x98080000,0xab930009,
-/*
-
-get_status:
-	; Disable selection timer
-	MOVE CTEST7 | 0x10 TO CTEST7
-
-at 0x00000028 : */	0x7a1b1000,0x00000000,
-/*
-	MOVE FROM dsa_status, WHEN STATUS
-
-at 0x0000002a : */	0x1b000000,0x00000018,
-/*
-	INT int_status_not_msgin, WHEN NOT MSG_IN
-
-at 0x0000002c : */	0x9f030000,0xab930015,
-/*
-	MOVE FROM dsa_msgin, WHEN MSG_IN
-
-at 0x0000002e : */	0x1f000000,0x00000020,
-/*
-	INT int_not_cmd_complete, IF NOT 0x00
-
-at 0x00000030 : */	0x98040000,0xab930012,
-/*
-	CLEAR ACK
-
-at 0x00000032 : */	0x60000040,0x00000000,
-/*
-ENTRY wait_disc_complete
-wait_disc_complete:
-	WAIT DISCONNECT
-
-at 0x00000034 : */	0x48000000,0x00000000,
-/*
-	INT int_cmd_complete
-
-at 0x00000036 : */	0x98080000,0xab93000a,
-/*
-
-input_data:
-	MOVE SCRATCH0 | had_datain TO SCRATCH0
-
-at 0x00000038 : */	0x7a340800,0x00000000,
-/*
-ENTRY patch_input_data
-patch_input_data:
-	JUMP 0
-
-at 0x0000003a : */	0x80080000,0x00000000,
-/*
-	MOVE FROM dsa_datain+0x0000, WHEN DATA_IN
-
-at 0x0000003c : */	0x19000000,0x00000028,
-/*
-	MOVE FROM dsa_datain+0x0008, WHEN DATA_IN
-
-at 0x0000003e : */	0x19000000,0x00000030,
-/*
-	MOVE FROM dsa_datain+0x0010, WHEN DATA_IN
-
-at 0x00000040 : */	0x19000000,0x00000038,
-/*
-	MOVE FROM dsa_datain+0x0018, WHEN DATA_IN
-
-at 0x00000042 : */	0x19000000,0x00000040,
-/*
-	MOVE FROM dsa_datain+0x0020, WHEN DATA_IN
-
-at 0x00000044 : */	0x19000000,0x00000048,
-/*
-	MOVE FROM dsa_datain+0x0028, WHEN DATA_IN
-
-at 0x00000046 : */	0x19000000,0x00000050,
-/*
-	MOVE FROM dsa_datain+0x0030, WHEN DATA_IN
-
-at 0x00000048 : */	0x19000000,0x00000058,
-/*
-	MOVE FROM dsa_datain+0x0038, WHEN DATA_IN
-
-at 0x0000004a : */	0x19000000,0x00000060,
-/*
-	MOVE FROM dsa_datain+0x0040, WHEN DATA_IN
-
-at 0x0000004c : */	0x19000000,0x00000068,
-/*
-	MOVE FROM dsa_datain+0x0048, WHEN DATA_IN
-
-at 0x0000004e : */	0x19000000,0x00000070,
-/*
-	MOVE FROM dsa_datain+0x0050, WHEN DATA_IN
-
-at 0x00000050 : */	0x19000000,0x00000078,
-/*
-	MOVE FROM dsa_datain+0x0058, WHEN DATA_IN
-
-at 0x00000052 : */	0x19000000,0x00000080,
-/*
-	MOVE FROM dsa_datain+0x0060, WHEN DATA_IN
-
-at 0x00000054 : */	0x19000000,0x00000088,
-/*
-	MOVE FROM dsa_datain+0x0068, WHEN DATA_IN
-
-at 0x00000056 : */	0x19000000,0x00000090,
-/*
-	MOVE FROM dsa_datain+0x0070, WHEN DATA_IN
-
-at 0x00000058 : */	0x19000000,0x00000098,
-/*
-	MOVE FROM dsa_datain+0x0078, WHEN DATA_IN
-
-at 0x0000005a : */	0x19000000,0x000000a0,
-/*
-	MOVE FROM dsa_datain+0x0080, WHEN DATA_IN
-
-at 0x0000005c : */	0x19000000,0x000000a8,
-/*
-	MOVE FROM dsa_datain+0x0088, WHEN DATA_IN
-
-at 0x0000005e : */	0x19000000,0x000000b0,
-/*
-	MOVE FROM dsa_datain+0x0090, WHEN DATA_IN
-
-at 0x00000060 : */	0x19000000,0x000000b8,
-/*
-	MOVE FROM dsa_datain+0x0098, WHEN DATA_IN
-
-at 0x00000062 : */	0x19000000,0x000000c0,
-/*
-	MOVE FROM dsa_datain+0x00a0, WHEN DATA_IN
-
-at 0x00000064 : */	0x19000000,0x000000c8,
-/*
-	MOVE FROM dsa_datain+0x00a8, WHEN DATA_IN
-
-at 0x00000066 : */	0x19000000,0x000000d0,
-/*
-	MOVE FROM dsa_datain+0x00b0, WHEN DATA_IN
-
-at 0x00000068 : */	0x19000000,0x000000d8,
-/*
-	MOVE FROM dsa_datain+0x00b8, WHEN DATA_IN
-
-at 0x0000006a : */	0x19000000,0x000000e0,
-/*
-	MOVE FROM dsa_datain+0x00c0, WHEN DATA_IN
-
-at 0x0000006c : */	0x19000000,0x000000e8,
-/*
-	MOVE FROM dsa_datain+0x00c8, WHEN DATA_IN
-
-at 0x0000006e : */	0x19000000,0x000000f0,
-/*
-	MOVE FROM dsa_datain+0x00d0, WHEN DATA_IN
-
-at 0x00000070 : */	0x19000000,0x000000f8,
-/*
-	MOVE FROM dsa_datain+0x00d8, WHEN DATA_IN
-
-at 0x00000072 : */	0x19000000,0x00000100,
-/*
-	MOVE FROM dsa_datain+0x00e0, WHEN DATA_IN
-
-at 0x00000074 : */	0x19000000,0x00000108,
-/*
-	MOVE FROM dsa_datain+0x00e8, WHEN DATA_IN
-
-at 0x00000076 : */	0x19000000,0x00000110,
-/*
-	MOVE FROM dsa_datain+0x00f0, WHEN DATA_IN
-
-at 0x00000078 : */	0x19000000,0x00000118,
-/*
-	MOVE FROM dsa_datain+0x00f8, WHEN DATA_IN
-
-at 0x0000007a : */	0x19000000,0x00000120,
-/*
-	MOVE FROM dsa_datain+0x0100, WHEN DATA_IN
-
-at 0x0000007c : */	0x19000000,0x00000128,
-/*
-	MOVE FROM dsa_datain+0x0108, WHEN DATA_IN
-
-at 0x0000007e : */	0x19000000,0x00000130,
-/*
-	MOVE FROM dsa_datain+0x0110, WHEN DATA_IN
-
-at 0x00000080 : */	0x19000000,0x00000138,
-/*
-	MOVE FROM dsa_datain+0x0118, WHEN DATA_IN
-
-at 0x00000082 : */	0x19000000,0x00000140,
-/*
-	MOVE FROM dsa_datain+0x0120, WHEN DATA_IN
-
-at 0x00000084 : */	0x19000000,0x00000148,
-/*
-	MOVE FROM dsa_datain+0x0128, WHEN DATA_IN
-
-at 0x00000086 : */	0x19000000,0x00000150,
-/*
-	MOVE FROM dsa_datain+0x0130, WHEN DATA_IN
-
-at 0x00000088 : */	0x19000000,0x00000158,
-/*
-	MOVE FROM dsa_datain+0x0138, WHEN DATA_IN
-
-at 0x0000008a : */	0x19000000,0x00000160,
-/*
-	MOVE FROM dsa_datain+0x0140, WHEN DATA_IN
-
-at 0x0000008c : */	0x19000000,0x00000168,
-/*
-	MOVE FROM dsa_datain+0x0148, WHEN DATA_IN
-
-at 0x0000008e : */	0x19000000,0x00000170,
-/*
-	MOVE FROM dsa_datain+0x0150, WHEN DATA_IN
-
-at 0x00000090 : */	0x19000000,0x00000178,
-/*
-	MOVE FROM dsa_datain+0x0158, WHEN DATA_IN
-
-at 0x00000092 : */	0x19000000,0x00000180,
-/*
-	MOVE FROM dsa_datain+0x0160, WHEN DATA_IN
-
-at 0x00000094 : */	0x19000000,0x00000188,
-/*
-	MOVE FROM dsa_datain+0x0168, WHEN DATA_IN
-
-at 0x00000096 : */	0x19000000,0x00000190,
-/*
-	MOVE FROM dsa_datain+0x0170, WHEN DATA_IN
-
-at 0x00000098 : */	0x19000000,0x00000198,
-/*
-	MOVE FROM dsa_datain+0x0178, WHEN DATA_IN
-
-at 0x0000009a : */	0x19000000,0x000001a0,
-/*
-	MOVE FROM dsa_datain+0x0180, WHEN DATA_IN
-
-at 0x0000009c : */	0x19000000,0x000001a8,
-/*
-	MOVE FROM dsa_datain+0x0188, WHEN DATA_IN
-
-at 0x0000009e : */	0x19000000,0x000001b0,
-/*
-	MOVE FROM dsa_datain+0x0190, WHEN DATA_IN
-
-at 0x000000a0 : */	0x19000000,0x000001b8,
-/*
-	MOVE FROM dsa_datain+0x0198, WHEN DATA_IN
-
-at 0x000000a2 : */	0x19000000,0x000001c0,
-/*
-	MOVE FROM dsa_datain+0x01a0, WHEN DATA_IN
-
-at 0x000000a4 : */	0x19000000,0x000001c8,
-/*
-	MOVE FROM dsa_datain+0x01a8, WHEN DATA_IN
-
-at 0x000000a6 : */	0x19000000,0x000001d0,
-/*
-	MOVE FROM dsa_datain+0x01b0, WHEN DATA_IN
-
-at 0x000000a8 : */	0x19000000,0x000001d8,
-/*
-	MOVE FROM dsa_datain+0x01b8, WHEN DATA_IN
-
-at 0x000000aa : */	0x19000000,0x000001e0,
-/*
-	MOVE FROM dsa_datain+0x01c0, WHEN DATA_IN
-
-at 0x000000ac : */	0x19000000,0x000001e8,
-/*
-	MOVE FROM dsa_datain+0x01c8, WHEN DATA_IN
-
-at 0x000000ae : */	0x19000000,0x000001f0,
-/*
-	MOVE FROM dsa_datain+0x01d0, WHEN DATA_IN
-
-at 0x000000b0 : */	0x19000000,0x000001f8,
-/*
-	MOVE FROM dsa_datain+0x01d8, WHEN DATA_IN
-
-at 0x000000b2 : */	0x19000000,0x00000200,
-/*
-	MOVE FROM dsa_datain+0x01e0, WHEN DATA_IN
-
-at 0x000000b4 : */	0x19000000,0x00000208,
-/*
-	MOVE FROM dsa_datain+0x01e8, WHEN DATA_IN
-
-at 0x000000b6 : */	0x19000000,0x00000210,
-/*
-	MOVE FROM dsa_datain+0x01f0, WHEN DATA_IN
-
-at 0x000000b8 : */	0x19000000,0x00000218,
-/*
-	MOVE FROM dsa_datain+0x01f8, WHEN DATA_IN
-
-at 0x000000ba : */	0x19000000,0x00000220,
-/*
-	MOVE FROM dsa_datain+0x0200, WHEN DATA_IN
-
-at 0x000000bc : */	0x19000000,0x00000228,
-/*
-	MOVE FROM dsa_datain+0x0208, WHEN DATA_IN
-
-at 0x000000be : */	0x19000000,0x00000230,
-/*
-	MOVE FROM dsa_datain+0x0210, WHEN DATA_IN
-
-at 0x000000c0 : */	0x19000000,0x00000238,
-/*
-	MOVE FROM dsa_datain+0x0218, WHEN DATA_IN
-
-at 0x000000c2 : */	0x19000000,0x00000240,
-/*
-	MOVE FROM dsa_datain+0x0220, WHEN DATA_IN
-
-at 0x000000c4 : */	0x19000000,0x00000248,
-/*
-	MOVE FROM dsa_datain+0x0228, WHEN DATA_IN
-
-at 0x000000c6 : */	0x19000000,0x00000250,
-/*
-	MOVE FROM dsa_datain+0x0230, WHEN DATA_IN
-
-at 0x000000c8 : */	0x19000000,0x00000258,
-/*
-	MOVE FROM dsa_datain+0x0238, WHEN DATA_IN
-
-at 0x000000ca : */	0x19000000,0x00000260,
-/*
-	MOVE FROM dsa_datain+0x0240, WHEN DATA_IN
-
-at 0x000000cc : */	0x19000000,0x00000268,
-/*
-	MOVE FROM dsa_datain+0x0248, WHEN DATA_IN
-
-at 0x000000ce : */	0x19000000,0x00000270,
-/*
-	MOVE FROM dsa_datain+0x0250, WHEN DATA_IN
-
-at 0x000000d0 : */	0x19000000,0x00000278,
-/*
-	MOVE FROM dsa_datain+0x0258, WHEN DATA_IN
-
-at 0x000000d2 : */	0x19000000,0x00000280,
-/*
-	MOVE FROM dsa_datain+0x0260, WHEN DATA_IN
-
-at 0x000000d4 : */	0x19000000,0x00000288,
-/*
-	MOVE FROM dsa_datain+0x0268, WHEN DATA_IN
-
-at 0x000000d6 : */	0x19000000,0x00000290,
-/*
-	MOVE FROM dsa_datain+0x0270, WHEN DATA_IN
-
-at 0x000000d8 : */	0x19000000,0x00000298,
-/*
-	MOVE FROM dsa_datain+0x0278, WHEN DATA_IN
-
-at 0x000000da : */	0x19000000,0x000002a0,
-/*
-	MOVE FROM dsa_datain+0x0280, WHEN DATA_IN
-
-at 0x000000dc : */	0x19000000,0x000002a8,
-/*
-	MOVE FROM dsa_datain+0x0288, WHEN DATA_IN
-
-at 0x000000de : */	0x19000000,0x000002b0,
-/*
-	MOVE FROM dsa_datain+0x0290, WHEN DATA_IN
-
-at 0x000000e0 : */	0x19000000,0x000002b8,
-/*
-	MOVE FROM dsa_datain+0x0298, WHEN DATA_IN
-
-at 0x000000e2 : */	0x19000000,0x000002c0,
-/*
-	MOVE FROM dsa_datain+0x02a0, WHEN DATA_IN
-
-at 0x000000e4 : */	0x19000000,0x000002c8,
-/*
-	MOVE FROM dsa_datain+0x02a8, WHEN DATA_IN
-
-at 0x000000e6 : */	0x19000000,0x000002d0,
-/*
-	MOVE FROM dsa_datain+0x02b0, WHEN DATA_IN
-
-at 0x000000e8 : */	0x19000000,0x000002d8,
-/*
-	MOVE FROM dsa_datain+0x02b8, WHEN DATA_IN
-
-at 0x000000ea : */	0x19000000,0x000002e0,
-/*
-	MOVE FROM dsa_datain+0x02c0, WHEN DATA_IN
-
-at 0x000000ec : */	0x19000000,0x000002e8,
-/*
-	MOVE FROM dsa_datain+0x02c8, WHEN DATA_IN
-
-at 0x000000ee : */	0x19000000,0x000002f0,
-/*
-	MOVE FROM dsa_datain+0x02d0, WHEN DATA_IN
-
-at 0x000000f0 : */	0x19000000,0x000002f8,
-/*
-	MOVE FROM dsa_datain+0x02d8, WHEN DATA_IN
-
-at 0x000000f2 : */	0x19000000,0x00000300,
-/*
-	MOVE FROM dsa_datain+0x02e0, WHEN DATA_IN
-
-at 0x000000f4 : */	0x19000000,0x00000308,
-/*
-	MOVE FROM dsa_datain+0x02e8, WHEN DATA_IN
-
-at 0x000000f6 : */	0x19000000,0x00000310,
-/*
-	MOVE FROM dsa_datain+0x02f0, WHEN DATA_IN
-
-at 0x000000f8 : */	0x19000000,0x00000318,
-/*
-	MOVE FROM dsa_datain+0x02f8, WHEN DATA_IN
-
-at 0x000000fa : */	0x19000000,0x00000320,
-/*
-	MOVE FROM dsa_datain+0x0300, WHEN DATA_IN
-
-at 0x000000fc : */	0x19000000,0x00000328,
-/*
-	MOVE FROM dsa_datain+0x0308, WHEN DATA_IN
-
-at 0x000000fe : */	0x19000000,0x00000330,
-/*
-	MOVE FROM dsa_datain+0x0310, WHEN DATA_IN
-
-at 0x00000100 : */	0x19000000,0x00000338,
-/*
-	MOVE FROM dsa_datain+0x0318, WHEN DATA_IN
-
-at 0x00000102 : */	0x19000000,0x00000340,
-/*
-	MOVE FROM dsa_datain+0x0320, WHEN DATA_IN
-
-at 0x00000104 : */	0x19000000,0x00000348,
-/*
-	MOVE FROM dsa_datain+0x0328, WHEN DATA_IN
-
-at 0x00000106 : */	0x19000000,0x00000350,
-/*
-	MOVE FROM dsa_datain+0x0330, WHEN DATA_IN
-
-at 0x00000108 : */	0x19000000,0x00000358,
-/*
-	MOVE FROM dsa_datain+0x0338, WHEN DATA_IN
-
-at 0x0000010a : */	0x19000000,0x00000360,
-/*
-	MOVE FROM dsa_datain+0x0340, WHEN DATA_IN
-
-at 0x0000010c : */	0x19000000,0x00000368,
-/*
-	MOVE FROM dsa_datain+0x0348, WHEN DATA_IN
-
-at 0x0000010e : */	0x19000000,0x00000370,
-/*
-	MOVE FROM dsa_datain+0x0350, WHEN DATA_IN
-
-at 0x00000110 : */	0x19000000,0x00000378,
-/*
-	MOVE FROM dsa_datain+0x0358, WHEN DATA_IN
-
-at 0x00000112 : */	0x19000000,0x00000380,
-/*
-	MOVE FROM dsa_datain+0x0360, WHEN DATA_IN
-
-at 0x00000114 : */	0x19000000,0x00000388,
-/*
-	MOVE FROM dsa_datain+0x0368, WHEN DATA_IN
-
-at 0x00000116 : */	0x19000000,0x00000390,
-/*
-	MOVE FROM dsa_datain+0x0370, WHEN DATA_IN
-
-at 0x00000118 : */	0x19000000,0x00000398,
-/*
-	MOVE FROM dsa_datain+0x0378, WHEN DATA_IN
-
-at 0x0000011a : */	0x19000000,0x000003a0,
-/*
-	MOVE FROM dsa_datain+0x0380, WHEN DATA_IN
-
-at 0x0000011c : */	0x19000000,0x000003a8,
-/*
-	MOVE FROM dsa_datain+0x0388, WHEN DATA_IN
-
-at 0x0000011e : */	0x19000000,0x000003b0,
-/*
-	MOVE FROM dsa_datain+0x0390, WHEN DATA_IN
-
-at 0x00000120 : */	0x19000000,0x000003b8,
-/*
-	MOVE FROM dsa_datain+0x0398, WHEN DATA_IN
-
-at 0x00000122 : */	0x19000000,0x000003c0,
-/*
-	MOVE FROM dsa_datain+0x03a0, WHEN DATA_IN
-
-at 0x00000124 : */	0x19000000,0x000003c8,
-/*
-	MOVE FROM dsa_datain+0x03a8, WHEN DATA_IN
-
-at 0x00000126 : */	0x19000000,0x000003d0,
-/*
-	MOVE FROM dsa_datain+0x03b0, WHEN DATA_IN
-
-at 0x00000128 : */	0x19000000,0x000003d8,
-/*
-	MOVE FROM dsa_datain+0x03b8, WHEN DATA_IN
-
-at 0x0000012a : */	0x19000000,0x000003e0,
-/*
-	MOVE FROM dsa_datain+0x03c0, WHEN DATA_IN
-
-at 0x0000012c : */	0x19000000,0x000003e8,
-/*
-	MOVE FROM dsa_datain+0x03c8, WHEN DATA_IN
-
-at 0x0000012e : */	0x19000000,0x000003f0,
-/*
-	MOVE FROM dsa_datain+0x03d0, WHEN DATA_IN
-
-at 0x00000130 : */	0x19000000,0x000003f8,
-/*
-	MOVE FROM dsa_datain+0x03d8, WHEN DATA_IN
-
-at 0x00000132 : */	0x19000000,0x00000400,
-/*
-	MOVE FROM dsa_datain+0x03e0, WHEN DATA_IN
-
-at 0x00000134 : */	0x19000000,0x00000408,
-/*
-	MOVE FROM dsa_datain+0x03e8, WHEN DATA_IN
-
-at 0x00000136 : */	0x19000000,0x00000410,
-/*
-	MOVE FROM dsa_datain+0x03f0, WHEN DATA_IN
-
-at 0x00000138 : */	0x19000000,0x00000418,
-/*
-	MOVE FROM dsa_datain+0x03f8, WHEN DATA_IN
-
-at 0x0000013a : */	0x19000000,0x00000420,
-/*
-	JUMP end_data_trans
-
-at 0x0000013c : */	0x80080000,0x00000908,
-/*
-
-output_data:
-	MOVE SCRATCH0 | had_dataout TO SCRATCH0
-
-at 0x0000013e : */	0x7a341000,0x00000000,
-/*
-ENTRY patch_output_data
-patch_output_data:
-	JUMP 0
-
-at 0x00000140 : */	0x80080000,0x00000000,
-/*
-	MOVE FROM dsa_dataout+0x0000, WHEN DATA_OUT
-
-at 0x00000142 : */	0x18000000,0x00000428,
-/*
-	MOVE FROM dsa_dataout+0x0008, WHEN DATA_OUT
-
-at 0x00000144 : */	0x18000000,0x00000430,
-/*
-	MOVE FROM dsa_dataout+0x0010, WHEN DATA_OUT
-
-at 0x00000146 : */	0x18000000,0x00000438,
-/*
-	MOVE FROM dsa_dataout+0x0018, WHEN DATA_OUT
-
-at 0x00000148 : */	0x18000000,0x00000440,
-/*
-	MOVE FROM dsa_dataout+0x0020, WHEN DATA_OUT
-
-at 0x0000014a : */	0x18000000,0x00000448,
-/*
-	MOVE FROM dsa_dataout+0x0028, WHEN DATA_OUT
-
-at 0x0000014c : */	0x18000000,0x00000450,
-/*
-	MOVE FROM dsa_dataout+0x0030, WHEN DATA_OUT
-
-at 0x0000014e : */	0x18000000,0x00000458,
-/*
-	MOVE FROM dsa_dataout+0x0038, WHEN DATA_OUT
-
-at 0x00000150 : */	0x18000000,0x00000460,
-/*
-	MOVE FROM dsa_dataout+0x0040, WHEN DATA_OUT
-
-at 0x00000152 : */	0x18000000,0x00000468,
-/*
-	MOVE FROM dsa_dataout+0x0048, WHEN DATA_OUT
-
-at 0x00000154 : */	0x18000000,0x00000470,
-/*
-	MOVE FROM dsa_dataout+0x0050, WHEN DATA_OUT
-
-at 0x00000156 : */	0x18000000,0x00000478,
-/*
-	MOVE FROM dsa_dataout+0x0058, WHEN DATA_OUT
-
-at 0x00000158 : */	0x18000000,0x00000480,
-/*
-	MOVE FROM dsa_dataout+0x0060, WHEN DATA_OUT
-
-at 0x0000015a : */	0x18000000,0x00000488,
-/*
-	MOVE FROM dsa_dataout+0x0068, WHEN DATA_OUT
-
-at 0x0000015c : */	0x18000000,0x00000490,
-/*
-	MOVE FROM dsa_dataout+0x0070, WHEN DATA_OUT
-
-at 0x0000015e : */	0x18000000,0x00000498,
-/*
-	MOVE FROM dsa_dataout+0x0078, WHEN DATA_OUT
-
-at 0x00000160 : */	0x18000000,0x000004a0,
-/*
-	MOVE FROM dsa_dataout+0x0080, WHEN DATA_OUT
-
-at 0x00000162 : */	0x18000000,0x000004a8,
-/*
-	MOVE FROM dsa_dataout+0x0088, WHEN DATA_OUT
-
-at 0x00000164 : */	0x18000000,0x000004b0,
-/*
-	MOVE FROM dsa_dataout+0x0090, WHEN DATA_OUT
-
-at 0x00000166 : */	0x18000000,0x000004b8,
-/*
-	MOVE FROM dsa_dataout+0x0098, WHEN DATA_OUT
-
-at 0x00000168 : */	0x18000000,0x000004c0,
-/*
-	MOVE FROM dsa_dataout+0x00a0, WHEN DATA_OUT
-
-at 0x0000016a : */	0x18000000,0x000004c8,
-/*
-	MOVE FROM dsa_dataout+0x00a8, WHEN DATA_OUT
-
-at 0x0000016c : */	0x18000000,0x000004d0,
-/*
-	MOVE FROM dsa_dataout+0x00b0, WHEN DATA_OUT
-
-at 0x0000016e : */	0x18000000,0x000004d8,
-/*
-	MOVE FROM dsa_dataout+0x00b8, WHEN DATA_OUT
-
-at 0x00000170 : */	0x18000000,0x000004e0,
-/*
-	MOVE FROM dsa_dataout+0x00c0, WHEN DATA_OUT
-
-at 0x00000172 : */	0x18000000,0x000004e8,
-/*
-	MOVE FROM dsa_dataout+0x00c8, WHEN DATA_OUT
-
-at 0x00000174 : */	0x18000000,0x000004f0,
-/*
-	MOVE FROM dsa_dataout+0x00d0, WHEN DATA_OUT
-
-at 0x00000176 : */	0x18000000,0x000004f8,
-/*
-	MOVE FROM dsa_dataout+0x00d8, WHEN DATA_OUT
-
-at 0x00000178 : */	0x18000000,0x00000500,
-/*
-	MOVE FROM dsa_dataout+0x00e0, WHEN DATA_OUT
-
-at 0x0000017a : */	0x18000000,0x00000508,
-/*
-	MOVE FROM dsa_dataout+0x00e8, WHEN DATA_OUT
-
-at 0x0000017c : */	0x18000000,0x00000510,
-/*
-	MOVE FROM dsa_dataout+0x00f0, WHEN DATA_OUT
-
-at 0x0000017e : */	0x18000000,0x00000518,
-/*
-	MOVE FROM dsa_dataout+0x00f8, WHEN DATA_OUT
-
-at 0x00000180 : */	0x18000000,0x00000520,
-/*
-	MOVE FROM dsa_dataout+0x0100, WHEN DATA_OUT
-
-at 0x00000182 : */	0x18000000,0x00000528,
-/*
-	MOVE FROM dsa_dataout+0x0108, WHEN DATA_OUT
-
-at 0x00000184 : */	0x18000000,0x00000530,
-/*
-	MOVE FROM dsa_dataout+0x0110, WHEN DATA_OUT
-
-at 0x00000186 : */	0x18000000,0x00000538,
-/*
-	MOVE FROM dsa_dataout+0x0118, WHEN DATA_OUT
-
-at 0x00000188 : */	0x18000000,0x00000540,
-/*
-	MOVE FROM dsa_dataout+0x0120, WHEN DATA_OUT
-
-at 0x0000018a : */	0x18000000,0x00000548,
-/*
-	MOVE FROM dsa_dataout+0x0128, WHEN DATA_OUT
-
-at 0x0000018c : */	0x18000000,0x00000550,
-/*
-	MOVE FROM dsa_dataout+0x0130, WHEN DATA_OUT
-
-at 0x0000018e : */	0x18000000,0x00000558,
-/*
-	MOVE FROM dsa_dataout+0x0138, WHEN DATA_OUT
-
-at 0x00000190 : */	0x18000000,0x00000560,
-/*
-	MOVE FROM dsa_dataout+0x0140, WHEN DATA_OUT
-
-at 0x00000192 : */	0x18000000,0x00000568,
-/*
-	MOVE FROM dsa_dataout+0x0148, WHEN DATA_OUT
-
-at 0x00000194 : */	0x18000000,0x00000570,
-/*
-	MOVE FROM dsa_dataout+0x0150, WHEN DATA_OUT
-
-at 0x00000196 : */	0x18000000,0x00000578,
-/*
-	MOVE FROM dsa_dataout+0x0158, WHEN DATA_OUT
-
-at 0x00000198 : */	0x18000000,0x00000580,
-/*
-	MOVE FROM dsa_dataout+0x0160, WHEN DATA_OUT
-
-at 0x0000019a : */	0x18000000,0x00000588,
-/*
-	MOVE FROM dsa_dataout+0x0168, WHEN DATA_OUT
-
-at 0x0000019c : */	0x18000000,0x00000590,
-/*
-	MOVE FROM dsa_dataout+0x0170, WHEN DATA_OUT
-
-at 0x0000019e : */	0x18000000,0x00000598,
-/*
-	MOVE FROM dsa_dataout+0x0178, WHEN DATA_OUT
-
-at 0x000001a0 : */	0x18000000,0x000005a0,
-/*
-	MOVE FROM dsa_dataout+0x0180, WHEN DATA_OUT
-
-at 0x000001a2 : */	0x18000000,0x000005a8,
-/*
-	MOVE FROM dsa_dataout+0x0188, WHEN DATA_OUT
-
-at 0x000001a4 : */	0x18000000,0x000005b0,
-/*
-	MOVE FROM dsa_dataout+0x0190, WHEN DATA_OUT
-
-at 0x000001a6 : */	0x18000000,0x000005b8,
-/*
-	MOVE FROM dsa_dataout+0x0198, WHEN DATA_OUT
-
-at 0x000001a8 : */	0x18000000,0x000005c0,
-/*
-	MOVE FROM dsa_dataout+0x01a0, WHEN DATA_OUT
-
-at 0x000001aa : */	0x18000000,0x000005c8,
-/*
-	MOVE FROM dsa_dataout+0x01a8, WHEN DATA_OUT
-
-at 0x000001ac : */	0x18000000,0x000005d0,
-/*
-	MOVE FROM dsa_dataout+0x01b0, WHEN DATA_OUT
-
-at 0x000001ae : */	0x18000000,0x000005d8,
-/*
-	MOVE FROM dsa_dataout+0x01b8, WHEN DATA_OUT
-
-at 0x000001b0 : */	0x18000000,0x000005e0,
-/*
-	MOVE FROM dsa_dataout+0x01c0, WHEN DATA_OUT
-
-at 0x000001b2 : */	0x18000000,0x000005e8,
-/*
-	MOVE FROM dsa_dataout+0x01c8, WHEN DATA_OUT
-
-at 0x000001b4 : */	0x18000000,0x000005f0,
-/*
-	MOVE FROM dsa_dataout+0x01d0, WHEN DATA_OUT
-
-at 0x000001b6 : */	0x18000000,0x000005f8,
-/*
-	MOVE FROM dsa_dataout+0x01d8, WHEN DATA_OUT
-
-at 0x000001b8 : */	0x18000000,0x00000600,
-/*
-	MOVE FROM dsa_dataout+0x01e0, WHEN DATA_OUT
-
-at 0x000001ba : */	0x18000000,0x00000608,
-/*
-	MOVE FROM dsa_dataout+0x01e8, WHEN DATA_OUT
-
-at 0x000001bc : */	0x18000000,0x00000610,
-/*
-	MOVE FROM dsa_dataout+0x01f0, WHEN DATA_OUT
-
-at 0x000001be : */	0x18000000,0x00000618,
-/*
-	MOVE FROM dsa_dataout+0x01f8, WHEN DATA_OUT
-
-at 0x000001c0 : */	0x18000000,0x00000620,
-/*
-	MOVE FROM dsa_dataout+0x0200, WHEN DATA_OUT
-
-at 0x000001c2 : */	0x18000000,0x00000628,
-/*
-	MOVE FROM dsa_dataout+0x0208, WHEN DATA_OUT
-
-at 0x000001c4 : */	0x18000000,0x00000630,
-/*
-	MOVE FROM dsa_dataout+0x0210, WHEN DATA_OUT
-
-at 0x000001c6 : */	0x18000000,0x00000638,
-/*
-	MOVE FROM dsa_dataout+0x0218, WHEN DATA_OUT
-
-at 0x000001c8 : */	0x18000000,0x00000640,
-/*
-	MOVE FROM dsa_dataout+0x0220, WHEN DATA_OUT
-
-at 0x000001ca : */	0x18000000,0x00000648,
-/*
-	MOVE FROM dsa_dataout+0x0228, WHEN DATA_OUT
-
-at 0x000001cc : */	0x18000000,0x00000650,
-/*
-	MOVE FROM dsa_dataout+0x0230, WHEN DATA_OUT
-
-at 0x000001ce : */	0x18000000,0x00000658,
-/*
-	MOVE FROM dsa_dataout+0x0238, WHEN DATA_OUT
-
-at 0x000001d0 : */	0x18000000,0x00000660,
-/*
-	MOVE FROM dsa_dataout+0x0240, WHEN DATA_OUT
-
-at 0x000001d2 : */	0x18000000,0x00000668,
-/*
-	MOVE FROM dsa_dataout+0x0248, WHEN DATA_OUT
-
-at 0x000001d4 : */	0x18000000,0x00000670,
-/*
-	MOVE FROM dsa_dataout+0x0250, WHEN DATA_OUT
-
-at 0x000001d6 : */	0x18000000,0x00000678,
-/*
-	MOVE FROM dsa_dataout+0x0258, WHEN DATA_OUT
-
-at 0x000001d8 : */	0x18000000,0x00000680,
-/*
-	MOVE FROM dsa_dataout+0x0260, WHEN DATA_OUT
-
-at 0x000001da : */	0x18000000,0x00000688,
-/*
-	MOVE FROM dsa_dataout+0x0268, WHEN DATA_OUT
-
-at 0x000001dc : */	0x18000000,0x00000690,
-/*
-	MOVE FROM dsa_dataout+0x0270, WHEN DATA_OUT
-
-at 0x000001de : */	0x18000000,0x00000698,
-/*
-	MOVE FROM dsa_dataout+0x0278, WHEN DATA_OUT
-
-at 0x000001e0 : */	0x18000000,0x000006a0,
-/*
-	MOVE FROM dsa_dataout+0x0280, WHEN DATA_OUT
-
-at 0x000001e2 : */	0x18000000,0x000006a8,
-/*
-	MOVE FROM dsa_dataout+0x0288, WHEN DATA_OUT
-
-at 0x000001e4 : */	0x18000000,0x000006b0,
-/*
-	MOVE FROM dsa_dataout+0x0290, WHEN DATA_OUT
-
-at 0x000001e6 : */	0x18000000,0x000006b8,
-/*
-	MOVE FROM dsa_dataout+0x0298, WHEN DATA_OUT
-
-at 0x000001e8 : */	0x18000000,0x000006c0,
-/*
-	MOVE FROM dsa_dataout+0x02a0, WHEN DATA_OUT
-
-at 0x000001ea : */	0x18000000,0x000006c8,
-/*
-	MOVE FROM dsa_dataout+0x02a8, WHEN DATA_OUT
-
-at 0x000001ec : */	0x18000000,0x000006d0,
-/*
-	MOVE FROM dsa_dataout+0x02b0, WHEN DATA_OUT
-
-at 0x000001ee : */	0x18000000,0x000006d8,
-/*
-	MOVE FROM dsa_dataout+0x02b8, WHEN DATA_OUT
-
-at 0x000001f0 : */	0x18000000,0x000006e0,
-/*
-	MOVE FROM dsa_dataout+0x02c0, WHEN DATA_OUT
-
-at 0x000001f2 : */	0x18000000,0x000006e8,
-/*
-	MOVE FROM dsa_dataout+0x02c8, WHEN DATA_OUT
-
-at 0x000001f4 : */	0x18000000,0x000006f0,
-/*
-	MOVE FROM dsa_dataout+0x02d0, WHEN DATA_OUT
-
-at 0x000001f6 : */	0x18000000,0x000006f8,
-/*
-	MOVE FROM dsa_dataout+0x02d8, WHEN DATA_OUT
-
-at 0x000001f8 : */	0x18000000,0x00000700,
-/*
-	MOVE FROM dsa_dataout+0x02e0, WHEN DATA_OUT
-
-at 0x000001fa : */	0x18000000,0x00000708,
-/*
-	MOVE FROM dsa_dataout+0x02e8, WHEN DATA_OUT
-
-at 0x000001fc : */	0x18000000,0x00000710,
-/*
-	MOVE FROM dsa_dataout+0x02f0, WHEN DATA_OUT
-
-at 0x000001fe : */	0x18000000,0x00000718,
-/*
-	MOVE FROM dsa_dataout+0x02f8, WHEN DATA_OUT
-
-at 0x00000200 : */	0x18000000,0x00000720,
-/*
-	MOVE FROM dsa_dataout+0x0300, WHEN DATA_OUT
-
-at 0x00000202 : */	0x18000000,0x00000728,
-/*
-	MOVE FROM dsa_dataout+0x0308, WHEN DATA_OUT
-
-at 0x00000204 : */	0x18000000,0x00000730,
-/*
-	MOVE FROM dsa_dataout+0x0310, WHEN DATA_OUT
-
-at 0x00000206 : */	0x18000000,0x00000738,
-/*
-	MOVE FROM dsa_dataout+0x0318, WHEN DATA_OUT
-
-at 0x00000208 : */	0x18000000,0x00000740,
-/*
-	MOVE FROM dsa_dataout+0x0320, WHEN DATA_OUT
-
-at 0x0000020a : */	0x18000000,0x00000748,
-/*
-	MOVE FROM dsa_dataout+0x0328, WHEN DATA_OUT
-
-at 0x0000020c : */	0x18000000,0x00000750,
-/*
-	MOVE FROM dsa_dataout+0x0330, WHEN DATA_OUT
-
-at 0x0000020e : */	0x18000000,0x00000758,
-/*
-	MOVE FROM dsa_dataout+0x0338, WHEN DATA_OUT
-
-at 0x00000210 : */	0x18000000,0x00000760,
-/*
-	MOVE FROM dsa_dataout+0x0340, WHEN DATA_OUT
-
-at 0x00000212 : */	0x18000000,0x00000768,
-/*
-	MOVE FROM dsa_dataout+0x0348, WHEN DATA_OUT
-
-at 0x00000214 : */	0x18000000,0x00000770,
-/*
-	MOVE FROM dsa_dataout+0x0350, WHEN DATA_OUT
-
-at 0x00000216 : */	0x18000000,0x00000778,
-/*
-	MOVE FROM dsa_dataout+0x0358, WHEN DATA_OUT
-
-at 0x00000218 : */	0x18000000,0x00000780,
-/*
-	MOVE FROM dsa_dataout+0x0360, WHEN DATA_OUT
-
-at 0x0000021a : */	0x18000000,0x00000788,
-/*
-	MOVE FROM dsa_dataout+0x0368, WHEN DATA_OUT
-
-at 0x0000021c : */	0x18000000,0x00000790,
-/*
-	MOVE FROM dsa_dataout+0x0370, WHEN DATA_OUT
-
-at 0x0000021e : */	0x18000000,0x00000798,
-/*
-	MOVE FROM dsa_dataout+0x0378, WHEN DATA_OUT
-
-at 0x00000220 : */	0x18000000,0x000007a0,
-/*
-	MOVE FROM dsa_dataout+0x0380, WHEN DATA_OUT
-
-at 0x00000222 : */	0x18000000,0x000007a8,
-/*
-	MOVE FROM dsa_dataout+0x0388, WHEN DATA_OUT
-
-at 0x00000224 : */	0x18000000,0x000007b0,
-/*
-	MOVE FROM dsa_dataout+0x0390, WHEN DATA_OUT
-
-at 0x00000226 : */	0x18000000,0x000007b8,
-/*
-	MOVE FROM dsa_dataout+0x0398, WHEN DATA_OUT
-
-at 0x00000228 : */	0x18000000,0x000007c0,
-/*
-	MOVE FROM dsa_dataout+0x03a0, WHEN DATA_OUT
-
-at 0x0000022a : */	0x18000000,0x000007c8,
-/*
-	MOVE FROM dsa_dataout+0x03a8, WHEN DATA_OUT
-
-at 0x0000022c : */	0x18000000,0x000007d0,
-/*
-	MOVE FROM dsa_dataout+0x03b0, WHEN DATA_OUT
-
-at 0x0000022e : */	0x18000000,0x000007d8,
-/*
-	MOVE FROM dsa_dataout+0x03b8, WHEN DATA_OUT
-
-at 0x00000230 : */	0x18000000,0x000007e0,
-/*
-	MOVE FROM dsa_dataout+0x03c0, WHEN DATA_OUT
-
-at 0x00000232 : */	0x18000000,0x000007e8,
-/*
-	MOVE FROM dsa_dataout+0x03c8, WHEN DATA_OUT
-
-at 0x00000234 : */	0x18000000,0x000007f0,
-/*
-	MOVE FROM dsa_dataout+0x03d0, WHEN DATA_OUT
-
-at 0x00000236 : */	0x18000000,0x000007f8,
-/*
-	MOVE FROM dsa_dataout+0x03d8, WHEN DATA_OUT
-
-at 0x00000238 : */	0x18000000,0x00000800,
-/*
-	MOVE FROM dsa_dataout+0x03e0, WHEN DATA_OUT
-
-at 0x0000023a : */	0x18000000,0x00000808,
-/*
-	MOVE FROM dsa_dataout+0x03e8, WHEN DATA_OUT
-
-at 0x0000023c : */	0x18000000,0x00000810,
-/*
-	MOVE FROM dsa_dataout+0x03f0, WHEN DATA_OUT
-
-at 0x0000023e : */	0x18000000,0x00000818,
-/*
-	MOVE FROM dsa_dataout+0x03f8, WHEN DATA_OUT
-
-at 0x00000240 : */	0x18000000,0x00000820,
-/*
-ENTRY end_data_trans
-end_data_trans:
-redo_msgin3:
-	JUMP get_status, WHEN STATUS
-
-at 0x00000242 : */	0x830b0000,0x000000a0,
-/*
-	JUMP get_msgin3, WHEN MSG_IN
-
-at 0x00000244 : */	0x870b0000,0x00000b20,
-/*
-	INT int_data_bad_phase
-
-at 0x00000246 : */	0x98080000,0xab93000b,
-/*
-
-get_msgin1:
-	MOVE SCRATCH0 | had_msgin TO SCRATCH0
-
-at 0x00000248 : */	0x7a344000,0x00000000,
-/*
-	MOVE 1, msgin_buf, WHEN MSG_IN
-
-at 0x0000024a : */	0x0f000001,0x00000000,
-/*
-	JUMP ext_msg1, IF 0x01		; Extended Message
-
-at 0x0000024c : */	0x800c0001,0x00000968,
-/*
-	JUMP ignore_msg1, IF 0x02	; Save Data Pointers
-
-at 0x0000024e : */	0x800c0002,0x00000958,
-/*
-	JUMP ignore_msg1, IF 0x03	; Save Restore Pointers
-
-at 0x00000250 : */	0x800c0003,0x00000958,
-/*
-	JUMP disc1, IF 0x04		; Disconnect
-
-at 0x00000252 : */	0x800c0004,0x000009c8,
-/*
-	INT int_bad_msg1
-
-at 0x00000254 : */	0x98080000,0xab930006,
-/*
-ignore_msg1:
-	CLEAR ACK
-
-at 0x00000256 : */	0x60000040,0x00000000,
-/*
-	JUMP redo_msgin1
-
-at 0x00000258 : */	0x80080000,0x00000058,
-/*
-ext_msg1:
-	MOVE SCRATCH0 | had_extmsg TO SCRATCH0
-
-at 0x0000025a : */	0x7a348000,0x00000000,
-/*
-	CLEAR ACK
-
-at 0x0000025c : */	0x60000040,0x00000000,
-/*
-	MOVE 1, msgin_buf + 1, WHEN MSG_IN
-
-at 0x0000025e : */	0x0f000001,0x00000001,
-/*
-	JUMP ext_msg1a, IF 0x03
-
-at 0x00000260 : */	0x800c0003,0x00000990,
-/*
-	INT int_bad_extmsg1a
-
-at 0x00000262 : */	0x98080000,0xab930000,
-/*
-ext_msg1a:
-	CLEAR ACK
-
-at 0x00000264 : */	0x60000040,0x00000000,
-/*
-	MOVE 1, msgin_buf + 2, WHEN MSG_IN
-
-at 0x00000266 : */	0x0f000001,0x00000002,
-/*
-	JUMP ext_msg1b, IF 0x01		; Must be SDTR
-
-at 0x00000268 : */	0x800c0001,0x000009b0,
-/*
-	INT int_bad_extmsg1b
-
-at 0x0000026a : */	0x98080000,0xab930001,
-/*
-ext_msg1b:
-	CLEAR ACK
-
-at 0x0000026c : */	0x60000040,0x00000000,
-/*
-	MOVE 2, msgin_buf + 3, WHEN MSG_IN
-
-at 0x0000026e : */	0x0f000002,0x00000003,
-/*
-	INT int_msg_sdtr1
-
-at 0x00000270 : */	0x98080000,0xab93000c,
-/*
-disc1:
-	CLEAR ACK
-
-at 0x00000272 : */	0x60000040,0x00000000,
-/*
-ENTRY wait_disc1
-wait_disc1:
-	WAIT DISCONNECT
-
-at 0x00000274 : */	0x48000000,0x00000000,
-/*
-	INT int_disc1
-
-at 0x00000276 : */	0x98080000,0xab930019,
-/*
-ENTRY resume_msgin1a
-resume_msgin1a:
-	CLEAR ACK
-
-at 0x00000278 : */	0x60000040,0x00000000,
-/*
-	JUMP redo_msgin1
-
-at 0x0000027a : */	0x80080000,0x00000058,
-/*
-ENTRY resume_msgin1b
-resume_msgin1b:
-	SET ATN
-
-at 0x0000027c : */	0x58000008,0x00000000,
-/*
-	CLEAR ACK
-
-at 0x0000027e : */	0x60000040,0x00000000,
-/*
-	INT int_no_msgout1, WHEN NOT MSG_OUT
-
-at 0x00000280 : */	0x9e030000,0xab93000f,
-/*
-	MOVE SCRATCH0 | had_msgout TO SCRATCH0
-
-at 0x00000282 : */	0x7a340200,0x00000000,
-/*
-	MOVE FROM dsa_msgout, when MSG_OUT
-
-at 0x00000284 : */	0x1e000000,0x00000008,
-/*
-	JUMP redo_msgin1
-
-at 0x00000286 : */	0x80080000,0x00000058,
-/*
-
-get_msgin2:
-	MOVE SCRATCH0 | had_msgin TO SCRATCH0
-
-at 0x00000288 : */	0x7a344000,0x00000000,
-/*
-	MOVE 1, msgin_buf, WHEN MSG_IN
-
-at 0x0000028a : */	0x0f000001,0x00000000,
-/*
-	JUMP ext_msg2, IF 0x01		; Extended Message
-
-at 0x0000028c : */	0x800c0001,0x00000a68,
-/*
-	JUMP ignore_msg2, IF 0x02	; Save Data Pointers
-
-at 0x0000028e : */	0x800c0002,0x00000a58,
-/*
-	JUMP ignore_msg2, IF 0x03	; Save Restore Pointers
-
-at 0x00000290 : */	0x800c0003,0x00000a58,
-/*
-	JUMP disc2, IF 0x04		; Disconnect
-
-at 0x00000292 : */	0x800c0004,0x00000ac8,
-/*
-	INT int_bad_msg2
-
-at 0x00000294 : */	0x98080000,0xab930007,
-/*
-ignore_msg2:
-	CLEAR ACK
-
-at 0x00000296 : */	0x60000040,0x00000000,
-/*
-	JUMP redo_msgin2
-
-at 0x00000298 : */	0x80080000,0x00000078,
-/*
-ext_msg2:
-	MOVE SCRATCH0 | had_extmsg TO SCRATCH0
-
-at 0x0000029a : */	0x7a348000,0x00000000,
-/*
-	CLEAR ACK
-
-at 0x0000029c : */	0x60000040,0x00000000,
-/*
-	MOVE 1, msgin_buf + 1, WHEN MSG_IN
-
-at 0x0000029e : */	0x0f000001,0x00000001,
-/*
-	JUMP ext_msg2a, IF 0x03
-
-at 0x000002a0 : */	0x800c0003,0x00000a90,
-/*
-	INT int_bad_extmsg2a
-
-at 0x000002a2 : */	0x98080000,0xab930002,
-/*
-ext_msg2a:
-	CLEAR ACK
-
-at 0x000002a4 : */	0x60000040,0x00000000,
-/*
-	MOVE 1, msgin_buf + 2, WHEN MSG_IN
-
-at 0x000002a6 : */	0x0f000001,0x00000002,
-/*
-	JUMP ext_msg2b, IF 0x01		; Must be SDTR
-
-at 0x000002a8 : */	0x800c0001,0x00000ab0,
-/*
-	INT int_bad_extmsg2b
-
-at 0x000002aa : */	0x98080000,0xab930003,
-/*
-ext_msg2b:
-	CLEAR ACK
-
-at 0x000002ac : */	0x60000040,0x00000000,
-/*
-	MOVE 2, msgin_buf + 3, WHEN MSG_IN
-
-at 0x000002ae : */	0x0f000002,0x00000003,
-/*
-	INT int_msg_sdtr2
-
-at 0x000002b0 : */	0x98080000,0xab93000d,
-/*
-disc2:
-	CLEAR ACK
-
-at 0x000002b2 : */	0x60000040,0x00000000,
-/*
-ENTRY wait_disc2
-wait_disc2:
-	WAIT DISCONNECT
-
-at 0x000002b4 : */	0x48000000,0x00000000,
-/*
-	INT int_disc2
-
-at 0x000002b6 : */	0x98080000,0xab93001a,
-/*
-ENTRY resume_msgin2a
-resume_msgin2a:
-	CLEAR ACK
-
-at 0x000002b8 : */	0x60000040,0x00000000,
-/*
-	JUMP redo_msgin2
-
-at 0x000002ba : */	0x80080000,0x00000078,
-/*
-ENTRY resume_msgin2b
-resume_msgin2b:
-	SET ATN
-
-at 0x000002bc : */	0x58000008,0x00000000,
-/*
-	CLEAR ACK
-
-at 0x000002be : */	0x60000040,0x00000000,
-/*
-	INT int_no_msgout2, WHEN NOT MSG_OUT
-
-at 0x000002c0 : */	0x9e030000,0xab930010,
-/*
-	MOVE SCRATCH0 | had_msgout TO SCRATCH0
-
-at 0x000002c2 : */	0x7a340200,0x00000000,
-/*
-	MOVE FROM dsa_msgout, when MSG_OUT
-
-at 0x000002c4 : */	0x1e000000,0x00000008,
-/*
-	JUMP redo_msgin2
-
-at 0x000002c6 : */	0x80080000,0x00000078,
-/*
-
-get_msgin3:
-	MOVE SCRATCH0 | had_msgin TO SCRATCH0
-
-at 0x000002c8 : */	0x7a344000,0x00000000,
-/*
-	MOVE 1, msgin_buf, WHEN MSG_IN
-
-at 0x000002ca : */	0x0f000001,0x00000000,
-/*
-	JUMP ext_msg3, IF 0x01		; Extended Message
-
-at 0x000002cc : */	0x800c0001,0x00000b68,
-/*
-	JUMP ignore_msg3, IF 0x02	; Save Data Pointers
-
-at 0x000002ce : */	0x800c0002,0x00000b58,
-/*
-	JUMP ignore_msg3, IF 0x03	; Save Restore Pointers
-
-at 0x000002d0 : */	0x800c0003,0x00000b58,
-/*
-	JUMP disc3, IF 0x04		; Disconnect
-
-at 0x000002d2 : */	0x800c0004,0x00000bc8,
-/*
-	INT int_bad_msg3
-
-at 0x000002d4 : */	0x98080000,0xab930008,
-/*
-ignore_msg3:
-	CLEAR ACK
-
-at 0x000002d6 : */	0x60000040,0x00000000,
-/*
-	JUMP redo_msgin3
-
-at 0x000002d8 : */	0x80080000,0x00000908,
-/*
-ext_msg3:
-	MOVE SCRATCH0 | had_extmsg TO SCRATCH0
-
-at 0x000002da : */	0x7a348000,0x00000000,
-/*
-	CLEAR ACK
-
-at 0x000002dc : */	0x60000040,0x00000000,
-/*
-	MOVE 1, msgin_buf + 1, WHEN MSG_IN
-
-at 0x000002de : */	0x0f000001,0x00000001,
-/*
-	JUMP ext_msg3a, IF 0x03
-
-at 0x000002e0 : */	0x800c0003,0x00000b90,
-/*
-	INT int_bad_extmsg3a
-
-at 0x000002e2 : */	0x98080000,0xab930004,
-/*
-ext_msg3a:
-	CLEAR ACK
-
-at 0x000002e4 : */	0x60000040,0x00000000,
-/*
-	MOVE 1, msgin_buf + 2, WHEN MSG_IN
-
-at 0x000002e6 : */	0x0f000001,0x00000002,
-/*
-	JUMP ext_msg3b, IF 0x01		; Must be SDTR
-
-at 0x000002e8 : */	0x800c0001,0x00000bb0,
-/*
-	INT int_bad_extmsg3b
-
-at 0x000002ea : */	0x98080000,0xab930005,
-/*
-ext_msg3b:
-	CLEAR ACK
-
-at 0x000002ec : */	0x60000040,0x00000000,
-/*
-	MOVE 2, msgin_buf + 3, WHEN MSG_IN
-
-at 0x000002ee : */	0x0f000002,0x00000003,
-/*
-	INT int_msg_sdtr3
-
-at 0x000002f0 : */	0x98080000,0xab93000e,
-/*
-disc3:
-	CLEAR ACK
-
-at 0x000002f2 : */	0x60000040,0x00000000,
-/*
-ENTRY wait_disc3
-wait_disc3:
-	WAIT DISCONNECT
-
-at 0x000002f4 : */	0x48000000,0x00000000,
-/*
-	INT int_disc3
-
-at 0x000002f6 : */	0x98080000,0xab93001b,
-/*
-ENTRY resume_msgin3a
-resume_msgin3a:
-	CLEAR ACK
-
-at 0x000002f8 : */	0x60000040,0x00000000,
-/*
-	JUMP redo_msgin3
-
-at 0x000002fa : */	0x80080000,0x00000908,
-/*
-ENTRY resume_msgin3b
-resume_msgin3b:
-	SET ATN
-
-at 0x000002fc : */	0x58000008,0x00000000,
-/*
-	CLEAR ACK
-
-at 0x000002fe : */	0x60000040,0x00000000,
-/*
-	INT int_no_msgout3, WHEN NOT MSG_OUT
-
-at 0x00000300 : */	0x9e030000,0xab930011,
-/*
-	MOVE SCRATCH0 | had_msgout TO SCRATCH0
-
-at 0x00000302 : */	0x7a340200,0x00000000,
-/*
-	MOVE FROM dsa_msgout, when MSG_OUT
-
-at 0x00000304 : */	0x1e000000,0x00000008,
-/*
-	JUMP redo_msgin3
-
-at 0x00000306 : */	0x80080000,0x00000908,
-/*
-
-ENTRY resume_rej_ident
-resume_rej_ident:
-	CLEAR ATN
-
-at 0x00000308 : */	0x60000008,0x00000000,
-/*
-	MOVE 1, msgin_buf, WHEN MSG_IN
-
-at 0x0000030a : */	0x0f000001,0x00000000,
-/*
-	INT int_not_rej, IF NOT 0x07		; Reject
-
-at 0x0000030c : */	0x98040007,0xab93001c,
-/*
-	CLEAR ACK
-
-at 0x0000030e : */	0x60000040,0x00000000,
-/*
-	JUMP done_ident
-
-at 0x00000310 : */	0x80080000,0x00000050,
-/*
-
-ENTRY reselect
-reselect:
-	; Disable selection timer
-	MOVE CTEST7 | 0x10 TO CTEST7
-
-at 0x00000312 : */	0x7a1b1000,0x00000000,
-/*
-	WAIT RESELECT resel_err
-
-at 0x00000314 : */	0x50000000,0x00000c70,
-/*
-	INT int_resel_not_msgin, WHEN NOT MSG_IN
-
-at 0x00000316 : */	0x9f030000,0xab930016,
-/*
-	MOVE 1, reselected_identify, WHEN MSG_IN
-
-at 0x00000318 : */	0x0f000001,0x00000000,
-/*
-	INT int_reselected
-
-at 0x0000031a : */	0x98080000,0xab930017,
-/*
-resel_err:
-	MOVE CTEST2 & 0x40 TO SFBR
-
-at 0x0000031c : */	0x74164000,0x00000000,
-/*
-	JUMP selected, IF 0x00
-
-at 0x0000031e : */	0x800c0000,0x00000cb0,
-/*
-	MOVE SFBR & 0 TO SFBR
-
-at 0x00000320 : */	0x7c080000,0x00000000,
-/*
-ENTRY patch_new_dsa
-patch_new_dsa:
-	MOVE SFBR | 0x11 TO DSA0
-
-at 0x00000322 : */	0x6a101100,0x00000000,
-/*
-	MOVE SFBR | 0x22 TO DSA1
-
-at 0x00000324 : */	0x6a112200,0x00000000,
-/*
-	MOVE SFBR | 0x33 TO DSA2
-
-at 0x00000326 : */	0x6a123300,0x00000000,
-/*
-	MOVE SFBR | 0x44 TO DSA3
-
-at 0x00000328 : */	0x6a134400,0x00000000,
-/*
-	JUMP do_select
-
-at 0x0000032a : */	0x80080000,0x00000000,
-/*
-
-selected:
-	INT int_selected
-
-at 0x0000032c : */	0x98080000,0xab930018,
-};
-
-#define A_dsa_cmnd	0x00000010
-static u32 A_dsa_cmnd_used[] __attribute((unused)) = {
-	0x0000001d,
-};
-
-#define A_dsa_datain	0x00000028
-static u32 A_dsa_datain_used[] __attribute((unused)) = {
-	0x0000003d,
-	0x0000003f,
-	0x00000041,
-	0x00000043,
-	0x00000045,
-	0x00000047,
-	0x00000049,
-	0x0000004b,
-	0x0000004d,
-	0x0000004f,
-	0x00000051,
-	0x00000053,
-	0x00000055,
-	0x00000057,
-	0x00000059,
-	0x0000005b,
-	0x0000005d,
-	0x0000005f,
-	0x00000061,
-	0x00000063,
-	0x00000065,
-	0x00000067,
-	0x00000069,
-	0x0000006b,
-	0x0000006d,
-	0x0000006f,
-	0x00000071,
-	0x00000073,
-	0x00000075,
-	0x00000077,
-	0x00000079,
-	0x0000007b,
-	0x0000007d,
-	0x0000007f,
-	0x00000081,
-	0x00000083,
-	0x00000085,
-	0x00000087,
-	0x00000089,
-	0x0000008b,
-	0x0000008d,
-	0x0000008f,
-	0x00000091,
-	0x00000093,
-	0x00000095,
-	0x00000097,
-	0x00000099,
-	0x0000009b,
-	0x0000009d,
-	0x0000009f,
-	0x000000a1,
-	0x000000a3,
-	0x000000a5,
-	0x000000a7,
-	0x000000a9,
-	0x000000ab,
-	0x000000ad,
-	0x000000af,
-	0x000000b1,
-	0x000000b3,
-	0x000000b5,
-	0x000000b7,
-	0x000000b9,
-	0x000000bb,
-	0x000000bd,
-	0x000000bf,
-	0x000000c1,
-	0x000000c3,
-	0x000000c5,
-	0x000000c7,
-	0x000000c9,
-	0x000000cb,
-	0x000000cd,
-	0x000000cf,
-	0x000000d1,
-	0x000000d3,
-	0x000000d5,
-	0x000000d7,
-	0x000000d9,
-	0x000000db,
-	0x000000dd,
-	0x000000df,
-	0x000000e1,
-	0x000000e3,
-	0x000000e5,
-	0x000000e7,
-	0x000000e9,
-	0x000000eb,
-	0x000000ed,
-	0x000000ef,
-	0x000000f1,
-	0x000000f3,
-	0x000000f5,
-	0x000000f7,
-	0x000000f9,
-	0x000000fb,
-	0x000000fd,
-	0x000000ff,
-	0x00000101,
-	0x00000103,
-	0x00000105,
-	0x00000107,
-	0x00000109,
-	0x0000010b,
-	0x0000010d,
-	0x0000010f,
-	0x00000111,
-	0x00000113,
-	0x00000115,
-	0x00000117,
-	0x00000119,
-	0x0000011b,
-	0x0000011d,
-	0x0000011f,
-	0x00000121,
-	0x00000123,
-	0x00000125,
-	0x00000127,
-	0x00000129,
-	0x0000012b,
-	0x0000012d,
-	0x0000012f,
-	0x00000131,
-	0x00000133,
-	0x00000135,
-	0x00000137,
-	0x00000139,
-	0x0000013b,
-};
-
-#define A_dsa_dataout	0x00000428
-static u32 A_dsa_dataout_used[] __attribute((unused)) = {
-	0x00000143,
-	0x00000145,
-	0x00000147,
-	0x00000149,
-	0x0000014b,
-	0x0000014d,
-	0x0000014f,
-	0x00000151,
-	0x00000153,
-	0x00000155,
-	0x00000157,
-	0x00000159,
-	0x0000015b,
-	0x0000015d,
-	0x0000015f,
-	0x00000161,
-	0x00000163,
-	0x00000165,
-	0x00000167,
-	0x00000169,
-	0x0000016b,
-	0x0000016d,
-	0x0000016f,
-	0x00000171,
-	0x00000173,
-	0x00000175,
-	0x00000177,
-	0x00000179,
-	0x0000017b,
-	0x0000017d,
-	0x0000017f,
-	0x00000181,
-	0x00000183,
-	0x00000185,
-	0x00000187,
-	0x00000189,
-	0x0000018b,
-	0x0000018d,
-	0x0000018f,
-	0x00000191,
-	0x00000193,
-	0x00000195,
-	0x00000197,
-	0x00000199,
-	0x0000019b,
-	0x0000019d,
-	0x0000019f,
-	0x000001a1,
-	0x000001a3,
-	0x000001a5,
-	0x000001a7,
-	0x000001a9,
-	0x000001ab,
-	0x000001ad,
-	0x000001af,
-	0x000001b1,
-	0x000001b3,
-	0x000001b5,
-	0x000001b7,
-	0x000001b9,
-	0x000001bb,
-	0x000001bd,
-	0x000001bf,
-	0x000001c1,
-	0x000001c3,
-	0x000001c5,
-	0x000001c7,
-	0x000001c9,
-	0x000001cb,
-	0x000001cd,
-	0x000001cf,
-	0x000001d1,
-	0x000001d3,
-	0x000001d5,
-	0x000001d7,
-	0x000001d9,
-	0x000001db,
-	0x000001dd,
-	0x000001df,
-	0x000001e1,
-	0x000001e3,
-	0x000001e5,
-	0x000001e7,
-	0x000001e9,
-	0x000001eb,
-	0x000001ed,
-	0x000001ef,
-	0x000001f1,
-	0x000001f3,
-	0x000001f5,
-	0x000001f7,
-	0x000001f9,
-	0x000001fb,
-	0x000001fd,
-	0x000001ff,
-	0x00000201,
-	0x00000203,
-	0x00000205,
-	0x00000207,
-	0x00000209,
-	0x0000020b,
-	0x0000020d,
-	0x0000020f,
-	0x00000211,
-	0x00000213,
-	0x00000215,
-	0x00000217,
-	0x00000219,
-	0x0000021b,
-	0x0000021d,
-	0x0000021f,
-	0x00000221,
-	0x00000223,
-	0x00000225,
-	0x00000227,
-	0x00000229,
-	0x0000022b,
-	0x0000022d,
-	0x0000022f,
-	0x00000231,
-	0x00000233,
-	0x00000235,
-	0x00000237,
-	0x00000239,
-	0x0000023b,
-	0x0000023d,
-	0x0000023f,
-	0x00000241,
-};
-
-#define A_dsa_msgin	0x00000020
-static u32 A_dsa_msgin_used[] __attribute((unused)) = {
-	0x0000002f,
-};
-
-#define A_dsa_msgout	0x00000008
-static u32 A_dsa_msgout_used[] __attribute((unused)) = {
-	0x00000013,
-	0x00000285,
-	0x000002c5,
-	0x00000305,
-};
-
-#define A_dsa_select	0x00000000
-static u32 A_dsa_select_used[] __attribute((unused)) = {
-	0x00000006,
-};
-
-#define A_dsa_size	0x00000828
-static u32 A_dsa_size_used[] __attribute((unused)) = {
-};
-
-#define A_dsa_status	0x00000018
-static u32 A_dsa_status_used[] __attribute((unused)) = {
-	0x0000002b,
-};
-
-#define A_had_cmdout	0x00000004
-static u32 A_had_cmdout_used[] __attribute((unused)) = {
-	0x0000001a,
-};
-
-#define A_had_datain	0x00000008
-static u32 A_had_datain_used[] __attribute((unused)) = {
-	0x00000038,
-};
-
-#define A_had_dataout	0x00000010
-static u32 A_had_dataout_used[] __attribute((unused)) = {
-	0x0000013e,
-};
-
-#define A_had_extmsg	0x00000080
-static u32 A_had_extmsg_used[] __attribute((unused)) = {
-	0x0000025a,
-	0x0000029a,
-	0x000002da,
-};
-
-#define A_had_msgin	0x00000040
-static u32 A_had_msgin_used[] __attribute((unused)) = {
-	0x00000248,
-	0x00000288,
-	0x000002c8,
-};
-
-#define A_had_msgout	0x00000002
-static u32 A_had_msgout_used[] __attribute((unused)) = {
-	0x00000010,
-	0x00000282,
-	0x000002c2,
-	0x00000302,
-};
-
-#define A_had_select	0x00000001
-static u32 A_had_select_used[] __attribute((unused)) = {
-	0x0000000c,
-};
-
-#define A_had_status	0x00000020
-static u32 A_had_status_used[] __attribute((unused)) = {
-};
-
-#define A_int_bad_extmsg1a	0xab930000
-static u32 A_int_bad_extmsg1a_used[] __attribute((unused)) = {
-	0x00000263,
-};
-
-#define A_int_bad_extmsg1b	0xab930001
-static u32 A_int_bad_extmsg1b_used[] __attribute((unused)) = {
-	0x0000026b,
-};
-
-#define A_int_bad_extmsg2a	0xab930002
-static u32 A_int_bad_extmsg2a_used[] __attribute((unused)) = {
-	0x000002a3,
-};
-
-#define A_int_bad_extmsg2b	0xab930003
-static u32 A_int_bad_extmsg2b_used[] __attribute((unused)) = {
-	0x000002ab,
-};
-
-#define A_int_bad_extmsg3a	0xab930004
-static u32 A_int_bad_extmsg3a_used[] __attribute((unused)) = {
-	0x000002e3,
-};
-
-#define A_int_bad_extmsg3b	0xab930005
-static u32 A_int_bad_extmsg3b_used[] __attribute((unused)) = {
-	0x000002eb,
-};
-
-#define A_int_bad_msg1	0xab930006
-static u32 A_int_bad_msg1_used[] __attribute((unused)) = {
-	0x00000255,
-};
-
-#define A_int_bad_msg2	0xab930007
-static u32 A_int_bad_msg2_used[] __attribute((unused)) = {
-	0x00000295,
-};
-
-#define A_int_bad_msg3	0xab930008
-static u32 A_int_bad_msg3_used[] __attribute((unused)) = {
-	0x000002d5,
-};
-
-#define A_int_cmd_bad_phase	0xab930009
-static u32 A_int_cmd_bad_phase_used[] __attribute((unused)) = {
-	0x00000027,
-};
-
-#define A_int_cmd_complete	0xab93000a
-static u32 A_int_cmd_complete_used[] __attribute((unused)) = {
-	0x00000037,
-};
-
-#define A_int_data_bad_phase	0xab93000b
-static u32 A_int_data_bad_phase_used[] __attribute((unused)) = {
-	0x00000247,
-};
-
-#define A_int_disc1	0xab930019
-static u32 A_int_disc1_used[] __attribute((unused)) = {
-	0x00000277,
-};
-
-#define A_int_disc2	0xab93001a
-static u32 A_int_disc2_used[] __attribute((unused)) = {
-	0x000002b7,
-};
-
-#define A_int_disc3	0xab93001b
-static u32 A_int_disc3_used[] __attribute((unused)) = {
-	0x000002f7,
-};
-
-#define A_int_msg_sdtr1	0xab93000c
-static u32 A_int_msg_sdtr1_used[] __attribute((unused)) = {
-	0x00000271,
-};
-
-#define A_int_msg_sdtr2	0xab93000d
-static u32 A_int_msg_sdtr2_used[] __attribute((unused)) = {
-	0x000002b1,
-};
-
-#define A_int_msg_sdtr3	0xab93000e
-static u32 A_int_msg_sdtr3_used[] __attribute((unused)) = {
-	0x000002f1,
-};
-
-#define A_int_no_msgout1	0xab93000f
-static u32 A_int_no_msgout1_used[] __attribute((unused)) = {
-	0x00000281,
-};
-
-#define A_int_no_msgout2	0xab930010
-static u32 A_int_no_msgout2_used[] __attribute((unused)) = {
-	0x000002c1,
-};
-
-#define A_int_no_msgout3	0xab930011
-static u32 A_int_no_msgout3_used[] __attribute((unused)) = {
-	0x00000301,
-};
-
-#define A_int_not_cmd_complete	0xab930012
-static u32 A_int_not_cmd_complete_used[] __attribute((unused)) = {
-	0x00000031,
-};
-
-#define A_int_not_rej	0xab93001c
-static u32 A_int_not_rej_used[] __attribute((unused)) = {
-	0x0000030d,
-};
-
-#define A_int_resel_not_msgin	0xab930016
-static u32 A_int_resel_not_msgin_used[] __attribute((unused)) = {
-	0x00000317,
-};
-
-#define A_int_reselected	0xab930017
-static u32 A_int_reselected_used[] __attribute((unused)) = {
-	0x0000031b,
-};
-
-#define A_int_sel_no_ident	0xab930013
-static u32 A_int_sel_no_ident_used[] __attribute((unused)) = {
-	0x0000000f,
-};
-
-#define A_int_sel_not_cmd	0xab930014
-static u32 A_int_sel_not_cmd_used[] __attribute((unused)) = {
-	0x00000019,
-};
-
-#define A_int_selected	0xab930018
-static u32 A_int_selected_used[] __attribute((unused)) = {
-	0x0000032d,
-};
-
-#define A_int_status_not_msgin	0xab930015
-static u32 A_int_status_not_msgin_used[] __attribute((unused)) = {
-	0x0000002d,
-};
-
-#define A_msgin_buf	0x00000000
-static u32 A_msgin_buf_used[] __attribute((unused)) = {
-	0x0000024b,
-	0x0000025f,
-	0x00000267,
-	0x0000026f,
-	0x0000028b,
-	0x0000029f,
-	0x000002a7,
-	0x000002af,
-	0x000002cb,
-	0x000002df,
-	0x000002e7,
-	0x000002ef,
-	0x0000030b,
-};
-
-#define A_reselected_identify	0x00000000
-static u32 A_reselected_identify_used[] __attribute((unused)) = {
-	0x00000319,
-};
-
-#define Ent_do_select	0x00000000
-#define Ent_done_ident	0x00000050
-#define Ent_end_data_trans	0x00000908
-#define Ent_patch_input_data	0x000000e8
-#define Ent_patch_new_dsa	0x00000c88
-#define Ent_patch_output_data	0x00000500
-#define Ent_reselect	0x00000c48
-#define Ent_resume_cmd	0x00000068
-#define Ent_resume_msgin1a	0x000009e0
-#define Ent_resume_msgin1b	0x000009f0
-#define Ent_resume_msgin2a	0x00000ae0
-#define Ent_resume_msgin2b	0x00000af0
-#define Ent_resume_msgin3a	0x00000be0
-#define Ent_resume_msgin3b	0x00000bf0
-#define Ent_resume_pmm	0x00000078
-#define Ent_resume_rej_ident	0x00000c20
-#define Ent_wait_disc1	0x000009d0
-#define Ent_wait_disc2	0x00000ad0
-#define Ent_wait_disc3	0x00000bd0
-#define Ent_wait_disc_complete	0x000000d0
-static u32 LABELPATCHES[] __attribute((unused)) = {
-	0x00000007,
-	0x00000009,
-	0x00000015,
-	0x00000017,
-	0x0000001f,
-	0x00000021,
-	0x00000023,
-	0x00000025,
-	0x0000013d,
-	0x00000243,
-	0x00000245,
-	0x0000024d,
-	0x0000024f,
-	0x00000251,
-	0x00000253,
-	0x00000259,
-	0x00000261,
-	0x00000269,
-	0x0000027b,
-	0x00000287,
-	0x0000028d,
-	0x0000028f,
-	0x00000291,
-	0x00000293,
-	0x00000299,
-	0x000002a1,
-	0x000002a9,
-	0x000002bb,
-	0x000002c7,
-	0x000002cd,
-	0x000002cf,
-	0x000002d1,
-	0x000002d3,
-	0x000002d9,
-	0x000002e1,
-	0x000002e9,
-	0x000002fb,
-	0x00000307,
-	0x00000311,
-	0x00000315,
-	0x0000031f,
-	0x0000032b,
-};
-
-static struct {
-	u32	offset;
-	void		*address;
-} EXTERNAL_PATCHES[] __attribute((unused)) = {
-};
-
-static u32 INSTRUCTIONS __attribute((unused))	= 407;
-static u32 PATCHES __attribute((unused))	= 42;
-static u32 EXTERNAL_PATCHES_LEN __attribute((unused))	= 0;
diff -Nru a/drivers/scsi/sim710_d.h_shipped b/drivers/scsi/sim710_d.h_shipped
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/scsi/sim710_d.h_shipped	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,2361 @@
+/* DO NOT EDIT - Generated automatically by script_asm.pl */
+static u32 SCRIPT[] = {
+/*
+
+
+
+
+
+
+ABSOLUTE dsa_select  = 0
+ABSOLUTE dsa_msgout  = 8
+ABSOLUTE dsa_cmnd    = 16
+ABSOLUTE dsa_status  = 24
+ABSOLUTE dsa_msgin   = 32
+ABSOLUTE dsa_datain  = 40	
+ABSOLUTE dsa_dataout = 1064	
+ABSOLUTE dsa_size     = 2088
+
+ABSOLUTE reselected_identify = 0
+ABSOLUTE msgin_buf = 0
+
+
+
+ABSOLUTE int_bad_extmsg1a	= 0xab930000
+ABSOLUTE int_bad_extmsg1b	= 0xab930001
+ABSOLUTE int_bad_extmsg2a	= 0xab930002
+ABSOLUTE int_bad_extmsg2b	= 0xab930003
+ABSOLUTE int_bad_extmsg3a	= 0xab930004
+ABSOLUTE int_bad_extmsg3b	= 0xab930005
+ABSOLUTE int_bad_msg1		= 0xab930006
+ABSOLUTE int_bad_msg2		= 0xab930007
+ABSOLUTE int_bad_msg3		= 0xab930008
+ABSOLUTE int_cmd_bad_phase	= 0xab930009
+ABSOLUTE int_cmd_complete	= 0xab93000a
+ABSOLUTE int_data_bad_phase	= 0xab93000b
+ABSOLUTE int_msg_sdtr1		= 0xab93000c
+ABSOLUTE int_msg_sdtr2		= 0xab93000d
+ABSOLUTE int_msg_sdtr3		= 0xab93000e
+ABSOLUTE int_no_msgout1		= 0xab93000f
+ABSOLUTE int_no_msgout2		= 0xab930010
+ABSOLUTE int_no_msgout3		= 0xab930011
+ABSOLUTE int_not_cmd_complete	= 0xab930012
+ABSOLUTE int_sel_no_ident	= 0xab930013
+ABSOLUTE int_sel_not_cmd	= 0xab930014
+ABSOLUTE int_status_not_msgin	= 0xab930015
+ABSOLUTE int_resel_not_msgin	= 0xab930016
+ABSOLUTE int_reselected		= 0xab930017
+ABSOLUTE int_selected		= 0xab930018
+ABSOLUTE int_disc1		= 0xab930019
+ABSOLUTE int_disc2		= 0xab93001a
+ABSOLUTE int_disc3		= 0xab93001b
+ABSOLUTE int_not_rej		= 0xab93001c
+
+
+
+
+ABSOLUTE had_select	= 0x01
+ABSOLUTE had_msgout	= 0x02
+ABSOLUTE had_cmdout	= 0x04
+ABSOLUTE had_datain	= 0x08
+ABSOLUTE had_dataout	= 0x10
+ABSOLUTE had_status	= 0x20
+ABSOLUTE had_msgin	= 0x40
+ABSOLUTE had_extmsg	= 0x80
+
+
+
+
+
+
+ENTRY do_select
+do_select:
+	CLEAR TARGET
+
+at 0x00000000 : */	0x60000200,0x00000000,
+/*
+	MOVE SCRATCH0 & 0 TO SCRATCH0
+
+at 0x00000002 : */	0x7c340000,0x00000000,
+/*
+	; Enable selection timer
+	MOVE CTEST7 & 0xef TO CTEST7
+
+at 0x00000004 : */	0x7c1bef00,0x00000000,
+/*
+	SELECT ATN FROM dsa_select, reselect
+
+at 0x00000006 : */	0x43000000,0x00000c48,
+/*
+	JUMP get_status, WHEN STATUS
+
+at 0x00000008 : */	0x830b0000,0x000000a0,
+/*
+	; Disable selection timer
+	MOVE CTEST7 | 0x10 TO CTEST7
+
+at 0x0000000a : */	0x7a1b1000,0x00000000,
+/*
+	MOVE SCRATCH0 | had_select TO SCRATCH0
+
+at 0x0000000c : */	0x7a340100,0x00000000,
+/*
+	INT int_sel_no_ident, IF NOT MSG_OUT
+
+at 0x0000000e : */	0x9e020000,0xab930013,
+/*
+	MOVE SCRATCH0 | had_msgout TO SCRATCH0
+
+at 0x00000010 : */	0x7a340200,0x00000000,
+/*
+	MOVE FROM dsa_msgout, when MSG_OUT
+
+at 0x00000012 : */	0x1e000000,0x00000008,
+/*
+ENTRY done_ident
+done_ident:
+	JUMP get_status, IF STATUS
+
+at 0x00000014 : */	0x830a0000,0x000000a0,
+/*
+redo_msgin1:
+	JUMP get_msgin1, WHEN MSG_IN
+
+at 0x00000016 : */	0x870b0000,0x00000920,
+/*
+	INT int_sel_not_cmd, IF NOT CMD
+
+at 0x00000018 : */	0x9a020000,0xab930014,
+/*
+ENTRY resume_cmd
+resume_cmd:
+	MOVE SCRATCH0 | had_cmdout TO SCRATCH0
+
+at 0x0000001a : */	0x7a340400,0x00000000,
+/*
+	MOVE FROM dsa_cmnd, WHEN CMD
+
+at 0x0000001c : */	0x1a000000,0x00000010,
+/*
+ENTRY resume_pmm
+resume_pmm:
+redo_msgin2:
+	JUMP get_msgin2, WHEN MSG_IN
+
+at 0x0000001e : */	0x870b0000,0x00000a20,
+/*
+	JUMP get_status, IF STATUS
+
+at 0x00000020 : */	0x830a0000,0x000000a0,
+/*
+	JUMP input_data, IF DATA_IN
+
+at 0x00000022 : */	0x810a0000,0x000000e0,
+/*
+	JUMP output_data, IF DATA_OUT
+
+at 0x00000024 : */	0x800a0000,0x000004f8,
+/*
+	INT int_cmd_bad_phase
+
+at 0x00000026 : */	0x98080000,0xab930009,
+/*
+
+get_status:
+	; Disable selection timer
+	MOVE CTEST7 | 0x10 TO CTEST7
+
+at 0x00000028 : */	0x7a1b1000,0x00000000,
+/*
+	MOVE FROM dsa_status, WHEN STATUS
+
+at 0x0000002a : */	0x1b000000,0x00000018,
+/*
+	INT int_status_not_msgin, WHEN NOT MSG_IN
+
+at 0x0000002c : */	0x9f030000,0xab930015,
+/*
+	MOVE FROM dsa_msgin, WHEN MSG_IN
+
+at 0x0000002e : */	0x1f000000,0x00000020,
+/*
+	INT int_not_cmd_complete, IF NOT 0x00
+
+at 0x00000030 : */	0x98040000,0xab930012,
+/*
+	CLEAR ACK
+
+at 0x00000032 : */	0x60000040,0x00000000,
+/*
+ENTRY wait_disc_complete
+wait_disc_complete:
+	WAIT DISCONNECT
+
+at 0x00000034 : */	0x48000000,0x00000000,
+/*
+	INT int_cmd_complete
+
+at 0x00000036 : */	0x98080000,0xab93000a,
+/*
+
+input_data:
+	MOVE SCRATCH0 | had_datain TO SCRATCH0
+
+at 0x00000038 : */	0x7a340800,0x00000000,
+/*
+ENTRY patch_input_data
+patch_input_data:
+	JUMP 0
+
+at 0x0000003a : */	0x80080000,0x00000000,
+/*
+	MOVE FROM dsa_datain+0x0000, WHEN DATA_IN
+
+at 0x0000003c : */	0x19000000,0x00000028,
+/*
+	MOVE FROM dsa_datain+0x0008, WHEN DATA_IN
+
+at 0x0000003e : */	0x19000000,0x00000030,
+/*
+	MOVE FROM dsa_datain+0x0010, WHEN DATA_IN
+
+at 0x00000040 : */	0x19000000,0x00000038,
+/*
+	MOVE FROM dsa_datain+0x0018, WHEN DATA_IN
+
+at 0x00000042 : */	0x19000000,0x00000040,
+/*
+	MOVE FROM dsa_datain+0x0020, WHEN DATA_IN
+
+at 0x00000044 : */	0x19000000,0x00000048,
+/*
+	MOVE FROM dsa_datain+0x0028, WHEN DATA_IN
+
+at 0x00000046 : */	0x19000000,0x00000050,
+/*
+	MOVE FROM dsa_datain+0x0030, WHEN DATA_IN
+
+at 0x00000048 : */	0x19000000,0x00000058,
+/*
+	MOVE FROM dsa_datain+0x0038, WHEN DATA_IN
+
+at 0x0000004a : */	0x19000000,0x00000060,
+/*
+	MOVE FROM dsa_datain+0x0040, WHEN DATA_IN
+
+at 0x0000004c : */	0x19000000,0x00000068,
+/*
+	MOVE FROM dsa_datain+0x0048, WHEN DATA_IN
+
+at 0x0000004e : */	0x19000000,0x00000070,
+/*
+	MOVE FROM dsa_datain+0x0050, WHEN DATA_IN
+
+at 0x00000050 : */	0x19000000,0x00000078,
+/*
+	MOVE FROM dsa_datain+0x0058, WHEN DATA_IN
+
+at 0x00000052 : */	0x19000000,0x00000080,
+/*
+	MOVE FROM dsa_datain+0x0060, WHEN DATA_IN
+
+at 0x00000054 : */	0x19000000,0x00000088,
+/*
+	MOVE FROM dsa_datain+0x0068, WHEN DATA_IN
+
+at 0x00000056 : */	0x19000000,0x00000090,
+/*
+	MOVE FROM dsa_datain+0x0070, WHEN DATA_IN
+
+at 0x00000058 : */	0x19000000,0x00000098,
+/*
+	MOVE FROM dsa_datain+0x0078, WHEN DATA_IN
+
+at 0x0000005a : */	0x19000000,0x000000a0,
+/*
+	MOVE FROM dsa_datain+0x0080, WHEN DATA_IN
+
+at 0x0000005c : */	0x19000000,0x000000a8,
+/*
+	MOVE FROM dsa_datain+0x0088, WHEN DATA_IN
+
+at 0x0000005e : */	0x19000000,0x000000b0,
+/*
+	MOVE FROM dsa_datain+0x0090, WHEN DATA_IN
+
+at 0x00000060 : */	0x19000000,0x000000b8,
+/*
+	MOVE FROM dsa_datain+0x0098, WHEN DATA_IN
+
+at 0x00000062 : */	0x19000000,0x000000c0,
+/*
+	MOVE FROM dsa_datain+0x00a0, WHEN DATA_IN
+
+at 0x00000064 : */	0x19000000,0x000000c8,
+/*
+	MOVE FROM dsa_datain+0x00a8, WHEN DATA_IN
+
+at 0x00000066 : */	0x19000000,0x000000d0,
+/*
+	MOVE FROM dsa_datain+0x00b0, WHEN DATA_IN
+
+at 0x00000068 : */	0x19000000,0x000000d8,
+/*
+	MOVE FROM dsa_datain+0x00b8, WHEN DATA_IN
+
+at 0x0000006a : */	0x19000000,0x000000e0,
+/*
+	MOVE FROM dsa_datain+0x00c0, WHEN DATA_IN
+
+at 0x0000006c : */	0x19000000,0x000000e8,
+/*
+	MOVE FROM dsa_datain+0x00c8, WHEN DATA_IN
+
+at 0x0000006e : */	0x19000000,0x000000f0,
+/*
+	MOVE FROM dsa_datain+0x00d0, WHEN DATA_IN
+
+at 0x00000070 : */	0x19000000,0x000000f8,
+/*
+	MOVE FROM dsa_datain+0x00d8, WHEN DATA_IN
+
+at 0x00000072 : */	0x19000000,0x00000100,
+/*
+	MOVE FROM dsa_datain+0x00e0, WHEN DATA_IN
+
+at 0x00000074 : */	0x19000000,0x00000108,
+/*
+	MOVE FROM dsa_datain+0x00e8, WHEN DATA_IN
+
+at 0x00000076 : */	0x19000000,0x00000110,
+/*
+	MOVE FROM dsa_datain+0x00f0, WHEN DATA_IN
+
+at 0x00000078 : */	0x19000000,0x00000118,
+/*
+	MOVE FROM dsa_datain+0x00f8, WHEN DATA_IN
+
+at 0x0000007a : */	0x19000000,0x00000120,
+/*
+	MOVE FROM dsa_datain+0x0100, WHEN DATA_IN
+
+at 0x0000007c : */	0x19000000,0x00000128,
+/*
+	MOVE FROM dsa_datain+0x0108, WHEN DATA_IN
+
+at 0x0000007e : */	0x19000000,0x00000130,
+/*
+	MOVE FROM dsa_datain+0x0110, WHEN DATA_IN
+
+at 0x00000080 : */	0x19000000,0x00000138,
+/*
+	MOVE FROM dsa_datain+0x0118, WHEN DATA_IN
+
+at 0x00000082 : */	0x19000000,0x00000140,
+/*
+	MOVE FROM dsa_datain+0x0120, WHEN DATA_IN
+
+at 0x00000084 : */	0x19000000,0x00000148,
+/*
+	MOVE FROM dsa_datain+0x0128, WHEN DATA_IN
+
+at 0x00000086 : */	0x19000000,0x00000150,
+/*
+	MOVE FROM dsa_datain+0x0130, WHEN DATA_IN
+
+at 0x00000088 : */	0x19000000,0x00000158,
+/*
+	MOVE FROM dsa_datain+0x0138, WHEN DATA_IN
+
+at 0x0000008a : */	0x19000000,0x00000160,
+/*
+	MOVE FROM dsa_datain+0x0140, WHEN DATA_IN
+
+at 0x0000008c : */	0x19000000,0x00000168,
+/*
+	MOVE FROM dsa_datain+0x0148, WHEN DATA_IN
+
+at 0x0000008e : */	0x19000000,0x00000170,
+/*
+	MOVE FROM dsa_datain+0x0150, WHEN DATA_IN
+
+at 0x00000090 : */	0x19000000,0x00000178,
+/*
+	MOVE FROM dsa_datain+0x0158, WHEN DATA_IN
+
+at 0x00000092 : */	0x19000000,0x00000180,
+/*
+	MOVE FROM dsa_datain+0x0160, WHEN DATA_IN
+
+at 0x00000094 : */	0x19000000,0x00000188,
+/*
+	MOVE FROM dsa_datain+0x0168, WHEN DATA_IN
+
+at 0x00000096 : */	0x19000000,0x00000190,
+/*
+	MOVE FROM dsa_datain+0x0170, WHEN DATA_IN
+
+at 0x00000098 : */	0x19000000,0x00000198,
+/*
+	MOVE FROM dsa_datain+0x0178, WHEN DATA_IN
+
+at 0x0000009a : */	0x19000000,0x000001a0,
+/*
+	MOVE FROM dsa_datain+0x0180, WHEN DATA_IN
+
+at 0x0000009c : */	0x19000000,0x000001a8,
+/*
+	MOVE FROM dsa_datain+0x0188, WHEN DATA_IN
+
+at 0x0000009e : */	0x19000000,0x000001b0,
+/*
+	MOVE FROM dsa_datain+0x0190, WHEN DATA_IN
+
+at 0x000000a0 : */	0x19000000,0x000001b8,
+/*
+	MOVE FROM dsa_datain+0x0198, WHEN DATA_IN
+
+at 0x000000a2 : */	0x19000000,0x000001c0,
+/*
+	MOVE FROM dsa_datain+0x01a0, WHEN DATA_IN
+
+at 0x000000a4 : */	0x19000000,0x000001c8,
+/*
+	MOVE FROM dsa_datain+0x01a8, WHEN DATA_IN
+
+at 0x000000a6 : */	0x19000000,0x000001d0,
+/*
+	MOVE FROM dsa_datain+0x01b0, WHEN DATA_IN
+
+at 0x000000a8 : */	0x19000000,0x000001d8,
+/*
+	MOVE FROM dsa_datain+0x01b8, WHEN DATA_IN
+
+at 0x000000aa : */	0x19000000,0x000001e0,
+/*
+	MOVE FROM dsa_datain+0x01c0, WHEN DATA_IN
+
+at 0x000000ac : */	0x19000000,0x000001e8,
+/*
+	MOVE FROM dsa_datain+0x01c8, WHEN DATA_IN
+
+at 0x000000ae : */	0x19000000,0x000001f0,
+/*
+	MOVE FROM dsa_datain+0x01d0, WHEN DATA_IN
+
+at 0x000000b0 : */	0x19000000,0x000001f8,
+/*
+	MOVE FROM dsa_datain+0x01d8, WHEN DATA_IN
+
+at 0x000000b2 : */	0x19000000,0x00000200,
+/*
+	MOVE FROM dsa_datain+0x01e0, WHEN DATA_IN
+
+at 0x000000b4 : */	0x19000000,0x00000208,
+/*
+	MOVE FROM dsa_datain+0x01e8, WHEN DATA_IN
+
+at 0x000000b6 : */	0x19000000,0x00000210,
+/*
+	MOVE FROM dsa_datain+0x01f0, WHEN DATA_IN
+
+at 0x000000b8 : */	0x19000000,0x00000218,
+/*
+	MOVE FROM dsa_datain+0x01f8, WHEN DATA_IN
+
+at 0x000000ba : */	0x19000000,0x00000220,
+/*
+	MOVE FROM dsa_datain+0x0200, WHEN DATA_IN
+
+at 0x000000bc : */	0x19000000,0x00000228,
+/*
+	MOVE FROM dsa_datain+0x0208, WHEN DATA_IN
+
+at 0x000000be : */	0x19000000,0x00000230,
+/*
+	MOVE FROM dsa_datain+0x0210, WHEN DATA_IN
+
+at 0x000000c0 : */	0x19000000,0x00000238,
+/*
+	MOVE FROM dsa_datain+0x0218, WHEN DATA_IN
+
+at 0x000000c2 : */	0x19000000,0x00000240,
+/*
+	MOVE FROM dsa_datain+0x0220, WHEN DATA_IN
+
+at 0x000000c4 : */	0x19000000,0x00000248,
+/*
+	MOVE FROM dsa_datain+0x0228, WHEN DATA_IN
+
+at 0x000000c6 : */	0x19000000,0x00000250,
+/*
+	MOVE FROM dsa_datain+0x0230, WHEN DATA_IN
+
+at 0x000000c8 : */	0x19000000,0x00000258,
+/*
+	MOVE FROM dsa_datain+0x0238, WHEN DATA_IN
+
+at 0x000000ca : */	0x19000000,0x00000260,
+/*
+	MOVE FROM dsa_datain+0x0240, WHEN DATA_IN
+
+at 0x000000cc : */	0x19000000,0x00000268,
+/*
+	MOVE FROM dsa_datain+0x0248, WHEN DATA_IN
+
+at 0x000000ce : */	0x19000000,0x00000270,
+/*
+	MOVE FROM dsa_datain+0x0250, WHEN DATA_IN
+
+at 0x000000d0 : */	0x19000000,0x00000278,
+/*
+	MOVE FROM dsa_datain+0x0258, WHEN DATA_IN
+
+at 0x000000d2 : */	0x19000000,0x00000280,
+/*
+	MOVE FROM dsa_datain+0x0260, WHEN DATA_IN
+
+at 0x000000d4 : */	0x19000000,0x00000288,
+/*
+	MOVE FROM dsa_datain+0x0268, WHEN DATA_IN
+
+at 0x000000d6 : */	0x19000000,0x00000290,
+/*
+	MOVE FROM dsa_datain+0x0270, WHEN DATA_IN
+
+at 0x000000d8 : */	0x19000000,0x00000298,
+/*
+	MOVE FROM dsa_datain+0x0278, WHEN DATA_IN
+
+at 0x000000da : */	0x19000000,0x000002a0,
+/*
+	MOVE FROM dsa_datain+0x0280, WHEN DATA_IN
+
+at 0x000000dc : */	0x19000000,0x000002a8,
+/*
+	MOVE FROM dsa_datain+0x0288, WHEN DATA_IN
+
+at 0x000000de : */	0x19000000,0x000002b0,
+/*
+	MOVE FROM dsa_datain+0x0290, WHEN DATA_IN
+
+at 0x000000e0 : */	0x19000000,0x000002b8,
+/*
+	MOVE FROM dsa_datain+0x0298, WHEN DATA_IN
+
+at 0x000000e2 : */	0x19000000,0x000002c0,
+/*
+	MOVE FROM dsa_datain+0x02a0, WHEN DATA_IN
+
+at 0x000000e4 : */	0x19000000,0x000002c8,
+/*
+	MOVE FROM dsa_datain+0x02a8, WHEN DATA_IN
+
+at 0x000000e6 : */	0x19000000,0x000002d0,
+/*
+	MOVE FROM dsa_datain+0x02b0, WHEN DATA_IN
+
+at 0x000000e8 : */	0x19000000,0x000002d8,
+/*
+	MOVE FROM dsa_datain+0x02b8, WHEN DATA_IN
+
+at 0x000000ea : */	0x19000000,0x000002e0,
+/*
+	MOVE FROM dsa_datain+0x02c0, WHEN DATA_IN
+
+at 0x000000ec : */	0x19000000,0x000002e8,
+/*
+	MOVE FROM dsa_datain+0x02c8, WHEN DATA_IN
+
+at 0x000000ee : */	0x19000000,0x000002f0,
+/*
+	MOVE FROM dsa_datain+0x02d0, WHEN DATA_IN
+
+at 0x000000f0 : */	0x19000000,0x000002f8,
+/*
+	MOVE FROM dsa_datain+0x02d8, WHEN DATA_IN
+
+at 0x000000f2 : */	0x19000000,0x00000300,
+/*
+	MOVE FROM dsa_datain+0x02e0, WHEN DATA_IN
+
+at 0x000000f4 : */	0x19000000,0x00000308,
+/*
+	MOVE FROM dsa_datain+0x02e8, WHEN DATA_IN
+
+at 0x000000f6 : */	0x19000000,0x00000310,
+/*
+	MOVE FROM dsa_datain+0x02f0, WHEN DATA_IN
+
+at 0x000000f8 : */	0x19000000,0x00000318,
+/*
+	MOVE FROM dsa_datain+0x02f8, WHEN DATA_IN
+
+at 0x000000fa : */	0x19000000,0x00000320,
+/*
+	MOVE FROM dsa_datain+0x0300, WHEN DATA_IN
+
+at 0x000000fc : */	0x19000000,0x00000328,
+/*
+	MOVE FROM dsa_datain+0x0308, WHEN DATA_IN
+
+at 0x000000fe : */	0x19000000,0x00000330,
+/*
+	MOVE FROM dsa_datain+0x0310, WHEN DATA_IN
+
+at 0x00000100 : */	0x19000000,0x00000338,
+/*
+	MOVE FROM dsa_datain+0x0318, WHEN DATA_IN
+
+at 0x00000102 : */	0x19000000,0x00000340,
+/*
+	MOVE FROM dsa_datain+0x0320, WHEN DATA_IN
+
+at 0x00000104 : */	0x19000000,0x00000348,
+/*
+	MOVE FROM dsa_datain+0x0328, WHEN DATA_IN
+
+at 0x00000106 : */	0x19000000,0x00000350,
+/*
+	MOVE FROM dsa_datain+0x0330, WHEN DATA_IN
+
+at 0x00000108 : */	0x19000000,0x00000358,
+/*
+	MOVE FROM dsa_datain+0x0338, WHEN DATA_IN
+
+at 0x0000010a : */	0x19000000,0x00000360,
+/*
+	MOVE FROM dsa_datain+0x0340, WHEN DATA_IN
+
+at 0x0000010c : */	0x19000000,0x00000368,
+/*
+	MOVE FROM dsa_datain+0x0348, WHEN DATA_IN
+
+at 0x0000010e : */	0x19000000,0x00000370,
+/*
+	MOVE FROM dsa_datain+0x0350, WHEN DATA_IN
+
+at 0x00000110 : */	0x19000000,0x00000378,
+/*
+	MOVE FROM dsa_datain+0x0358, WHEN DATA_IN
+
+at 0x00000112 : */	0x19000000,0x00000380,
+/*
+	MOVE FROM dsa_datain+0x0360, WHEN DATA_IN
+
+at 0x00000114 : */	0x19000000,0x00000388,
+/*
+	MOVE FROM dsa_datain+0x0368, WHEN DATA_IN
+
+at 0x00000116 : */	0x19000000,0x00000390,
+/*
+	MOVE FROM dsa_datain+0x0370, WHEN DATA_IN
+
+at 0x00000118 : */	0x19000000,0x00000398,
+/*
+	MOVE FROM dsa_datain+0x0378, WHEN DATA_IN
+
+at 0x0000011a : */	0x19000000,0x000003a0,
+/*
+	MOVE FROM dsa_datain+0x0380, WHEN DATA_IN
+
+at 0x0000011c : */	0x19000000,0x000003a8,
+/*
+	MOVE FROM dsa_datain+0x0388, WHEN DATA_IN
+
+at 0x0000011e : */	0x19000000,0x000003b0,
+/*
+	MOVE FROM dsa_datain+0x0390, WHEN DATA_IN
+
+at 0x00000120 : */	0x19000000,0x000003b8,
+/*
+	MOVE FROM dsa_datain+0x0398, WHEN DATA_IN
+
+at 0x00000122 : */	0x19000000,0x000003c0,
+/*
+	MOVE FROM dsa_datain+0x03a0, WHEN DATA_IN
+
+at 0x00000124 : */	0x19000000,0x000003c8,
+/*
+	MOVE FROM dsa_datain+0x03a8, WHEN DATA_IN
+
+at 0x00000126 : */	0x19000000,0x000003d0,
+/*
+	MOVE FROM dsa_datain+0x03b0, WHEN DATA_IN
+
+at 0x00000128 : */	0x19000000,0x000003d8,
+/*
+	MOVE FROM dsa_datain+0x03b8, WHEN DATA_IN
+
+at 0x0000012a : */	0x19000000,0x000003e0,
+/*
+	MOVE FROM dsa_datain+0x03c0, WHEN DATA_IN
+
+at 0x0000012c : */	0x19000000,0x000003e8,
+/*
+	MOVE FROM dsa_datain+0x03c8, WHEN DATA_IN
+
+at 0x0000012e : */	0x19000000,0x000003f0,
+/*
+	MOVE FROM dsa_datain+0x03d0, WHEN DATA_IN
+
+at 0x00000130 : */	0x19000000,0x000003f8,
+/*
+	MOVE FROM dsa_datain+0x03d8, WHEN DATA_IN
+
+at 0x00000132 : */	0x19000000,0x00000400,
+/*
+	MOVE FROM dsa_datain+0x03e0, WHEN DATA_IN
+
+at 0x00000134 : */	0x19000000,0x00000408,
+/*
+	MOVE FROM dsa_datain+0x03e8, WHEN DATA_IN
+
+at 0x00000136 : */	0x19000000,0x00000410,
+/*
+	MOVE FROM dsa_datain+0x03f0, WHEN DATA_IN
+
+at 0x00000138 : */	0x19000000,0x00000418,
+/*
+	MOVE FROM dsa_datain+0x03f8, WHEN DATA_IN
+
+at 0x0000013a : */	0x19000000,0x00000420,
+/*
+	JUMP end_data_trans
+
+at 0x0000013c : */	0x80080000,0x00000908,
+/*
+
+output_data:
+	MOVE SCRATCH0 | had_dataout TO SCRATCH0
+
+at 0x0000013e : */	0x7a341000,0x00000000,
+/*
+ENTRY patch_output_data
+patch_output_data:
+	JUMP 0
+
+at 0x00000140 : */	0x80080000,0x00000000,
+/*
+	MOVE FROM dsa_dataout+0x0000, WHEN DATA_OUT
+
+at 0x00000142 : */	0x18000000,0x00000428,
+/*
+	MOVE FROM dsa_dataout+0x0008, WHEN DATA_OUT
+
+at 0x00000144 : */	0x18000000,0x00000430,
+/*
+	MOVE FROM dsa_dataout+0x0010, WHEN DATA_OUT
+
+at 0x00000146 : */	0x18000000,0x00000438,
+/*
+	MOVE FROM dsa_dataout+0x0018, WHEN DATA_OUT
+
+at 0x00000148 : */	0x18000000,0x00000440,
+/*
+	MOVE FROM dsa_dataout+0x0020, WHEN DATA_OUT
+
+at 0x0000014a : */	0x18000000,0x00000448,
+/*
+	MOVE FROM dsa_dataout+0x0028, WHEN DATA_OUT
+
+at 0x0000014c : */	0x18000000,0x00000450,
+/*
+	MOVE FROM dsa_dataout+0x0030, WHEN DATA_OUT
+
+at 0x0000014e : */	0x18000000,0x00000458,
+/*
+	MOVE FROM dsa_dataout+0x0038, WHEN DATA_OUT
+
+at 0x00000150 : */	0x18000000,0x00000460,
+/*
+	MOVE FROM dsa_dataout+0x0040, WHEN DATA_OUT
+
+at 0x00000152 : */	0x18000000,0x00000468,
+/*
+	MOVE FROM dsa_dataout+0x0048, WHEN DATA_OUT
+
+at 0x00000154 : */	0x18000000,0x00000470,
+/*
+	MOVE FROM dsa_dataout+0x0050, WHEN DATA_OUT
+
+at 0x00000156 : */	0x18000000,0x00000478,
+/*
+	MOVE FROM dsa_dataout+0x0058, WHEN DATA_OUT
+
+at 0x00000158 : */	0x18000000,0x00000480,
+/*
+	MOVE FROM dsa_dataout+0x0060, WHEN DATA_OUT
+
+at 0x0000015a : */	0x18000000,0x00000488,
+/*
+	MOVE FROM dsa_dataout+0x0068, WHEN DATA_OUT
+
+at 0x0000015c : */	0x18000000,0x00000490,
+/*
+	MOVE FROM dsa_dataout+0x0070, WHEN DATA_OUT
+
+at 0x0000015e : */	0x18000000,0x00000498,
+/*
+	MOVE FROM dsa_dataout+0x0078, WHEN DATA_OUT
+
+at 0x00000160 : */	0x18000000,0x000004a0,
+/*
+	MOVE FROM dsa_dataout+0x0080, WHEN DATA_OUT
+
+at 0x00000162 : */	0x18000000,0x000004a8,
+/*
+	MOVE FROM dsa_dataout+0x0088, WHEN DATA_OUT
+
+at 0x00000164 : */	0x18000000,0x000004b0,
+/*
+	MOVE FROM dsa_dataout+0x0090, WHEN DATA_OUT
+
+at 0x00000166 : */	0x18000000,0x000004b8,
+/*
+	MOVE FROM dsa_dataout+0x0098, WHEN DATA_OUT
+
+at 0x00000168 : */	0x18000000,0x000004c0,
+/*
+	MOVE FROM dsa_dataout+0x00a0, WHEN DATA_OUT
+
+at 0x0000016a : */	0x18000000,0x000004c8,
+/*
+	MOVE FROM dsa_dataout+0x00a8, WHEN DATA_OUT
+
+at 0x0000016c : */	0x18000000,0x000004d0,
+/*
+	MOVE FROM dsa_dataout+0x00b0, WHEN DATA_OUT
+
+at 0x0000016e : */	0x18000000,0x000004d8,
+/*
+	MOVE FROM dsa_dataout+0x00b8, WHEN DATA_OUT
+
+at 0x00000170 : */	0x18000000,0x000004e0,
+/*
+	MOVE FROM dsa_dataout+0x00c0, WHEN DATA_OUT
+
+at 0x00000172 : */	0x18000000,0x000004e8,
+/*
+	MOVE FROM dsa_dataout+0x00c8, WHEN DATA_OUT
+
+at 0x00000174 : */	0x18000000,0x000004f0,
+/*
+	MOVE FROM dsa_dataout+0x00d0, WHEN DATA_OUT
+
+at 0x00000176 : */	0x18000000,0x000004f8,
+/*
+	MOVE FROM dsa_dataout+0x00d8, WHEN DATA_OUT
+
+at 0x00000178 : */	0x18000000,0x00000500,
+/*
+	MOVE FROM dsa_dataout+0x00e0, WHEN DATA_OUT
+
+at 0x0000017a : */	0x18000000,0x00000508,
+/*
+	MOVE FROM dsa_dataout+0x00e8, WHEN DATA_OUT
+
+at 0x0000017c : */	0x18000000,0x00000510,
+/*
+	MOVE FROM dsa_dataout+0x00f0, WHEN DATA_OUT
+
+at 0x0000017e : */	0x18000000,0x00000518,
+/*
+	MOVE FROM dsa_dataout+0x00f8, WHEN DATA_OUT
+
+at 0x00000180 : */	0x18000000,0x00000520,
+/*
+	MOVE FROM dsa_dataout+0x0100, WHEN DATA_OUT
+
+at 0x00000182 : */	0x18000000,0x00000528,
+/*
+	MOVE FROM dsa_dataout+0x0108, WHEN DATA_OUT
+
+at 0x00000184 : */	0x18000000,0x00000530,
+/*
+	MOVE FROM dsa_dataout+0x0110, WHEN DATA_OUT
+
+at 0x00000186 : */	0x18000000,0x00000538,
+/*
+	MOVE FROM dsa_dataout+0x0118, WHEN DATA_OUT
+
+at 0x00000188 : */	0x18000000,0x00000540,
+/*
+	MOVE FROM dsa_dataout+0x0120, WHEN DATA_OUT
+
+at 0x0000018a : */	0x18000000,0x00000548,
+/*
+	MOVE FROM dsa_dataout+0x0128, WHEN DATA_OUT
+
+at 0x0000018c : */	0x18000000,0x00000550,
+/*
+	MOVE FROM dsa_dataout+0x0130, WHEN DATA_OUT
+
+at 0x0000018e : */	0x18000000,0x00000558,
+/*
+	MOVE FROM dsa_dataout+0x0138, WHEN DATA_OUT
+
+at 0x00000190 : */	0x18000000,0x00000560,
+/*
+	MOVE FROM dsa_dataout+0x0140, WHEN DATA_OUT
+
+at 0x00000192 : */	0x18000000,0x00000568,
+/*
+	MOVE FROM dsa_dataout+0x0148, WHEN DATA_OUT
+
+at 0x00000194 : */	0x18000000,0x00000570,
+/*
+	MOVE FROM dsa_dataout+0x0150, WHEN DATA_OUT
+
+at 0x00000196 : */	0x18000000,0x00000578,
+/*
+	MOVE FROM dsa_dataout+0x0158, WHEN DATA_OUT
+
+at 0x00000198 : */	0x18000000,0x00000580,
+/*
+	MOVE FROM dsa_dataout+0x0160, WHEN DATA_OUT
+
+at 0x0000019a : */	0x18000000,0x00000588,
+/*
+	MOVE FROM dsa_dataout+0x0168, WHEN DATA_OUT
+
+at 0x0000019c : */	0x18000000,0x00000590,
+/*
+	MOVE FROM dsa_dataout+0x0170, WHEN DATA_OUT
+
+at 0x0000019e : */	0x18000000,0x00000598,
+/*
+	MOVE FROM dsa_dataout+0x0178, WHEN DATA_OUT
+
+at 0x000001a0 : */	0x18000000,0x000005a0,
+/*
+	MOVE FROM dsa_dataout+0x0180, WHEN DATA_OUT
+
+at 0x000001a2 : */	0x18000000,0x000005a8,
+/*
+	MOVE FROM dsa_dataout+0x0188, WHEN DATA_OUT
+
+at 0x000001a4 : */	0x18000000,0x000005b0,
+/*
+	MOVE FROM dsa_dataout+0x0190, WHEN DATA_OUT
+
+at 0x000001a6 : */	0x18000000,0x000005b8,
+/*
+	MOVE FROM dsa_dataout+0x0198, WHEN DATA_OUT
+
+at 0x000001a8 : */	0x18000000,0x000005c0,
+/*
+	MOVE FROM dsa_dataout+0x01a0, WHEN DATA_OUT
+
+at 0x000001aa : */	0x18000000,0x000005c8,
+/*
+	MOVE FROM dsa_dataout+0x01a8, WHEN DATA_OUT
+
+at 0x000001ac : */	0x18000000,0x000005d0,
+/*
+	MOVE FROM dsa_dataout+0x01b0, WHEN DATA_OUT
+
+at 0x000001ae : */	0x18000000,0x000005d8,
+/*
+	MOVE FROM dsa_dataout+0x01b8, WHEN DATA_OUT
+
+at 0x000001b0 : */	0x18000000,0x000005e0,
+/*
+	MOVE FROM dsa_dataout+0x01c0, WHEN DATA_OUT
+
+at 0x000001b2 : */	0x18000000,0x000005e8,
+/*
+	MOVE FROM dsa_dataout+0x01c8, WHEN DATA_OUT
+
+at 0x000001b4 : */	0x18000000,0x000005f0,
+/*
+	MOVE FROM dsa_dataout+0x01d0, WHEN DATA_OUT
+
+at 0x000001b6 : */	0x18000000,0x000005f8,
+/*
+	MOVE FROM dsa_dataout+0x01d8, WHEN DATA_OUT
+
+at 0x000001b8 : */	0x18000000,0x00000600,
+/*
+	MOVE FROM dsa_dataout+0x01e0, WHEN DATA_OUT
+
+at 0x000001ba : */	0x18000000,0x00000608,
+/*
+	MOVE FROM dsa_dataout+0x01e8, WHEN DATA_OUT
+
+at 0x000001bc : */	0x18000000,0x00000610,
+/*
+	MOVE FROM dsa_dataout+0x01f0, WHEN DATA_OUT
+
+at 0x000001be : */	0x18000000,0x00000618,
+/*
+	MOVE FROM dsa_dataout+0x01f8, WHEN DATA_OUT
+
+at 0x000001c0 : */	0x18000000,0x00000620,
+/*
+	MOVE FROM dsa_dataout+0x0200, WHEN DATA_OUT
+
+at 0x000001c2 : */	0x18000000,0x00000628,
+/*
+	MOVE FROM dsa_dataout+0x0208, WHEN DATA_OUT
+
+at 0x000001c4 : */	0x18000000,0x00000630,
+/*
+	MOVE FROM dsa_dataout+0x0210, WHEN DATA_OUT
+
+at 0x000001c6 : */	0x18000000,0x00000638,
+/*
+	MOVE FROM dsa_dataout+0x0218, WHEN DATA_OUT
+
+at 0x000001c8 : */	0x18000000,0x00000640,
+/*
+	MOVE FROM dsa_dataout+0x0220, WHEN DATA_OUT
+
+at 0x000001ca : */	0x18000000,0x00000648,
+/*
+	MOVE FROM dsa_dataout+0x0228, WHEN DATA_OUT
+
+at 0x000001cc : */	0x18000000,0x00000650,
+/*
+	MOVE FROM dsa_dataout+0x0230, WHEN DATA_OUT
+
+at 0x000001ce : */	0x18000000,0x00000658,
+/*
+	MOVE FROM dsa_dataout+0x0238, WHEN DATA_OUT
+
+at 0x000001d0 : */	0x18000000,0x00000660,
+/*
+	MOVE FROM dsa_dataout+0x0240, WHEN DATA_OUT
+
+at 0x000001d2 : */	0x18000000,0x00000668,
+/*
+	MOVE FROM dsa_dataout+0x0248, WHEN DATA_OUT
+
+at 0x000001d4 : */	0x18000000,0x00000670,
+/*
+	MOVE FROM dsa_dataout+0x0250, WHEN DATA_OUT
+
+at 0x000001d6 : */	0x18000000,0x00000678,
+/*
+	MOVE FROM dsa_dataout+0x0258, WHEN DATA_OUT
+
+at 0x000001d8 : */	0x18000000,0x00000680,
+/*
+	MOVE FROM dsa_dataout+0x0260, WHEN DATA_OUT
+
+at 0x000001da : */	0x18000000,0x00000688,
+/*
+	MOVE FROM dsa_dataout+0x0268, WHEN DATA_OUT
+
+at 0x000001dc : */	0x18000000,0x00000690,
+/*
+	MOVE FROM dsa_dataout+0x0270, WHEN DATA_OUT
+
+at 0x000001de : */	0x18000000,0x00000698,
+/*
+	MOVE FROM dsa_dataout+0x0278, WHEN DATA_OUT
+
+at 0x000001e0 : */	0x18000000,0x000006a0,
+/*
+	MOVE FROM dsa_dataout+0x0280, WHEN DATA_OUT
+
+at 0x000001e2 : */	0x18000000,0x000006a8,
+/*
+	MOVE FROM dsa_dataout+0x0288, WHEN DATA_OUT
+
+at 0x000001e4 : */	0x18000000,0x000006b0,
+/*
+	MOVE FROM dsa_dataout+0x0290, WHEN DATA_OUT
+
+at 0x000001e6 : */	0x18000000,0x000006b8,
+/*
+	MOVE FROM dsa_dataout+0x0298, WHEN DATA_OUT
+
+at 0x000001e8 : */	0x18000000,0x000006c0,
+/*
+	MOVE FROM dsa_dataout+0x02a0, WHEN DATA_OUT
+
+at 0x000001ea : */	0x18000000,0x000006c8,
+/*
+	MOVE FROM dsa_dataout+0x02a8, WHEN DATA_OUT
+
+at 0x000001ec : */	0x18000000,0x000006d0,
+/*
+	MOVE FROM dsa_dataout+0x02b0, WHEN DATA_OUT
+
+at 0x000001ee : */	0x18000000,0x000006d8,
+/*
+	MOVE FROM dsa_dataout+0x02b8, WHEN DATA_OUT
+
+at 0x000001f0 : */	0x18000000,0x000006e0,
+/*
+	MOVE FROM dsa_dataout+0x02c0, WHEN DATA_OUT
+
+at 0x000001f2 : */	0x18000000,0x000006e8,
+/*
+	MOVE FROM dsa_dataout+0x02c8, WHEN DATA_OUT
+
+at 0x000001f4 : */	0x18000000,0x000006f0,
+/*
+	MOVE FROM dsa_dataout+0x02d0, WHEN DATA_OUT
+
+at 0x000001f6 : */	0x18000000,0x000006f8,
+/*
+	MOVE FROM dsa_dataout+0x02d8, WHEN DATA_OUT
+
+at 0x000001f8 : */	0x18000000,0x00000700,
+/*
+	MOVE FROM dsa_dataout+0x02e0, WHEN DATA_OUT
+
+at 0x000001fa : */	0x18000000,0x00000708,
+/*
+	MOVE FROM dsa_dataout+0x02e8, WHEN DATA_OUT
+
+at 0x000001fc : */	0x18000000,0x00000710,
+/*
+	MOVE FROM dsa_dataout+0x02f0, WHEN DATA_OUT
+
+at 0x000001fe : */	0x18000000,0x00000718,
+/*
+	MOVE FROM dsa_dataout+0x02f8, WHEN DATA_OUT
+
+at 0x00000200 : */	0x18000000,0x00000720,
+/*
+	MOVE FROM dsa_dataout+0x0300, WHEN DATA_OUT
+
+at 0x00000202 : */	0x18000000,0x00000728,
+/*
+	MOVE FROM dsa_dataout+0x0308, WHEN DATA_OUT
+
+at 0x00000204 : */	0x18000000,0x00000730,
+/*
+	MOVE FROM dsa_dataout+0x0310, WHEN DATA_OUT
+
+at 0x00000206 : */	0x18000000,0x00000738,
+/*
+	MOVE FROM dsa_dataout+0x0318, WHEN DATA_OUT
+
+at 0x00000208 : */	0x18000000,0x00000740,
+/*
+	MOVE FROM dsa_dataout+0x0320, WHEN DATA_OUT
+
+at 0x0000020a : */	0x18000000,0x00000748,
+/*
+	MOVE FROM dsa_dataout+0x0328, WHEN DATA_OUT
+
+at 0x0000020c : */	0x18000000,0x00000750,
+/*
+	MOVE FROM dsa_dataout+0x0330, WHEN DATA_OUT
+
+at 0x0000020e : */	0x18000000,0x00000758,
+/*
+	MOVE FROM dsa_dataout+0x0338, WHEN DATA_OUT
+
+at 0x00000210 : */	0x18000000,0x00000760,
+/*
+	MOVE FROM dsa_dataout+0x0340, WHEN DATA_OUT
+
+at 0x00000212 : */	0x18000000,0x00000768,
+/*
+	MOVE FROM dsa_dataout+0x0348, WHEN DATA_OUT
+
+at 0x00000214 : */	0x18000000,0x00000770,
+/*
+	MOVE FROM dsa_dataout+0x0350, WHEN DATA_OUT
+
+at 0x00000216 : */	0x18000000,0x00000778,
+/*
+	MOVE FROM dsa_dataout+0x0358, WHEN DATA_OUT
+
+at 0x00000218 : */	0x18000000,0x00000780,
+/*
+	MOVE FROM dsa_dataout+0x0360, WHEN DATA_OUT
+
+at 0x0000021a : */	0x18000000,0x00000788,
+/*
+	MOVE FROM dsa_dataout+0x0368, WHEN DATA_OUT
+
+at 0x0000021c : */	0x18000000,0x00000790,
+/*
+	MOVE FROM dsa_dataout+0x0370, WHEN DATA_OUT
+
+at 0x0000021e : */	0x18000000,0x00000798,
+/*
+	MOVE FROM dsa_dataout+0x0378, WHEN DATA_OUT
+
+at 0x00000220 : */	0x18000000,0x000007a0,
+/*
+	MOVE FROM dsa_dataout+0x0380, WHEN DATA_OUT
+
+at 0x00000222 : */	0x18000000,0x000007a8,
+/*
+	MOVE FROM dsa_dataout+0x0388, WHEN DATA_OUT
+
+at 0x00000224 : */	0x18000000,0x000007b0,
+/*
+	MOVE FROM dsa_dataout+0x0390, WHEN DATA_OUT
+
+at 0x00000226 : */	0x18000000,0x000007b8,
+/*
+	MOVE FROM dsa_dataout+0x0398, WHEN DATA_OUT
+
+at 0x00000228 : */	0x18000000,0x000007c0,
+/*
+	MOVE FROM dsa_dataout+0x03a0, WHEN DATA_OUT
+
+at 0x0000022a : */	0x18000000,0x000007c8,
+/*
+	MOVE FROM dsa_dataout+0x03a8, WHEN DATA_OUT
+
+at 0x0000022c : */	0x18000000,0x000007d0,
+/*
+	MOVE FROM dsa_dataout+0x03b0, WHEN DATA_OUT
+
+at 0x0000022e : */	0x18000000,0x000007d8,
+/*
+	MOVE FROM dsa_dataout+0x03b8, WHEN DATA_OUT
+
+at 0x00000230 : */	0x18000000,0x000007e0,
+/*
+	MOVE FROM dsa_dataout+0x03c0, WHEN DATA_OUT
+
+at 0x00000232 : */	0x18000000,0x000007e8,
+/*
+	MOVE FROM dsa_dataout+0x03c8, WHEN DATA_OUT
+
+at 0x00000234 : */	0x18000000,0x000007f0,
+/*
+	MOVE FROM dsa_dataout+0x03d0, WHEN DATA_OUT
+
+at 0x00000236 : */	0x18000000,0x000007f8,
+/*
+	MOVE FROM dsa_dataout+0x03d8, WHEN DATA_OUT
+
+at 0x00000238 : */	0x18000000,0x00000800,
+/*
+	MOVE FROM dsa_dataout+0x03e0, WHEN DATA_OUT
+
+at 0x0000023a : */	0x18000000,0x00000808,
+/*
+	MOVE FROM dsa_dataout+0x03e8, WHEN DATA_OUT
+
+at 0x0000023c : */	0x18000000,0x00000810,
+/*
+	MOVE FROM dsa_dataout+0x03f0, WHEN DATA_OUT
+
+at 0x0000023e : */	0x18000000,0x00000818,
+/*
+	MOVE FROM dsa_dataout+0x03f8, WHEN DATA_OUT
+
+at 0x00000240 : */	0x18000000,0x00000820,
+/*
+ENTRY end_data_trans
+end_data_trans:
+redo_msgin3:
+	JUMP get_status, WHEN STATUS
+
+at 0x00000242 : */	0x830b0000,0x000000a0,
+/*
+	JUMP get_msgin3, WHEN MSG_IN
+
+at 0x00000244 : */	0x870b0000,0x00000b20,
+/*
+	INT int_data_bad_phase
+
+at 0x00000246 : */	0x98080000,0xab93000b,
+/*
+
+get_msgin1:
+	MOVE SCRATCH0 | had_msgin TO SCRATCH0
+
+at 0x00000248 : */	0x7a344000,0x00000000,
+/*
+	MOVE 1, msgin_buf, WHEN MSG_IN
+
+at 0x0000024a : */	0x0f000001,0x00000000,
+/*
+	JUMP ext_msg1, IF 0x01		; Extended Message
+
+at 0x0000024c : */	0x800c0001,0x00000968,
+/*
+	JUMP ignore_msg1, IF 0x02	; Save Data Pointers
+
+at 0x0000024e : */	0x800c0002,0x00000958,
+/*
+	JUMP ignore_msg1, IF 0x03	; Save Restore Pointers
+
+at 0x00000250 : */	0x800c0003,0x00000958,
+/*
+	JUMP disc1, IF 0x04		; Disconnect
+
+at 0x00000252 : */	0x800c0004,0x000009c8,
+/*
+	INT int_bad_msg1
+
+at 0x00000254 : */	0x98080000,0xab930006,
+/*
+ignore_msg1:
+	CLEAR ACK
+
+at 0x00000256 : */	0x60000040,0x00000000,
+/*
+	JUMP redo_msgin1
+
+at 0x00000258 : */	0x80080000,0x00000058,
+/*
+ext_msg1:
+	MOVE SCRATCH0 | had_extmsg TO SCRATCH0
+
+at 0x0000025a : */	0x7a348000,0x00000000,
+/*
+	CLEAR ACK
+
+at 0x0000025c : */	0x60000040,0x00000000,
+/*
+	MOVE 1, msgin_buf + 1, WHEN MSG_IN
+
+at 0x0000025e : */	0x0f000001,0x00000001,
+/*
+	JUMP ext_msg1a, IF 0x03
+
+at 0x00000260 : */	0x800c0003,0x00000990,
+/*
+	INT int_bad_extmsg1a
+
+at 0x00000262 : */	0x98080000,0xab930000,
+/*
+ext_msg1a:
+	CLEAR ACK
+
+at 0x00000264 : */	0x60000040,0x00000000,
+/*
+	MOVE 1, msgin_buf + 2, WHEN MSG_IN
+
+at 0x00000266 : */	0x0f000001,0x00000002,
+/*
+	JUMP ext_msg1b, IF 0x01		; Must be SDTR
+
+at 0x00000268 : */	0x800c0001,0x000009b0,
+/*
+	INT int_bad_extmsg1b
+
+at 0x0000026a : */	0x98080000,0xab930001,
+/*
+ext_msg1b:
+	CLEAR ACK
+
+at 0x0000026c : */	0x60000040,0x00000000,
+/*
+	MOVE 2, msgin_buf + 3, WHEN MSG_IN
+
+at 0x0000026e : */	0x0f000002,0x00000003,
+/*
+	INT int_msg_sdtr1
+
+at 0x00000270 : */	0x98080000,0xab93000c,
+/*
+disc1:
+	CLEAR ACK
+
+at 0x00000272 : */	0x60000040,0x00000000,
+/*
+ENTRY wait_disc1
+wait_disc1:
+	WAIT DISCONNECT
+
+at 0x00000274 : */	0x48000000,0x00000000,
+/*
+	INT int_disc1
+
+at 0x00000276 : */	0x98080000,0xab930019,
+/*
+ENTRY resume_msgin1a
+resume_msgin1a:
+	CLEAR ACK
+
+at 0x00000278 : */	0x60000040,0x00000000,
+/*
+	JUMP redo_msgin1
+
+at 0x0000027a : */	0x80080000,0x00000058,
+/*
+ENTRY resume_msgin1b
+resume_msgin1b:
+	SET ATN
+
+at 0x0000027c : */	0x58000008,0x00000000,
+/*
+	CLEAR ACK
+
+at 0x0000027e : */	0x60000040,0x00000000,
+/*
+	INT int_no_msgout1, WHEN NOT MSG_OUT
+
+at 0x00000280 : */	0x9e030000,0xab93000f,
+/*
+	MOVE SCRATCH0 | had_msgout TO SCRATCH0
+
+at 0x00000282 : */	0x7a340200,0x00000000,
+/*
+	MOVE FROM dsa_msgout, when MSG_OUT
+
+at 0x00000284 : */	0x1e000000,0x00000008,
+/*
+	JUMP redo_msgin1
+
+at 0x00000286 : */	0x80080000,0x00000058,
+/*
+
+get_msgin2:
+	MOVE SCRATCH0 | had_msgin TO SCRATCH0
+
+at 0x00000288 : */	0x7a344000,0x00000000,
+/*
+	MOVE 1, msgin_buf, WHEN MSG_IN
+
+at 0x0000028a : */	0x0f000001,0x00000000,
+/*
+	JUMP ext_msg2, IF 0x01		; Extended Message
+
+at 0x0000028c : */	0x800c0001,0x00000a68,
+/*
+	JUMP ignore_msg2, IF 0x02	; Save Data Pointers
+
+at 0x0000028e : */	0x800c0002,0x00000a58,
+/*
+	JUMP ignore_msg2, IF 0x03	; Save Restore Pointers
+
+at 0x00000290 : */	0x800c0003,0x00000a58,
+/*
+	JUMP disc2, IF 0x04		; Disconnect
+
+at 0x00000292 : */	0x800c0004,0x00000ac8,
+/*
+	INT int_bad_msg2
+
+at 0x00000294 : */	0x98080000,0xab930007,
+/*
+ignore_msg2:
+	CLEAR ACK
+
+at 0x00000296 : */	0x60000040,0x00000000,
+/*
+	JUMP redo_msgin2
+
+at 0x00000298 : */	0x80080000,0x00000078,
+/*
+ext_msg2:
+	MOVE SCRATCH0 | had_extmsg TO SCRATCH0
+
+at 0x0000029a : */	0x7a348000,0x00000000,
+/*
+	CLEAR ACK
+
+at 0x0000029c : */	0x60000040,0x00000000,
+/*
+	MOVE 1, msgin_buf + 1, WHEN MSG_IN
+
+at 0x0000029e : */	0x0f000001,0x00000001,
+/*
+	JUMP ext_msg2a, IF 0x03
+
+at 0x000002a0 : */	0x800c0003,0x00000a90,
+/*
+	INT int_bad_extmsg2a
+
+at 0x000002a2 : */	0x98080000,0xab930002,
+/*
+ext_msg2a:
+	CLEAR ACK
+
+at 0x000002a4 : */	0x60000040,0x00000000,
+/*
+	MOVE 1, msgin_buf + 2, WHEN MSG_IN
+
+at 0x000002a6 : */	0x0f000001,0x00000002,
+/*
+	JUMP ext_msg2b, IF 0x01		; Must be SDTR
+
+at 0x000002a8 : */	0x800c0001,0x00000ab0,
+/*
+	INT int_bad_extmsg2b
+
+at 0x000002aa : */	0x98080000,0xab930003,
+/*
+ext_msg2b:
+	CLEAR ACK
+
+at 0x000002ac : */	0x60000040,0x00000000,
+/*
+	MOVE 2, msgin_buf + 3, WHEN MSG_IN
+
+at 0x000002ae : */	0x0f000002,0x00000003,
+/*
+	INT int_msg_sdtr2
+
+at 0x000002b0 : */	0x98080000,0xab93000d,
+/*
+disc2:
+	CLEAR ACK
+
+at 0x000002b2 : */	0x60000040,0x00000000,
+/*
+ENTRY wait_disc2
+wait_disc2:
+	WAIT DISCONNECT
+
+at 0x000002b4 : */	0x48000000,0x00000000,
+/*
+	INT int_disc2
+
+at 0x000002b6 : */	0x98080000,0xab93001a,
+/*
+ENTRY resume_msgin2a
+resume_msgin2a:
+	CLEAR ACK
+
+at 0x000002b8 : */	0x60000040,0x00000000,
+/*
+	JUMP redo_msgin2
+
+at 0x000002ba : */	0x80080000,0x00000078,
+/*
+ENTRY resume_msgin2b
+resume_msgin2b:
+	SET ATN
+
+at 0x000002bc : */	0x58000008,0x00000000,
+/*
+	CLEAR ACK
+
+at 0x000002be : */	0x60000040,0x00000000,
+/*
+	INT int_no_msgout2, WHEN NOT MSG_OUT
+
+at 0x000002c0 : */	0x9e030000,0xab930010,
+/*
+	MOVE SCRATCH0 | had_msgout TO SCRATCH0
+
+at 0x000002c2 : */	0x7a340200,0x00000000,
+/*
+	MOVE FROM dsa_msgout, when MSG_OUT
+
+at 0x000002c4 : */	0x1e000000,0x00000008,
+/*
+	JUMP redo_msgin2
+
+at 0x000002c6 : */	0x80080000,0x00000078,
+/*
+
+get_msgin3:
+	MOVE SCRATCH0 | had_msgin TO SCRATCH0
+
+at 0x000002c8 : */	0x7a344000,0x00000000,
+/*
+	MOVE 1, msgin_buf, WHEN MSG_IN
+
+at 0x000002ca : */	0x0f000001,0x00000000,
+/*
+	JUMP ext_msg3, IF 0x01		; Extended Message
+
+at 0x000002cc : */	0x800c0001,0x00000b68,
+/*
+	JUMP ignore_msg3, IF 0x02	; Save Data Pointers
+
+at 0x000002ce : */	0x800c0002,0x00000b58,
+/*
+	JUMP ignore_msg3, IF 0x03	; Save Restore Pointers
+
+at 0x000002d0 : */	0x800c0003,0x00000b58,
+/*
+	JUMP disc3, IF 0x04		; Disconnect
+
+at 0x000002d2 : */	0x800c0004,0x00000bc8,
+/*
+	INT int_bad_msg3
+
+at 0x000002d4 : */	0x98080000,0xab930008,
+/*
+ignore_msg3:
+	CLEAR ACK
+
+at 0x000002d6 : */	0x60000040,0x00000000,
+/*
+	JUMP redo_msgin3
+
+at 0x000002d8 : */	0x80080000,0x00000908,
+/*
+ext_msg3:
+	MOVE SCRATCH0 | had_extmsg TO SCRATCH0
+
+at 0x000002da : */	0x7a348000,0x00000000,
+/*
+	CLEAR ACK
+
+at 0x000002dc : */	0x60000040,0x00000000,
+/*
+	MOVE 1, msgin_buf + 1, WHEN MSG_IN
+
+at 0x000002de : */	0x0f000001,0x00000001,
+/*
+	JUMP ext_msg3a, IF 0x03
+
+at 0x000002e0 : */	0x800c0003,0x00000b90,
+/*
+	INT int_bad_extmsg3a
+
+at 0x000002e2 : */	0x98080000,0xab930004,
+/*
+ext_msg3a:
+	CLEAR ACK
+
+at 0x000002e4 : */	0x60000040,0x00000000,
+/*
+	MOVE 1, msgin_buf + 2, WHEN MSG_IN
+
+at 0x000002e6 : */	0x0f000001,0x00000002,
+/*
+	JUMP ext_msg3b, IF 0x01		; Must be SDTR
+
+at 0x000002e8 : */	0x800c0001,0x00000bb0,
+/*
+	INT int_bad_extmsg3b
+
+at 0x000002ea : */	0x98080000,0xab930005,
+/*
+ext_msg3b:
+	CLEAR ACK
+
+at 0x000002ec : */	0x60000040,0x00000000,
+/*
+	MOVE 2, msgin_buf + 3, WHEN MSG_IN
+
+at 0x000002ee : */	0x0f000002,0x00000003,
+/*
+	INT int_msg_sdtr3
+
+at 0x000002f0 : */	0x98080000,0xab93000e,
+/*
+disc3:
+	CLEAR ACK
+
+at 0x000002f2 : */	0x60000040,0x00000000,
+/*
+ENTRY wait_disc3
+wait_disc3:
+	WAIT DISCONNECT
+
+at 0x000002f4 : */	0x48000000,0x00000000,
+/*
+	INT int_disc3
+
+at 0x000002f6 : */	0x98080000,0xab93001b,
+/*
+ENTRY resume_msgin3a
+resume_msgin3a:
+	CLEAR ACK
+
+at 0x000002f8 : */	0x60000040,0x00000000,
+/*
+	JUMP redo_msgin3
+
+at 0x000002fa : */	0x80080000,0x00000908,
+/*
+ENTRY resume_msgin3b
+resume_msgin3b:
+	SET ATN
+
+at 0x000002fc : */	0x58000008,0x00000000,
+/*
+	CLEAR ACK
+
+at 0x000002fe : */	0x60000040,0x00000000,
+/*
+	INT int_no_msgout3, WHEN NOT MSG_OUT
+
+at 0x00000300 : */	0x9e030000,0xab930011,
+/*
+	MOVE SCRATCH0 | had_msgout TO SCRATCH0
+
+at 0x00000302 : */	0x7a340200,0x00000000,
+/*
+	MOVE FROM dsa_msgout, when MSG_OUT
+
+at 0x00000304 : */	0x1e000000,0x00000008,
+/*
+	JUMP redo_msgin3
+
+at 0x00000306 : */	0x80080000,0x00000908,
+/*
+
+ENTRY resume_rej_ident
+resume_rej_ident:
+	CLEAR ATN
+
+at 0x00000308 : */	0x60000008,0x00000000,
+/*
+	MOVE 1, msgin_buf, WHEN MSG_IN
+
+at 0x0000030a : */	0x0f000001,0x00000000,
+/*
+	INT int_not_rej, IF NOT 0x07		; Reject
+
+at 0x0000030c : */	0x98040007,0xab93001c,
+/*
+	CLEAR ACK
+
+at 0x0000030e : */	0x60000040,0x00000000,
+/*
+	JUMP done_ident
+
+at 0x00000310 : */	0x80080000,0x00000050,
+/*
+
+ENTRY reselect
+reselect:
+	; Disable selection timer
+	MOVE CTEST7 | 0x10 TO CTEST7
+
+at 0x00000312 : */	0x7a1b1000,0x00000000,
+/*
+	WAIT RESELECT resel_err
+
+at 0x00000314 : */	0x50000000,0x00000c70,
+/*
+	INT int_resel_not_msgin, WHEN NOT MSG_IN
+
+at 0x00000316 : */	0x9f030000,0xab930016,
+/*
+	MOVE 1, reselected_identify, WHEN MSG_IN
+
+at 0x00000318 : */	0x0f000001,0x00000000,
+/*
+	INT int_reselected
+
+at 0x0000031a : */	0x98080000,0xab930017,
+/*
+resel_err:
+	MOVE CTEST2 & 0x40 TO SFBR
+
+at 0x0000031c : */	0x74164000,0x00000000,
+/*
+	JUMP selected, IF 0x00
+
+at 0x0000031e : */	0x800c0000,0x00000cb0,
+/*
+	MOVE SFBR & 0 TO SFBR
+
+at 0x00000320 : */	0x7c080000,0x00000000,
+/*
+ENTRY patch_new_dsa
+patch_new_dsa:
+	MOVE SFBR | 0x11 TO DSA0
+
+at 0x00000322 : */	0x6a101100,0x00000000,
+/*
+	MOVE SFBR | 0x22 TO DSA1
+
+at 0x00000324 : */	0x6a112200,0x00000000,
+/*
+	MOVE SFBR | 0x33 TO DSA2
+
+at 0x00000326 : */	0x6a123300,0x00000000,
+/*
+	MOVE SFBR | 0x44 TO DSA3
+
+at 0x00000328 : */	0x6a134400,0x00000000,
+/*
+	JUMP do_select
+
+at 0x0000032a : */	0x80080000,0x00000000,
+/*
+
+selected:
+	INT int_selected
+
+at 0x0000032c : */	0x98080000,0xab930018,
+};
+
+#define A_dsa_cmnd	0x00000010
+static u32 A_dsa_cmnd_used[] __attribute((unused)) = {
+	0x0000001d,
+};
+
+#define A_dsa_datain	0x00000028
+static u32 A_dsa_datain_used[] __attribute((unused)) = {
+	0x0000003d,
+	0x0000003f,
+	0x00000041,
+	0x00000043,
+	0x00000045,
+	0x00000047,
+	0x00000049,
+	0x0000004b,
+	0x0000004d,
+	0x0000004f,
+	0x00000051,
+	0x00000053,
+	0x00000055,
+	0x00000057,
+	0x00000059,
+	0x0000005b,
+	0x0000005d,
+	0x0000005f,
+	0x00000061,
+	0x00000063,
+	0x00000065,
+	0x00000067,
+	0x00000069,
+	0x0000006b,
+	0x0000006d,
+	0x0000006f,
+	0x00000071,
+	0x00000073,
+	0x00000075,
+	0x00000077,
+	0x00000079,
+	0x0000007b,
+	0x0000007d,
+	0x0000007f,
+	0x00000081,
+	0x00000083,
+	0x00000085,
+	0x00000087,
+	0x00000089,
+	0x0000008b,
+	0x0000008d,
+	0x0000008f,
+	0x00000091,
+	0x00000093,
+	0x00000095,
+	0x00000097,
+	0x00000099,
+	0x0000009b,
+	0x0000009d,
+	0x0000009f,
+	0x000000a1,
+	0x000000a3,
+	0x000000a5,
+	0x000000a7,
+	0x000000a9,
+	0x000000ab,
+	0x000000ad,
+	0x000000af,
+	0x000000b1,
+	0x000000b3,
+	0x000000b5,
+	0x000000b7,
+	0x000000b9,
+	0x000000bb,
+	0x000000bd,
+	0x000000bf,
+	0x000000c1,
+	0x000000c3,
+	0x000000c5,
+	0x000000c7,
+	0x000000c9,
+	0x000000cb,
+	0x000000cd,
+	0x000000cf,
+	0x000000d1,
+	0x000000d3,
+	0x000000d5,
+	0x000000d7,
+	0x000000d9,
+	0x000000db,
+	0x000000dd,
+	0x000000df,
+	0x000000e1,
+	0x000000e3,
+	0x000000e5,
+	0x000000e7,
+	0x000000e9,
+	0x000000eb,
+	0x000000ed,
+	0x000000ef,
+	0x000000f1,
+	0x000000f3,
+	0x000000f5,
+	0x000000f7,
+	0x000000f9,
+	0x000000fb,
+	0x000000fd,
+	0x000000ff,
+	0x00000101,
+	0x00000103,
+	0x00000105,
+	0x00000107,
+	0x00000109,
+	0x0000010b,
+	0x0000010d,
+	0x0000010f,
+	0x00000111,
+	0x00000113,
+	0x00000115,
+	0x00000117,
+	0x00000119,
+	0x0000011b,
+	0x0000011d,
+	0x0000011f,
+	0x00000121,
+	0x00000123,
+	0x00000125,
+	0x00000127,
+	0x00000129,
+	0x0000012b,
+	0x0000012d,
+	0x0000012f,
+	0x00000131,
+	0x00000133,
+	0x00000135,
+	0x00000137,
+	0x00000139,
+	0x0000013b,
+};
+
+#define A_dsa_dataout	0x00000428
+static u32 A_dsa_dataout_used[] __attribute((unused)) = {
+	0x00000143,
+	0x00000145,
+	0x00000147,
+	0x00000149,
+	0x0000014b,
+	0x0000014d,
+	0x0000014f,
+	0x00000151,
+	0x00000153,
+	0x00000155,
+	0x00000157,
+	0x00000159,
+	0x0000015b,
+	0x0000015d,
+	0x0000015f,
+	0x00000161,
+	0x00000163,
+	0x00000165,
+	0x00000167,
+	0x00000169,
+	0x0000016b,
+	0x0000016d,
+	0x0000016f,
+	0x00000171,
+	0x00000173,
+	0x00000175,
+	0x00000177,
+	0x00000179,
+	0x0000017b,
+	0x0000017d,
+	0x0000017f,
+	0x00000181,
+	0x00000183,
+	0x00000185,
+	0x00000187,
+	0x00000189,
+	0x0000018b,
+	0x0000018d,
+	0x0000018f,
+	0x00000191,
+	0x00000193,
+	0x00000195,
+	0x00000197,
+	0x00000199,
+	0x0000019b,
+	0x0000019d,
+	0x0000019f,
+	0x000001a1,
+	0x000001a3,
+	0x000001a5,
+	0x000001a7,
+	0x000001a9,
+	0x000001ab,
+	0x000001ad,
+	0x000001af,
+	0x000001b1,
+	0x000001b3,
+	0x000001b5,
+	0x000001b7,
+	0x000001b9,
+	0x000001bb,
+	0x000001bd,
+	0x000001bf,
+	0x000001c1,
+	0x000001c3,
+	0x000001c5,
+	0x000001c7,
+	0x000001c9,
+	0x000001cb,
+	0x000001cd,
+	0x000001cf,
+	0x000001d1,
+	0x000001d3,
+	0x000001d5,
+	0x000001d7,
+	0x000001d9,
+	0x000001db,
+	0x000001dd,
+	0x000001df,
+	0x000001e1,
+	0x000001e3,
+	0x000001e5,
+	0x000001e7,
+	0x000001e9,
+	0x000001eb,
+	0x000001ed,
+	0x000001ef,
+	0x000001f1,
+	0x000001f3,
+	0x000001f5,
+	0x000001f7,
+	0x000001f9,
+	0x000001fb,
+	0x000001fd,
+	0x000001ff,
+	0x00000201,
+	0x00000203,
+	0x00000205,
+	0x00000207,
+	0x00000209,
+	0x0000020b,
+	0x0000020d,
+	0x0000020f,
+	0x00000211,
+	0x00000213,
+	0x00000215,
+	0x00000217,
+	0x00000219,
+	0x0000021b,
+	0x0000021d,
+	0x0000021f,
+	0x00000221,
+	0x00000223,
+	0x00000225,
+	0x00000227,
+	0x00000229,
+	0x0000022b,
+	0x0000022d,
+	0x0000022f,
+	0x00000231,
+	0x00000233,
+	0x00000235,
+	0x00000237,
+	0x00000239,
+	0x0000023b,
+	0x0000023d,
+	0x0000023f,
+	0x00000241,
+};
+
+#define A_dsa_msgin	0x00000020
+static u32 A_dsa_msgin_used[] __attribute((unused)) = {
+	0x0000002f,
+};
+
+#define A_dsa_msgout	0x00000008
+static u32 A_dsa_msgout_used[] __attribute((unused)) = {
+	0x00000013,
+	0x00000285,
+	0x000002c5,
+	0x00000305,
+};
+
+#define A_dsa_select	0x00000000
+static u32 A_dsa_select_used[] __attribute((unused)) = {
+	0x00000006,
+};
+
+#define A_dsa_size	0x00000828
+static u32 A_dsa_size_used[] __attribute((unused)) = {
+};
+
+#define A_dsa_status	0x00000018
+static u32 A_dsa_status_used[] __attribute((unused)) = {
+	0x0000002b,
+};
+
+#define A_had_cmdout	0x00000004
+static u32 A_had_cmdout_used[] __attribute((unused)) = {
+	0x0000001a,
+};
+
+#define A_had_datain	0x00000008
+static u32 A_had_datain_used[] __attribute((unused)) = {
+	0x00000038,
+};
+
+#define A_had_dataout	0x00000010
+static u32 A_had_dataout_used[] __attribute((unused)) = {
+	0x0000013e,
+};
+
+#define A_had_extmsg	0x00000080
+static u32 A_had_extmsg_used[] __attribute((unused)) = {
+	0x0000025a,
+	0x0000029a,
+	0x000002da,
+};
+
+#define A_had_msgin	0x00000040
+static u32 A_had_msgin_used[] __attribute((unused)) = {
+	0x00000248,
+	0x00000288,
+	0x000002c8,
+};
+
+#define A_had_msgout	0x00000002
+static u32 A_had_msgout_used[] __attribute((unused)) = {
+	0x00000010,
+	0x00000282,
+	0x000002c2,
+	0x00000302,
+};
+
+#define A_had_select	0x00000001
+static u32 A_had_select_used[] __attribute((unused)) = {
+	0x0000000c,
+};
+
+#define A_had_status	0x00000020
+static u32 A_had_status_used[] __attribute((unused)) = {
+};
+
+#define A_int_bad_extmsg1a	0xab930000
+static u32 A_int_bad_extmsg1a_used[] __attribute((unused)) = {
+	0x00000263,
+};
+
+#define A_int_bad_extmsg1b	0xab930001
+static u32 A_int_bad_extmsg1b_used[] __attribute((unused)) = {
+	0x0000026b,
+};
+
+#define A_int_bad_extmsg2a	0xab930002
+static u32 A_int_bad_extmsg2a_used[] __attribute((unused)) = {
+	0x000002a3,
+};
+
+#define A_int_bad_extmsg2b	0xab930003
+static u32 A_int_bad_extmsg2b_used[] __attribute((unused)) = {
+	0x000002ab,
+};
+
+#define A_int_bad_extmsg3a	0xab930004
+static u32 A_int_bad_extmsg3a_used[] __attribute((unused)) = {
+	0x000002e3,
+};
+
+#define A_int_bad_extmsg3b	0xab930005
+static u32 A_int_bad_extmsg3b_used[] __attribute((unused)) = {
+	0x000002eb,
+};
+
+#define A_int_bad_msg1	0xab930006
+static u32 A_int_bad_msg1_used[] __attribute((unused)) = {
+	0x00000255,
+};
+
+#define A_int_bad_msg2	0xab930007
+static u32 A_int_bad_msg2_used[] __attribute((unused)) = {
+	0x00000295,
+};
+
+#define A_int_bad_msg3	0xab930008
+static u32 A_int_bad_msg3_used[] __attribute((unused)) = {
+	0x000002d5,
+};
+
+#define A_int_cmd_bad_phase	0xab930009
+static u32 A_int_cmd_bad_phase_used[] __attribute((unused)) = {
+	0x00000027,
+};
+
+#define A_int_cmd_complete	0xab93000a
+static u32 A_int_cmd_complete_used[] __attribute((unused)) = {
+	0x00000037,
+};
+
+#define A_int_data_bad_phase	0xab93000b
+static u32 A_int_data_bad_phase_used[] __attribute((unused)) = {
+	0x00000247,
+};
+
+#define A_int_disc1	0xab930019
+static u32 A_int_disc1_used[] __attribute((unused)) = {
+	0x00000277,
+};
+
+#define A_int_disc2	0xab93001a
+static u32 A_int_disc2_used[] __attribute((unused)) = {
+	0x000002b7,
+};
+
+#define A_int_disc3	0xab93001b
+static u32 A_int_disc3_used[] __attribute((unused)) = {
+	0x000002f7,
+};
+
+#define A_int_msg_sdtr1	0xab93000c
+static u32 A_int_msg_sdtr1_used[] __attribute((unused)) = {
+	0x00000271,
+};
+
+#define A_int_msg_sdtr2	0xab93000d
+static u32 A_int_msg_sdtr2_used[] __attribute((unused)) = {
+	0x000002b1,
+};
+
+#define A_int_msg_sdtr3	0xab93000e
+static u32 A_int_msg_sdtr3_used[] __attribute((unused)) = {
+	0x000002f1,
+};
+
+#define A_int_no_msgout1	0xab93000f
+static u32 A_int_no_msgout1_used[] __attribute((unused)) = {
+	0x00000281,
+};
+
+#define A_int_no_msgout2	0xab930010
+static u32 A_int_no_msgout2_used[] __attribute((unused)) = {
+	0x000002c1,
+};
+
+#define A_int_no_msgout3	0xab930011
+static u32 A_int_no_msgout3_used[] __attribute((unused)) = {
+	0x00000301,
+};
+
+#define A_int_not_cmd_complete	0xab930012
+static u32 A_int_not_cmd_complete_used[] __attribute((unused)) = {
+	0x00000031,
+};
+
+#define A_int_not_rej	0xab93001c
+static u32 A_int_not_rej_used[] __attribute((unused)) = {
+	0x0000030d,
+};
+
+#define A_int_resel_not_msgin	0xab930016
+static u32 A_int_resel_not_msgin_used[] __attribute((unused)) = {
+	0x00000317,
+};
+
+#define A_int_reselected	0xab930017
+static u32 A_int_reselected_used[] __attribute((unused)) = {
+	0x0000031b,
+};
+
+#define A_int_sel_no_ident	0xab930013
+static u32 A_int_sel_no_ident_used[] __attribute((unused)) = {
+	0x0000000f,
+};
+
+#define A_int_sel_not_cmd	0xab930014
+static u32 A_int_sel_not_cmd_used[] __attribute((unused)) = {
+	0x00000019,
+};
+
+#define A_int_selected	0xab930018
+static u32 A_int_selected_used[] __attribute((unused)) = {
+	0x0000032d,
+};
+
+#define A_int_status_not_msgin	0xab930015
+static u32 A_int_status_not_msgin_used[] __attribute((unused)) = {
+	0x0000002d,
+};
+
+#define A_msgin_buf	0x00000000
+static u32 A_msgin_buf_used[] __attribute((unused)) = {
+	0x0000024b,
+	0x0000025f,
+	0x00000267,
+	0x0000026f,
+	0x0000028b,
+	0x0000029f,
+	0x000002a7,
+	0x000002af,
+	0x000002cb,
+	0x000002df,
+	0x000002e7,
+	0x000002ef,
+	0x0000030b,
+};
+
+#define A_reselected_identify	0x00000000
+static u32 A_reselected_identify_used[] __attribute((unused)) = {
+	0x00000319,
+};
+
+#define Ent_do_select	0x00000000
+#define Ent_done_ident	0x00000050
+#define Ent_end_data_trans	0x00000908
+#define Ent_patch_input_data	0x000000e8
+#define Ent_patch_new_dsa	0x00000c88
+#define Ent_patch_output_data	0x00000500
+#define Ent_reselect	0x00000c48
+#define Ent_resume_cmd	0x00000068
+#define Ent_resume_msgin1a	0x000009e0
+#define Ent_resume_msgin1b	0x000009f0
+#define Ent_resume_msgin2a	0x00000ae0
+#define Ent_resume_msgin2b	0x00000af0
+#define Ent_resume_msgin3a	0x00000be0
+#define Ent_resume_msgin3b	0x00000bf0
+#define Ent_resume_pmm	0x00000078
+#define Ent_resume_rej_ident	0x00000c20
+#define Ent_wait_disc1	0x000009d0
+#define Ent_wait_disc2	0x00000ad0
+#define Ent_wait_disc3	0x00000bd0
+#define Ent_wait_disc_complete	0x000000d0
+static u32 LABELPATCHES[] __attribute((unused)) = {
+	0x00000007,
+	0x00000009,
+	0x00000015,
+	0x00000017,
+	0x0000001f,
+	0x00000021,
+	0x00000023,
+	0x00000025,
+	0x0000013d,
+	0x00000243,
+	0x00000245,
+	0x0000024d,
+	0x0000024f,
+	0x00000251,
+	0x00000253,
+	0x00000259,
+	0x00000261,
+	0x00000269,
+	0x0000027b,
+	0x00000287,
+	0x0000028d,
+	0x0000028f,
+	0x00000291,
+	0x00000293,
+	0x00000299,
+	0x000002a1,
+	0x000002a9,
+	0x000002bb,
+	0x000002c7,
+	0x000002cd,
+	0x000002cf,
+	0x000002d1,
+	0x000002d3,
+	0x000002d9,
+	0x000002e1,
+	0x000002e9,
+	0x000002fb,
+	0x00000307,
+	0x00000311,
+	0x00000315,
+	0x0000031f,
+	0x0000032b,
+};
+
+static struct {
+	u32	offset;
+	void		*address;
+} EXTERNAL_PATCHES[] __attribute((unused)) = {
+};
+
+static u32 INSTRUCTIONS __attribute((unused))	= 407;
+static u32 PATCHES __attribute((unused))	= 42;
+static u32 EXTERNAL_PATCHES_LEN __attribute((unused))	= 0;
diff -Nru a/drivers/scsi/sim710_u.h b/drivers/scsi/sim710_u.h
--- a/drivers/scsi/sim710_u.h	Thu Jun 20 15:54:00 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,67 +0,0 @@
-#undef A_dsa_cmnd
-#undef A_dsa_datain
-#undef A_dsa_dataout
-#undef A_dsa_msgin
-#undef A_dsa_msgout
-#undef A_dsa_select
-#undef A_dsa_size
-#undef A_dsa_status
-#undef A_had_cmdout
-#undef A_had_datain
-#undef A_had_dataout
-#undef A_had_extmsg
-#undef A_had_msgin
-#undef A_had_msgout
-#undef A_had_select
-#undef A_had_status
-#undef A_int_bad_extmsg1a
-#undef A_int_bad_extmsg1b
-#undef A_int_bad_extmsg2a
-#undef A_int_bad_extmsg2b
-#undef A_int_bad_extmsg3a
-#undef A_int_bad_extmsg3b
-#undef A_int_bad_msg1
-#undef A_int_bad_msg2
-#undef A_int_bad_msg3
-#undef A_int_cmd_bad_phase
-#undef A_int_cmd_complete
-#undef A_int_data_bad_phase
-#undef A_int_disc1
-#undef A_int_disc2
-#undef A_int_disc3
-#undef A_int_msg_sdtr1
-#undef A_int_msg_sdtr2
-#undef A_int_msg_sdtr3
-#undef A_int_no_msgout1
-#undef A_int_no_msgout2
-#undef A_int_no_msgout3
-#undef A_int_not_cmd_complete
-#undef A_int_not_rej
-#undef A_int_resel_not_msgin
-#undef A_int_reselected
-#undef A_int_sel_no_ident
-#undef A_int_sel_not_cmd
-#undef A_int_selected
-#undef A_int_status_not_msgin
-#undef A_msgin_buf
-#undef A_reselected_identify
-#undef Ent_do_select
-#undef Ent_done_ident
-#undef Ent_end_data_trans
-#undef Ent_patch_input_data
-#undef Ent_patch_new_dsa
-#undef Ent_patch_output_data
-#undef Ent_reselect
-#undef Ent_resume_cmd
-#undef Ent_resume_msgin1a
-#undef Ent_resume_msgin1b
-#undef Ent_resume_msgin2a
-#undef Ent_resume_msgin2b
-#undef Ent_resume_msgin3a
-#undef Ent_resume_msgin3b
-#undef Ent_resume_pmm
-#undef Ent_resume_rej_ident
-#undef Ent_wait_disc1
-#undef Ent_wait_disc2
-#undef Ent_wait_disc3
-#undef Ent_wait_disc_complete
diff -Nru a/drivers/tc/Makefile b/drivers/tc/Makefile
--- a/drivers/tc/Makefile	Thu Jun 20 15:54:00 2002
+++ b/drivers/tc/Makefile	Thu Jun 20 15:54:00 2002
@@ -15,5 +15,5 @@
 
 include $(TOPDIR)/Rules.make
 
-lk201-map.c: lk201-map.map
-	loadkeys --mktable lk201-map.map > lk201-map.c
+$(obj)/lk201-map.c: $(src)/lk201-map.map
+	loadkeys --mktable $< > $@
diff -Nru a/drivers/usb/net/usbnet.c b/drivers/usb/net/usbnet.c
--- a/drivers/usb/net/usbnet.c	Thu Jun 20 15:53:59 2002
+++ b/drivers/usb/net/usbnet.c	Thu Jun 20 15:53:59 2002
@@ -116,6 +116,7 @@
 #include <linux/etherdevice.h>
 #include <linux/random.h>
 #include <linux/ethtool.h>
+#include <linux/tqueue.h>
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
 
diff -Nru a/drivers/video/Makefile b/drivers/video/Makefile
--- a/drivers/video/Makefile	Thu Jun 20 15:54:00 2002
+++ b/drivers/video/Makefile	Thu Jun 20 15:54:00 2002
@@ -122,17 +122,12 @@
 obj-$(CONFIG_FBCON_STI)           += fbcon-sti.o
 obj-$(CONFIG_FBCON_ACCEL)	  += fbcon-accel.o
 
-host-progs := ../conmakehash
+host-progs := ../char/conmakehash
 
 include $(TOPDIR)/Rules.make
 
-clean:
-	rm -f core *.o *.a *.s
-
-promcon_tbl.c: prom.uni ../char/conmakehash
-	../char/conmakehash prom.uni | \
+$(obj)/promcon_tbl.c: $(src)/prom.uni $(obj)/../char/conmakehash
+	$(obj)/../char/conmakehash $< | \
 	sed -e '/#include <[^>]*>/p' -e 's/types/init/' \
-	    -e 's/dfont\(_uni.*\]\)/promfont\1 __initdata/' > promcon_tbl.c
-
-promcon_tbl.o: promcon_tbl.c $(TOPDIR)/include/linux/types.h
+	    -e 's/dfont\(_uni.*\]\)/promfont\1 __initdata/' > $@
 
diff -Nru a/drivers/video/radeonfb.c b/drivers/video/radeonfb.c
--- a/drivers/video/radeonfb.c	Thu Jun 20 15:54:01 2002
+++ b/drivers/video/radeonfb.c	Thu Jun 20 15:54:01 2002
@@ -1449,7 +1449,7 @@
                 
         /* use highest possible virtual resolution */
         if (v->xres_virtual == -1 && v->yres_virtual == -1) {
-                printk("radeonfb: using max availabe virtual resolution\n");
+                printk("radeonfb: using max available virtual resolution\n");
                 for (i=0; modes[i].xres != -1; i++) {
                         if (modes[i].xres * nom / den * modes[i].yres <
                             rinfo->video_ram / 2)
diff -Nru a/drivers/zorro/Makefile b/drivers/zorro/Makefile
--- a/drivers/zorro/Makefile	Thu Jun 20 15:54:00 2002
+++ b/drivers/zorro/Makefile	Thu Jun 20 15:54:00 2002
@@ -11,7 +11,11 @@
 
 include $(TOPDIR)/Rules.make
 
-names.o: devlist.h
+# Dependencies on generated files need to be listed explicitly
 
-devlist.h: zorro.ids gen-devlist
-	./gen-devlist <zorro.ids
+$(obj)/names.o: $(obj)/devlist.h
+
+# And that's how to generate them
+
+$(obj)/devlist.h: $(src)/zorro.ids $(obj)/gen-devlist
+	$(obj)/gen-devlist < $<
diff -Nru a/fs/Config.in b/fs/Config.in
--- a/fs/Config.in	Thu Jun 20 15:54:01 2002
+++ b/fs/Config.in	Thu Jun 20 15:54:01 2002
@@ -17,7 +17,7 @@
 dep_mbool '  Enable reiserfs debug mode' CONFIG_REISERFS_CHECK $CONFIG_REISERFS_FS
 dep_mbool '  Stats in /proc/fs/reiserfs' CONFIG_REISERFS_PROC_INFO $CONFIG_REISERFS_FS
 
-dep_tristate 'ADFS file system support' CONFIG_ADFS_FS $CONFIG_EXPERIMENTAL
+dep_tristate 'ADFS file system support (EXPERIMENTAL)' CONFIG_ADFS_FS $CONFIG_EXPERIMENTAL
 dep_mbool '  ADFS write support (DANGEROUS)' CONFIG_ADFS_FS_RW $CONFIG_ADFS_FS $CONFIG_EXPERIMENTAL
 
 dep_tristate 'Amiga FFS file system support (EXPERIMENTAL)' CONFIG_AFFS_FS $CONFIG_EXPERIMENTAL
@@ -50,7 +50,7 @@
 dep_tristate 'Journalling Flash File System v2 (JFFS2) support' CONFIG_JFFS2_FS $CONFIG_MTD
 if [ "$CONFIG_JFFS2_FS" = "y" -o "$CONFIG_JFFS2_FS" = "m" ] ; then
    int '  JFFS2 debugging verbosity (0 = quiet, 2 = noisy)' CONFIG_JFFS2_FS_DEBUG 0
-   dep_bool '  JFFS2 support for NAND flash' CONFIG_JFFS2_FS_NAND $CONFIG_EXPERIMENTAL
+   dep_bool '  JFFS2 support for NAND flash (EXPERIMENTAL)' CONFIG_JFFS2_FS_NAND $CONFIG_EXPERIMENTAL
 fi
 tristate 'Compressed ROM file system support' CONFIG_CRAMFS
 bool 'Virtual memory file system support (former shm fs)' CONFIG_TMPFS
@@ -106,7 +106,7 @@
    comment 'Network File Systems'
 
    dep_tristate 'Coda file system support (advanced network fs)' CONFIG_CODA_FS $CONFIG_INET
-   dep_tristate 'InterMezzo file system support (experimental, replicating fs)' CONFIG_INTERMEZZO_FS $CONFIG_INET $CONFIG_EXPERIMENTAL
+   dep_tristate 'InterMezzo file system support (replicating fs) (EXPERIMENTAL)' CONFIG_INTERMEZZO_FS $CONFIG_INET $CONFIG_EXPERIMENTAL
    dep_tristate 'NFS file system support' CONFIG_NFS_FS $CONFIG_INET
    dep_mbool '  Provide NFSv3 client support' CONFIG_NFS_V3 $CONFIG_NFS_FS
    dep_bool '  Root file system on NFS' CONFIG_ROOT_NFS $CONFIG_NFS_FS $CONFIG_IP_PNP
diff -Nru a/fs/ext2/balloc.c b/fs/ext2/balloc.c
--- a/fs/ext2/balloc.c	Thu Jun 20 15:54:00 2002
+++ b/fs/ext2/balloc.c	Thu Jun 20 15:54:00 2002
@@ -602,7 +602,7 @@
 	}
 }
 
-int ext2_group_sparse(int group)
+static int ext2_group_sparse(int group)
 {
 	return (test_root(group, 3) || test_root(group, 5) ||
 		test_root(group, 7));
diff -Nru a/fs/ext2/ext2.h b/fs/ext2/ext2.h
--- a/fs/ext2/ext2.h	Thu Jun 20 15:54:01 2002
+++ b/fs/ext2/ext2.h	Thu Jun 20 15:54:01 2002
@@ -92,10 +92,7 @@
 extern void ext2_warning (struct super_block *, const char *, const char *, ...)
 	__attribute__ ((format (printf, 3, 4)));
 extern void ext2_update_dynamic_rev (struct super_block *sb);
-extern void ext2_put_super (struct super_block *);
 extern void ext2_write_super (struct super_block *);
-extern int ext2_remount (struct super_block *, int *, char *);
-extern int ext2_statfs (struct super_block *, struct statfs *);
 
 /*
  * Inodes and files operations
diff -Nru a/fs/ext2/ioctl.c b/fs/ext2/ioctl.c
--- a/fs/ext2/ioctl.c	Thu Jun 20 15:54:01 2002
+++ b/fs/ext2/ioctl.c	Thu Jun 20 15:54:01 2002
@@ -31,7 +31,7 @@
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
-			return -EPERM;
+			return -EACCES;
 
 		if (get_user(flags, (int *) arg))
 			return -EFAULT;
diff -Nru a/fs/ext2/super.c b/fs/ext2/super.c
--- a/fs/ext2/super.c	Thu Jun 20 15:54:01 2002
+++ b/fs/ext2/super.c	Thu Jun 20 15:54:01 2002
@@ -31,6 +31,8 @@
 
 static void ext2_sync_super(struct super_block *sb,
 			    struct ext2_super_block *es);
+static int ext2_remount (struct super_block * sb, int * flags, char * data);
+static int ext2_statfs (struct super_block * sb, struct statfs * buf);
 
 static char error_buf[1024];
 
@@ -123,7 +125,7 @@
 	 */
 }
 
-void ext2_put_super (struct super_block * sb)
+static void ext2_put_super (struct super_block * sb)
 {
 	int db_count;
 	int i;
@@ -772,7 +774,7 @@
 	unlock_kernel();
 }
 
-int ext2_remount (struct super_block * sb, int * flags, char * data)
+static int ext2_remount (struct super_block * sb, int * flags, char * data)
 {
 	struct ext2_sb_info * sbi = EXT2_SB(sb);
 	struct ext2_super_block * es;
@@ -827,7 +829,7 @@
 	return 0;
 }
 
-int ext2_statfs (struct super_block * sb, struct statfs * buf)
+static int ext2_statfs (struct super_block * sb, struct statfs * buf)
 {
 	struct ext2_sb_info *sbi = EXT2_SB(sb);
 	unsigned long overhead;
diff -Nru a/fs/ext3/ioctl.c b/fs/ext3/ioctl.c
--- a/fs/ext3/ioctl.c	Thu Jun 20 15:54:00 2002
+++ b/fs/ext3/ioctl.c	Thu Jun 20 15:54:00 2002
@@ -38,7 +38,7 @@
 			return -EROFS;
 
 		if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
-			return -EPERM;
+			return -EACCES;
 
 		if (get_user(flags, (int *) arg))
 			return -EFAULT;
diff -Nru a/fs/jfs/file.c b/fs/jfs/file.c
--- a/fs/jfs/file.c	Thu Jun 20 15:54:00 2002
+++ b/fs/jfs/file.c	Thu Jun 20 15:54:00 2002
@@ -35,7 +35,7 @@
 
 	if (!(inode->i_state & I_DIRTY))
 		return rc;
-	if (datasync || !(inode->i_state & I_DIRTY_DATASYNC))
+	if (datasync && !(inode->i_state & I_DIRTY_DATASYNC))
 		return rc;
 
 	IWRITE_LOCK(inode);
diff -Nru a/fs/jfs/jfs_dmap.c b/fs/jfs/jfs_dmap.c
--- a/fs/jfs/jfs_dmap.c	Thu Jun 20 15:54:00 2002
+++ b/fs/jfs/jfs_dmap.c	Thu Jun 20 15:54:00 2002
@@ -552,8 +552,7 @@
 
 				/* move bp after tblock in logsync list */
 				LOGSYNC_LOCK(log);
-				list_del(&mp->synclist);
-				list_add(&mp->synclist, &tblk->synclist);
+				list_move(&mp->synclist, &tblk->synclist);
 				LOGSYNC_UNLOCK(log);
 			}
 
diff -Nru a/fs/jfs/jfs_imap.c b/fs/jfs/jfs_imap.c
--- a/fs/jfs/jfs_imap.c	Thu Jun 20 15:54:00 2002
+++ b/fs/jfs/jfs_imap.c	Thu Jun 20 15:54:00 2002
@@ -2819,8 +2819,7 @@
 			mp->lsn = lsn;
 			/* move mp after tblock in logsync list */
 			LOGSYNC_LOCK(log);
-			list_del(&mp->synclist);
-			list_add(&mp->synclist, &tblk->synclist);
+			list_move(&mp->synclist, &tblk->synclist);
 			LOGSYNC_UNLOCK(log);
 		}
 		/* inherit younger/larger clsn */
@@ -3052,7 +3051,6 @@
 	ip->i_ctime = le32_to_cpu(dip->di_ctime.tv_sec);
 	ip->i_blksize = ip->i_sb->s_blocksize;
 	ip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));
-	ip->i_version = ++event;
 	ip->i_generation = le32_to_cpu(dip->di_gen);
 
 	jfs_ip->ixpxd = dip->di_ixpxd;	/* in-memory pxd's are little-endian */
diff -Nru a/fs/jfs/jfs_inode.c b/fs/jfs/jfs_inode.c
--- a/fs/jfs/jfs_inode.c	Thu Jun 20 15:54:00 2002
+++ b/fs/jfs/jfs_inode.c	Thu Jun 20 15:54:00 2002
@@ -69,7 +69,6 @@
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	jfs_inode->otime = inode->i_ctime;
-	inode->i_version = ++event;
 	inode->i_generation = JFS_SBI(sb)->gengen++;
 
 	jfs_inode->cflag = 0;
diff -Nru a/fs/jfs/jfs_logmgr.c b/fs/jfs/jfs_logmgr.c
--- a/fs/jfs/jfs_logmgr.c	Thu Jun 20 15:54:01 2002
+++ b/fs/jfs/jfs_logmgr.c	Thu Jun 20 15:54:01 2002
@@ -74,10 +74,11 @@
 
 
 /*
- * lbuf's ready to be redriven.  Protected by log_redrive_lock (jfsIOtask)
+ * lbuf's ready to be redriven.  Protected by log_redrive_lock (jfsIO thread)
  */
 static lbuf_t *log_redrive_list;
 static spinlock_t log_redrive_lock = SPIN_LOCK_UNLOCKED;
+DECLARE_WAIT_QUEUE_HEAD(jfs_IO_thread_wait);
 
 
 /*
@@ -160,8 +161,7 @@
  * external references
  */
 extern void txLazyUnlock(tblock_t * tblk);
-extern int jfs_thread_stopped(void);
-extern struct task_struct *jfsIOtask;
+extern int jfs_stop_threads;
 extern struct completion jfsIOwait;
 
 /*
@@ -291,8 +291,7 @@
 			tblk->lsn = mp->lsn;
 
 			/* move tblock after page on logsynclist */
-			list_del(&tblk->synclist);
-			list_add(&tblk->synclist, &mp->synclist);
+			list_move(&tblk->synclist, &mp->synclist);
 		}
 	}
 
@@ -1093,7 +1092,7 @@
 	 * initialize log.
 	 */
 	if ((rc = lmLogInit(log)))
-		goto errout10;
+		goto free;
 	goto out;
 
 	/*
@@ -1103,18 +1102,19 @@
 	 */
       externalLog:
 
-	/*
-	 * TODO: Check for already opened log devices
-	 */
-
 	if (!(bdev = bdget(kdev_t_to_nr(JFS_SBI(sb)->logdev)))) {
 		rc = ENODEV;
-		goto errout10;
+		goto free;
 	}
 
 	if ((rc = blkdev_get(bdev, FMODE_READ|FMODE_WRITE, 0, BDEV_FS))) {
 		rc = -rc;
-		goto errout10;
+		goto bdput;
+	}
+
+	if ((rc = bd_claim(bdev, log))) {
+		rc = -rc;
+		goto close;
 	}
 
 	log->bdev = bdev;
@@ -1124,13 +1124,13 @@
 	 * initialize log:
 	 */
 	if ((rc = lmLogInit(log)))
-		goto errout20;
+		goto unclaim;
 
 	/*
 	 * add file system to log active file system list
 	 */
 	if ((rc = lmLogFileSystem(log, JFS_SBI(sb)->uuid, 1)))
-		goto errout30;
+		goto shutdown;
 
       out:
 	jFYI(1, ("lmLogOpen: exit(0)\n"));
@@ -1140,13 +1140,19 @@
 	/*
 	 *      unwind on error
 	 */
-      errout30:		/* unwind lbmLogInit() */
+      shutdown:		/* unwind lbmLogInit() */
 	lbmLogShutdown(log);
 
-      errout20:		/* close external log device */
+      unclaim:
+	bd_release(bdev);
+
+      close:		/* close external log device */
 	blkdev_put(bdev, BDEV_FS);
 
-      errout10:		/* free log descriptor */
+      bdput:
+	bdput(bdev);
+
+      free:		/* free log descriptor */
 	kfree(log);
 
 	jFYI(1, ("lmLogOpen: exit(%d)\n", rc));
@@ -1369,6 +1375,7 @@
  */
 int lmLogClose(struct super_block *sb, log_t * log)
 {
+	struct block_device *bdev = log->bdev;
 	int rc;
 
 	jFYI(1, ("lmLogClose: log:0x%p\n", log));
@@ -1388,7 +1395,10 @@
       externalLog:
 	lmLogFileSystem(log, JFS_SBI(sb)->uuid, 0);
 	rc = lmLogShutdown(log);
-	blkdev_put(log->bdev, BDEV_FS);
+
+	bd_release(bdev);
+	blkdev_put(bdev, BDEV_FS);
+	bdput(bdev);
 
       out:
 	jFYI(0, ("lmLogClose: exit(%d)\n", rc));
@@ -1780,7 +1790,7 @@
 	log_redrive_list = bp;
 	spin_unlock_irqrestore(&log_redrive_lock, flags);
 
-	wake_up_process(jfsIOtask);
+	wake_up(&jfs_IO_thread_wait);
 }
 
 
@@ -2155,17 +2165,16 @@
 
 	unlock_kernel();
 
-	jfsIOtask = current;
-
 	spin_lock_irq(&current->sigmask_lock);
-	siginitsetinv(&current->blocked,
-		      sigmask(SIGHUP) | sigmask(SIGKILL) | sigmask(SIGSTOP)
-		      | sigmask(SIGCONT));
+	sigfillset(&current->blocked);
+	recalc_sigpending();
 	spin_unlock_irq(&current->sigmask_lock);
 
 	complete(&jfsIOwait);
 
 	do {
+		DECLARE_WAITQUEUE(wq, current);
+
 		spin_lock_irq(&log_redrive_lock);
 		while ((bp = log_redrive_list)) {
 			log_redrive_list = bp->l_redrive_next;
@@ -2174,11 +2183,13 @@
 			lbmStartIO(bp);
 			spin_lock_irq(&log_redrive_lock);
 		}
-		spin_unlock_irq(&log_redrive_lock);
-
+		add_wait_queue(&jfs_IO_thread_wait, &wq);
 		set_current_state(TASK_INTERRUPTIBLE);
+		spin_unlock_irq(&log_redrive_lock);
 		schedule();
-	} while (!jfs_thread_stopped());
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&jfs_IO_thread_wait, &wq);
+	} while (!jfs_stop_threads);
 
 	jFYI(1,("jfsIOWait being killed!\n"));
 	complete(&jfsIOwait);
diff -Nru a/fs/jfs/jfs_txnmgr.c b/fs/jfs/jfs_txnmgr.c
--- a/fs/jfs/jfs_txnmgr.c	Thu Jun 20 15:54:00 2002
+++ b/fs/jfs/jfs_txnmgr.c	Thu Jun 20 15:54:00 2002
@@ -100,6 +100,9 @@
 #define LAZY_LOCK(flags)	spin_lock_irqsave(&TxAnchor.LazyLock, flags)
 #define LAZY_UNLOCK(flags) spin_unlock_irqrestore(&TxAnchor.LazyLock, flags)
 
+DECLARE_WAIT_QUEUE_HEAD(jfs_sync_thread_wait);
+DECLARE_WAIT_QUEUE_HEAD(jfs_commit_thread_wait);
+
 /*
  * Retry logic exist outside these macros to protect from spurrious wakeups.
  */
@@ -143,11 +146,10 @@
 extern void lmSync(log_t *);
 extern int readSuper(struct super_block *sb, metapage_t ** bpp);
 extern int jfs_commit_inode(struct inode *, int);
-extern int jfs_thread_stopped(void);
+extern int jfs_stop_threads;
 
-extern struct task_struct *jfsCommitTask;
+struct task_struct *jfsCommitTask;
 extern struct completion jfsIOwait;
-extern struct task_struct *jfsSyncTask;
 
 /*
  * forward references
@@ -190,7 +192,7 @@
 	if ((++TxAnchor.tlocksInUse > TxLockHWM) && (TlocksLow == 0)) {
 		jEVENT(0,("txLockAlloc TlocksLow\n"));
 		TlocksLow = 1;
-	wake_up_process(jfsSyncTask);
+		wake_up(&jfs_sync_thread_wait);
 	}
 
 	return lid;
@@ -1223,11 +1225,10 @@
 	 */
 	if (tblk->xflag & (COMMIT_CREATE | COMMIT_DELETE))
 		atomic_inc(&tblk->ip->i_count);
-	if (tblk->xflag & COMMIT_DELETE) {
-		ip = tblk->ip;
-		assert((ip->i_nlink == 0) && !test_cflag(COMMIT_Nolink, ip));
-		set_cflag(COMMIT_Nolink, ip);
-	}
+
+	ASSERT((!(tblk->xflag & COMMIT_DELETE)) ||
+	       ((tblk->ip->i_nlink == 0) &&
+		!test_cflag(COMMIT_Nolink, tblk->ip)));
 
 	/*
 	 *      write COMMIT log record
@@ -2784,9 +2785,8 @@
 	jfsCommitTask = current;
 
 	spin_lock_irq(&current->sigmask_lock);
-	siginitsetinv(&current->blocked,
-		      sigmask(SIGHUP) | sigmask(SIGKILL) | sigmask(SIGSTOP)
-		      | sigmask(SIGCONT));
+	sigfillset(&current->blocked);
+	recalc_sigpending();
 	spin_unlock_irq(&current->sigmask_lock);
 
 	LAZY_LOCK_INIT();
@@ -2795,6 +2795,8 @@
 	complete(&jfsIOwait);
 
 	do {
+		DECLARE_WAITQUEUE(wq, current);
+
 		LAZY_LOCK(flags);
 restart:
 		WorkDone = 0;
@@ -2832,10 +2834,13 @@
 		if (WorkDone)
 			goto restart;
 
-		LAZY_UNLOCK(flags);
+		add_wait_queue(&jfs_commit_thread_wait, &wq);
 		set_current_state(TASK_INTERRUPTIBLE);
+		LAZY_UNLOCK(flags);
 		schedule();
-	} while (!jfs_thread_stopped());
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&jfs_commit_thread_wait, &wq);
+	} while (!jfs_stop_threads);
 
 	if (TxAnchor.unlock_queue)
 		jERROR(1, ("jfs_lazycommit being killed with pending transactions!\n"));
@@ -2858,7 +2863,7 @@
 	TxAnchor.unlock_tail = tblk;
 	tblk->cqnext = 0;
 	LAZY_UNLOCK(flags);
-	wake_up_process(jfsCommitTask);
+	wake_up(&jfs_commit_thread_wait);
 }
 
 static void LogSyncRelease(metapage_t * mp)
@@ -2905,17 +2910,15 @@
 
 	unlock_kernel();
 
-	jfsSyncTask = current;
-
 	spin_lock_irq(&current->sigmask_lock);
-	siginitsetinv(&current->blocked,
-		      sigmask(SIGHUP) | sigmask(SIGKILL) | sigmask(SIGSTOP)
-		      | sigmask(SIGCONT));
+	sigfillset(&current->blocked);
+	recalc_sigpending();
 	spin_unlock_irq(&current->sigmask_lock);
 
 	complete(&jfsIOwait);
 
 	do {
+		DECLARE_WAITQUEUE(wq, current);
 		/*
 		 * write each inode on the anonymous inode list
 		 */
@@ -2976,11 +2979,13 @@
 			list_splice(&TxAnchor.anon_list2, &TxAnchor.anon_list);
 			INIT_LIST_HEAD(&TxAnchor.anon_list2);
 		}
-		TXN_UNLOCK();
-
+		add_wait_queue(&jfs_sync_thread_wait, &wq);
 		set_current_state(TASK_INTERRUPTIBLE);
+		TXN_UNLOCK();
 		schedule();
-	} while (!jfs_thread_stopped());
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&jfs_sync_thread_wait, &wq);
+	} while (!jfs_stop_threads);
 
 	jFYI(1, ("jfs_sync being killed\n"));
 	complete(&jfsIOwait);
diff -Nru a/fs/jfs/namei.c b/fs/jfs/namei.c
--- a/fs/jfs/namei.c	Thu Jun 20 15:54:01 2002
+++ b/fs/jfs/namei.c	Thu Jun 20 15:54:01 2002
@@ -138,7 +138,6 @@
 	mark_inode_dirty(ip);
 	d_instantiate(dentry, ip);
 
-	dip->i_version = ++event;
 	dip->i_ctime = dip->i_mtime = CURRENT_TIME;
 
 	mark_inode_dirty(dip);
@@ -264,7 +263,6 @@
 
 	/* update parent directory inode */
 	dip->i_nlink++;		/* for '..' from child directory */
-	dip->i_version = ++event;
 	dip->i_ctime = dip->i_mtime = CURRENT_TIME;
 	mark_inode_dirty(dip);
 
@@ -359,7 +357,6 @@
 	 */
 	dip->i_nlink--;
 	dip->i_ctime = dip->i_mtime = CURRENT_TIME;
-	dip->i_version = ++event;
 	mark_inode_dirty(dip);
 
 	/*
@@ -473,7 +470,6 @@
 	ASSERT(ip->i_nlink);
 
 	ip->i_ctime = dip->i_ctime = dip->i_mtime = CURRENT_TIME;
-	dip->i_version = ++event;
 	mark_inode_dirty(dip);
 
 	/* update target's inode */
@@ -528,6 +524,9 @@
 		txEnd(tid);
 	}
 
+	if (ip->i_nlink == 0)
+		set_cflag(COMMIT_Nolink, ip);
+
 	if (!test_cflag(COMMIT_Holdlock, ip))
 		IWRITE_UNLOCK(ip);
 
@@ -794,8 +793,6 @@
 	if ((rc = dtInsert(tid, dir, &dname, &ino, &btstack)))
 		goto out;
 
-	dir->i_version = ++event;
-
 	/* update object inode */
 	ip->i_nlink++;		/* for new link */
 	ip->i_ctime = CURRENT_TIME;
@@ -990,7 +987,6 @@
 			goto out2;
 		}
 	}
-	dip->i_version = ++event;
 
 	insert_inode_hash(ip);
 	mark_inode_dirty(ip);
@@ -1224,7 +1220,6 @@
 	old_ip->i_ctime = CURRENT_TIME;
 	mark_inode_dirty(old_ip);
 
-	new_dir->i_version = ++event;
 	new_dir->i_ctime = CURRENT_TIME;
 	mark_inode_dirty(new_dir);
 
@@ -1237,7 +1232,6 @@
 
 	if (old_dir != new_dir) {
 		iplist[ipcount++] = new_dir;
-		old_dir->i_version = ++event;
 		old_dir->i_ctime = CURRENT_TIME;
 		mark_inode_dirty(old_dir);
 	}
@@ -1273,6 +1267,8 @@
 			rc = txCommit(tid, 1, &new_ip, COMMIT_SYNC);
 		txEnd(tid);
 	}
+	if (new_ip && (new_ip->i_nlink == 0))
+		set_cflag(COMMIT_Nolink, new_ip);
       out3:
 	free_UCSname(&new_dname);
       out2:
@@ -1358,7 +1354,6 @@
 	mark_inode_dirty(ip);
 	d_instantiate(dentry, ip);
 
-	dir->i_version = ++event;
 	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
 
 	mark_inode_dirty(dir);
diff -Nru a/fs/jfs/super.c b/fs/jfs/super.c
--- a/fs/jfs/super.c	Thu Jun 20 15:54:01 2002
+++ b/fs/jfs/super.c	Thu Jun 20 15:54:01 2002
@@ -36,13 +36,10 @@
 
 static kmem_cache_t * jfs_inode_cachep;
 
-static int in_shutdown;
+int jfs_stop_threads;
 static pid_t jfsIOthread;
 static pid_t jfsCommitThread;
 static pid_t jfsSyncThread;
-struct task_struct *jfsIOtask;
-struct task_struct *jfsCommitTask;
-struct task_struct *jfsSyncTask;
 DECLARE_COMPLETION(jfsIOwait);
 
 #ifdef CONFIG_JFS_DEBUG
@@ -76,19 +73,9 @@
 extern void jfs_proc_clean(void);
 #endif
 
-int jfs_thread_stopped(void)
-{
-	unsigned long signr;
-	siginfo_t info;
-
-	spin_lock_irq(&current->sigmask_lock);
-	signr = dequeue_signal(&current->blocked, &info);
-	spin_unlock_irq(&current->sigmask_lock);
-
-	if (signr == SIGKILL && in_shutdown)
-		return 1;
-	return 0;
-}
+extern wait_queue_head_t jfs_IO_thread_wait;
+extern wait_queue_head_t jfs_commit_thread_wait;
+extern wait_queue_head_t jfs_sync_thread_wait;
 
 static struct inode *jfs_alloc_inode(struct super_block *sb)
 {
@@ -469,10 +456,12 @@
 
 
 kill_committask:
-	send_sig(SIGKILL, jfsCommitTask, 1);
+	jfs_stop_threads = 1;
+	wake_up(&jfs_commit_thread_wait);
 	wait_for_completion(&jfsIOwait);	/* Wait until Commit thread exits */
 kill_iotask:
-	send_sig(SIGKILL, jfsIOtask, 1);
+	jfs_stop_threads = 1;
+	wake_up(&jfs_IO_thread_wait);
 	wait_for_completion(&jfsIOwait);	/* Wait until IO thread exits */
 end_txmngr:
 	txExit();
@@ -487,14 +476,14 @@
 {
 	jFYI(1, ("exit_jfs_fs called\n"));
 
-	in_shutdown = 1;
+	jfs_stop_threads = 1;
 	txExit();
 	metapage_exit();
-	send_sig(SIGKILL, jfsIOtask, 1);
+	wake_up(&jfs_IO_thread_wait);
 	wait_for_completion(&jfsIOwait);	/* Wait until IO thread exits */
-	send_sig(SIGKILL, jfsCommitTask, 1);
+	wake_up(&jfs_commit_thread_wait);
 	wait_for_completion(&jfsIOwait);	/* Wait until Commit thread exits */
-	send_sig(SIGKILL, jfsSyncTask, 1);
+	wake_up(&jfs_sync_thread_wait);
 	wait_for_completion(&jfsIOwait);	/* Wait until Sync thread exits */
 #if defined(CONFIG_JFS_DEBUG) && defined(CONFIG_PROC_FS)
 	jfs_proc_clean();
diff -Nru a/fs/namespace.c b/fs/namespace.c
--- a/fs/namespace.c	Thu Jun 20 15:54:01 2002
+++ b/fs/namespace.c	Thu Jun 20 15:54:01 2002
@@ -22,9 +22,9 @@
 
 #include <asm/uaccess.h>
 
-struct vfsmount *do_kern_mount(const char *type, int flags, char *name, void *data);
-int do_remount_sb(struct super_block *sb, int flags, void * data);
-int __init init_rootfs(void);
+extern struct vfsmount *do_kern_mount(const char *type, int flags, char *name, void *data);
+extern int do_remount_sb(struct super_block *sb, int flags, void * data);
+extern int __init init_rootfs(void);
 
 static struct list_head *mount_hashtable;
 static int hash_mask, hash_bits;
diff -Nru a/fs/ntfs/ChangeLog b/fs/ntfs/ChangeLog
--- a/fs/ntfs/ChangeLog	Thu Jun 20 15:54:00 2002
+++ b/fs/ntfs/ChangeLog	Thu Jun 20 15:54:00 2002
@@ -23,6 +23,28 @@
 	  them cleaner and make code reuse easier.
 	- Want to use dummy inodes for address space i/o.
 
+2.0.10 - There can only be 2^32 - 1 inodes on an NTFS volume.
+
+	- Add check at mount time to verify that the number of inodes on the
+	  volume does not exceed 2^32 - 1, which is the maximum allowed for
+	  NTFS according to Microsoft.
+	- Change mft_no member of ntfs_inode structure to be unsigned long.
+	  Update all users. This makes ntfs_inode->mft_no just a copy of struct
+	  inode->i_ino. But we can't just always use struct inode->i_ino and
+	  remove mft_no because extent inodes do not have an attached struct
+	  inode.
+
+2.0.9 - Decompression engine now uses a single buffer and other cleanups.
+
+	- Change decompression engine to use a single buffer protected by a
+	  spin lock instead of per-CPU buffers. (Rusty Russell)
+	- Switch to using the new KM_BIO_SRC_IRQ for atomic kmaps. (Andrew
+	  Morton)
+	- Change buffer size in ntfs_readdir()/ntfs_filldir() to use
+	  NLS_MAX_CHARSET_SIZE which makes the buffers almost 1kiB each but
+	  it also makes everything safer so it is a good thing.
+	- Miscellaneous minor cleanups to comments.
+
 2.0.8 - Major updates for handling of case sensitivity and dcache aliasing.
 
 	Big thanks go to Al Viro and other inhabitants of #kernel for investing
diff -Nru a/fs/ntfs/Makefile b/fs/ntfs/Makefile
--- a/fs/ntfs/Makefile	Thu Jun 20 15:54:00 2002
+++ b/fs/ntfs/Makefile	Thu Jun 20 15:54:00 2002
@@ -5,7 +5,7 @@
 ntfs-objs := aops.o attrib.o compress.o debug.o dir.o file.o inode.o mft.o \
 	     mst.o namei.o super.o sysctl.o time.o unistr.o upcase.o
 
-EXTRA_CFLAGS = -DNTFS_VERSION=\"2.0.8\"
+EXTRA_CFLAGS = -DNTFS_VERSION=\"2.0.10\"
 
 ifeq ($(CONFIG_NTFS_DEBUG),y)
 EXTRA_CFLAGS += -DDEBUG
diff -Nru a/fs/ntfs/attrib.c b/fs/ntfs/attrib.c
--- a/fs/ntfs/attrib.c	Thu Jun 20 15:54:01 2002
+++ b/fs/ntfs/attrib.c	Thu Jun 20 15:54:01 2002
@@ -1243,8 +1243,7 @@
 
 	ni = ctx->ntfs_ino;
 	base_ni = ctx->base_ntfs_ino;
-	ntfs_debug("Entering for inode 0x%Lx, type 0x%x.",
-			(unsigned long long)ni->mft_no, type);
+	ntfs_debug("Entering for inode 0x%lx, type 0x%x.", ni->mft_no, type);
 	if (!base_ni) {
 		/* First call happens with the base mft record. */
 		base_ni = ctx->base_ntfs_ino = ctx->ntfs_ino;
diff -Nru a/fs/ntfs/compress.c b/fs/ntfs/compress.c
--- a/fs/ntfs/compress.c	Thu Jun 20 15:54:01 2002
+++ b/fs/ntfs/compress.c	Thu Jun 20 15:54:01 2002
@@ -50,11 +50,13 @@
 } ntfs_compression_constants;
 
 /**
- * ntfs_compression_buffer - one buffer for the decompression engine.
+ * ntfs_compression_buffer - one buffer for the decompression engine
  */
 static u8 *ntfs_compression_buffer = NULL;
 
-/* This spinlock which protects it */
+/**
+ * ntfs_cb_lock - spinlock which protects ntfs_compression_buffer
+ */
 static spinlock_t ntfs_cb_lock = SPIN_LOCK_UNLOCKED;
 
 /**
@@ -66,8 +68,6 @@
  */
 int allocate_compression_buffers(void)
 {
-	int i, j;
-
 	BUG_ON(ntfs_compression_buffer);
 
 	ntfs_compression_buffer = vmalloc(NTFS_MAX_CB_SIZE);
@@ -83,8 +83,6 @@
  */
 void free_compression_buffers(void)
 {
-	int i;
-
 	BUG_ON(!ntfs_compression_buffer);
 	vfree(ntfs_compression_buffer);
 	ntfs_compression_buffer = NULL;
@@ -592,7 +590,8 @@
 
 	/*
 	 * Get the compression buffer. We must not sleep any more
-	 * until we are finished with it.  */
+	 * until we are finished with it.
+	 */
 	spin_lock(&ntfs_cb_lock);
 	cb = ntfs_compression_buffer;
 
@@ -668,7 +667,10 @@
 			if (page)
 				memset(page_address(page) + cur_ofs, 0,
 						cb_max_ofs - cur_ofs);
-			cb_pos += cb_max_ofs - cur_ofs;
+			/*
+			 * No need to update cb_pos at this stage:
+			 *	cb_pos += cb_max_ofs - cur_ofs;
+			 */
 			cur_ofs = cb_max_ofs;
 		}
 	} else if (vcn == start_vcn) {
@@ -742,12 +744,13 @@
 				cb_pos,	cb_size - (cb_pos - cb));
 		/*
 		 * We can sleep from now on, lock already dropped by
-		 * ntfs_decompress.  */
+		 * ntfs_decompress().
+		 */
 		if (err) {
 			ntfs_error(vol->sb, "ntfs_decompress() failed in inode "
-					"0x%Lx with error code %i. Skipping "
+					"0x%lx with error code %i. Skipping "
 					"this compression block.\n",
-					(unsigned long long)ni->mft_no, -err);
+					ni->mft_no, -err);
 			/* Release the unfinished pages. */
 			for (; prev_cur_page < cur_page; prev_cur_page++) {
 				page = pages[prev_cur_page];
diff -Nru a/fs/ntfs/dir.c b/fs/ntfs/dir.c
--- a/fs/ntfs/dir.c	Thu Jun 20 15:54:00 2002
+++ b/fs/ntfs/dir.c	Thu Jun 20 15:54:00 2002
@@ -64,7 +64,7 @@
  * work but we don't care for how quickly one can access them. This also fixes
  * the dcache aliasing issues.
  */
-u64 ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const uchar_t *uname,
+MFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const uchar_t *uname,
 		const int uname_len, ntfs_name **res)
 {
 	ntfs_volume *vol = dir_ni->vol;
@@ -98,8 +98,7 @@
 	if (!lookup_attr(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL, 0,
 			ctx)) {
 		ntfs_error(sb, "Index root attribute missing in directory "
-				"inode 0x%Lx.",
-				(unsigned long long)dir_ni->mft_no);
+				"inode 0x%lx.", dir_ni->mft_no);
 		err = -EIO;
 		goto put_unm_err_out;
 	}
@@ -278,9 +277,8 @@
 	/* Consistency check: Verify that an index allocation exists. */
 	if (!NInoIndexAllocPresent(dir_ni)) {
 		ntfs_error(sb, "No index allocation attribute but index entry "
-				"requires one. Directory inode 0x%Lx is "
-				"corrupt or driver bug.",
-				(unsigned long long)dir_ni->mft_no);
+				"requires one. Directory inode 0x%lx is "
+				"corrupt or driver bug.", dir_ni->mft_no);
 		err = -EIO;
 		goto put_unm_err_out;
 	}
@@ -308,30 +306,27 @@
 	/* Bounds checks. */
 	if ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {
 		ntfs_error(sb, "Out of bounds check failed. Corrupt directory "
-				"inode 0x%Lx or driver bug.",
-				(unsigned long long)dir_ni->mft_no);
+				"inode 0x%lx or driver bug.", dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
 	if (sle64_to_cpu(ia->index_block_vcn) != vcn) {
 		ntfs_error(sb, "Actual VCN (0x%Lx) of index buffer is "
 				"different from expected VCN (0x%Lx). "
-				"Directory inode 0x%Lx is corrupt or driver "
+				"Directory inode 0x%lx is corrupt or driver "
 				"bug.",
 				(long long)sle64_to_cpu(ia->index_block_vcn),
-				(long long)vcn,
-				(unsigned long long)dir_ni->mft_no);
+				(long long)vcn, dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
 	if (le32_to_cpu(ia->index.allocated_size) + 0x18 !=
 			dir_ni->_IDM(index_block_size)) {
 		ntfs_error(sb, "Index buffer (VCN 0x%Lx) of directory inode "
-				"0x%Lx has a size (%u) differing from the "
+				"0x%lx has a size (%u) differing from the "
 				"directory specified size (%u). Directory "
 				"inode is corrupt or driver bug.",
-				(long long)vcn,
-				(unsigned long long)dir_ni->mft_no,
+				(long long)vcn, dir_ni->mft_no,
 				le32_to_cpu(ia->index.allocated_size) + 0x18,
 				dir_ni->_IDM(index_block_size));
 		err = -EIO;
@@ -340,19 +335,17 @@
 	index_end = (u8*)ia + dir_ni->_IDM(index_block_size);
 	if (index_end > kaddr + PAGE_CACHE_SIZE) {
 		ntfs_error(sb, "Index buffer (VCN 0x%Lx) of directory inode "
-				"0x%Lx crosses page boundary. Impossible! "
+				"0x%lx crosses page boundary. Impossible! "
 				"Cannot access! This is probably a bug in the "
-				"driver.", (long long)vcn,
-				(unsigned long long)dir_ni->mft_no);
+				"driver.", (long long)vcn, dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
 	index_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);
 	if (index_end > (u8*)ia + dir_ni->_IDM(index_block_size)) {
 		ntfs_error(sb, "Size of index buffer (VCN 0x%Lx) of directory "
-				"inode 0x%Lx exceeds maximum size.",
-				(long long)vcn,
-				(unsigned long long)dir_ni->mft_no);
+				"inode 0x%lx exceeds maximum size.",
+				(long long)vcn, dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
@@ -371,8 +364,8 @@
 				(u8*)ie + le16_to_cpu(ie->_IEH(key_length)) >
 				index_end) {
 			ntfs_error(sb, "Index entry out of bounds in "
-					"directory inode 0x%Lx.",
-					(unsigned long long)dir_ni->mft_no);
+					"directory inode 0x%lx.",
+					dir_ni->mft_no);
 			err = -EIO;
 			goto unm_unm_err_out;
 		}
@@ -523,8 +516,8 @@
 	if (ie->_IEH(flags) & INDEX_ENTRY_NODE) {
 		if ((ia->index.flags & NODE_MASK) == LEAF_NODE) {
 			ntfs_error(sb, "Index entry with child node found in "
-					"a leaf node in directory inode 0x%Lx.",
-					(unsigned long long)dir_ni->mft_no);
+					"a leaf node in directory inode 0x%lx.",
+					dir_ni->mft_no);
 			err = -EIO;
 			goto unm_unm_err_out;
 		}
@@ -544,7 +537,7 @@
 			goto descend_into_child_node;
 		}
 		ntfs_error(sb, "Negative child node vcn in directory inode "
-				"0x%Lx.", (unsigned long long)dir_ni->mft_no);
+				"0x%lx.", dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
@@ -643,8 +636,7 @@
 	if (!lookup_attr(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL, 0,
 			ctx)) {
 		ntfs_error(sb, "Index root attribute missing in directory "
-				"inode 0x%Lx.",
-				(unsigned long long)dir_ni->mft_no);
+				"inode 0x%lx.", dir_ni->mft_no);
 		err = -EIO;
 		goto put_unm_err_out;
 	}
@@ -750,9 +742,8 @@
 	/* Consistency check: Verify that an index allocation exists. */
 	if (!NInoIndexAllocPresent(dir_ni)) {
 		ntfs_error(sb, "No index allocation attribute but index entry "
-				"requires one. Directory inode 0x%Lx is "
-				"corrupt or driver bug.",
-				(unsigned long long)dir_ni->mft_no);
+				"requires one. Directory inode 0x%lx is "
+				"corrupt or driver bug.", dir_ni->mft_no);
 		err = -EIO;
 		goto put_unm_err_out;
 	}
@@ -780,30 +771,27 @@
 	/* Bounds checks. */
 	if ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {
 		ntfs_error(sb, "Out of bounds check failed. Corrupt directory "
-				"inode 0x%Lx or driver bug.",
-				(unsigned long long)dir_ni->mft_no);
+				"inode 0x%lx or driver bug.", dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
 	if (sle64_to_cpu(ia->index_block_vcn) != vcn) {
 		ntfs_error(sb, "Actual VCN (0x%Lx) of index buffer is "
 				"different from expected VCN (0x%Lx). "
-				"Directory inode 0x%Lx is corrupt or driver "
+				"Directory inode 0x%lx is corrupt or driver "
 				"bug.",
 				(long long)sle64_to_cpu(ia->index_block_vcn),
-				(long long)vcn,
-				(unsigned long long)dir_ni->mft_no);
+				(long long)vcn, dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
 	if (le32_to_cpu(ia->index.allocated_size) + 0x18 !=
 			dir_ni->_IDM(index_block_size)) {
 		ntfs_error(sb, "Index buffer (VCN 0x%Lx) of directory inode "
-				"0x%Lx has a size (%u) differing from the "
+				"0x%lx has a size (%u) differing from the "
 				"directory specified size (%u). Directory "
 				"inode is corrupt or driver bug.",
-				(long long)vcn,
-				(unsigned long long)dir_ni->mft_no,
+				(long long)vcn, dir_ni->mft_no,
 				le32_to_cpu(ia->index.allocated_size) + 0x18,
 				dir_ni->_IDM(index_block_size));
 		err = -EIO;
@@ -812,19 +800,17 @@
 	index_end = (u8*)ia + dir_ni->_IDM(index_block_size);
 	if (index_end > kaddr + PAGE_CACHE_SIZE) {
 		ntfs_error(sb, "Index buffer (VCN 0x%Lx) of directory inode "
-				"0x%Lx crosses page boundary. Impossible! "
+				"0x%lx crosses page boundary. Impossible! "
 				"Cannot access! This is probably a bug in the "
-				"driver.", (long long)vcn,
-				(unsigned long long)dir_ni->mft_no);
+				"driver.", (long long)vcn, dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
 	index_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);
 	if (index_end > (u8*)ia + dir_ni->_IDM(index_block_size)) {
 		ntfs_error(sb, "Size of index buffer (VCN 0x%Lx) of directory "
-				"inode 0x%Lx exceeds maximum size.",
-				(long long)vcn,
-				(unsigned long long)dir_ni->mft_no);
+				"inode 0x%lx exceeds maximum size.",
+				(long long)vcn, dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
@@ -843,8 +829,8 @@
 				(u8*)ie + le16_to_cpu(ie->_IEH(key_length)) >
 				index_end) {
 			ntfs_error(sb, "Index entry out of bounds in "
-					"directory inode 0x%Lx.",
-					(unsigned long long)dir_ni->mft_no);
+					"directory inode 0x%lx.",
+					dir_ni->mft_no);
 			err = -EIO;
 			goto unm_unm_err_out;
 		}
@@ -928,8 +914,8 @@
 	if (ie->_IEH(flags) & INDEX_ENTRY_NODE) {
 		if ((ia->index.flags & NODE_MASK) == LEAF_NODE) {
 			ntfs_error(sb, "Index entry with child node found in "
-					"a leaf node in directory inode 0x%Lx.",
-					(unsigned long long)dir_ni->mft_no);
+					"a leaf node in directory inode 0x%lx.",
+					dir_ni->mft_no);
 			err = -EIO;
 			goto unm_unm_err_out;
 		}
@@ -949,7 +935,7 @@
 			goto descend_into_child_node;
 		}
 		ntfs_error(sb, "Negative child node vcn in directory inode "
-				"0x%Lx.", (unsigned long long)dir_ni->mft_no);
+				"0x%lx.", dir_ni->mft_no);
 		err = -EIO;
 		goto unm_unm_err_out;
 	}
@@ -995,10 +981,10 @@
  * @ie:		current index entry
  * @name:	buffer to use for the converted name
  * @dirent:	vfs filldir callback context
- * filldir:	vfs filldir callback
+ * @filldir:	vfs filldir callback
  *
- * Convert the Unicode name to the loaded NLS and pass it to
- * the filldir callback.
+ * Convert the Unicode @name to the loaded NLS and pass it to the @filldir
+ * callback.
  */
 static inline int ntfs_filldir(ntfs_volume *vol, struct file *filp,
 		ntfs_inode *ndir, const INDEX_TYPE index_type,
@@ -1033,7 +1019,7 @@
 	}
 	name_len = ntfs_ucstonls(vol, (uchar_t*)&ie->key.file_name.file_name,
 			ie->key.file_name.file_name_length, &name,
-			NTFS_MAX_NAME_LEN * 3 + 1);
+			NTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1);
 	if (name_len <= 0) {
 		ntfs_debug("Skipping unrepresentable file.");
 		return 0;
@@ -1044,12 +1030,11 @@
 	else
 		dt_type = DT_REG;
 	ntfs_debug("Calling filldir for %s with len %i, f_pos 0x%Lx, inode "
-			"0x%Lx, DT_%s.", name, name_len, filp->f_pos,
-			(unsigned long long)MREF_LE(ie->_IIF(indexed_file)),
+			"0x%lx, DT_%s.", name, name_len, filp->f_pos,
+			MREF_LE(ie->_IIF(indexed_file)),
 			dt_type == DT_DIR ? "DIR" : "REG");
 	return filldir(dirent, name, name_len, filp->f_pos,
-			(unsigned long)MREF_LE(ie->_IIF(indexed_file)),
-			dt_type);
+			MREF_LE(ie->_IIF(indexed_file)), dt_type);
 }
 
 /*
@@ -1083,8 +1068,8 @@
 	u8 *kaddr, *bmp, *index_end;
 	attr_search_context *ctx;
 
-	ntfs_debug("Entering for inode 0x%Lx, f_pos 0x%Lx.",
-			(unsigned long long)ndir->mft_no, filp->f_pos);
+	ntfs_debug("Entering for inode 0x%lx, f_pos 0x%Lx.",
+			vdir->i_ino, filp->f_pos);
 	rc = err = 0;
 	/* Are we at end of dir yet? */
 	if (filp->f_pos >= vdir->i_size + vol->mft_record_size)
@@ -1092,8 +1077,7 @@
 	/* Emulate . and .. for all directories. */
 	if (!filp->f_pos) {
 		ntfs_debug("Calling filldir for . with len 1, f_pos 0x0, "
-				"inode 0x%Lx, DT_DIR.",
-				(unsigned long long)ndir->mft_no);
+				"inode 0x%lx, DT_DIR.", vdir->i_ino);
 		rc = filldir(dirent, ".", 1, filp->f_pos, vdir->i_ino, DT_DIR);
 		if (rc)
 			goto done;
@@ -1126,7 +1110,8 @@
 	 * Allocate a buffer to store the current name being processed
 	 * converted to format determined by current NLS.
 	 */
-	name = (u8*)kmalloc(NTFS_MAX_NAME_LEN * 3 + 1, GFP_NOFS);
+	name = (u8*)kmalloc(NTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1,
+			GFP_NOFS);
 	if (!name) {
 		err = -ENOMEM;
 		goto put_unm_err_out;
@@ -1140,8 +1125,7 @@
 	if (!lookup_attr(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL, 0,
 			ctx)) {
 		ntfs_error(sb, "Index root attribute missing in directory "
-				"inode 0x%Lx.",
-				(unsigned long long)ndir->mft_no);
+				"inode 0x%lx.", vdir->i_ino);
 		err = -EIO;
 		goto kf_unm_err_out;
 	}
@@ -1200,8 +1184,7 @@
 		if (!lookup_attr(AT_BITMAP, I30, 4, CASE_SENSITIVE, 0, NULL, 0,
 				ctx)) {
 			ntfs_error(sb, "Index bitmap attribute missing in "
-					"directory inode 0x%Lx.",
-					(unsigned long long)ndir->mft_no);
+					"directory inode 0x%lx.", vdir->i_ino);
 			err = -EIO;
 			goto kf_unm_err_out;
 		}
@@ -1250,8 +1233,7 @@
 	/* Bounds checks. */
 	if ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {
 		ntfs_error(sb, "Out of bounds check failed. Corrupt directory "
-				"inode 0x%Lx or driver bug.",
-				(unsigned long long)ndir->mft_no);
+				"inode 0x%lx or driver bug.", vdir->i_ino);
 		err = -EIO;
 		goto unm_dir_err_out;
 	}
@@ -1260,23 +1242,22 @@
 			ndir->_IDM(index_vcn_size_bits)) {
 		ntfs_error(sb, "Actual VCN (0x%Lx) of index buffer is "
 				"different from expected VCN (0x%Lx). "
-				"Directory inode 0x%Lx is corrupt or driver "
+				"Directory inode 0x%lx is corrupt or driver "
 				"bug. ",
 				(long long)sle64_to_cpu(ia->index_block_vcn),
 				(long long)ia_pos >>
-				ndir->_IDM(index_vcn_size_bits),
-				(unsigned long long)ndir->mft_no);
+				ndir->_IDM(index_vcn_size_bits), vdir->i_ino);
 		err = -EIO;
 		goto unm_dir_err_out;
 	}
 	if (le32_to_cpu(ia->index.allocated_size) + 0x18 !=
 			ndir->_IDM(index_block_size)) {
 		ntfs_error(sb, "Index buffer (VCN 0x%Lx) of directory inode "
-				"0x%Lx has a size (%u) differing from the "
+				"0x%lx has a size (%u) differing from the "
 				"directory specified size (%u). Directory "
 				"inode is corrupt or driver bug.",
-				(long long)ia_pos >> ndir->_IDM(index_vcn_size_bits),
-				(unsigned long long)ndir->mft_no,
+				(long long)ia_pos >>
+				ndir->_IDM(index_vcn_size_bits), vdir->i_ino,
 				le32_to_cpu(ia->index.allocated_size) + 0x18,
 				ndir->_IDM(index_block_size));
 		err = -EIO;
@@ -1285,11 +1266,10 @@
 	index_end = (u8*)ia + ndir->_IDM(index_block_size);
 	if (index_end > kaddr + PAGE_CACHE_SIZE) {
 		ntfs_error(sb, "Index buffer (VCN 0x%Lx) of directory inode "
-				"0x%Lx crosses page boundary. Impossible! "
+				"0x%lx crosses page boundary. Impossible! "
 				"Cannot access! This is probably a bug in the "
 				"driver.", (long long)ia_pos >>
-				ndir->_IDM(index_vcn_size_bits),
-				(unsigned long long)ndir->mft_no);
+				ndir->_IDM(index_vcn_size_bits), vdir->i_ino);
 		err = -EIO;
 		goto unm_dir_err_out;
 	}
@@ -1297,10 +1277,9 @@
 	index_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);
 	if (index_end > (u8*)ia + ndir->_IDM(index_block_size)) {
 		ntfs_error(sb, "Size of index buffer (VCN 0x%Lx) of directory "
-				"inode 0x%Lx exceeds maximum size.",
+				"inode 0x%lx exceeds maximum size.",
 				(long long)ia_pos >>
-				ndir->_IDM(index_vcn_size_bits),
-				(unsigned long long)ndir->mft_no);
+				ndir->_IDM(index_vcn_size_bits), vdir->i_ino);
 		err = -EIO;
 		goto unm_dir_err_out;
 	}
diff -Nru a/fs/ntfs/dir.h b/fs/ntfs/dir.h
--- a/fs/ntfs/dir.h	Thu Jun 20 15:54:00 2002
+++ b/fs/ntfs/dir.h	Thu Jun 20 15:54:00 2002
@@ -40,8 +40,8 @@
 /* The little endian Unicode string $I30 as a global constant. */
 extern const uchar_t I30[5];
 
-extern u64 ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const uchar_t *uname,
-		const int uname_len, ntfs_name **res);
+extern MFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni,
+		const uchar_t *uname, const int uname_len, ntfs_name **res);
 
 #endif /* _LINUX_NTFS_FS_DIR_H */
 
diff -Nru a/fs/ntfs/inode.c b/fs/ntfs/inode.c
--- a/fs/ntfs/inode.c	Thu Jun 20 15:54:00 2002
+++ b/fs/ntfs/inode.c	Thu Jun 20 15:54:00 2002
@@ -357,8 +357,7 @@
 	if (lookup_attr(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx)) {
 		if (vi->i_ino == FILE_MFT)
 			goto skip_attr_list_load;
-		ntfs_debug("Attribute list found in inode %li (0x%lx).",
-				vi->i_ino, vi->i_ino);
+		ntfs_debug("Attribute list found in inode 0x%lx.", vi->i_ino);
 		ni->state |= 1 << NI_AttrList;
 		if (ctx->attr->flags & ATTR_IS_ENCRYPTED ||
 				ctx->attr->flags & ATTR_COMPRESSION_MASK) {
@@ -805,8 +804,8 @@
 ec_unm_err_out:
 	unmap_mft_record(READ, ni);
 err_out:
-	ntfs_error(vi->i_sb, "Failed with error code %i. Marking inode "
-			"%li (0x%lx) as bad.", -err, vi->i_ino, vi->i_ino);
+	ntfs_error(vi->i_sb, "Failed with error code %i. Marking inode 0x%lx "
+			"as bad.", -err, vi->i_ino);
 	make_bad_inode(vi);
 	return;
 }
@@ -857,7 +856,7 @@
 	ntfs_init_big_inode(vi);
 	ni = NTFS_I(vi);
 	if (vi->i_ino != FILE_MFT) {
-		ntfs_error(sb, "Called for inode %ld but only inode %d "
+		ntfs_error(sb, "Called for inode 0x%lx but only inode %d "
 				"allowed.", vi->i_ino, FILE_MFT);
 		goto err_out;
 	}
@@ -1034,7 +1033,7 @@
 			if (al_entry->lowest_vcn)
 				goto em_put_err_out;
 			/* First entry has to be in the base mft record. */
-			if (MREF_LE(al_entry->mft_reference) != ni->mft_no) {
+			if (MREF_LE(al_entry->mft_reference) != vi->i_ino) {
 				/* MFT references do not match, logic fails. */
 				ntfs_error(sb, "BUG: The first $DATA extent "
 						"of $MFT is not in the base "
@@ -1096,6 +1095,8 @@
 
 		/* Are we in the first extent? */
 		if (!next_vcn) {
+			u64 ll;
+
 			if (attr->_ANR(lowest_vcn)) {
 				ntfs_error(sb, "First extent of $DATA "
 						"attribute has non zero "
@@ -1113,8 +1114,16 @@
 			ni->allocated_size = sle64_to_cpu(
 					attr->_ANR(allocated_size));
 			/* Set the number of mft records. */
-			vol->_VMM(nr_mft_records) = vi->i_size >>
-					vol->mft_record_size_bits;
+			ll = vi->i_size >> vol->mft_record_size_bits;
+			/*
+			 * Verify the number of mft records does not exceed
+			 * 2^32 - 1.
+			 */
+			if (ll >= (1ULL << 32)) {
+				ntfs_error(sb, "$MFT is too big! Aborting.");
+				goto put_err_out;
+			}
+			vol->_VMM(nr_mft_records) = ll;
 			/*
 			 * We have got the first extent of the run_list for
 			 * $MFT which means it is now relatively safe to call
@@ -1255,8 +1264,7 @@
  */
 int ntfs_commit_inode(ntfs_inode *ni)
 {
-	ntfs_debug("Entering for inode 0x%Lx.",
-			(unsigned long long)ni->mft_no);
+	ntfs_debug("Entering for inode 0x%lx.", ni->mft_no);
 	NInoClearDirty(ni);
 	return 0;
 }
@@ -1265,8 +1273,7 @@
 {
 	int err;
 
-	ntfs_debug("Entering for inode 0x%Lx.",
-			(unsigned long long)ni->mft_no);
+	ntfs_debug("Entering for inode 0x%lx.", ni->mft_no);
 	if (NInoDirty(ni)) {
 		err = ntfs_commit_inode(ni);
 		if (err) {
diff -Nru a/fs/ntfs/inode.h b/fs/ntfs/inode.h
--- a/fs/ntfs/inode.h	Thu Jun 20 15:54:01 2002
+++ b/fs/ntfs/inode.h	Thu Jun 20 15:54:01 2002
@@ -39,7 +39,7 @@
 	s64 allocated_size;	/* Copy from $DATA/$INDEX_ALLOCATION. */
 	unsigned long state;	/* NTFS specific flags describing this inode.
 				   See fs/ntfs/ntfs.h:ntfs_inode_state_bits. */
-	u64 mft_no;		/* Mft record number (inode number). */
+	unsigned long mft_no;	/* Number of the mft record / inode. */
 	u16 seq_no;		/* Sequence number of the mft record. */
 	atomic_t count;		/* Inode reference count for book keeping. */
 	ntfs_volume *vol;	/* Pointer to the ntfs volume of this inode. */
diff -Nru a/fs/ntfs/layout.h b/fs/ntfs/layout.h
--- a/fs/ntfs/layout.h	Thu Jun 20 15:53:59 2002
+++ b/fs/ntfs/layout.h	Thu Jun 20 15:53:59 2002
@@ -278,9 +278,9 @@
 
 typedef u64 MFT_REF;
 
-#define MREF(x)		((u64)((x) & MFT_REF_MASK_CPU))
+#define MREF(x)		((unsigned long)((x) & MFT_REF_MASK_CPU))
 #define MSEQNO(x)	((u16)(((x) >> 48) & 0xffff))
-#define MREF_LE(x)	((u64)(le64_to_cpu(x) & MFT_REF_MASK_CPU))
+#define MREF_LE(x)	((unsigned long)(le64_to_cpu(x) & MFT_REF_MASK_CPU))
 #define MSEQNO_LE(x)	((u16)((le64_to_cpu(x) >> 48) & 0xffff))
 
 #define IS_ERR_MREF(x)	(((x) & 0x0000800000000000ULL) ? 1 : 0)
@@ -948,8 +948,7 @@
 					   data attribute. NOTE: Is a multiple
 					   of the cluster size. */
 /* 30*/	s64 data_size;			/* Byte size of actual data in data
-					   attribute. NOTE: Only present when
-					   lowest_vcn is 0. */
+					   attribute. */
 /* 38*/	FILE_ATTR_FLAGS file_attributes;	/* Flags describing the file. */
 /* 3c*/	union {
 	/* 3c*/	struct {
diff -Nru a/fs/ntfs/mft.c b/fs/ntfs/mft.c
--- a/fs/ntfs/mft.c	Thu Jun 20 15:54:00 2002
+++ b/fs/ntfs/mft.c	Thu Jun 20 15:54:00 2002
@@ -240,8 +240,7 @@
  *
  * The mft record is now ours and we return a pointer to it. You need to check
  * the returned pointer with IS_ERR() and if that is true, PTR_ERR() will return
- * the error code. The following error codes are defined:
- * 	TODO: Fill in the possible error codes.
+ * the error code.
  *
  * NOTE: Caller is responsible for setting the mft record dirty before calling
  * unmap_mft_record(). This is obviously only necessary if the caller really
@@ -254,8 +253,7 @@
 {
 	MFT_RECORD *m;
 
-	ntfs_debug("Entering for i_ino 0x%Lx, mapping for %s.",
-			(unsigned long long)ni->mft_no,
+	ntfs_debug("Entering for mft_no 0x%lx, mapping for %s.", ni->mft_no,
 			rw == READ ? "READ" : "WRITE");
 
 	/* Make sure the ntfs inode doesn't go away. */
@@ -318,8 +316,7 @@
 
 	BUG_ON(!atomic_read(&ni->mft_count) || !page);
 
-	ntfs_debug("Entering for mft_no 0x%Lx, unmapping from %s.",
-			(unsigned long long)ni->mft_no,
+	ntfs_debug("Entering for mft_no 0x%lx, unmapping from %s.", ni->mft_no,
 			rw == READ ? "READ" : "WRITE");
 
 	/* Only release the actual page mapping if this is the last one. */
@@ -369,13 +366,12 @@
 	ntfs_inode *ni = NULL;
 	ntfs_inode **extent_nis = NULL;
 	int i;
-	u64 mft_no = MREF_LE(mref);
+	unsigned long mft_no = MREF_LE(mref);
 	u16 seq_no = MSEQNO_LE(mref);
 	BOOL destroy_ni = FALSE;
 
-	ntfs_debug("Mapping extent mft record 0x%Lx (base mft record 0x%Lx).",
-			(unsigned long long)mft_no,
-			(unsigned long long)base_ni->mft_no);
+	ntfs_debug("Mapping extent mft record 0x%lx (base mft record 0x%lx).",
+			mft_no, base_ni->mft_no);
 	/* Make sure the base ntfs inode doesn't go away. */
 	atomic_inc(&base_ni->count);
 	/*
diff -Nru a/fs/ntfs/namei.c b/fs/ntfs/namei.c
--- a/fs/ntfs/namei.c	Thu Jun 20 15:54:01 2002
+++ b/fs/ntfs/namei.c	Thu Jun 20 15:54:01 2002
@@ -93,7 +93,7 @@
 	struct inode *dent_inode;
 	uchar_t *uname;
 	ntfs_name *name = NULL;
-	u64 mref;
+	MFT_REF mref;
 	unsigned long dent_ino;
 	int uname_len;
 
@@ -110,7 +110,7 @@
 			&name);
 	kmem_cache_free(ntfs_name_cache, uname);
 	if (!IS_ERR_MREF(mref)) {
-		dent_ino = (unsigned long)MREF(mref);
+		dent_ino = MREF(mref);
 		ntfs_debug("Found inode 0x%lx. Calling iget.", dent_ino);
 		dent_inode = iget(vol->sb, dent_ino);
 		if (dent_inode) {
@@ -130,17 +130,15 @@
 				goto handle_name;
 			}
 			ntfs_error(vol->sb, "Found stale reference to inode "
-					"0x%Lx (reference sequence number = "
+					"0x%lx (reference sequence number = "
 					"0x%x, inode sequence number = 0x%x, "
 					"returning -EACCES. Run chkdsk.",
-					(unsigned long long)MREF(mref),
-					MSEQNO(mref),
+					dent_ino, MSEQNO(mref),
 					NTFS_I(dent_inode)->seq_no);
 			iput(dent_inode);
 		} else
-			ntfs_error(vol->sb, "iget(0x%Lx) failed, returning "
-					"-EACCES.",
-					(unsigned long long)MREF(mref));
+			ntfs_error(vol->sb, "iget(0x%lx) failed, returning "
+					"-EACCES.", dent_ino);
 		if (name)
 			kfree(name);
 		return ERR_PTR(-EACCES);
@@ -235,8 +233,9 @@
 	}
 	nls_name.hash = full_name_hash(nls_name.name, nls_name.len);
 
-	// FIXME: Do we need dcache_lock or dparent_lock here or is the
-	// fact that i_sem is held on the parent inode sufficient? (AIA)
+	/*
+	 * Note: No need for dparent_lock as i_sem is held on the parent inode.
+	 */
 
 	/* Does a dentry matching the nls_name exist already? */
 	real_dent = d_lookup(dent->d_parent, &nls_name);
diff -Nru a/fs/ntfs/super.c b/fs/ntfs/super.c
--- a/fs/ntfs/super.c	Thu Jun 20 15:54:00 2002
+++ b/fs/ntfs/super.c	Thu Jun 20 15:54:00 2002
@@ -1236,14 +1236,13 @@
  * Errors are ignored and we just return the number of free inodes we have
  * found. This means we return an underestimate on error.
  */
-s64 get_nr_free_mft_records(ntfs_volume *vol)
+unsigned long get_nr_free_mft_records(ntfs_volume *vol)
 {
 	struct address_space *mapping;
 	filler_t *readpage;
 	struct page *page;
-	unsigned long index, max_index;
+	unsigned long index, max_index, nr_free = 0;
 	unsigned int max_size, i;
-	s64 nr_free = 0LL;
 	u32 *b;
 
 	ntfs_debug("Entering.");
@@ -1285,7 +1284,7 @@
 		b = (u32*)kmap(page);
 		/* For each 4 bytes, add up the number of zero bits. */
 	  	for (i = 0; i < max_size; i++)
-			nr_free += (s64)(32 - hweight32(b[i]));
+			nr_free += 32 - hweight32(b[i]);
 		kunmap(page);
 		page_cache_release(page);
 	}
@@ -1300,7 +1299,7 @@
 		if (max_size) {
 			/* Compensate for out of bounds zero bits. */
 			if ((i = vol->_VMM(nr_mft_records) & 31))
-				nr_free -= (s64)(32 - i);
+				nr_free -= 32 - i;
 			ntfs_debug("Handling partial page, max_size = 0x%x",
 					max_size);
 			goto handle_partial_page;
@@ -1358,10 +1357,7 @@
 	/* Total file nodes in file system (at this moment in time). */
 	sfs->f_files  = vol->mft_ino->i_size >> vol->mft_record_size_bits;
 	/* Free file nodes in fs (based on current total count). */
-	size	      = get_nr_free_mft_records(vol);
-	if (size < 0LL)
-		size = 0LL;
-	sfs->f_ffree = size;
+	sfs->f_ffree = get_nr_free_mft_records(vol);
 	/*
 	 * File system id. This is extremely *nix flavour dependent and even
 	 * within Linux itself all fs do their own thing. I interpret this to
diff -Nru a/fs/ntfs/volume.h b/fs/ntfs/volume.h
--- a/fs/ntfs/volume.h	Thu Jun 20 15:54:00 2002
+++ b/fs/ntfs/volume.h	Thu Jun 20 15:54:00 2002
@@ -105,8 +105,8 @@
 	struct rw_semaphore mftbmp_lock; /* Lock for serializing accesses to the
 					    mft record bitmap ($MFT/$BITMAP). */
 	union {
-		s64 nr_mft_records;	/* Number of records in the mft. */
-		s64 nr_mft_bits;	/* Number of bits in mft bitmap. */
+		unsigned long nr_mft_records; /* Number of mft records. */
+		unsigned long nr_mft_bits; /* Number of bits in mft bitmap. */
 	} SN(vmm);
 	struct address_space mftbmp_mapping; /* Page cache for $MFT/$BITMAP. */
 	run_list mftbmp_rl;		/* Run list for $MFT/$BITMAP. */
diff -Nru a/fs/partitions/Config.in b/fs/partitions/Config.in
--- a/fs/partitions/Config.in	Thu Jun 20 15:54:00 2002
+++ b/fs/partitions/Config.in	Thu Jun 20 15:54:00 2002
@@ -25,7 +25,7 @@
       bool '    Solaris (x86) partition table support' CONFIG_SOLARIS_X86_PARTITION
       bool '    Unixware slices support' CONFIG_UNIXWARE_DISKLABEL
    fi
-   dep_bool '  Windows Logical Disk Manager (Dynamic Disk) support' CONFIG_LDM_PARTITION $CONFIG_EXPERIMENTAL
+   dep_bool '  Windows Logical Disk Manager (Dynamic Disk) support (EXPERIMENTAL)' CONFIG_LDM_PARTITION $CONFIG_EXPERIMENTAL
    if [ "$CONFIG_LDM_PARTITION" = "y" ]; then
       bool '    Windows LDM extra logging' CONFIG_LDM_DEBUG
    fi
diff -Nru a/fs/reiserfs/journal.c b/fs/reiserfs/journal.c
--- a/fs/reiserfs/journal.c	Thu Jun 20 15:54:01 2002
+++ b/fs/reiserfs/journal.c	Thu Jun 20 15:54:01 2002
@@ -57,7 +57,7 @@
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/smp_lock.h>
-#include <linux/suspend.h> 
+#include <linux/suspend.h>
 #include <linux/buffer_head.h>
 
 /* the number of mounted filesystems.  This is used to decide when to
diff -Nru a/fs/smbfs/sock.c b/fs/smbfs/sock.c
--- a/fs/smbfs/sock.c	Thu Jun 20 15:54:00 2002
+++ b/fs/smbfs/sock.c	Thu Jun 20 15:54:00 2002
@@ -18,6 +18,7 @@
 #include <linux/mm.h>
 #include <linux/netdevice.h>
 #include <linux/smp_lock.h>
+#include <linux/tqueue.h>
 #include <net/scm.h>
 #include <net/ip.h>
 
diff -Nru a/include/asm-alpha/signal.h b/include/asm-alpha/signal.h
--- a/include/asm-alpha/signal.h	Thu Jun 20 15:54:01 2002
+++ b/include/asm-alpha/signal.h	Thu Jun 20 15:54:01 2002
@@ -187,6 +187,7 @@
 #include <asm/sigcontext.h>
 
 #define HAVE_ARCH_GET_SIGNAL_TO_DELIVER
+#define HAVE_ARCH_SYS_PAUSE
 
 #endif
 
diff -Nru a/include/asm-alpha/unistd.h b/include/asm-alpha/unistd.h
--- a/include/asm-alpha/unistd.h	Thu Jun 20 15:54:01 2002
+++ b/include/asm-alpha/unistd.h	Thu Jun 20 15:54:01 2002
@@ -319,6 +319,19 @@
 #define __NR_readahead			379
 #define __NR_security			380 /* syscall for security modules */
 #define __NR_tkill			381
+#define __NR_setxattr			382
+#define __NR_lsetxattr			383
+#define __NR_fsetxattr			384
+#define __NR_getxattr			385
+#define __NR_lgetxattr			386
+#define __NR_fgetxattr			387
+#define __NR_listxattr			388
+#define __NR_llistxattr			389
+#define __NR_flistxattr			390
+#define __NR_removexattr		391
+#define __NR_lremovexattr		392
+#define __NR_fremovexattr		393
+
 
 #if defined(__GNUC__)
 
diff -Nru a/include/asm-i386/xor.h b/include/asm-i386/xor.h
--- a/include/asm-i386/xor.h	Thu Jun 20 15:54:00 2002
+++ b/include/asm-i386/xor.h	Thu Jun 20 15:54:00 2002
@@ -550,7 +550,7 @@
 		"movups %%xmm1,0x10(%1)	;\n\t"	\
 		"movups %%xmm2,0x20(%1)	;\n\t"	\
 		"movups %%xmm3,0x30(%1)	;\n\t"	\
-		: "=r" (cr0)			\
+		: "=&r" (cr0)			\
 		: "r" (xmm_save) 		\
 		: "memory")
 
diff -Nru a/include/asm-ia64/delay.h b/include/asm-ia64/delay.h
--- a/include/asm-ia64/delay.h	Thu Jun 20 15:54:00 2002
+++ b/include/asm-ia64/delay.h	Thu Jun 20 15:54:00 2002
@@ -15,6 +15,7 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/compiler.h>
 
 #include <asm/processor.h>
 
@@ -52,7 +53,7 @@
 
 	__asm__ __volatile__("mov %0=ar.itc" : "=r"(result) :: "memory");
 #ifdef CONFIG_ITANIUM
-	while (__builtin_expect ((__s32) result == -1, 0))
+	while (unlikely ((__s32) result == -1)
 		__asm__ __volatile__("mov %0=ar.itc" : "=r"(result) :: "memory");
 #endif
 	return result;
diff -Nru a/include/asm-ia64/pgalloc.h b/include/asm-ia64/pgalloc.h
--- a/include/asm-ia64/pgalloc.h	Thu Jun 20 15:54:00 2002
+++ b/include/asm-ia64/pgalloc.h	Thu Jun 20 15:54:00 2002
@@ -17,6 +17,7 @@
 
 #include <linux/mm.h>
 #include <linux/threads.h>
+#include <linux/compiler.h>
 
 #include <asm/mmu_context.h>
 #include <asm/processor.h>
@@ -37,7 +38,7 @@
 {
 	unsigned long *ret = pgd_quicklist;
 
-	if (__builtin_expect(ret != NULL, 1)) {
+	if (likely(ret != NULL)) {
 		pgd_quicklist = (unsigned long *)(*ret);
 		ret[0] = 0;
 		--pgtable_cache_size;
@@ -52,9 +53,9 @@
 	/* the VM system never calls pgd_alloc_one_fast(), so we do it here. */
 	pgd_t *pgd = pgd_alloc_one_fast(mm);
 
-	if (__builtin_expect(pgd == NULL, 0)) {
+	if (unlikely(pgd == NULL)) {
 		pgd = (pgd_t *)__get_free_page(GFP_KERNEL);
-		if (__builtin_expect(pgd != NULL, 1))
+		if (likely(pgd != NULL))
 			clear_page(pgd);
 	}
 	return pgd;
@@ -80,7 +81,7 @@
 {
 	unsigned long *ret = (unsigned long *)pmd_quicklist;
 
-	if (__builtin_expect(ret != NULL, 1)) {
+	if (likely(ret != NULL)) {
 		pmd_quicklist = (unsigned long *)(*ret);
 		ret[0] = 0;
 		--pgtable_cache_size;
@@ -93,7 +94,7 @@
 {
 	pmd_t *pmd = (pmd_t *) __get_free_page(GFP_KERNEL);
 
-	if (__builtin_expect(pmd != NULL, 1))
+	if (likely(pmd != NULL))
 		clear_page(pmd);
 	return pmd;
 }
@@ -125,7 +126,7 @@
 {
 	struct page *pte = alloc_pages(GFP_KERNEL, 0);
 
-	if (__builtin_expect(pte != NULL, 1))
+	if (likely(pte != NULL))
 		clear_page(page_address(pte));
 	return pte;
 }
@@ -135,7 +136,7 @@
 {
 	pte_t *pte = (pte_t *) __get_free_page(GFP_KERNEL);
 
-	if (__builtin_expect(pte != NULL, 1))
+	if (likely(pte != NULL))
 		clear_page(pte);
 	return pte;
 }
diff -Nru a/include/asm-ia64/processor.h b/include/asm-ia64/processor.h
--- a/include/asm-ia64/processor.h	Thu Jun 20 15:54:00 2002
+++ b/include/asm-ia64/processor.h	Thu Jun 20 15:54:00 2002
@@ -16,6 +16,7 @@
 #include <linux/config.h>
 
 #include <linux/percpu.h>
+#include <linux/compiler.h>
 
 #include <asm/ptrace.h>
 #include <asm/kregs.h>
@@ -283,7 +284,7 @@
 	regs->loadrs = 0;									\
 	regs->r8 = current->mm->dumpable;	/* set "don't zap registers" flag */		\
 	regs->r12 = new_sp - 16;	/* allocate 16 byte scratch area */			\
-	if (!__builtin_expect (current->mm->dumpable, 1)) {					\
+	if (!likely (current->mm->dumpable)) {					\
 		/*										\
 		 * Zap scratch regs to avoid leaking bits between processes with different	\
 		 * uid/privileges.								\
diff -Nru a/include/asm-ia64/signal.h b/include/asm-ia64/signal.h
--- a/include/asm-ia64/signal.h	Thu Jun 20 15:54:00 2002
+++ b/include/asm-ia64/signal.h	Thu Jun 20 15:54:00 2002
@@ -167,6 +167,7 @@
 #  include <asm/sigcontext.h>
 
 #define HAVE_ARCH_GET_SIGNAL_TO_DELIVER
+#define HAVE_ARCH_SYS_PAUSE
 
 #endif /* __KERNEL__ */
 
diff -Nru a/include/asm-ia64/softirq.h b/include/asm-ia64/softirq.h
--- a/include/asm-ia64/softirq.h	Thu Jun 20 15:54:01 2002
+++ b/include/asm-ia64/softirq.h	Thu Jun 20 15:54:01 2002
@@ -1,6 +1,8 @@
 #ifndef _ASM_IA64_SOFTIRQ_H
 #define _ASM_IA64_SOFTIRQ_H
 
+#include <linux/compiler.h>
+
 /*
  * Copyright (C) 1998-2001 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
@@ -13,7 +15,7 @@
 #define local_bh_enable()								\
 do {											\
 	__local_bh_enable();								\
-	if (__builtin_expect(local_softirq_pending(), 0) && really_local_bh_count() == 0)	\
+	if (unlikely(local_softirq_pending()) && really_local_bh_count() == 0)	\
 		do_softirq();								\
 } while (0)
 
diff -Nru a/include/asm-sparc64/hardirq.h b/include/asm-sparc64/hardirq.h
--- a/include/asm-sparc64/hardirq.h	Thu Jun 20 15:54:00 2002
+++ b/include/asm-sparc64/hardirq.h	Thu Jun 20 15:54:00 2002
@@ -64,9 +64,12 @@
 {
 	int i;
 
-	for (i = 0; i < smp_num_cpus; i++)
-		if (local_irq_count(cpu_logical_map(i)))
+	for (i = 0; i < NR_CPUS; i++) {
+		if (!cpu_online(i))
+			continue;
+		if (local_irq_count(i))
 			return 1;
+	}
 	return 0;
 }
 
diff -Nru a/include/asm-sparc64/signal.h b/include/asm-sparc64/signal.h
--- a/include/asm-sparc64/signal.h	Thu Jun 20 15:54:00 2002
+++ b/include/asm-sparc64/signal.h	Thu Jun 20 15:54:00 2002
@@ -254,6 +254,7 @@
 } stack_t32;
 
 #define HAVE_ARCH_GET_SIGNAL_TO_DELIVER
+#define HAVE_ARCH_SYS_PAUSE
 
 #endif
 
diff -Nru a/include/asm-sparc64/smp.h b/include/asm-sparc64/smp.h
--- a/include/asm-sparc64/smp.h	Thu Jun 20 15:54:00 2002
+++ b/include/asm-sparc64/smp.h	Thu Jun 20 15:54:00 2002
@@ -24,7 +24,8 @@
 };
 
 extern int linux_num_cpus;	/* number of CPUs probed  */
-extern struct prom_cpuinfo linux_cpus[64];
+extern struct prom_cpuinfo linux_cpus[NR_CPUS];
+extern unsigned int prom_cpu_nodes[NR_CPUS];
 
 #endif /* !(__ASSEMBLY__) */
 
@@ -60,9 +61,21 @@
  *	Private routines/data
  */
  
+#include <asm/bitops.h>
+#include <asm/atomic.h>
+
 extern unsigned char boot_cpu_id;
-extern unsigned long cpu_present_map;
-#define cpu_online_map cpu_present_map
+extern unsigned long cpu_online_map;
+#define cpu_online(cpu)		(cpu_online_map & (1UL << (cpu)))
+extern atomic_t sparc64_num_cpus_online;
+#define num_online_cpus()	(atomic_read(&sparc64_num_cpus_online))
+
+static inline int any_online_cpu(unsigned long mask)
+{
+	if ((mask &= cpu_online_map) != 0UL)
+		return __ffs(mask);
+	return -1;
+}
 
 /*
  *	General functions that each host system must provide.
@@ -71,18 +84,6 @@
 extern void smp_callin(void);
 extern void smp_boot_cpus(void);
 extern void smp_store_cpu_info(int id);
-
-extern __volatile__ int __cpu_number_map[NR_CPUS];
-extern __volatile__ int __cpu_logical_map[NR_CPUS];
-
-extern __inline__ int cpu_logical_map(int cpu)
-{
-	return __cpu_logical_map[cpu];
-}
-extern __inline__ int cpu_number_map(int cpu)
-{
-	return __cpu_number_map[cpu];
-}
 
 extern __inline__ int hard_smp_processor_id(void)
 {
diff -Nru a/include/linux/blk.h b/include/linux/blk.h
--- a/include/linux/blk.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/blk.h	Thu Jun 20 15:54:00 2002
@@ -40,6 +40,7 @@
 
 extern int end_that_request_first(struct request *, int, int);
 extern void end_that_request_last(struct request *);
+struct request *elv_next_request(request_queue_t *q);
 
 static inline void blkdev_dequeue_request(struct request *req)
 {
@@ -47,38 +48,6 @@
 
 	if (req->q)
 		elv_remove_request(req->q, req);
-}
-
-extern inline struct request *elv_next_request(request_queue_t *q)
-{
-	struct request *rq;
-
-	while ((rq = __elv_next_request(q))) {
-		rq->flags |= REQ_STARTED;
-
-		if (&rq->queuelist == q->last_merge)
-			q->last_merge = NULL;
-
-		if ((rq->flags & REQ_DONTPREP) || !q->prep_rq_fn)
-			break;
-
-		/*
-		 * all ok, break and return it
-		 */
-		if (!q->prep_rq_fn(q, rq))
-			break;
-
-		/*
-		 * prep said no-go, kill it
-		 */
-		blkdev_dequeue_request(rq);
-		if (end_that_request_first(rq, 0, rq->nr_sectors))
-			BUG();
-
-		end_that_request_last(rq);
-	}
-
-	return rq;
 }
 
 #define _elv_add_request_core(q, rq, where, plug)			\
diff -Nru a/include/linux/elevator.h b/include/linux/elevator.h
--- a/include/linux/elevator.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/elevator.h	Thu Jun 20 15:54:00 2002
@@ -40,7 +40,6 @@
  */
 extern void __elv_add_request(request_queue_t *, struct request *,
 			      struct list_head *);
-extern struct request *__elv_next_request(request_queue_t *);
 extern void elv_merge_cleanup(request_queue_t *, struct request *, int);
 extern int elv_merge(request_queue_t *, struct request **, struct bio *);
 extern void elv_merge_requests(request_queue_t *, struct request *,
diff -Nru a/include/linux/ethtool.h b/include/linux/ethtool.h
--- a/include/linux/ethtool.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/ethtool.h	Thu Jun 20 15:54:00 2002
@@ -39,7 +39,8 @@
 	char	bus_info[ETHTOOL_BUSINFO_LEN];	/* Bus info for this IF. */
 				/* For PCI devices, use pci_dev->slot_name. */
 	char	reserved1[32];
-	char	reserved2[20];
+	char	reserved2[16];
+	u32	n_stats;	/* number of u64's from ETHTOOL_GSTATS */
 	u32	testinfo_len;
 	u32	eedump_len;	/* Size of data from ETHTOOL_GEEPROM (bytes) */
 	u32	regdump_len;	/* Size of data from ETHTOOL_GREGS (bytes) */
@@ -242,6 +243,13 @@
 	u64	data[0];
 };
 
+/* for dumping NIC-specific statistics */
+struct ethtool_stats {
+	u32	cmd;		/* ETHTOOL_GSTATS */
+	u32	n_stats;	/* number of u64's being returned */
+	u64	data[0];
+};
+
 /* CMDs currently supported */
 #define ETHTOOL_GSET		0x00000001 /* Get settings. */
 #define ETHTOOL_SSET		0x00000002 /* Set settings, privileged. */
@@ -272,6 +280,7 @@
 #define ETHTOOL_TEST		0x0000001a /* execute NIC self-test, priv. */
 #define ETHTOOL_GSTRINGS	0x0000001b /* get specified string set */
 #define ETHTOOL_PHYS_ID		0x0000001c /* identify the NIC */
+#define ETHTOOL_GSTATS		0x0000001d /* get NIC-specific statistics */
 
 /* compatibility with older code */
 #define SPARC_ETH_GSET		ETHTOOL_GSET
diff -Nru a/include/linux/futex.h b/include/linux/futex.h
--- a/include/linux/futex.h	Thu Jun 20 15:54:01 2002
+++ b/include/linux/futex.h	Thu Jun 20 15:54:01 2002
@@ -4,5 +4,6 @@
 /* Second argument to futex syscall */
 #define FUTEX_WAIT (0)
 #define FUTEX_WAKE (1)
+#define FUTEX_FD (2)
 
 #endif
diff -Nru a/include/linux/i2c-dev.h b/include/linux/i2c-dev.h
--- a/include/linux/i2c-dev.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/i2c-dev.h	Thu Jun 20 15:54:00 2002
@@ -19,7 +19,7 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef I2C_DEV_H
 #define I2C_DEV_H
@@ -160,6 +160,22 @@
 	data.block[0] = length;
 	return i2c_smbus_access(file,I2C_SMBUS_WRITE,command,
 	                        I2C_SMBUS_BLOCK_DATA, &data);
+}
+
+/* Returns the number of read bytes */
+static inline __s32 i2c_smbus_read_i2c_block_data(int file, __u8 command,
+                                                  __u8 *values)
+{
+	union i2c_smbus_data data;
+	int i;
+	if (i2c_smbus_access(file,I2C_SMBUS_READ,command,
+	                      I2C_SMBUS_I2C_BLOCK_DATA,&data))
+		return -1;
+	else {
+		for (i = 1; i <= data.block[0]; i++)
+			values[i-1] = data.block[i];
+		return data.block[0];
+	}
 }
 
 static inline __s32 i2c_smbus_write_i2c_block_data(int file, __u8 command,
diff -Nru a/include/linux/i2c-id.h b/include/linux/i2c-id.h
--- a/include/linux/i2c-id.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/i2c-id.h	Thu Jun 20 15:54:00 2002
@@ -20,7 +20,7 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
 /* ------------------------------------------------------------------------- */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef I2C_ID_H
 #define I2C_ID_H
@@ -90,6 +90,10 @@
 #define I2C_DRIVERID_DRP3510	43     /* ADR decoder (Astra Radio)	*/
 #define I2C_DRIVERID_SP5055	44     /* Satellite tuner		*/
 #define I2C_DRIVERID_STV0030	45     /* Multipurpose switch		*/
+#define I2C_DRIVERID_SAA7108    46     /* video decoder, image scaler   */
+
+
+
 
 #define I2C_DRIVERID_EXP0	0xF0	/* experimental use id's	*/
 #define I2C_DRIVERID_EXP1	0xF1
@@ -127,6 +131,9 @@
 #define I2C_DRIVERID_ADM1024 1025
 #define I2C_DRIVERID_IT87 1026
 #define I2C_DRIVERID_CH700X 1027 /* single driver for CH7003-7009 digital pc to tv encoders */
+#define I2C_DRIVERID_FSCPOS 1028
+#define I2C_DRIVERID_FSCSCY 1029
+#define I2C_DRIVERID_PCF8591 1030
 
 /*
  * ---- Adapter types ----------------------------------------------------
@@ -143,7 +150,8 @@
 #define I2C_ALGO_ISA 	0x050000	/* lm_sensors ISA pseudo-adapter */
 #define I2C_ALGO_SAA7146 0x060000	/* SAA 7146 video decoder bus	*/
 #define I2C_ALGO_ACB 	0x070000	/* ACCESS.bus algorithm         */
-
+#define I2C_ALGO_IIC    0x080000 	/* ITE IIC bus */
+#define I2C_ALGO_SAA7134 0x090000
 #define I2C_ALGO_EC     0x100000        /* ACPI embedded controller     */
 
 #define I2C_ALGO_MPC8XX 0x110000	/* MPC8xx PowerPC I2C algorithm */
@@ -188,6 +196,9 @@
 
 /* --- MPC8xx PowerPC adapters						*/
 #define I2C_HW_MPC8XX_EPON 0x00	/* Eponymous MPC8xx I2C adapter 	*/
+
+/* --- ITE based algorithms						*/
+#define I2C_HW_I_IIC	0x00	/* controller on the ITE */
 
 /* --- SMBus only adapters						*/
 #define I2C_HW_SMBUS_PIIX4	0x00
diff -Nru a/include/linux/i2c-proc.h b/include/linux/i2c-proc.h
--- a/include/linux/i2c-proc.h	Thu Jun 20 15:54:01 2002
+++ b/include/linux/i2c-proc.h	Thu Jun 20 15:54:01 2002
@@ -1,6 +1,7 @@
 /*
-    sensors.h - Part of lm_sensors, Linux kernel modules for hardware
-                monitoring
+    i2c-proc.h - Part of the i2c package
+    was originally sensors.h - Part of lm_sensors, Linux kernel modules
+                               for hardware monitoring
     Copyright (c) 1998, 1999  Frodo Looijaard <frodol@dds.nl>
 
     This program is free software; you can redistribute it and/or modify
diff -Nru a/include/linux/i2c.h b/include/linux/i2c.h
--- a/include/linux/i2c.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/i2c.h	Thu Jun 20 15:54:00 2002
@@ -23,13 +23,13 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and
    Frodo Looijaard <frodol@dds.nl> */
 
-/* $Id$ */
+/* $Id$ */
 
 #ifndef I2C_H
 #define I2C_H
 
-#define I2C_DATE "20010830"
-#define I2C_VERSION "2.6.1"
+#define I2C_DATE "20020322"
+#define I2C_VERSION "2.6.3"
 
 #include <linux/i2c-id.h>	/* id values of adapters et. al. 	*/
 #include <linux/types.h>
@@ -48,11 +48,8 @@
 #endif
 
 #include <asm/page.h>			/* for 2.2.xx 			*/
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,0,25)
 #include <linux/sched.h>
-#else
 #include <asm/semaphore.h>
-#endif
 #include <linux/config.h>
 
 /* --- General options ------------------------------------------------	*/
@@ -123,6 +120,8 @@
 extern s32 i2c_smbus_write_block_data(struct i2c_client * client,
                                       u8 command, u8 length,
                                       u8 *values);
+extern s32 i2c_smbus_read_i2c_block_data(struct i2c_client * client,
+                                         u8 command, u8 *values);
 extern s32 i2c_smbus_write_i2c_block_data(struct i2c_client * client,
                                           u8 command, u8 length,
                                           u8 *values);
@@ -406,8 +405,10 @@
 #define I2C_FUNC_SMBUS_PROC_CALL	0x00800000 
 #define I2C_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000 
 #define I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000 
-#define I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* New I2C-like block */
-#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* transfer */
+#define I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* I2C-like block xfer  */
+#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */
+#define I2C_FUNC_SMBUS_READ_I2C_BLOCK_2	 0x10000000 /* I2C-like block xfer  */
+#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK_2 0x20000000 /* w/ 2-byte reg. addr. */
 
 #define I2C_FUNC_SMBUS_BYTE I2C_FUNC_SMBUS_READ_BYTE | \
                             I2C_FUNC_SMBUS_WRITE_BYTE
@@ -419,13 +420,17 @@
                                   I2C_FUNC_SMBUS_WRITE_BLOCK_DATA
 #define I2C_FUNC_SMBUS_I2C_BLOCK I2C_FUNC_SMBUS_READ_I2C_BLOCK | \
                                   I2C_FUNC_SMBUS_WRITE_I2C_BLOCK
+#define I2C_FUNC_SMBUS_I2C_BLOCK_2 I2C_FUNC_SMBUS_READ_I2C_BLOCK_2 | \
+                                   I2C_FUNC_SMBUS_WRITE_I2C_BLOCK_2
 
 #define I2C_FUNC_SMBUS_EMUL I2C_FUNC_SMBUS_QUICK | \
                             I2C_FUNC_SMBUS_BYTE | \
                             I2C_FUNC_SMBUS_BYTE_DATA | \
                             I2C_FUNC_SMBUS_WORD_DATA | \
                             I2C_FUNC_SMBUS_PROC_CALL | \
-                            I2C_FUNC_SMBUS_WRITE_BLOCK_DATA
+                            I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \
+                            I2C_FUNC_SMBUS_I2C_BLOCK | \
+                            I2C_FUNC_SMBUS_I2C_BLOCK_2
 
 /* 
  * Data for SMBus Messages 
diff -Nru a/include/linux/ide.h b/include/linux/ide.h
--- a/include/linux/ide.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/ide.h	Thu Jun 20 15:54:00 2002
@@ -298,7 +298,6 @@
 	unsigned using_tcq	: 1;	/* disk is using queueing */
 	unsigned dsc_overlap	: 1;	/* flag: DSC overlap */
 
-	unsigned waiting_for_dma: 1;	/* dma currently in progress */
 	unsigned busy		: 1;	/* currently doing revalidate_disk() */
 	unsigned blocked        : 1;	/* 1=powermanagment told us not to do anything, so sleep nicely */
 
@@ -681,7 +680,8 @@
 		bio_kunmap_irq(to, flags);
 }
 
-extern int ide_raw_taskfile(struct ata_device *, struct ata_taskfile *, char *);
+extern ide_startstop_t ata_special_intr(struct ata_device *, struct request *);
+extern int ide_raw_taskfile(struct ata_device *, struct ata_taskfile *);
 
 extern void ide_fix_driveid(struct hd_driveid *id);
 extern int ide_config_drive_speed(struct ata_device *, byte);
@@ -756,6 +756,8 @@
 
 static inline int udma_stop(struct ata_device *drive)
 {
+	clear_bit(IDE_DMA, drive->channel->active);
+
 	return drive->channel->udma_stop(drive);
 }
 
@@ -764,7 +766,11 @@
  */
 static inline ide_startstop_t udma_init(struct ata_device *drive, struct request *rq)
 {
-	return drive->channel->udma_init(drive, rq);
+	int ret = drive->channel->udma_init(drive, rq);
+	if (ret == ide_started)
+		set_bit(IDE_DMA, drive->channel->active);
+
+	return ret;
 }
 
 static inline int udma_irq_status(struct ata_device *drive)
diff -Nru a/include/linux/if_tun.h b/include/linux/if_tun.h
--- a/include/linux/if_tun.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/if_tun.h	Thu Jun 20 15:54:00 2002
@@ -50,10 +50,6 @@
 #endif  
 };
 
-#ifndef MIN
-#define MIN(a,b) ( (a)<(b) ? (a):(b) ) 
-#endif
-
 #endif /* __KERNEL__ */
 
 /* Read queue size */
diff -Nru a/include/linux/interrupt.h b/include/linux/interrupt.h
--- a/include/linux/interrupt.h	Thu Jun 20 15:53:59 2002
+++ b/include/linux/interrupt.h	Thu Jun 20 15:53:59 2002
@@ -28,20 +28,17 @@
    
 enum {
 	TIMER_BH = 0,
-	TQUEUE_BH,
-	DIGI_BH,
-	SERIAL_BH,
-	RISCOM8_BH,
-	SPECIALIX_BH,
-	AURORA_BH,
-	ESP_BH,
-	SCSI_BH,
-	IMMEDIATE_BH,
-	CYCLADES_BH,
-	CM206_BH,
-	JS_BH,
-	MACSERIAL_BH,
-	ISICOM_BH
+	TQUEUE_BH = 1,
+	DIGI_BH = 2,
+	SERIAL_BH = 3,
+	RISCOM8_BH = 4,
+	SPECIALIX_BH = 5,
+	AURORA_BH = 6,
+	ESP_BH = 7,
+	IMMEDIATE_BH = 9,
+	CYCLADES_BH = 10,
+	MACSERIAL_BH = 13,
+	ISICOM_BH = 14
 };
 
 #include <asm/hardirq.h>
diff -Nru a/include/linux/proc_fs.h b/include/linux/proc_fs.h
--- a/include/linux/proc_fs.h	Thu Jun 20 15:53:59 2002
+++ b/include/linux/proc_fs.h	Thu Jun 20 15:53:59 2002
@@ -198,6 +198,7 @@
 	mode_t mode, struct proc_dir_entry *base, get_info_t *get_info)
 	{ return NULL; }
 
+struct tty_driver;
 static inline void proc_tty_register_driver(struct tty_driver *driver) {};
 static inline void proc_tty_unregister_driver(struct tty_driver *driver) {};
 
diff -Nru a/include/linux/sched.h b/include/linux/sched.h
--- a/include/linux/sched.h	Thu Jun 20 15:54:00 2002
+++ b/include/linux/sched.h	Thu Jun 20 15:54:00 2002
@@ -863,6 +863,34 @@
 		clear_thread_flag(TIF_SIGPENDING);
 }
 
+/*
+ * Wrappers for p->thread_info->cpu access. No-op on UP.
+ */
+#ifdef CONFIG_SMP
+
+static inline unsigned int task_cpu(struct task_struct *p)
+{
+	return p->thread_info->cpu;
+}
+
+static inline void set_task_cpu(struct task_struct *p, unsigned int cpu)
+{
+	p->thread_info->cpu = cpu;
+}
+
+#else
+
+static inline unsigned int task_cpu(struct task_struct *p)
+{
+	return 0;
+}
+
+static inline void set_task_cpu(struct task_struct *p, unsigned int cpu)
+{
+}
+
+#endif /* CONFIG_SMP */
+
 #endif /* __KERNEL__ */
 
 #endif
diff -Nru a/include/linux/smp.h b/include/linux/smp.h
--- a/include/linux/smp.h	Thu Jun 20 15:54:01 2002
+++ b/include/linux/smp.h	Thu Jun 20 15:54:01 2002
@@ -86,6 +86,7 @@
 #define smp_call_function(func,info,retry,wait)	({ 0; })
 static inline void smp_send_reschedule(int cpu) { }
 static inline void smp_send_reschedule_all(void) { }
+#define cpu_online_map				1
 #define cpu_online(cpu)				1
 #define num_online_cpus()			1
 #define __per_cpu_data
diff -Nru a/include/net/ip6_route.h b/include/net/ip6_route.h
--- a/include/net/ip6_route.h	Thu Jun 20 15:54:00 2002
+++ b/include/net/ip6_route.h	Thu Jun 20 15:54:00 2002
@@ -23,9 +23,6 @@
 
 extern struct rt6_info	ip6_null_entry;
 
-extern int ip6_rt_max_size;
-extern int ip6_rt_gc_min;
-extern int ip6_rt_gc_timeout;
 extern int ip6_rt_gc_interval;
 
 extern void			ip6_route_input(struct sk_buff *skb);
diff -Nru a/include/net/irda/af_irda.h b/include/net/irda/af_irda.h
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/include/net/irda/af_irda.h	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,82 @@
+/*********************************************************************
+ *                
+ * Filename:      af_irda.h
+ * Version:       1.0
+ * Description:   IrDA sockets declarations
+ * Status:        Stable
+ * Author:        Dag Brattli <dagb@cs.uit.no>
+ * Created at:    Tue Dec  9 21:13:12 1997
+ * Modified at:   Fri Jan 28 13:16:32 2000
+ * Modified by:   Dag Brattli <dagb@cs.uit.no>
+ * 
+ *     Copyright (c) 1998-2000 Dag Brattli, All Rights Reserved.
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
+ *      
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version.
+ *  
+ *     Neither Dag Brattli nor University of Troms admit liability nor
+ *     provide warranty for any of this software. This material is 
+ *     provided "AS-IS" and at no charge.
+ *     
+ ********************************************************************/
+
+#ifndef AF_IRDA_H
+#define AF_IRDA_H
+
+#include <linux/irda.h>
+#include <net/irda/irda.h>
+#include <net/irda/iriap.h>		/* struct iriap_cb */
+#include <net/irda/irias_object.h>	/* struct ias_value */
+#include <net/irda/irlmp.h>		/* struct lsap_cb */
+#include <net/irda/irttp.h>		/* struct tsap_cb */
+#include <net/irda/discovery.h>		/* struct discovery_t */
+
+/* IrDA Socket */
+struct irda_sock {
+	__u32 saddr;          /* my local address */
+	__u32 daddr;          /* peer address */
+
+	struct lsap_cb *lsap; /* LSAP used by Ultra */
+	__u8  pid;            /* Protocol IP (PID) used by Ultra */
+
+	struct tsap_cb *tsap; /* TSAP used by this connection */
+	__u8 dtsap_sel;       /* remote TSAP address */
+	__u8 stsap_sel;       /* local TSAP address */
+	
+	__u32 max_sdu_size_rx;
+	__u32 max_sdu_size_tx;
+	__u32 max_data_size;
+	__u8  max_header_size;
+	struct qos_info qos_tx;
+
+	__u16 mask;           /* Hint bits mask */
+	__u16 hints;          /* Hint bits */
+
+	__u32 ckey;           /* IrLMP client handle */
+	__u32 skey;           /* IrLMP service handle */
+
+	struct ias_object *ias_obj;   /* Our service name + lsap in IAS */
+	struct iriap_cb *iriap;	      /* Used to query remote IAS */
+	struct ias_value *ias_result; /* Result of remote IAS query */
+
+	hashbin_t *cachelog;		/* Result of discovery query */
+	struct discovery_t *cachediscovery;	/* Result of selective discovery query */
+
+	int nslots;           /* Number of slots to use for discovery */
+
+	int errno;            /* status of the IAS query */
+
+	struct sock *sk;
+	wait_queue_head_t query_wait;	/* Wait for the answer to a query */
+	struct timer_list watchdog;	/* Timeout for discovery */
+
+	LOCAL_FLOW tx_flow;
+	LOCAL_FLOW rx_flow;
+};
+
+#define irda_sk(__sk) ((struct irda_sock *)(__sk)->protinfo)
+
+#endif /* AF_IRDA_H */
diff -Nru a/include/net/irda/discovery.h b/include/net/irda/discovery.h
--- a/include/net/irda/discovery.h	Thu Jun 20 15:54:01 2002
+++ b/include/net/irda/discovery.h	Thu Jun 20 15:54:01 2002
@@ -10,6 +10,7 @@
  * Modified by:   Dag Brattli <dagb@cs.uit.no>
  * 
  *     Copyright (c) 1999 Dag Brattli, All Rights Reserved.
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -34,10 +35,22 @@
 #include <asm/param.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irqueue.h>
+#include <net/irda/irqueue.h>		/* irda_queue_t */
+#include <net/irda/irlap_event.h>	/* LAP_REASON */
 
 #define DISCOVERY_EXPIRE_TIMEOUT (2*sysctl_discovery_timeout*HZ)
 #define DISCOVERY_DEFAULT_SLOTS  0
+
+/*
+ *  This type is used by the protocols that transmit 16 bits words in 
+ *  little endian format. A little endian machine stores MSB of word in
+ *  byte[1] and LSB in byte[0]. A big endian machine stores MSB in byte[0] 
+ *  and LSB in byte[1].
+ */
+typedef union {
+	__u16 word;
+	__u8  byte[2];
+} __u16_host_order;
 
 /* Types of discovery */
 typedef enum {
diff -Nru a/include/net/irda/ircomm_core.h b/include/net/irda/ircomm_core.h
--- a/include/net/irda/ircomm_core.h	Thu Jun 20 15:54:00 2002
+++ b/include/net/irda/ircomm_core.h	Thu Jun 20 15:54:00 2002
@@ -32,6 +32,7 @@
 #define IRCOMM_CORE_H
 
 #include <net/irda/irda.h>
+#include <net/irda/irqueue.h>
 #include <net/irda/ircomm_event.h>
 
 #define IRCOMM_MAGIC 0x98347298
diff -Nru a/include/net/irda/ircomm_event.h b/include/net/irda/ircomm_event.h
--- a/include/net/irda/ircomm_event.h	Thu Jun 20 15:54:01 2002
+++ b/include/net/irda/ircomm_event.h	Thu Jun 20 15:54:01 2002
@@ -31,6 +31,8 @@
 #ifndef IRCOMM_EVENT_H
 #define IRCOMM_EVENT_H
 
+#include <net/irda/irmod.h>
+
 typedef enum {
         IRCOMM_IDLE,
         IRCOMM_WAITI,
diff -Nru a/include/net/irda/ircomm_tty.h b/include/net/irda/ircomm_tty.h
--- a/include/net/irda/ircomm_tty.h	Thu Jun 20 15:54:00 2002
+++ b/include/net/irda/ircomm_tty.h	Thu Jun 20 15:54:00 2002
@@ -34,6 +34,7 @@
 #include <linux/serial.h>
 #include <linux/termios.h>
 #include <linux/timer.h>
+#include <linux/tty.h>		/* struct tty_struct */
 
 #include <net/irda/irias_object.h>
 #include <net/irda/ircomm_core.h>
diff -Nru a/include/net/irda/irda-usb.h b/include/net/irda/irda-usb.h
--- a/include/net/irda/irda-usb.h	Thu Jun 20 15:54:01 2002
+++ b/include/net/irda/irda-usb.h	Thu Jun 20 15:54:01 2002
@@ -29,8 +29,7 @@
 #include <linux/time.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irlap.h>
-#include <net/irda/irda_device.h>
+#include <net/irda/irda_device.h>      /* struct irlap_cb */
 
 #define RX_COPY_THRESHOLD 200
 #define IRDA_USB_MAX_MTU 2051
diff -Nru a/include/net/irda/irda.h b/include/net/irda/irda.h
--- a/include/net/irda/irda.h	Thu Jun 20 15:54:00 2002
+++ b/include/net/irda/irda.h	Thu Jun 20 15:54:00 2002
@@ -10,7 +10,7 @@
  * Modified by:   Dag Brattli <dagb@cs.uit.no>
  * 
  *     Copyright (c) 1998-2000 Dag Brattli, All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *      
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -27,16 +27,13 @@
 #define NET_IRDA_H
 
 #include <linux/config.h>
-#include <linux/skbuff.h>
+#include <linux/skbuff.h>		/* struct sk_buff */
 #include <linux/kernel.h>
-#include <linux/if.h>
+#include <linux/if.h>			/* sa_family_t in <linux/irda.h> */
 #include <linux/irda.h>
 
 typedef __u32 magic_t;
 
-#include <net/irda/qos.h>
-#include <net/irda/irqueue.h>
-
 #ifndef TRUE
 #define TRUE 1
 #endif
@@ -57,8 +54,8 @@
 #ifndef IRDA_ALIGN
 #  define IRDA_ALIGN __attribute__((aligned))
 #endif
-#ifndef PACK
-#  define PACK __attribute__((packed))
+#ifndef IRDA_PACK
+#  define IRDA_PACK __attribute__((packed))
 #endif
 
 
@@ -115,152 +112,5 @@
 #define IAS_IRLAN_ID  0x34234
 #define IAS_IRCOMM_ID 0x2343
 #define IAS_IRLPT_ID  0x9876
-
-typedef enum { FLOW_STOP, FLOW_START } LOCAL_FLOW;
-
-/* A few forward declarations (to make compiler happy) */
-struct tsap_cb;		/* in <net/irda/irttp.h> */
-struct lsap_cb;		/* in <net/irda/irlmp.h> */
-struct iriap_cb;	/* in <net/irda/iriap.h> */
-struct ias_value;	/* in <net/irda/irias_object.h> */
-struct discovery_t;	/* in <net/irda/discovery.h> */
-
-/* IrDA Socket */
-struct irda_sock {
-	__u32 saddr;          /* my local address */
-	__u32 daddr;          /* peer address */
-
-	struct lsap_cb *lsap; /* LSAP used by Ultra */
-	__u8  pid;            /* Protocol IP (PID) used by Ultra */
-
-	struct tsap_cb *tsap; /* TSAP used by this connection */
-	__u8 dtsap_sel;       /* remote TSAP address */
-	__u8 stsap_sel;       /* local TSAP address */
-	
-	__u32 max_sdu_size_rx;
-	__u32 max_sdu_size_tx;
-	__u32 max_data_size;
-	__u8  max_header_size;
-	struct qos_info qos_tx;
-
-	__u16 mask;           /* Hint bits mask */
-	__u16 hints;          /* Hint bits */
-
-	__u32 ckey;           /* IrLMP client handle */
-	__u32 skey;           /* IrLMP service handle */
-
-	struct ias_object *ias_obj;   /* Our service name + lsap in IAS */
-	struct iriap_cb *iriap;	      /* Used to query remote IAS */
-	struct ias_value *ias_result; /* Result of remote IAS query */
-
-	hashbin_t *cachelog;		/* Result of discovery query */
-	struct discovery_t *cachediscovery;	/* Result of selective discovery query */
-
-	int nslots;           /* Number of slots to use for discovery */
-
-	int errno;            /* status of the IAS query */
-
-	struct sock *sk;
-	wait_queue_head_t query_wait;	/* Wait for the answer to a query */
-	struct timer_list watchdog;	/* Timeout for discovery */
-
-	LOCAL_FLOW tx_flow;
-	LOCAL_FLOW rx_flow;
-};
-
-#define irda_sk(__sk) ((struct irda_sock *)(__sk)->protinfo)
-
-/*
- *  This type is used by the protocols that transmit 16 bits words in 
- *  little endian format. A little endian machine stores MSB of word in
- *  byte[1] and LSB in byte[0]. A big endian machine stores MSB in byte[0] 
- *  and LSB in byte[1].
- */
-typedef union {
-	__u16 word;
-	__u8  byte[2];
-} __u16_host_order;
-
-/* 
- * Per-packet information we need to hide inside sk_buff 
- * (must not exceed 48 bytes, check with struct sk_buff) 
- */
-struct irda_skb_cb {
-	magic_t magic;       /* Be sure that we can trust the information */
-	__u32   next_speed;  /* The Speed to be set *after* this frame */
-	__u16   mtt;         /* Minimum turn around time */
-	__u16   xbofs;       /* Number of xbofs required, used by SIR mode */
-	__u16   next_xbofs;  /* Number of xbofs required *after* this frame */
-	void    *context;    /* May be used by drivers */
-	void    (*destructor)(struct sk_buff *skb); /* Used for flow control */
-	__u16   xbofs_delay; /* Number of xbofs used for generating the mtt */
-	__u8    line;        /* Used by IrCOMM in IrLPT mode */
-};
-
-/* Misc status information */
-typedef enum {
-	STATUS_OK,
-	STATUS_ABORTED,
-	STATUS_NO_ACTIVITY,
-	STATUS_NOISY,
-	STATUS_REMOTE,
-} LINK_STATUS;
-
-typedef enum {
-	LOCK_NO_CHANGE,
-	LOCK_LOCKED,
-	LOCK_UNLOCKED,
-} LOCK_STATUS;
-
-typedef enum { /* FIXME check the two first reason codes */
-	LAP_DISC_INDICATION=1, /* Received a disconnect request from peer */
-	LAP_NO_RESPONSE,       /* To many retransmits without response */
-	LAP_RESET_INDICATION,  /* To many retransmits, or invalid nr/ns */
-	LAP_FOUND_NONE,        /* No devices were discovered */
-	LAP_MEDIA_BUSY,
-	LAP_PRIMARY_CONFLICT,
-} LAP_REASON;
-
-/*  
- *  IrLMP disconnect reasons. The order is very important, since they 
- *  correspond to disconnect reasons sent in IrLMP disconnect frames, so
- *  please do not touch :-)
- */
-typedef enum {
-	LM_USER_REQUEST = 1,  /* User request */
-	LM_LAP_DISCONNECT,    /* Unexpected IrLAP disconnect */
-	LM_CONNECT_FAILURE,   /* Failed to establish IrLAP connection */
-	LM_LAP_RESET,         /* IrLAP reset */
-	LM_INIT_DISCONNECT,   /* Link Management initiated disconnect */
-	LM_LSAP_NOTCONN,      /* Data delivered on unconnected LSAP */
-	LM_NON_RESP_CLIENT,   /* Non responsive LM-MUX client */
-	LM_NO_AVAIL_CLIENT,   /* No available LM-MUX client */
-	LM_CONN_HALF_OPEN,    /* Connection is half open */
-	LM_BAD_SOURCE_ADDR,   /* Illegal source address (i.e 0x00) */
-} LM_REASON;
-#define LM_UNKNOWN 0xff       /* Unspecified disconnect reason */
-
-/*
- *  Notify structure used between transport and link management layers
- */
-typedef struct {
-	int (*data_indication)(void *priv, void *sap, struct sk_buff *skb);
-	int (*udata_indication)(void *priv, void *sap, struct sk_buff *skb);
-	void (*connect_confirm)(void *instance, void *sap, 
-				struct qos_info *qos, __u32 max_sdu_size,
-				__u8 max_header_size, struct sk_buff *skb);
-	void (*connect_indication)(void *instance, void *sap, 
-				   struct qos_info *qos, __u32 max_sdu_size, 
-				   __u8 max_header_size, struct sk_buff *skb);
-	void (*disconnect_indication)(void *instance, void *sap, 
-				      LM_REASON reason, struct sk_buff *);
-	void (*flow_indication)(void *instance, void *sap, LOCAL_FLOW flow);
-	void (*status_indication)(void *instance,
-				  LINK_STATUS link, LOCK_STATUS lock);
-	void *instance; /* Layer instance pointer */
-	char name[16];  /* Name of layer */
-} notify_t;
-
-#define NOTIFY_MAX_NAME 16
 
 #endif /* NET_IRDA_H */
diff -Nru a/include/net/irda/irda_device.h b/include/net/irda/irda_device.h
--- a/include/net/irda/irda_device.h	Thu Jun 20 15:54:01 2002
+++ b/include/net/irda/irda_device.h	Thu Jun 20 15:54:01 2002
@@ -11,6 +11,7 @@
  * 
  *     Copyright (c) 1999-2000 Dag Brattli, All Rights Reserved.
  *     Copyright (c) 1998 Thomas Davis, <ratbert@radiks.net>,
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -29,18 +30,27 @@
  *     
  ********************************************************************/
 
+/*
+ * This header contains all the IrDA definitions a driver really
+ * needs, and therefore the driver should not need to include
+ * any other IrDA headers - Jean II
+ */
+
 #ifndef IRDA_DEVICE_H
 #define IRDA_DEVICE_H
 
 #include <linux/tty.h>
 #include <linux/netdevice.h>
 #include <linux/spinlock.h>
+#include <linux/skbuff.h>		/* struct sk_buff */
 #include <linux/irda.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/qos.h>
-#include <net/irda/irqueue.h>
-#include <net/irda/irlap_frame.h>
+#include <net/irda/qos.h>		/* struct qos_info */
+#include <net/irda/irqueue.h>		/* irda_queue_t */
+
+/* A few forward declarations (to make compiler happy) */
+struct irlap_cb;
 
 /* Some non-standard interface flags (should not conflict with any in if.h) */
 #define IFF_SIR 	0x0001 /* Supports SIR speeds */
@@ -120,6 +130,22 @@
 	int  (*change_speed)(struct irda_task *task);
 };
 
+/* 
+ * Per-packet information we need to hide inside sk_buff 
+ * (must not exceed 48 bytes, check with struct sk_buff) 
+ */
+struct irda_skb_cb {
+	magic_t magic;       /* Be sure that we can trust the information */
+	__u32   next_speed;  /* The Speed to be set *after* this frame */
+	__u16   mtt;         /* Minimum turn around time */
+	__u16   xbofs;       /* Number of xbofs required, used by SIR mode */
+	__u16   next_xbofs;  /* Number of xbofs required *after* this frame */
+	void    *context;    /* May be used by drivers */
+	void    (*destructor)(struct sk_buff *skb); /* Used for flow control */
+	__u16   xbofs_delay; /* Number of xbofs used for generating the mtt */
+	__u8    line;        /* Used by IrCOMM in IrLPT mode */
+};
+
 /* Chip specific info */
 typedef struct {
 	int cfg_base;         /* Config register IO base */
@@ -157,6 +183,13 @@
 /* Function prototypes */
 int  irda_device_init(void);
 void irda_device_cleanup(void);
+
+/* IrLAP entry points used by the drivers.
+ * We declare them here to avoid the driver pulling a whole bunch stack
+ * headers they don't really need - Jean II */
+struct irlap_cb *irlap_open(struct net_device *dev, struct qos_info *qos,
+			    char *	hw_name);
+void irlap_close(struct irlap_cb *self);
 
 /* Interface to be uses by IrLAP */
 void irda_device_set_media_busy(struct net_device *dev, int status);
diff -Nru a/include/net/irda/iriap.h b/include/net/irda/iriap.h
--- a/include/net/irda/iriap.h	Thu Jun 20 15:54:00 2002
+++ b/include/net/irda/iriap.h	Thu Jun 20 15:54:00 2002
@@ -29,11 +29,10 @@
 #include <linux/types.h>
 #include <linux/skbuff.h>
 
-#include <net/irda/qos.h>
 #include <net/irda/iriap_event.h>
 #include <net/irda/irias_object.h>
-#include <net/irda/irqueue.h>
-#include <net/irda/timer.h>
+#include <net/irda/irqueue.h>		/* irda_queue_t */
+#include <net/irda/timer.h>		/* struct timer_list */
 
 #define IAP_LST 0x80
 #define IAP_ACK 0x40
diff -Nru a/include/net/irda/irlap.h b/include/net/irda/irlap.h
--- a/include/net/irda/irlap.h	Thu Jun 20 15:54:01 2002
+++ b/include/net/irda/irlap.h	Thu Jun 20 15:54:01 2002
@@ -11,7 +11,7 @@
  * 
  *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
  *     All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -33,7 +33,11 @@
 #include <linux/netdevice.h>
 #include <linux/timer.h>
 
-#include <net/irda/irlap_event.h>
+#include <net/irda/irqueue.h>		/* irda_queue_t */
+#include <net/irda/qos.h>		/* struct qos_info */
+#include <net/irda/discovery.h>		/* discovery_t */
+#include <net/irda/irlap_event.h>	/* IRLAP_STATE, ... */
+#include <net/irda/irmod.h>		/* struct notify_t */
 
 #define CONFIG_IRDA_DYNAMIC_WINDOW 1
 
@@ -84,6 +88,29 @@
 #define NS_EXPECTED     1
 #define NS_UNEXPECTED   0
 #define NS_INVALID     -1
+
+/*
+ *  Meta information passed within the IrLAP state machine
+ */
+struct irlap_info {
+	__u8 caddr;   /* Connection address */
+	__u8 control; /* Frame type */
+        __u8 cmd;
+
+	__u32 saddr;
+	__u32 daddr;
+	
+	int pf;        /* Poll/final bit set */
+
+	__u8  nr;      /* Sequence number of next frame expected */
+	__u8  ns;      /* Sequence number of frame sent */
+
+	int  S;        /* Number of slots */
+	int  slot;     /* Random chosen slot */
+	int  s;        /* Current slot */
+
+	discovery_t *discovery; /* Discovery information */
+};
 
 /* Main structure of IrLAP */
 struct irlap_cb {
diff -Nru a/include/net/irda/irlap_event.h b/include/net/irda/irlap_event.h
--- a/include/net/irda/irlap_event.h	Thu Jun 20 15:53:59 2002
+++ b/include/net/irda/irlap_event.h	Thu Jun 20 15:53:59 2002
@@ -12,7 +12,7 @@
  * 
  *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
  *     All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -35,9 +35,10 @@
 #define IRLAP_EVENT_H
 
 #include <net/irda/irda.h>
-#include <net/irda/discovery.h>
 
+/* A few forward declarations (to make compiler happy) */
 struct irlap_cb;
+struct irlap_info;
 
 /* IrLAP States */
 typedef enum {
@@ -108,27 +109,16 @@
 } IRLAP_EVENT;
 
 /*
- *  Various things used by the IrLAP state machine
+ * Disconnect reason code
  */
-struct irlap_info {
-	__u8 caddr;   /* Connection address */
-	__u8 control; /* Frame type */
-        __u8 cmd;
-
-	__u32 saddr;
-	__u32 daddr;
-	
-	int pf;        /* Poll/final bit set */
-
-	__u8  nr;      /* Sequence number of next frame expected */
-	__u8  ns;      /* Sequence number of frame sent */
-
-	int  S;        /* Number of slots */
-	int  slot;     /* Random chosen slot */
-	int  s;        /* Current slot */
-
-	discovery_t *discovery; /* Discovery information */
-};
+typedef enum { /* FIXME check the two first reason codes */
+	LAP_DISC_INDICATION=1, /* Received a disconnect request from peer */
+	LAP_NO_RESPONSE,       /* To many retransmits without response */
+	LAP_RESET_INDICATION,  /* To many retransmits, or invalid nr/ns */
+	LAP_FOUND_NONE,        /* No devices were discovered */
+	LAP_MEDIA_BUSY,
+	LAP_PRIMARY_CONFLICT,
+} LAP_REASON;
 
 extern const char *irlap_state[];
 
diff -Nru a/include/net/irda/irlap_frame.h b/include/net/irda/irlap_frame.h
--- a/include/net/irda/irlap_frame.h	Thu Jun 20 15:53:59 2002
+++ b/include/net/irda/irlap_frame.h	Thu Jun 20 15:53:59 2002
@@ -11,6 +11,7 @@
  * 
  *     Copyright (c) 1997-1999 Dag Brattli <dagb@cs.uit.no>,
  *     All Rights Reserved.
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -35,8 +36,10 @@
 #include <linux/skbuff.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irlap.h>
-#include <net/irda/qos.h>
+
+/* A few forward declarations (to make compiler happy) */
+struct irlap_cb;
+struct discovery_t;
 
 /* Frame types and templates */
 #define INVALID   0xff
@@ -80,14 +83,14 @@
 	__u8  flags; /* Discovery flags */
 	__u8  slotnr;
 	__u8  version;
-} PACK;
+} IRDA_PACK;
 
 struct test_frame {
 	__u8 caddr;          /* Connection address */
 	__u8 control;
 	__u32 saddr;         /* Source device address */
 	__u32 daddr;         /* Destination device address */
-} PACK;
+} IRDA_PACK;
 
 struct ua_frame {
 	__u8 caddr;
@@ -95,12 +98,12 @@
 
 	__u32 saddr; /* Source device address */
 	__u32 daddr; /* Dest device address */
-} PACK;
+} IRDA_PACK;
 	
 struct i_frame {
 	__u8 caddr;
 	__u8 control;
-} PACK;
+} IRDA_PACK;
 
 struct snrm_frame {
 	__u8  caddr;
@@ -108,11 +111,12 @@
 	__u32 saddr;
 	__u32 daddr;
 	__u8  ncaddr;
-} PACK;
+} IRDA_PACK;
 
 void irlap_queue_xmit(struct irlap_cb *self, struct sk_buff *skb);
 void irlap_send_discovery_xid_frame(struct irlap_cb *, int S, __u8 s, 
-				    __u8 command, discovery_t *discovery);
+				    __u8 command,
+				    struct discovery_t *discovery);
 void irlap_send_snrm_frame(struct irlap_cb *, struct qos_info *);
 void irlap_send_test_frame(struct irlap_cb *self, __u8 caddr, __u32 daddr, 
 			   struct sk_buff *cmd);
diff -Nru a/include/net/irda/irlmp.h b/include/net/irda/irlmp.h
--- a/include/net/irda/irlmp.h	Thu Jun 20 15:54:00 2002
+++ b/include/net/irda/irlmp.h	Thu Jun 20 15:54:00 2002
@@ -11,7 +11,7 @@
  * 
  *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
  *     All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -34,7 +34,7 @@
 
 #include <net/irda/irda.h>
 #include <net/irda/qos.h>
-#include <net/irda/irlap.h>
+#include <net/irda/irlap.h>		/* LAP_MAX_HEADER, ... */
 #include <net/irda/irlmp_event.h>
 #include <net/irda/irqueue.h>
 #include <net/irda/discovery.h>
@@ -90,8 +90,6 @@
 	DISCOVERY_CALLBACK1 expir_callback;	/* Selective expiration */
 	void *priv;                /* Used to identify client */
 } irlmp_client_t;
-
-struct lap_cb; /* Forward decl. */
 
 /*
  *  Information about each logical LSAP connection
diff -Nru a/include/net/irda/irlmp_event.h b/include/net/irda/irlmp_event.h
--- a/include/net/irda/irlmp_event.h	Thu Jun 20 15:54:01 2002
+++ b/include/net/irda/irlmp_event.h	Thu Jun 20 15:54:01 2002
@@ -11,7 +11,7 @@
  * 
  *     Copyright (c) 1997, 1999 Dag Brattli <dagb@cs.uit.no>, 
  *     All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -27,9 +27,11 @@
 #ifndef IRLMP_EVENT_H
 #define IRLMP_EVENT_H
 
+/* A few forward declarations (to make compiler happy) */
 struct irlmp_cb;
 struct lsap_cb;
 struct lap_cb;
+struct discovery_t;
 
 /* LAP states */
 typedef enum {
@@ -94,7 +96,7 @@
 
 	int reason;
 
-	discovery_t *discovery;
+	struct discovery_t *discovery;
 };
 
 extern const char *irlmp_state[];
diff -Nru a/include/net/irda/irmod.h b/include/net/irda/irmod.h
--- a/include/net/irda/irmod.h	Thu Jun 20 15:54:01 2002
+++ b/include/net/irda/irmod.h	Thu Jun 20 15:54:01 2002
@@ -10,7 +10,7 @@
  * Modified by:   Dag Brattli <dagb@cs.uit.no>
  *
  *     Copyright (c) 1998-2000 Dag Brattli, All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *      
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -26,19 +26,76 @@
 #ifndef IRMOD_H
 #define IRMOD_H
 
-#include <net/irda/irda.h>		/* Notify stuff */
+/* Misc status information */
+typedef enum {
+	STATUS_OK,
+	STATUS_ABORTED,
+	STATUS_NO_ACTIVITY,
+	STATUS_NOISY,
+	STATUS_REMOTE,
+} LINK_STATUS;
 
-/* Nothing much here anymore - Maybe this header should be merged in
- * another header like net/irda/irda.h... - Jean II */
+typedef enum {
+	LOCK_NO_CHANGE,
+	LOCK_LOCKED,
+	LOCK_UNLOCKED,
+} LOCK_STATUS;
+
+typedef enum { FLOW_STOP, FLOW_START } LOCAL_FLOW;
+
+/*  
+ *  IrLMP disconnect reasons. The order is very important, since they 
+ *  correspond to disconnect reasons sent in IrLMP disconnect frames, so
+ *  please do not touch :-)
+ */
+typedef enum {
+	LM_USER_REQUEST = 1,  /* User request */
+	LM_LAP_DISCONNECT,    /* Unexpected IrLAP disconnect */
+	LM_CONNECT_FAILURE,   /* Failed to establish IrLAP connection */
+	LM_LAP_RESET,         /* IrLAP reset */
+	LM_INIT_DISCONNECT,   /* Link Management initiated disconnect */
+	LM_LSAP_NOTCONN,      /* Data delivered on unconnected LSAP */
+	LM_NON_RESP_CLIENT,   /* Non responsive LM-MUX client */
+	LM_NO_AVAIL_CLIENT,   /* No available LM-MUX client */
+	LM_CONN_HALF_OPEN,    /* Connection is half open */
+	LM_BAD_SOURCE_ADDR,   /* Illegal source address (i.e 0x00) */
+} LM_REASON;
+#define LM_UNKNOWN 0xff       /* Unspecified disconnect reason */
+
+/* A few forward declarations (to make compiler happy) */
+struct qos_info;		/* in <net/irda/qos.h> */
+
+/*
+ *  Notify structure used between transport and link management layers
+ */
+typedef struct {
+	int (*data_indication)(void *priv, void *sap, struct sk_buff *skb);
+	int (*udata_indication)(void *priv, void *sap, struct sk_buff *skb);
+	void (*connect_confirm)(void *instance, void *sap, 
+				struct qos_info *qos, __u32 max_sdu_size,
+				__u8 max_header_size, struct sk_buff *skb);
+	void (*connect_indication)(void *instance, void *sap, 
+				   struct qos_info *qos, __u32 max_sdu_size, 
+				   __u8 max_header_size, struct sk_buff *skb);
+	void (*disconnect_indication)(void *instance, void *sap, 
+				      LM_REASON reason, struct sk_buff *);
+	void (*flow_indication)(void *instance, void *sap, LOCAL_FLOW flow);
+	void (*status_indication)(void *instance,
+				  LINK_STATUS link, LOCK_STATUS lock);
+	void *instance; /* Layer instance pointer */
+	char name[16];  /* Name of layer */
+} notify_t;
+
+#define NOTIFY_MAX_NAME 16
+
+/* Zero the notify structure */
+void irda_notify_init(notify_t *notify);
 
 /* Locking wrapper - Note the inverted logic on irda_lock().
  * Those function basically return false if the lock is already in the
  * position you want to set it. - Jean II */
 #define irda_lock(lock)		(! test_and_set_bit(0, (void *) (lock)))
 #define irda_unlock(lock)	(test_and_clear_bit(0, (void *) (lock)))
-
-/* Zero the notify structure */
-void irda_notify_init(notify_t *notify);
 
 #endif /* IRMOD_H */
 
diff -Nru a/include/net/irda/irttp.h b/include/net/irda/irttp.h
--- a/include/net/irda/irttp.h	Thu Jun 20 15:54:00 2002
+++ b/include/net/irda/irttp.h	Thu Jun 20 15:54:00 2002
@@ -11,6 +11,7 @@
  * 
  *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
  *     All Rights Reserved.
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -31,8 +32,8 @@
 #include <linux/spinlock.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irlmp.h>
-#include <net/irda/qos.h>
+#include <net/irda/irlmp.h>		/* struct lsap_cb */
+#include <net/irda/qos.h>		/* struct qos_info */
 #include <net/irda/irqueue.h>
 
 #define TTP_MAX_CONNECTIONS    LM_MAX_CONNECTIONS
diff -Nru a/include/net/irda/timer.h b/include/net/irda/timer.h
--- a/include/net/irda/timer.h	Thu Jun 20 15:54:00 2002
+++ b/include/net/irda/timer.h	Thu Jun 20 15:54:00 2002
@@ -11,7 +11,7 @@
  * 
  *     Copyright (c) 1997, 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
  *     All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -27,15 +27,17 @@
 #ifndef TIMER_H
 #define TIMER_H
 
-#include <linux/netdevice.h>
+#include <linux/timer.h>
 
 #include <asm/param.h>  /* for HZ */
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
-#include <net/irda/irlap.h>
-#include <net/irda/irlmp.h>
-#include <net/irda/irda_device.h>
+
+/* A few forward declarations (to make compiler happy) */
+struct irlmp_cb;
+struct irlap_cb;
+struct lsap_cb;
+struct lap_cb;
 
 /* 
  *  Timeout definitions, some defined in IrLAP p. 92
@@ -81,8 +83,6 @@
 void irlap_start_mbusy_timer(struct irlap_cb *self, int timeout);
 void irlap_stop_mbusy_timer(struct irlap_cb *);
 
-struct lsap_cb;
-struct lap_cb;
 inline void irlmp_start_watchdog_timer(struct lsap_cb *, int timeout);
 inline void irlmp_start_discovery_timer(struct irlmp_cb *, int timeout);
 inline void irlmp_start_idle_timer(struct lap_cb *, int timeout);
diff -Nru a/include/net/irda/wrapper.h b/include/net/irda/wrapper.h
--- a/include/net/irda/wrapper.h	Thu Jun 20 15:53:59 2002
+++ b/include/net/irda/wrapper.h	Thu Jun 20 15:53:59 2002
@@ -30,7 +30,7 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 
-#include <net/irda/irda_device.h>
+#include <net/irda/irda_device.h>	/* iobuff_t */
 
 #define BOF  0xc0 /* Beginning of frame */
 #define XBOF 0xff
diff -Nru a/include/sound/ac97_codec.h b/include/sound/ac97_codec.h
--- a/include/sound/ac97_codec.h	Thu Jun 20 15:53:59 2002
+++ b/include/sound/ac97_codec.h	Thu Jun 20 15:53:59 2002
@@ -118,6 +118,15 @@
 #define AC97_AD_SERIAL_CFG	0x74	/* Serial Configuration */
 #define AC97_AD_MISC		0x76	/* Misc Control Bits */
 
+/* specific - Cirrus Logic */
+#define AC97_CSR_ACMODE		0x5e	/* AC Mode Register */
+#define AC97_CSR_MISC_CRYSTAL	0x60	/* Misc Crystal Control */
+#define AC97_CSR_SPDIF		0x68	/* S/PDIF Register */
+#define AC97_CSR_SERIAL		0x6a	/* Serial Port Control */
+#define AC97_CSR_SPECF_ADDR	0x6c	/* Special Feature Address */
+#define AC97_CSR_SPECF_DATA	0x6e	/* Special Feature Data */
+#define AC97_CSR_BDI_STATUS	0x7a	/* BDI Status */
+
 /* ac97->scaps */
 #define AC97_SCAP_SURROUND_DAC	(1<<0)	/* surround L&R DACs are present */
 #define AC97_SCAP_CENTER_LFE_DAC (1<<1)	/* center and LFE DACs are present */
@@ -160,7 +169,7 @@
 	unsigned int rates_mic_adc;
 	unsigned int spdif_status;
 	unsigned short regs[0x80]; /* register cache */
-	bitmap_member(reg_accessed, 0x80); /* bit flags */
+	bitmap_member(reg_accessed,0x80); /* bit flags */
 	union {			/* vendor specific code */
 		struct {
 			unsigned short unchained[3];	// 0 = C34, 1 = C79, 2 = C69
diff -Nru a/include/sound/asound.h b/include/sound/asound.h
--- a/include/sound/asound.h	Thu Jun 20 15:54:01 2002
+++ b/include/sound/asound.h	Thu Jun 20 15:54:01 2002
@@ -602,7 +602,8 @@
 	SNDRV_CTL_ELEM_TYPE_ENUMERATED,		/* enumerated type */
 	SNDRV_CTL_ELEM_TYPE_BYTES,		/* byte array */
 	SNDRV_CTL_ELEM_TYPE_IEC958,		/* IEC958 (S/PDIF) setup */
-	SNDRV_CTL_ELEM_TYPE_LAST = SNDRV_CTL_ELEM_TYPE_IEC958,
+	SNDRV_CTL_ELEM_TYPE_INTEGER64,		/* 64-bit integer type */
+	SNDRV_CTL_ELEM_TYPE_LAST = SNDRV_CTL_ELEM_TYPE_INTEGER64,
 };
 
 enum sndrv_ctl_elem_iface {
@@ -664,6 +665,11 @@
 			long step;		/* R: step (0 variable) */
 		} integer;
 		struct {
+			long long min;		/* R: minimum value */
+			long long max;		/* R: maximum value */
+			long long step;		/* R: step (0 variable) */
+		} integer64;
+		struct {
 			unsigned int items;	/* R: number of items */
 			unsigned int item;	/* W: item number */
 			char name[64];		/* R: value name */
@@ -681,6 +687,10 @@
 			long value[128];
 			long *value_ptr;
 		} integer;
+		union {
+			long long value[64];
+			long long *value_ptr;
+		} integer64;
 		union {
 			unsigned int item[128];
 			unsigned int *item_ptr;
diff -Nru a/include/sound/core.h b/include/sound/core.h
--- a/include/sound/core.h	Thu Jun 20 15:54:01 2002
+++ b/include/sound/core.h	Thu Jun 20 15:54:01 2002
@@ -103,7 +103,7 @@
 typedef struct _snd_timer snd_timer_t;
 typedef struct _snd_timer_instance snd_timer_instance_t;
 typedef struct _snd_hwdep snd_hwdep_t;
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 typedef struct _snd_oss_mixer snd_mixer_oss_t;
 #endif
 
@@ -145,7 +145,7 @@
 	wait_queue_head_t power_sleep;
 #endif
 
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	snd_mixer_oss_t *mixer_oss;
 	int mixer_oss_change_count;
 #endif
@@ -251,16 +251,22 @@
 void *snd_malloc_pages(unsigned long size, unsigned int dma_flags);
 void *snd_malloc_pages_fallback(unsigned long size, unsigned int dma_flags, unsigned long *res_size);
 void snd_free_pages(void *ptr, unsigned long size);
-#ifdef CONFIG_ISA
-void *snd_malloc_isa_pages(unsigned long size, dma_addr_t *dma_addr);
-void *snd_malloc_isa_pages_fallback(unsigned long size, dma_addr_t *dma_addr, unsigned long *res_size);
-#define snd_free_isa_pages(size, ptr, dma_addr) snd_free_pages(ptr, size)
-#endif
 #ifdef CONFIG_PCI
 void *snd_malloc_pci_pages(struct pci_dev *pci, unsigned long size, dma_addr_t *dma_addr);
 void *snd_malloc_pci_pages_fallback(struct pci_dev *pci, unsigned long size, dma_addr_t *dma_addr, unsigned long *res_size);
 void snd_free_pci_pages(struct pci_dev *pci, unsigned long size, void *ptr, dma_addr_t dma_addr);
 #endif
+#ifdef CONFIG_ISA
+#ifdef CONFIG_PCI
+#define snd_malloc_isa_pages(size, dma_addr) snd_malloc_pci_pages(NULL, size, dma_addr)
+#define snd_malloc_isa_pages_fallback(size, dma_addr, res_size) snd_malloc_pci_pages_fallback(NULL, size, dma_addr, res_size)
+#define snd_free_isa_pages(size, ptr, dma_addr) snd_free_pci_pages(NULL, size, ptr, dma_addr)
+#else /* !CONFIG_PCI */
+void *snd_malloc_isa_pages(unsigned long size, dma_addr_t *dma_addr);
+void *snd_malloc_isa_pages_fallback(unsigned long size, dma_addr_t *dma_addr, unsigned long *res_size);
+#define snd_free_isa_pages(size, ptr, dma_addr) snd_free_pages(ptr, size)
+#endif /* CONFIG_PCI */
+#endif /* CONFIG_ISA */
 int copy_to_user_fromio(void *dst, unsigned long src, size_t count);
 int copy_from_user_toio(unsigned long dst, const void *src, size_t count);
 
@@ -269,7 +275,7 @@
 extern int snd_cards_count;
 extern snd_card_t *snd_cards[SNDRV_CARDS];
 extern rwlock_t snd_card_rwlock;
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 extern int (*snd_mixer_oss_notify_callback)(snd_card_t *card, int free_flag);
 #endif
 
diff -Nru a/include/sound/emu10k1.h b/include/sound/emu10k1.h
--- a/include/sound/emu10k1.h	Thu Jun 20 15:54:00 2002
+++ b/include/sound/emu10k1.h	Thu Jun 20 15:54:00 2002
@@ -1295,16 +1295,16 @@
 
 typedef struct {
 	char name[128];
-	unsigned int gpr_valid[0x100/32]; /* bitmask of valid initializers */
+	unsigned long gpr_valid[0x100/(sizeof(unsigned long)*8)]; /* bitmask of valid initializers */
 	unsigned int gpr_map[0x100];	  /* initializers */
 	unsigned int gpr_add_control_count; /* count of GPR controls to add/replace */
 	emu10k1_fx8010_control_gpr_t *gpr_add_controls; /* GPR controls to add/replace */
 	unsigned int gpr_del_control_count; /* count of GPR controls to remove */
 	snd_ctl_elem_id_t *gpr_del_controls; /* IDs of GPR controls to remove */
-	unsigned int tram_valid[0xa0/32]; /* bitmask of valid initializers */
+	unsigned long tram_valid[0xa0/(sizeof(unsigned long)*8)]; /* bitmask of valid initializers */
 	unsigned int tram_data_map[0xa0]; /* data initializers */
 	unsigned int tram_addr_map[0xa0]; /* map initializers */
-	unsigned int code_valid[512/32];  /* bitmask of valid instructions */
+	unsigned long code_valid[512/(sizeof(unsigned long)*8)];  /* bitmask of valid instructions */
 	unsigned int code[512][2];	  /* one instruction - 64 bits */
 } emu10k1_fx8010_code_t;
 
diff -Nru a/include/sound/emu8000.h b/include/sound/emu8000.h
--- a/include/sound/emu8000.h	Thu Jun 20 15:54:01 2002
+++ b/include/sound/emu8000.h	Thu Jun 20 15:54:01 2002
@@ -36,6 +36,8 @@
 #define EMU8000_RAM_READ   0
 #define EMU8000_RAM_WRITE  1
 #define EMU8000_RAM_CLOSE  2
+#define EMU8000_RAM_MODE_MASK	0x03
+#define EMU8000_RAM_RIGHT	0x10	/* use 'right' DMA channel */
 
 enum {
 	EMU8000_CONTROL_BASS = 0,
@@ -86,6 +88,8 @@
 
 	spinlock_t control_lock;
 	snd_kcontrol_t *controls[EMU8000_NUM_CONTROLS];
+
+	snd_pcm_t *pcm; /* pcm on emu8000 wavetable */
 
 } emu8000_t;
 
diff -Nru a/include/sound/emux_synth.h b/include/sound/emux_synth.h
--- a/include/sound/emux_synth.h	Thu Jun 20 15:54:00 2002
+++ b/include/sound/emux_synth.h	Thu Jun 20 15:54:00 2002
@@ -25,7 +25,7 @@
 #include "seq_device.h"
 #include "soundfont.h"
 #include "seq_midi_emul.h"
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 #include "seq_oss.h"
 #endif
 #include "emux_legacy.h"
@@ -65,7 +65,7 @@
 	void (*sample_reset)(snd_emux_t *emu);
 	int (*load_fx)(snd_emux_t *emu, int type, int arg, const void *data, long count);
 	void (*sysex)(snd_emux_t *emu, char *buf, int len, int parsed, snd_midi_channel_set_t *chset);
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	int (*oss_ioctl)(snd_emux_t *emu, int cmd, int p1, int p2);
 #endif
 } snd_emux_operators_t;
@@ -102,6 +102,7 @@
 	unsigned long flags;	/* other conditions */
 	int midi_ports;		/* number of virtual midi devices */
 	int midi_devidx;	/* device offset of virtual midi */
+	unsigned int linear_panning: 1; /* panning is linear (sbawe = 1, emu10k1 = 0) */
 
 	/* private */
 	int num_voices;		/* current number of voices */
@@ -124,7 +125,7 @@
 	snd_info_entry_t *proc;
 #endif
 
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	snd_seq_device_t *oss_synth;
 #endif
 };
@@ -145,7 +146,7 @@
 #ifdef SNDRV_EMUX_USE_RAW_EFFECT
 	snd_emux_effect_table_t *effect;
 #endif
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	snd_seq_oss_arg_t *oss_arg;
 #endif
 };
diff -Nru a/include/sound/mixer_oss.h b/include/sound/mixer_oss.h
--- a/include/sound/mixer_oss.h	Thu Jun 20 15:54:01 2002
+++ b/include/sound/mixer_oss.h	Thu Jun 20 15:54:01 2002
@@ -22,7 +22,7 @@
  *
  */
 
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 
 typedef struct _snd_oss_mixer_slot snd_mixer_oss_slot_t;
 typedef struct _snd_oss_file snd_mixer_oss_file_t;
@@ -66,6 +66,6 @@
 	snd_mixer_oss_t *mixer;
 };
 
-#endif /* CONFIG_SND_OSSEMUL */
+#endif /* CONFIG_SND_MIXER_OSS */
 
 #endif /* __SOUND_MIXER_OSS_H */
diff -Nru a/include/sound/opl3.h b/include/sound/opl3.h
--- a/include/sound/opl3.h	Thu Jun 20 15:54:00 2002
+++ b/include/sound/opl3.h	Thu Jun 20 15:54:00 2002
@@ -57,7 +57,7 @@
 #include "hwdep.h"
 #include "timer.h"
 #include "seq_midi_emul.h"
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 #include "seq_oss.h"
 #include "seq_oss_legacy.h"
 #endif
@@ -287,7 +287,7 @@
 	snd_seq_device_t *seq_dev;	/* sequencer device */
 	snd_midi_channel_set_t * chset;
 
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	snd_seq_device_t *oss_seq_dev;	/* OSS sequencer device, WIP */
 	snd_midi_channel_set_t * oss_chset;
 #endif
diff -Nru a/include/sound/pcm.h b/include/sound/pcm.h
--- a/include/sound/pcm.h	Thu Jun 20 15:54:01 2002
+++ b/include/sound/pcm.h	Thu Jun 20 15:54:01 2002
@@ -57,7 +57,7 @@
 typedef struct _snd_pcm_file snd_pcm_file_t;
 typedef struct _snd_pcm_runtime snd_pcm_runtime_t;
 
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 #include "pcm_oss.h"
 #endif
 
@@ -339,7 +339,7 @@
 	dma_addr_t dma_addr;		/* physical bus address (not accessible from main CPU) */
 	unsigned long dma_bytes;	/* size of DMA area */
 
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
 	snd_pcm_oss_runtime_t oss;
 #endif
@@ -373,7 +373,7 @@
 	snd_pcm_substream_t *link_prev;
 	snd_pcm_file_t *file;
 	struct file *ffile;
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
 	snd_pcm_oss_substream_t oss;
 #endif
@@ -385,7 +385,7 @@
 	snd_info_entry_t *proc_prealloc_entry;
 };
 
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 #define SUBSTREAM_BUSY(substream) ((substream)->file != NULL || ((substream)->oss.file != NULL))
 #else
 #define SUBSTREAM_BUSY(substream) ((substream)->file != NULL)
@@ -399,7 +399,7 @@
 	unsigned int substream_count;
 	unsigned int substream_opened;
 	snd_pcm_substream_t *substream;
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
 	snd_pcm_oss_stream_t oss;
 #endif
@@ -422,7 +422,7 @@
 	wait_queue_head_t open_wait;
 	void *private_data;
 	void (*private_free) (snd_pcm_t *pcm);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	snd_pcm_oss_t oss;
 #endif
 };
@@ -776,7 +776,9 @@
 int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
 snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian);
 ssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples);
- 
+const char *snd_pcm_format_name(snd_pcm_format_t format);
+const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat);
+
 void snd_pcm_set_ops(snd_pcm_t * pcm, int direction, snd_pcm_ops_t *ops);
 void snd_pcm_set_sync(snd_pcm_substream_t * substream);
 int snd_pcm_lib_interleave_len(snd_pcm_substream_t *substream);
diff -Nru a/include/sound/soundfont.h b/include/sound/soundfont.h
--- a/include/sound/soundfont.h	Thu Jun 20 15:54:01 2002
+++ b/include/sound/soundfont.h	Thu Jun 20 15:54:01 2002
@@ -125,6 +125,7 @@
 int snd_sf_calc_parm_decay(int msec);
 #define snd_sf_calc_parm_delay(msec) (0x8000 - (msec) * 1000 / 725);
 extern int snd_sf_vol_table[128];
+int snd_sf_linear_to_log(unsigned int amount, int offset, int ratio);
 
 
 #endif /* __SOUND_SOUNDFONT_H */
diff -Nru a/include/sound/timer.h b/include/sound/timer.h
--- a/include/sound/timer.h	Thu Jun 20 15:53:59 2002
+++ b/include/sound/timer.h	Thu Jun 20 15:53:59 2002
@@ -128,6 +128,7 @@
 extern unsigned long snd_timer_resolution(snd_timer_instance_t * timeri);
 extern int snd_timer_start(snd_timer_instance_t * timeri, unsigned int ticks);
 extern int snd_timer_stop(snd_timer_instance_t * timeri);
+extern int snd_timer_del(snd_timer_instance_t * timeri);
 extern int snd_timer_continue(snd_timer_instance_t * timeri);
 
 extern void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left);
diff -Nru a/include/sound/version.h b/include/sound/version.h
--- a/include/sound/version.h	Thu Jun 20 15:54:00 2002
+++ b/include/sound/version.h	Thu Jun 20 15:54:00 2002
@@ -1,3 +1,3 @@
 /* include/version.h.  Generated automatically by configure.  */
-#define CONFIG_SND_VERSION "0.9.0rc1"
-#define CONFIG_SND_DATE " (Mon Apr 29 06:46:09 2002 UTC)"
+#define CONFIG_SND_VERSION "0.9.0rc2"
+#define CONFIG_SND_DATE " (Wed Jun 19 08:56:25 2002 UTC)"
diff -Nru a/include/sound/ymfpci.h b/include/sound/ymfpci.h
--- a/include/sound/ymfpci.h	Thu Jun 20 15:54:00 2002
+++ b/include/sound/ymfpci.h	Thu Jun 20 15:54:00 2002
@@ -264,9 +264,9 @@
 	snd_ymfpci_pcm_type_t type;
 	snd_pcm_substream_t *substream;
 	ymfpci_voice_t *voices[2];	/* playback only */
-	int running: 1,
-	    spdif: 1,
-	    mode4ch : 1;	
+	int running: 1;
+	int output_front: 1;
+	int output_rear: 1;
 	u32 period_size;		/* cached from runtime->period_size */
 	u32 buffer_size;		/* cached from runtime->buffer_size */
 	u32 period_pos;
@@ -333,6 +333,9 @@
 	snd_kcontrol_t *ctl_vol_spdifrec;
 	unsigned short spdif_bits, spdif_pcm_bits;
 	snd_kcontrol_t *spdif_pcm_ctl;
+	int mode_dup4ch;
+	int rear_opened;
+	int spdif_opened;
 
 	spinlock_t reg_lock;
 	spinlock_t voice_lock;
diff -Nru a/init/Makefile b/init/Makefile
--- a/init/Makefile	Thu Jun 20 15:54:00 2002
+++ b/init/Makefile	Thu Jun 20 15:54:00 2002
@@ -10,17 +10,13 @@
 
 # dependencies on generated files need to be listed explicitly
 
-version.o: ../include/linux/compile.h
-
-# 'make dep' may add a dependency on $(TOPDIR)/include/linux/compile.h
-
-$(TOPDIR)/include/linux/compile.h: ../include/linux/compile.h ;
+$(obj)/version.o: $(objtree)/include/linux/compile.h
 
 # compile.h changes depending on hostname, generation number, etc,
 # so we regenerate it always.
 # mkcompile_h will make sure to only update the
 # actual file if its content has changed.
 
-../include/linux/compile.h: FORCE
+$(objtree)/include/linux/compile.h: FORCE
 	@echo -n '  Generating $@'
 	@../scripts/mkcompile_h $@ "$(ARCH)" "$(CONFIG_SMP)" "$(CC) $(CFLAGS)"
diff -Nru a/kernel/fork.c b/kernel/fork.c
--- a/kernel/fork.c	Thu Jun 20 15:54:00 2002
+++ b/kernel/fork.c	Thu Jun 20 15:54:00 2002
@@ -99,7 +99,7 @@
 	init_task.rlim[RLIMIT_NPROC].rlim_max = max_threads/2;
 }
 
-struct task_struct *dup_task_struct(struct task_struct *orig)
+static struct task_struct *dup_task_struct(struct task_struct *orig)
 {
 	struct task_struct *tsk;
 	struct thread_info *ti;
diff -Nru a/kernel/futex.c b/kernel/futex.c
--- a/kernel/futex.c	Thu Jun 20 15:54:00 2002
+++ b/kernel/futex.c	Thu Jun 20 15:54:00 2002
@@ -34,6 +34,10 @@
 #include <linux/highmem.h>
 #include <linux/time.h>
 #include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/file.h>
+#include <linux/dcache.h>
 #include <asm/uaccess.h>
 
 /* Simple "sleep if unchanged" interface. */
@@ -41,6 +45,11 @@
 /* FIXME: This may be way too small. --RR */
 #define FUTEX_HASHBITS 6
 
+extern void send_sigio(struct fown_struct *fown, int fd, int band);
+
+/* Everyone needs a dentry and inode */
+static struct dentry *futex_dentry;
+
 /* We use this instead of a normal wait_queue_t, so we can wake only
    the relevent ones (hashed queues may be shared) */
 struct futex_q {
@@ -49,6 +58,9 @@
 	/* Page struct and offset within it. */
 	struct page *page;
 	unsigned int offset;
+	/* For fd, sigio sent using these. */
+	int fd;
+	struct file *filp;
 };
 
 /* The key for the hash is the address + index + offset within page */
@@ -65,9 +77,20 @@
 	return &futex_queues[hash_long(h, FUTEX_HASHBITS)];
 }
 
+/* Waiter either waiting in FUTEX_WAIT or poll(), or expecting signal */
 static inline void tell_waiter(struct futex_q *q)
 {
 	wake_up_all(&q->waiters);
+	if (q->filp)
+		send_sigio(&q->filp->f_owner, q->fd, POLL_IN);
+}
+
+static inline void unpin_page(struct page *page)
+{
+	/* Avoid releasing the page which is on the LRU list.  I don't
+           know if this is correct, but it stops the BUG() in
+           __free_pages_ok(). */
+	page_cache_release(page);
 }
 
 static int futex_wake(struct list_head *head,
@@ -95,14 +118,16 @@
 
 /* Add at end to avoid starvation */
 static inline void queue_me(struct list_head *head,
-			    wait_queue_t *wait,
 			    struct futex_q *q,
 			    struct page *page,
-			    unsigned int offset)
+			    unsigned int offset,
+			    int fd,
+			    struct file *filp)
 {
-	add_wait_queue(&q->waiters, wait);
 	q->page = page;
 	q->offset = offset;
+	q->fd = fd;
+	q->filp = filp;
 
 	spin_lock(&futex_lock);
 	list_add_tail(&q->list, head);
@@ -130,9 +155,9 @@
 	int err;
 
 	down_read(&mm->mmap_sem);
-	err = get_user_pages(current, current->mm, page_start,
+	err = get_user_pages(current, mm, page_start,
 			     1 /* one page */,
-			     1 /* writable */,
+			     0 /* writable not important */,
 			     0 /* don't force */,
 			     &page,
 			     NULL /* don't return vmas */);
@@ -156,7 +181,9 @@
 	int ret = 0;
 
 	set_current_state(TASK_INTERRUPTIBLE);
-	queue_me(head, &wait, &q, page, offset);
+	init_waitqueue_head(&q.waiters);
+	add_wait_queue(&q.waiters, &wait);
+	queue_me(head, &q, page, offset, -1, NULL);
 
 	/* Page is pinned, but may no longer be in this address space. */
 	if (get_user(curval, uaddr) != 0) {
@@ -185,6 +212,92 @@
 	return ret;
 }
 
+static int futex_close(struct inode *inode, struct file *filp)
+{
+	struct futex_q *q = filp->private_data;
+
+	spin_lock(&futex_lock);
+	if (!list_empty(&q->list)) {
+		list_del(&q->list);
+		/* Noone can be polling on us now. */
+		BUG_ON(waitqueue_active(&q->waiters));
+	}
+	spin_unlock(&futex_lock);
+	unpin_page(q->page);
+	kfree(filp->private_data);
+	return 0;
+}
+
+/* This is one-shot: once it's gone off you need a new fd */
+static unsigned int futex_poll(struct file *filp,
+			       struct poll_table_struct *wait)
+{
+	struct futex_q *q = filp->private_data;
+	int ret = 0;
+
+	poll_wait(filp, &q->waiters, wait);
+	spin_lock(&futex_lock);
+	if (list_empty(&q->list))
+		ret = POLLIN | POLLRDNORM;
+	spin_unlock(&futex_lock);
+
+	return ret;
+}
+
+static struct file_operations futex_fops = {
+	release:	futex_close,
+	poll:		futex_poll,
+};
+
+/* Signal allows caller to avoid the race which would occur if they
+   set the sigio stuff up afterwards. */
+static int futex_fd(struct list_head *head,
+		    struct page *page,
+		    int offset,
+		    int signal)
+{
+	int fd;
+	struct futex_q *q;
+	struct file *filp;
+
+	if (signal < 0 || signal > _NSIG)
+		return -EINVAL;
+
+	fd = get_unused_fd();
+	if (fd < 0)
+		return fd;
+	filp = get_empty_filp();
+	if (!filp) {
+		put_unused_fd(fd);
+		return -ENFILE;
+	}
+	filp->f_op = &futex_fops;
+	filp->f_dentry = dget(futex_dentry);
+
+	if (signal) {
+		filp->f_owner.pid = current->pid;
+		filp->f_owner.uid = current->uid;
+		filp->f_owner.euid = current->euid;
+		filp->f_owner.signum = signal;
+	}
+
+	q = kmalloc(sizeof(*q), GFP_KERNEL);
+	if (!q) {
+		put_unused_fd(fd);
+		put_filp(filp);
+		return -ENOMEM;
+	}
+
+	/* Initialize queue structure, and add to hash table. */
+	filp->private_data = q;
+	init_waitqueue_head(&q->waiters);
+	queue_me(head, q, page, offset, fd, filp);
+
+	/* Now we map fd to filp, so userspace can access it */
+	fd_install(fd, filp);
+	return fd;
+}
+
 asmlinkage int sys_futex(void *uaddr, int op, int val, struct timespec *utime)
 {
 	int ret;
@@ -220,17 +333,69 @@
 	case FUTEX_WAKE:
 		ret = futex_wake(head, page, pos_in_page, val);
 		break;
+	case FUTEX_FD:
+		/* non-zero val means F_SETOWN(getpid()) & F_SETSIG(val) */
+		ret = futex_fd(head, page, pos_in_page, val);
+		if (ret >= 0)
+			/* Leave page pinned (attached to fd). */
+			return ret;
+		break;
 	default:
 		ret = -EINVAL;
 	}
-	page_cache_release(page);
+	unpin_page(page);
 
 	return ret;
 }
 
+/* FIXME: Oh yeah, makes sense to write a filesystem... */
+static struct super_operations futexfs_ops = { statfs: simple_statfs };
+
+/* Don't check error returns: we're dead if they happen */
+static int futexfs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct inode *root;
+
+	sb->s_blocksize = 1024;
+	sb->s_blocksize_bits = 10;
+	sb->s_magic = 0xBAD1DEA;
+	sb->s_op = &futexfs_ops;
+
+	root = new_inode(sb);
+	root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
+	root->i_uid = root->i_gid = 0;
+	root->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;
+
+	sb->s_root = d_alloc(NULL, &(const struct qstr) { "futex", 5, 0 });
+	sb->s_root->d_sb = sb;
+	sb->s_root->d_parent = sb->s_root;
+	d_instantiate(sb->s_root, root);
+
+	/* We never let this drop to zero. */
+	futex_dentry = dget(sb->s_root);
+
+	return 0;
+}
+
+static struct super_block *
+futexfs_get_sb(struct file_system_type *fs_type,
+	       int flags, char *dev_name, void *data)
+{
+	return get_sb_nodev(fs_type, flags, data, futexfs_fill_super);
+}
+
+static struct file_system_type futex_fs_type = {
+	name:		"futexfs",
+	get_sb:		futexfs_get_sb,
+	kill_sb:	kill_anon_super,
+};
+
 static int __init init(void)
 {
 	unsigned int i;
+
+	register_filesystem(&futex_fs_type);
+	kern_mount(&futex_fs_type);
 
 	for (i = 0; i < ARRAY_SIZE(futex_queues); i++)
 		INIT_LIST_HEAD(&futex_queues[i]);
diff -Nru a/kernel/ksyms.c b/kernel/ksyms.c
--- a/kernel/ksyms.c	Thu Jun 20 15:54:00 2002
+++ b/kernel/ksyms.c	Thu Jun 20 15:54:00 2002
@@ -459,6 +459,7 @@
 
 /* process management */
 EXPORT_SYMBOL(complete_and_exit);
+EXPORT_SYMBOL(default_wake_function);
 EXPORT_SYMBOL(__wake_up);
 #if CONFIG_SMP
 EXPORT_SYMBOL_GPL(__wake_up_sync); /* internal use only */
diff -Nru a/kernel/sched.c b/kernel/sched.c
--- a/kernel/sched.c	Thu Jun 20 15:54:00 2002
+++ b/kernel/sched.c	Thu Jun 20 15:54:00 2002
@@ -148,7 +148,7 @@
 
 #define cpu_rq(cpu)		(runqueues + (cpu))
 #define this_rq()		cpu_rq(smp_processor_id())
-#define task_rq(p)		cpu_rq((p)->thread_info->cpu)
+#define task_rq(p)		cpu_rq(task_cpu(p))
 #define cpu_curr(cpu)		(cpu_rq(cpu)->curr)
 #define rt_task(p)		((p)->prio < MAX_RT_PRIO)
 
@@ -284,8 +284,8 @@
 	need_resched = test_and_set_tsk_thread_flag(p,TIF_NEED_RESCHED);
 	nrpolling |= test_tsk_thread_flag(p,TIF_POLLING_NRFLAG);
 
-	if (!need_resched && !nrpolling && (p->thread_info->cpu != smp_processor_id()))
-		smp_send_reschedule(p->thread_info->cpu);
+	if (!need_resched && !nrpolling && (task_cpu(p) != smp_processor_id()))
+		smp_send_reschedule(task_cpu(p));
 	preempt_enable();
 #else
 	set_tsk_need_resched(p);
@@ -366,10 +366,10 @@
 		 * currently. Do not violate hard affinity.
 		 */
 		if (unlikely(sync && (rq->curr != p) &&
-			(p->thread_info->cpu != smp_processor_id()) &&
+			(task_cpu(p) != smp_processor_id()) &&
 			(p->cpus_allowed & (1UL << smp_processor_id())))) {
 
-			p->thread_info->cpu = smp_processor_id();
+			set_task_cpu(p, smp_processor_id());
 			task_rq_unlock(rq, &flags);
 			goto repeat_lock_task;
 		}
@@ -409,7 +409,7 @@
 		p->sleep_avg = p->sleep_avg * CHILD_PENALTY / 100;
 		p->prio = effective_prio(p);
 	}
-	p->thread_info->cpu = smp_processor_id();
+	set_task_cpu(p, smp_processor_id());
 	activate_task(p, rq);
 
 	rq_unlock(rq);
@@ -663,7 +663,7 @@
 	 */
 	dequeue_task(next, array);
 	busiest->nr_running--;
-	next->thread_info->cpu = this_cpu;
+	set_task_cpu(next, this_cpu);
 	this_rq->nr_running++;
 	enqueue_task(next, this_rq->active);
 	if (next->prio < current->prio)
@@ -821,7 +821,7 @@
 	spin_lock_irq(&rq->lock);
 
 	/*
-	 * if entering off a kernel preemption go straight
+	 * if entering off of a kernel preemption go straight
 	 * to picking the next task.
 	 */
 	if (unlikely(preempt_get_count() & PREEMPT_ACTIVE))
@@ -906,7 +906,7 @@
 	schedule();
 	ti->preempt_count = 0;
 
-	/* we can miss a preemption opportunity between schedule and now */
+	/* we could miss a preemption opportunity between schedule and now */
 	barrier();
 	if (unlikely(test_thread_flag(TIF_NEED_RESCHED)))
 		goto need_resched;
@@ -1630,7 +1630,7 @@
 
 void __init init_idle(task_t *idle, int cpu)
 {
-	runqueue_t *idle_rq = cpu_rq(cpu), *rq = cpu_rq(idle->thread_info->cpu);
+	runqueue_t *idle_rq = cpu_rq(cpu), *rq = cpu_rq(task_cpu(idle));
 	unsigned long flags;
 
 	__save_flags(flags);
@@ -1642,7 +1642,7 @@
 	idle->array = NULL;
 	idle->prio = MAX_PRIO;
 	idle->state = TASK_RUNNING;
-	idle->thread_info->cpu = cpu;
+	set_task_cpu(idle, cpu);
 	double_rq_unlock(idle_rq, rq);
 	set_tsk_need_resched(idle);
 	__restore_flags(flags);
@@ -1751,7 +1751,7 @@
 	 * Can the task run on the task's current CPU? If not then
 	 * migrate the process off to a proper CPU.
 	 */
-	if (new_mask & (1UL << p->thread_info->cpu)) {
+	if (new_mask & (1UL << task_cpu(p))) {
 		task_rq_unlock(rq, &flags);
 		goto out;
 	}
@@ -1760,7 +1760,7 @@
 	 * it is sufficient to simply update the task's cpu field.
 	 */
 	if (!p->array && (p != rq->curr)) {
-		p->thread_info->cpu = __ffs(p->cpus_allowed);
+		set_task_cpu(p, __ffs(p->cpus_allowed));
 		task_rq_unlock(rq, &flags);
 		goto out;
 	}
@@ -1775,6 +1775,8 @@
 	preempt_enable();
 }
 
+static __initdata int master_migration_thread;
+
 static int migration_thread(void * bind_cpu)
 {
 	int cpu = (int) (long) bind_cpu;
@@ -1786,14 +1788,12 @@
 	sigfillset(&current->blocked);
 	set_fs(KERNEL_DS);
 
-	/* FIXME: First CPU may not be zero, but this crap code
-           vanishes with hotplug cpu patch anyway. --RR */
 	/*
-	 * The first migration thread is started on CPU #0. This one can
-	 * migrate the other migration threads to their destination CPUs.
+	 * The first migration thread is started on the boot CPU, it
+	 * migrates the other migration threads to their destination CPUs.
 	 */
-	if (cpu != 0) {
-		while (!cpu_rq(0)->migration_thread)
+	if (cpu != master_migration_thread) {
+		while (!cpu_rq(master_migration_thread)->migration_thread)
 			yield();
 		set_cpus_allowed(current, 1UL << cpu);
 	}
@@ -1829,18 +1829,18 @@
 		cpu_dest = __ffs(p->cpus_allowed);
 		rq_dest = cpu_rq(cpu_dest);
 repeat:
-		cpu_src = p->thread_info->cpu;
+		cpu_src = task_cpu(p);
 		rq_src = cpu_rq(cpu_src);
 
 		local_irq_save(flags);
 		double_rq_lock(rq_src, rq_dest);
-		if (p->thread_info->cpu != cpu_src) {
+		if (task_cpu(p) != cpu_src) {
 			double_rq_unlock(rq_src, rq_dest);
 			local_irq_restore(flags);
 			goto repeat;
 		}
 		if (rq_src == rq) {
-			p->thread_info->cpu = cpu_dest;
+			set_task_cpu(p, cpu_dest);
 			if (p->array) {
 				deactivate_task(p, rq_src);
 				activate_task(p, rq_dest);
@@ -1857,7 +1857,9 @@
 {
 	int cpu;
 
-	current->cpus_allowed = 1UL << 0;
+	master_migration_thread = smp_processor_id();
+	current->cpus_allowed = 1UL << master_migration_thread;
+	
 	for (cpu = 0; cpu < NR_CPUS; cpu++) {
 		if (!cpu_online(cpu))
 			continue;
diff -Nru a/kernel/signal.c b/kernel/signal.c
--- a/kernel/signal.c	Thu Jun 20 15:54:00 2002
+++ b/kernel/signal.c	Thu Jun 20 15:54:00 2002
@@ -1488,3 +1488,15 @@
 	return ret ? ret : (unsigned long)old_sa.sa.sa_handler;
 }
 #endif /* !alpha && !__ia64__ && !defined(__mips__) && !defined(__arm__) */
+
+#ifndef HAVE_ARCH_SYS_PAUSE
+
+asmlinkage int
+sys_pause(void)
+{
+	current->state = TASK_INTERRUPTIBLE;
+	schedule();
+	return -ERESTARTNOHAND;
+}
+
+#endif /* HAVE_ARCH_SYS_PAUSE */
diff -Nru a/kernel/softirq.c b/kernel/softirq.c
--- a/kernel/softirq.c	Thu Jun 20 15:54:00 2002
+++ b/kernel/softirq.c	Thu Jun 20 15:54:00 2002
@@ -61,7 +61,7 @@
 
 asmlinkage void do_softirq()
 {
-	int cpu = smp_processor_id();
+	unsigned long cpu;
 	__u32 pending;
 	long flags;
 	__u32 mask;
@@ -71,6 +71,7 @@
 
 	local_irq_save(flags);
 
+	cpu = smp_processor_id();
 	pending = softirq_pending(cpu);
 
 	if (pending) {
diff -Nru a/kernel/timer.c b/kernel/timer.c
--- a/kernel/timer.c	Thu Jun 20 15:54:00 2002
+++ b/kernel/timer.c	Thu Jun 20 15:54:00 2002
@@ -187,7 +187,7 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&timerlist_lock, flags);
-	if (timer_pending(timer))
+	if (unlikely(timer_pending(timer)))
 		goto bug;
 	internal_add_timer(timer);
 	spin_unlock_irqrestore(&timerlist_lock, flags);
diff -Nru a/mm/mmap.c b/mm/mmap.c
--- a/mm/mmap.c	Thu Jun 20 15:54:00 2002
+++ b/mm/mmap.c	Thu Jun 20 15:54:00 2002
@@ -781,6 +781,8 @@
 		break;
 	}
 no_mmaps:
+	if (last < first)	/* needed for arches with discontiguous pgd indices */
+		return;
 	/*
 	 * If the PGD bits are not consecutive in the virtual address, the
 	 * old method of shifting the VA >> by PGDIR_SHIFT doesn't work.
diff -Nru a/mm/page_alloc.c b/mm/page_alloc.c
--- a/mm/page_alloc.c	Thu Jun 20 15:54:00 2002
+++ b/mm/page_alloc.c	Thu Jun 20 15:54:00 2002
@@ -15,11 +15,9 @@
 #include <linux/config.h>
 #include <linux/mm.h>
 #include <linux/swap.h>
-#include <linux/swapctl.h>
 #include <linux/interrupt.h>
 #include <linux/pagemap.h>
 #include <linux/bootmem.h>
-#include <linux/slab.h>
 #include <linux/compiler.h>
 #include <linux/module.h>
 #include <linux/suspend.h>
@@ -44,14 +42,18 @@
 static int zone_balance_max[MAX_NR_ZONES] __initdata = { 255 , 255, 255, };
 
 /*
- * Temporary debugging check.
+ * Temporary debugging check for pages not lying within a given zone.
  */
-#define BAD_RANGE(zone, page)						\
-(									\
-	(((page) - mem_map) >= ((zone)->zone_start_mapnr+(zone)->size))	\
-	|| (((page) - mem_map) < (zone)->zone_start_mapnr)		\
-	|| ((zone) != page_zone(page))					\
-)
+static inline int bad_range(zone_t *zone, struct page *page)
+{
+	if (page - mem_map >= zone->zone_start_mapnr + zone->size)
+		return 1;
+	if (page - mem_map < zone->zone_start_mapnr)
+		return 1;
+	if (zone != page_zone(page))
+		return 1;
+	return 0;
+}
 
 /*
  * Freeing function for a buddy system allocator.
@@ -65,10 +67,13 @@
  * at the bottom level available, and propagating the changes upward
  * as necessary, plus some accounting needed to play nicely with other
  * parts of the VM system.
- *
- * TODO: give references to descriptions of buddy system allocators,
- * describe precisely the silly trick buddy allocators use to avoid
- * storing an extra bit, utilizing entry point information.
+ * At each level, we keep one bit for each pair of blocks, which
+ * is set to 1 iff only one of the pair is allocated.  So when we
+ * are allocating or freeing one, we can derive the state of the
+ * other.  That is, if we allocate a small block, and both were   
+ * free, the remainder of the region must be split into blocks.   
+ * If a block is freed, and its buddy is also free, then this
+ * triggers coalescing into a block of larger size.            
  *
  * -- wli
  */
@@ -132,9 +137,9 @@
 		 */
 		buddy1 = base + (page_idx ^ -mask);
 		buddy2 = base + page_idx;
-		if (BAD_RANGE(zone,buddy1))
+		if (bad_range(zone, buddy1))
 			BUG();
-		if (BAD_RANGE(zone,buddy2))
+		if (bad_range(zone, buddy2))
 			BUG();
 
 		list_del(&buddy1->list);
@@ -168,17 +173,17 @@
 	unsigned long size = 1 << high;
 
 	while (high > low) {
-		if (BAD_RANGE(zone,page))
+		if (bad_range(zone, page))
 			BUG();
 		area--;
 		high--;
 		size >>= 1;
-		list_add(&(page)->list, &(area)->free_list);
+		list_add(&page->list, &area->free_list);
 		MARK_USED(index, high, area);
 		index += size;
 		page += size;
 	}
-	if (BAD_RANGE(zone,page))
+	if (bad_range(zone, page))
 		BUG();
 	return page;
 }
@@ -201,7 +206,7 @@
 			unsigned int index;
 
 			page = list_entry(curr, struct page, list);
-			if (BAD_RANGE(zone,page))
+			if (bad_range(zone, page))
 				BUG();
 			list_del(curr);
 			index = page - zone->zone_mem_map;
@@ -213,7 +218,7 @@
 			spin_unlock_irqrestore(&zone->lock, flags);
 
 			set_page_count(page, 1);
-			if (BAD_RANGE(zone,page))
+			if (bad_range(zone, page))
 				BUG();
 			if (PageLRU(page))
 				BUG();
@@ -495,16 +500,13 @@
  */
 unsigned int nr_free_pages(void)
 {
-	unsigned int sum;
-	zone_t *zone;
-	pg_data_t *pgdat = pgdat_list;
+	unsigned int i, sum = 0;
+	pg_data_t *pgdat;
+
+	for (pgdat = pgdat_list; pgdat; pgdat = pgdat->node_next)
+		for (i = 0; i < MAX_NR_ZONES; ++i)
+			sum += pgdat->node_zones[i].free_pages;
 
-	sum = 0;
-	while (pgdat) {
-		for (zone = pgdat->node_zones; zone < pgdat->node_zones + MAX_NR_ZONES; zone++)
-			sum += zone->free_pages;
-		pgdat = pgdat->node_next;
-	}
 	return sum;
 }
 
diff -Nru a/net/802/Makefile b/net/802/Makefile
--- a/net/802/Makefile	Thu Jun 20 15:54:01 2002
+++ b/net/802/Makefile	Thu Jun 20 15:54:01 2002
@@ -2,52 +2,40 @@
 # Makefile for the Linux 802.x protocol layers.
 #
 
-export-objs = llc_macinit.o p8022.o psnap.o
+export-objs		:= llc_macinit.o p8022.o psnap.o
 
-obj-y	= p8023.o
+obj-y			:= p8023.o
 
-obj-$(CONFIG_SYSCTL) += sysctl_net_802.o
-obj-$(CONFIG_LLC) += llc_sendpdu.o llc_utility.o cl2llc.o llc_macinit.o
-ifeq ($(CONFIG_SYSCTL),y)
-obj-y += sysctl_net_802.o
-endif
-
-ifeq ($(CONFIG_LLC),y)
-subdir-y += transit
-obj-y += llc_sendpdu.o llc_utility.o cl2llc.o llc_macinit.o
-SNAP = y
-endif
-
-ifdef CONFIG_TR
-obj-y += tr.o
-	SNAP=y
-endif
-
-ifdef CONFIG_NET_FC
-obj-y += fc.o
-endif
-
-ifdef CONFIG_FDDI
-obj-y += fddi.o
-endif
-
-ifdef CONFIG_HIPPI
-obj-y += hippi.o
-endif
-
-ifdef CONFIG_IPX
-	SNAP=y
-endif
-
-ifdef CONFIG_ATALK
-	SNAP=y
-endif
-
-ifeq ($(SNAP),y)
-obj-y += p8022.o psnap.o
-endif
+obj-$(CONFIG_SYSCTL)	+= sysctl_net_802.o
+obj-$(CONFIG_LLC)	+= p8022.o psnap.o llc_sendpdu.o llc_utility.o \
+			   		   cl2llc.o llc_macinit.o	
+obj-$(CONFIG_TR)	+= p8022.o psnap.o tr.o
+obj-$(CONFIG_NET_FC)	+=                 fc.o
+obj-$(CONFIG_FDDI)	+=                 fddi.o
+obj-$(CONFIG_HIPPI)	+=                 hippi.o
+obj-$(CONFIG_IPX)	+= p8022.o psnap.o
+obj-$(CONFIG_ATALK)	+= p8022.o psnap.o
 
 include $(TOPDIR)/Rules.make
 
-cl2llc.c: cl2llc.pre
-	sed -f ./pseudo/opcd2num.sed cl2llc.pre >cl2llc.c
+# Dependencies on generated files need to be listed explicitly
+
+$(obj)/cl2llc.o: $(obj)/transit/pdutr.h $(obj)/transit/timertr.h \
+		 $(obj)/pseudo/pseudocode.h
+
+# Generated files
+
+$(obj)/transit/pdutr.h: $(src)/transit/pdutr.pre $(src)/transit/compile.awk
+	awk -f $(src)/transit/compile.awk $< >$@
+
+$(obj)/transit/timertr.h: $(src)/transit/timertr.pre $(src)/transit/compile.awk
+	awk -f $(src)/transit/compile.awk $< >$@
+
+$(obj)/pseudo/pseudocode.h: $(src)/pseudo/pseudocode \
+			    $(src)/pseudo/opcd2num.sed \
+			    $(src)/pseudo/compile.awk
+	sed -f $(src)/pseudo/opcd2num.sed $< | \
+	awk -f $(src)/pseudo/compile.awk >$@
+
+$(obj)/cl2llc.c: $(src)/cl2llc.pre $(src)/pseudo/opcd2num.sed
+	sed -f $(src)/pseudo/opcd2num.sed $< >$@
diff -Nru a/net/802/cl2llc.c b/net/802/cl2llc.c
--- a/net/802/cl2llc.c	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,615 +0,0 @@
-/*
- * NET		An implementation of the IEEE 802.2 LLC protocol for the
- *		LINUX operating system.  LLC is implemented as a set of 
- *		state machines and callbacks for higher networking layers.
- *
- *		Class 2 llc algorithm.
- *		Pseudocode interpreter, transition table lookup,
- *			data_request & indicate primitives...
- *
- *		Code for initialization, termination, registration and 
- *		MAC layer glue.
- *
- *		Copyright Tim Alpaerts, 
- *			<Tim_Alpaerts@toyota-motor-europe.com>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- *	Changes
- *		Alan Cox	:	Chainsawed into Linux format
- *					Modified to use llc_ names
- *					Changed callbacks
- *
- *	This file must be processed by sed before it can be compiled.
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/netdevice.h>
-#include <linux/skbuff.h>
-#include <net/p8022.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <asm/byteorder.h>
-
-#include "pseudo/pseudocode.h"
-#include "transit/pdutr.h"
-#include "transit/timertr.h"
-#include <net/llc_frame.h>
-#include <net/llc.h>
-
-/*
- *	Data_request() is called by the client to present a data unit
- *	to the llc for transmission.
- *	In the future this function should also check if the transmit window
- *	allows the sending of another pdu, and if not put the skb on the atq
- *	for deferred sending.
- */
-
-int llc_data_request(llcptr lp, struct sk_buff *skb)
-{
-	if (skb_headroom(skb) < (lp->dev->hard_header_len +4)){
-		printk("cl2llc: data_request() not enough headroom in skb\n");
-		return -1;
-	};
-
-	skb_push(skb, 4);
-
-	if ((lp->state != NORMAL) && (lp->state != BUSY) && (lp->state != REJECT))
-	{
-		printk("cl2llc: data_request() while no llc connection\n"); 
-		return -1;  
-	}
-
-	if (lp->remote_busy)
-	{     /* if the remote llc is BUSY, */
-		ADD_TO_ATQ(skb);      /* save skb in the await transmit queue */
-		return 0;
-	}                           
-	else
-	{
-		/*
-		 *	Else proceed with xmit 
-		 */
-
-		switch(lp->state)
-		{
-			case NORMAL:
-				if(lp->p_flag)
-					llc_interpret_pseudo_code(lp, NORMAL2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, NORMAL1, skb, NO_FRAME);
-				break;
-			case BUSY:
-				if (lp->p_flag)
-					llc_interpret_pseudo_code(lp, BUSY2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, BUSY1, skb, NO_FRAME);
-				break;
-			case REJECT:
-				if (lp->p_flag)
-					llc_interpret_pseudo_code(lp, REJECT2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, REJECT1, skb, NO_FRAME);
-				break;
-			default:;
-		}
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		return 0;  
-	}              
-}
-
-
-
-/* 
- *	Disconnect_request() requests that the llc to terminate a connection
- */
-
-void disconnect_request(llcptr lp)
-{
-	if ((lp->state == NORMAL) ||
-    		(lp->state == BUSY) ||
-		(lp->state == REJECT) ||
-		(lp->state == AWAIT) ||
-		(lp->state == AWAIT_BUSY) ||
-		(lp->state == AWAIT_REJECT))
-	{
-		lp->state = D_CONN;
-		llc_interpret_pseudo_code(lp, SH1, NULL, NO_FRAME);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may be invalid after the callback
-		 */
-	}
-}
-
-
-/*
- *	Connect_request() requests that the llc to start a connection
- */
-
-void connect_request(llcptr lp)
-{
-	if (lp->state == ADM)
-	{
-		lp->state = SETUP;
-		llc_interpret_pseudo_code(lp, ADM1, NULL, NO_FRAME);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may be invalid after the callback
-		 */
-	}
-}
-
-
-/*
- *	Interpret_pseudo_code() executes the actions in the connection component
- *	state transition table. Table 4 in document on p88.
- *
- *	If this function is called to handle an incoming pdu, skb will point
- *	to the buffer with the pdu and type will contain the decoded pdu type.
- *
- *	If called by data_request skb points to an skb that was skb_alloc-ed by 
- *	the llc client to hold the information unit to be transmitted, there is
- *	no valid type in this case.  
- *
- *	If called because a timer expired no skb is passed, and there is no 
- *	type.
- */
-
-void llc_interpret_pseudo_code(llcptr lp, int pc_label, struct sk_buff *skb, 
-		char type)
-{    
-	short int pc;	/* program counter in pseudo code array */ 
-	char p_flag_received;
-	frameptr fr;
-	int resend_count;   /* number of pdus resend by llc_resend_ipdu() */
-	int ack_count;      /* number of pdus acknowledged */
-	struct sk_buff *skb2;
-
-	if (skb != NULL) 
-	{
-		fr = (frameptr) skb->data;
-	}
-	else
-		fr = NULL;
-
-	pc = pseudo_code_idx[pc_label];
-	while(pseudo_code[pc])
-	{
-		switch(pseudo_code[pc])
-		{
-			case 9:
-				if ((type != I_CMD) || (fr->i_hdr.i_pflag == 0))
-					break;
-			case 1:
-				lp->remote_busy = 0;
-				llc_stop_timer(lp, BUSY_TIMER);
-				if ((lp->state == NORMAL) ||
-					(lp->state == REJECT) ||
-					(lp->state == BUSY))
-				{
-					skb2 = llc_pull_from_atq(lp);
-					if (skb2 != NULL) 
-						llc_start_timer(lp, ACK_TIMER);
-					while (skb2 != NULL)
-					{
-						llc_sendipdu( lp, I_CMD, 0, skb2);
-						skb2 = llc_pull_from_atq(lp);
-					}
-				}	   
-				break;
-			case 2:
-				lp->state = NORMAL;  /* needed to eliminate connect_response() */
-				lp->llc_mode = MODE_ABM;
-				lp->llc_callbacks|=LLC_CONN_INDICATION;
-				break;
-			case 3:
-				lp->llc_mode = MODE_ABM;
-				lp->llc_callbacks|=LLC_CONN_CONFIRM;
-				break;
-			case 4:
-				skb_pull(skb, 4);
-				lp->inc_skb=skb;
-				lp->llc_callbacks|=LLC_DATA_INDIC;
-				break;
-			case 5:
-				lp->llc_mode = MODE_ADM;
-				lp->llc_callbacks|=LLC_DISC_INDICATION;
-				break;
-			case 70:
-				lp->llc_callbacks|=LLC_RESET_INDIC_LOC;
-				break;
-			case 71:
-				lp->llc_callbacks|=LLC_RESET_INDIC_REM;
-				break;
-			case 7:
-				lp->llc_callbacks|=LLC_RST_CONFIRM;
-				break;
-			case 66:
-				lp->llc_callbacks|=LLC_FRMR_RECV;
-				break;
-			case 67:
-				lp->llc_callbacks|=LLC_FRMR_SENT;
-				break;
-			case 68:
-				lp->llc_callbacks|=LLC_REMOTE_BUSY;
-				break;
-			case 69:
-				lp->llc_callbacks|=LLC_REMOTE_NOTBUSY;
-				break;
-			case 11:
-				llc_sendpdu(lp, DISC_CMD, lp->f_flag, 0, NULL);
-				break;
-			case 12:
-				llc_sendpdu(lp, DM_RSP, 0, 0, NULL);
-				break;
-			case 13:                        
-				lp->frmr_info_fld.cntl1 = fr->pdu_cntl.byte1;
-				lp->frmr_info_fld.cntl2 = fr->pdu_cntl.byte2;
-				lp->frmr_info_fld.vs = lp->vs;
-				lp->frmr_info_fld.vr_cr = lp->vr;
-				llc_sendpdu(lp, FRMR_RSP, 0, 5, (char *) &lp->frmr_info_fld);
-				break;
-			case 14:
-				llc_sendpdu(lp, FRMR_RSP, 0, 5, (char *) &lp->frmr_info_fld);
-				break;
-			case 15:
-				llc_sendpdu(lp, FRMR_RSP, lp->p_flag,
-					5, (char *) &lp->frmr_info_fld);
-				break;
-			case 16:
-				llc_sendipdu(lp, I_CMD, 1, skb);   
-				break;
-			case 17:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 1);
-				break;
-			case 18:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 1);
-				if (resend_count == 0) 
-				{
-					llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				}    
-				break;
-			case 19:
-				llc_sendipdu(lp, I_CMD, 0, skb);   
-				break;
-			case 20:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 0);
-				break;
-			case 21:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 0);
-				if (resend_count == 0) 
-				{
-					llc_sendpdu(lp, RR_CMD, 0, 0, NULL);
-				}    
-				break;
-			case 22:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_RSP, 1);
-				break;
-			case 23:
-				llc_sendpdu(lp, REJ_CMD, 1, 0, NULL);
-				break;
-			case 24:
-				llc_sendpdu(lp, REJ_RSP, 1, 0, NULL);
-				break;
-			case 25:
-				if (IS_RSP(fr))
-					llc_sendpdu(lp, REJ_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, REJ_RSP, 0, 0, NULL);
-				break;
-			case 26:
-				llc_sendpdu(lp, RNR_CMD, 1, 0, NULL);
-				break;
-			case 27:
-				llc_sendpdu(lp, RNR_RSP, 1, 0, NULL);
-				break;
-			case 28:
-				if (IS_RSP(fr))
-					llc_sendpdu(lp, RNR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RNR_RSP, 0, 0, NULL);
-				break;
-			case 29:
-				if (lp->remote_busy == 0)
-				{
-					lp->remote_busy = 1;
-					llc_start_timer(lp, BUSY_TIMER);
-					lp->llc_callbacks|=LLC_REMOTE_BUSY;
-				}
-				else if (lp->timer_state[BUSY_TIMER] == TIMER_IDLE)
-				{
-					llc_start_timer(lp, BUSY_TIMER);
-				}
-				break;
-			case 30:
-				if (IS_RSP(fr)) 
-					llc_sendpdu(lp, RNR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RNR_RSP, 0, 0, NULL);
-				break;
-			case 31:
-				llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				break;
-			case 32:
-				llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				break;
-			case 33:
-				llc_sendpdu(lp, RR_RSP, 1, 0, NULL);
-				break;
-			case 34:
-				llc_sendpdu(lp, RR_RSP, 1, 0, NULL);
-				break;
-			case 35:
-				llc_sendpdu(lp, RR_RSP, 0, 0, NULL);
-				break;
-			case 36:
-				if (IS_RSP(fr)) 
-					llc_sendpdu(lp, RR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RR_RSP, 0, 0, NULL);
-				break;
-			case 37:
-				llc_sendpdu(lp, SABME_CMD, 0, 0, NULL);
-				lp->f_flag = 0;
-				break;
-			case 38:
-				llc_sendpdu(lp, UA_RSP, lp->f_flag, 0, NULL);
-				break;
-			case 39:
-				lp->s_flag = 0;
-				break;
-			case 40:
-				lp->s_flag = 1;
-				break;
-			case 41:
-				if(lp->timer_state[P_TIMER] == TIMER_RUNNING)
-					llc_stop_timer(lp, P_TIMER);
-				llc_start_timer(lp, P_TIMER);
-				if (lp->p_flag == 0)
-				{
-					lp->retry_count = 0;
-					lp->p_flag = 1;
-				}
-				break;
-			case 44:
-				if (lp->timer_state[ACK_TIMER] == TIMER_IDLE)
-					llc_start_timer(lp, ACK_TIMER);
-				break;
-			case 42:
-				llc_start_timer(lp, ACK_TIMER);
-				break;
-			case 43:
-				llc_start_timer(lp, REJ_TIMER);
-				break;
-			case 45:
-				llc_stop_timer(lp, ACK_TIMER);
-				break;
-			case 46:
-				llc_stop_timer(lp, ACK_TIMER);
-				lp->p_flag = 0;
-				break;
-			case 10:
-				if (lp->data_flag == 2)
-					llc_stop_timer(lp, REJ_TIMER);
-				break;
-			case 47:
-				llc_stop_timer(lp, REJ_TIMER);
-				break;
-			case 48:
-				llc_stop_timer(lp, ACK_TIMER);
-				llc_stop_timer(lp, P_TIMER);
-				llc_stop_timer(lp, REJ_TIMER);
-				llc_stop_timer(lp, BUSY_TIMER);
-				break;
-			case 49:
-				llc_stop_timer(lp, P_TIMER);
-				llc_stop_timer(lp, REJ_TIMER);
-				llc_stop_timer(lp, BUSY_TIMER);
-				break;
-			case 50:             
-				ack_count = llc_free_acknowledged_skbs(lp,
-					(unsigned char) fr->s_hdr.nr);
-				if (ack_count > 0)
-				{
-					lp->retry_count = 0;
-					llc_stop_timer(lp, ACK_TIMER);  
-					if (skb_peek(&lp->rtq) != NULL)
-					{
-						/*
- 						 *	Re-transmit queue not empty 
-						 */
-						llc_start_timer(lp, ACK_TIMER);  
-					}
-				}        
-				break;
-			case 51:
-				if (IS_UFRAME(fr)) 
-					p_flag_received = fr->u_hdr.u_pflag;
-				else
-					p_flag_received = fr->i_hdr.i_pflag;
-				if ((fr->pdu_hdr.ssap & 0x01) && (p_flag_received))
-				{
-					lp->p_flag = 0;
-					llc_stop_timer(lp, P_TIMER);  
-				}
-				break;
-			case 52:
-				lp->data_flag = 2;
-				break;
-			case 53:
-				lp->data_flag = 0;
-				break;
-			case 54:
-				lp->data_flag = 1;
-				break;
-			case 55:
-				if (lp->data_flag == 0)
-					lp->data_flag = 1;
-				break;
-			case 56:
-				lp->p_flag = 0;
-				break;
-			case 57:
-				lp->p_flag = lp->f_flag;
-				break;
-			case 58:
-				lp->remote_busy = 0;
-				break;
-			case 59:
-				lp->retry_count = 0;
-				break;
-			case 60:
-				lp->retry_count++;
-				break;
-			case 61:
-				lp->vr = 0;
-				break;
-			case 62:
-				lp->vr++;
-				break;
-			case 63:
-				lp->vs = 0;
-				break;
-			case 64:
-				lp->vs = fr->i_hdr.nr;
-				break;
-			case 65:
-				if (IS_UFRAME(fr)) 
-					lp->f_flag = fr->u_hdr.u_pflag;
-				else
-					lp->f_flag = fr->i_hdr.i_pflag;
-				break;
-			default:;
-		}
-		pc++;	
-	}
-}
-
-
-/*
- *	Process_otype2_frame will handle incoming frames
- *	for 802.2 Type 2 Procedure.
- */
-
-void llc_process_otype2_frame(llcptr lp, struct sk_buff *skb, char type)
-{
-	int idx;		/*	index in transition table */
-	int pc_label;		/*	action to perform, from tr tbl */
-	int validation;		/*	result of validate_seq_nos */
-	int p_flag_received;	/*	p_flag in received frame */
-	frameptr fr;
-
-	fr = (frameptr) skb->data;
-
-	if (IS_UFRAME(fr))
-		p_flag_received = fr->u_hdr.u_pflag;
-	else
-		p_flag_received = fr->i_hdr.i_pflag;
-
-	switch(lp->state)
-	{
-		/*	Compute index in transition table: */
-		case ADM:
-			idx = type;
-			idx = (idx << 1) + p_flag_received;
-			break;
-		case CONN:
-		case RESET_WAIT:
-		case RESET_CHECK:
-		case ERROR:
-			idx = type;
-			break;
-		case SETUP:
-		case RESET:
-		case D_CONN:
-			idx = type;
-			idx = (idx << 1) + lp->p_flag;
-			break;
-		case NORMAL:
-		case BUSY:
-		case REJECT:
-		case AWAIT:
-		case AWAIT_BUSY:
-		case AWAIT_REJECT:
-			validation = llc_validate_seq_nos(lp, fr);
-			if (validation > 3) 
-				type = BAD_FRAME;
-			idx = type;
-			idx = (idx << 1);
-			if (validation & 1) 
-				idx = idx +1;
-			idx = (idx << 1) + p_flag_received;
-			idx = (idx << 1) + lp->p_flag;
-		default:
-			printk("llc_proc: bad state\n");
-			return;
-	}
-	idx = (idx << 1) + pdutr_offset[lp->state];
-	lp->state = pdutr_entry[idx +1]; 
-	pc_label = pdutr_entry[idx];
-	if (pc_label != 0)
-	{ 
-		llc_interpret_pseudo_code(lp, pc_label, skb, type);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may no longer be valid after this point. Be
-		 *	careful what is added!
-		 */
-	}
-}
-
-
-void llc_timer_expired(llcptr lp, int t)
-{
-	int idx;		/* index in transition table	*/
-	int pc_label;       	/* action to perform, from tr tbl */
-
-	lp->timer_state[t] = TIMER_EXPIRED;
-	idx = lp->state;            /* Compute index in transition table: */
-	idx = (idx << 2) + t;
-	idx = idx << 1;
-	if (lp->retry_count >= lp->n2) 
-		idx = idx + 1;
-	idx = (idx << 1) + lp->s_flag;
-	idx = (idx << 1) + lp->p_flag;
-	idx = idx << 1;             /* 2 bytes per entry: action & newstate */
-
-	pc_label = timertr_entry[idx];
-	if (pc_label != 0)
-	{
-		llc_interpret_pseudo_code(lp, pc_label, NULL, NO_FRAME);
-		lp->state = timertr_entry[idx +1];
-	}
-	lp->timer_state[t] = TIMER_IDLE;
-	if(lp->llc_callbacks)
-	{
-		lp->llc_event(lp);
-		lp->llc_callbacks=0;
-	}
-	/*
- 	 *	And lp may have vanished in the event callback
- 	 */
-}
-
diff -Nru a/net/802/cl2llc.pre b/net/802/cl2llc.pre
--- a/net/802/cl2llc.pre	Thu Jun 20 15:54:00 2002
+++ b/net/802/cl2llc.pre	Thu Jun 20 15:54:00 2002
@@ -96,7 +96,7 @@
 				else
 					llc_interpret_pseudo_code(lp, REJECT1, skb, NO_FRAME);
 				break;
-			default:
+			default:;
 		}
 		if(lp->llc_callbacks)
 		{
@@ -497,7 +497,7 @@
 				else
 					lp->f_flag = fr->i_hdr.i_pflag;
 				break;
-			default:
+			default:;
 		}
 		pc++;	
 	}
diff -Nru a/net/802/pseudo/Makefile b/net/802/pseudo/Makefile
--- a/net/802/pseudo/Makefile	Thu Jun 20 15:54:00 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,13 +0,0 @@
-all:	pseudocode.h actionnm.h
-
-clean:
-	touch pseudocode.h actionnm.h
-	rm pseudocode.h actionnm.h
-
-pseudocode.h: pseudocode opcd2num.sed compile.awk
-	sed -f opcd2num.sed pseudocode |  awk -f compile.awk >pseudocode.h
-
-actionnm.h: pseudocode.h actionnm.awk
-	awk -f actionnm.awk pseudocode.h>actionnm.h
-
-	
diff -Nru a/net/802/pseudo/actionnm.h b/net/802/pseudo/actionnm.h
--- a/net/802/pseudo/actionnm.h	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,51 +0,0 @@
-
-/* this file generated on Thu Oct 24 11:42:37 GMT 1996  */
-
-static char *action_names[] = { 
-    "NOP"           ,"ADM1"          ,"ADM2"          ,"ADM3"          ,
-    "ADM4"          ,"ADM5"          ,"CONN2"         ,"CONN3"         ,
-    "CONN4"         ,"CONN5"         ,"RESWAIT1"      ,"RESWAIT2"      ,
-    "RESWAIT3"      ,"RESWAIT4"      ,"RESWAIT5"      ,"RESWAIT6"      ,
-    "RESWAIT7"      ,"RESWAIT8"      ,"RESCHK1"       ,"RESCHK2"       ,
-    "RESCHK3"       ,"RESCHK4"       ,"RESCHK5"       ,"RESCHK6"       ,
-    "SETUP1"        ,"SETUP2"        ,"SETUP3"        ,"SETUP4"        ,
-    "SETUP5"        ,"SETUP6"        ,"SETUP7"        ,"SETUP8"        ,
-    "RESET1"        ,"RESET2"        ,"RESET3"        ,"RESET4"        ,
-    "RESET5"        ,"RESET6"        ,"RESET7"        ,"RESET8"        ,
-    "D_CONN1"       ,"D_CONN2"       ,"D_CONN3"       ,"D_CONN4"       ,
-    "D_CONN5"       ,"D_CONN6"       ,"D_CONN7"       ,"ERR1"          ,
-    "ERR2"          ,"ERR3"          ,"ERR4"          ,"ERR5"          ,
-    "ERR6"          ,"ERR7"          ,"ERR8"          ,"SH1"           ,
-    "SH2"           ,"SH3"           ,"SH4"           ,"SH5"           ,
-    "SH6"           ,"SH7"           ,"SH8"           ,"SH9"           ,
-    "SH10"          ,"SH11"          ,"NORMAL1"       ,"NORMAL2"       ,
-    "NORMAL3"       ,"NORMAL4"       ,"NORMAL5"       ,"NORMAL6"       ,
-    "NORMAL7"       ,"NORMAL8A"      ,"NORMAL8B"      ,"NORMAL9"       ,
-    "NORMAL10"      ,"NORMAL11"      ,"NORMAL12"      ,"NORMAL13"      ,
-    "NORMAL14"      ,"NORMAL15"      ,"NORMAL16"      ,"NORMAL17"      ,
-    "NORMAL18"      ,"NORMAL19"      ,"NORMAL20"      ,"BUSY1"         ,
-    "BUSY2"         ,"BUSY3"         ,"BUSY4"         ,"BUSY5"         ,
-    "BUSY6"         ,"BUSY7"         ,"BUSY8"         ,"BUSY9"         ,
-    "BUSY10"        ,"BUSY11"        ,"BUSY12"        ,"BUSY13"        ,
-    "BUSY14"        ,"BUSY15"        ,"BUSY16"        ,"BUSY17"        ,
-    "BUSY18"        ,"BUSY19"        ,"BUSY20"        ,"BUSY21"        ,
-    "BUSY22"        ,"BUSY23"        ,"BUSY24"        ,"BUSY25"        ,
-    "BUSY26"        ,"REJECT1"       ,"REJECT2"       ,"REJECT3"       ,
-    "REJECT4"       ,"REJECT5"       ,"REJECT6"       ,"REJECT7"       ,
-    "REJECT8"       ,"REJECT9"       ,"REJECT10"      ,"REJECT11"      ,
-    "REJECT12"      ,"REJECT13"      ,"REJECT14"      ,"REJECT15"      ,
-    "REJECT16"      ,"REJECT17"      ,"REJECT18"      ,"REJECT19"      ,
-    "REJECT20"      ,"AWAIT1"        ,"AWAIT2"        ,"AWAIT3"        ,
-    "AWAIT4"        ,"AWAIT5"        ,"AWAIT6"        ,"AWAIT7"        ,
-    "AWAIT8"        ,"AWAIT9"        ,"AWAIT10"       ,"AWAIT11"       ,
-    "AWAIT12"       ,"AWAIT13"       ,"AWAIT14"       ,"AWAIT_BUSY1"   ,
-    "AWAIT_BUSY2"   ,"AWAIT_BUSY3"   ,"AWAIT_BUSY4"   ,"AWAIT_BUSY5"   ,
-    "AWAIT_BUSY6"   ,"AWAIT_BUSY7"   ,"AWAIT_BUSY8"   ,"AWAIT_BUSY9"   ,
-    "AWAIT_BUSY10"  ,"AWAIT_BUSY11"  ,"AWAIT_BUSY12"  ,"AWAIT_BUSY13"  ,
-    "AWAIT_BUSY14"  ,"AWAIT_BUSY15"  ,"AWAIT_BUSY16"  ,"AWAIT_REJECT1" ,
-    "AWAIT_REJECT2" ,"AWAIT_REJECT3" ,"AWAIT_REJECT4" ,"AWAIT_REJECT5" ,
-    "AWAIT_REJECT6" ,"AWAIT_REJECT7" ,"AWAIT_REJECT8" ,"AWAIT_REJECT9" ,
-    "AWAIT_REJECT10" ,"AWAIT_REJECT11" ,"AWAIT_REJECT12" ,"AWAIT_REJECT13" ,
-    	  0
-};
-
diff -Nru a/net/802/pseudo/pseudocode.h b/net/802/pseudo/pseudocode.h
--- a/net/802/pseudo/pseudocode.h	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,287 +0,0 @@
-
-/* this file generated on Thu Oct 24 11:42:35 GMT 1996  */
-
-static char pseudo_code [ ] = { 
-	   0,	  37,	  57,	  42,	  59,	  39,	   0,	  65,	  38,
-	  63,	  61,	  59,	  56,	  58,	   2,	   0,	  12,	   0,
-	  12,	   0,	   0,	   0,	  12,	   0,	  65,	   0,	   5,
-	   0,	   0,	   0,	  37,	  57,	  42,	  59,	   0,	  38,
-	  63,	  61,	  59,	  56,	  58,	   7,	   0,	  11,	  57,
-	  42,	  59,	   0,	  12,	   0,	   5,	   0,	  40,	  65,
-	   0,	  12,	   5,	   0,	   0,	   0,	  38,	  63,	  61,
-	  59,	  56,	  58,	   0,	  12,	   0,	   5,	   0,	  65,
-	   0,	  12,	   5,	   0,	   0,	   0,	  38,	  63,	  61,
-	  59,	  40,	   0,	  45,	  63,	  61,	  59,	  51,	   3,
-	  58,	   0,	  56,	   3,	  58,	   0,	  12,	   5,	  45,
-	   0,	   5,	  45,	   0,	   0,	   0,	  37,	  57,	  42,
-	  60,	   0,	   5,	   0,	  38,	  63,	  61,	  59,	  40,
-	   0,	  45,	  63,	  61,	  59,	  51,	   7,	  58,	   0,
-	  56,	   7,	  58,	   0,	  12,	   5,	  45,	   0,	   5,
-	  45,	   0,	   0,	   0,	  37,	  57,	  42,	  60,	   0,
-	   5,	   0,	  12,	  45,	   0,	  45,	   0,	  38,	   0,
-	  45,	   0,	   0,	   0,	  11,	  57,	  42,	  60,	   0,
-	   0,	   0,	  71,	  45,	  65,	   0,	  38,	   5,	  45,
-	   0,	   5,	  45,	   0,	  70,	  45,	  66,	  39,	   0,
-	  15,	  42,	   0,	   0,	   0,	  14,	  42,	  60,	   0,
-	  39,	  70,	   0,	  11,	  57,	  42,	  49,	  59,	   0,
-	  37,	  57,	  42,	  49,	  59,	  39,	   0,	  71,	  65,
-	  48,	   0,	  38,	   5,	  48,	   0,	  48,	  70,	  66,
-	  39,	   0,	   5,	  48,	   0,	  13,	  67,	  42,	  49,
-	  59,	   0,	   0,	  67,	  42,	  49,	  59,	   0,	   0,
-	  67,	  42,	  49,	  59,	   0,	  13,	  67,	  42,	  49,
-	  59,	   0,	  48,	  70,	  39,	   0,	  16,	  41,	  44,
-	   0,	  19,	  44,	   0,	  26,	  41,	  53,	   0,	  28,
-	  53,	   0,	  25,	  50,	  51,	  43,	   9,	   0,	  25,
-	  50,	  43,	   0,	  24,	  50,	  43,	   0,	  62,	  32,
-	  41,	  50,	   9,	   4,	   0,	  62,	  51,	  36,	  50,
-	   9,	   4,	   0,	  62,	  36,	  50,	   4,	   0,	  62,
-	  34,	  50,	   4,	   0,	  51,	  50,	   1,	   0,	  34,
-	  50,	   1,	   0,	  51,	  50,	  29,	   0,	  33,	  50,
-	  29,	   0,	  64,	  50,	  51,	  20,	   1,	   0,	  64,
-	  50,	  20,	   1,	   0,	  64,	  50,	  22,	   1,	   0,
-	  31,	  41,	   0,	  56,	   0,	  31,	  41,	  60,	   0,
-	  16,	  41,	  44,	   0,	  19,	  44,	   0,	  23,	  43,
-	  41,	   0,	  25,	  43,	   0,	  31,	  41,	  35,	   0,
-	  35,	   0,	  31,	  41,	  35,	   0,	  35,	   0,	  30,
-	  51,	  50,	  55,	   9,	   0,	  30,	  50,	  55,	   0,
-	  27,	  50,	  55,	   0,	  27,	  50,	  10,	  54,	   0,
-	  30,	  51,	  50,	  10,	  54,	   9,	   0,	  30,	  50,
-	  10,	  54,	   0,	  51,	  50,	   1,	   0,	  27,	  50,
-	   1,	   0,	  51,	  50,	  29,	   0,	  27,	  50,	  29,
-	   0,	  64,	  50,	  51,	  20,	   1,	   0,	  64,	  50,
-	  20,	   1,	   0,	  64,	  50,	  27,	  20,	   1,	   0,
-	  26,	  41,	   0,	  56,	   0,	  26,	  41,	  60,	   0,
-	  54,	   0,	  54,	   0,	  16,	  41,	  44,	   0,	  19,
-	  44,	   0,	  26,	  41,	  52,	   0,	  28,	  52,	   0,
-	  50,	  51,	   9,	   0,	  33,	  50,	   0,	  62,	  32,
-	  41,	  50,	   9,	  47,	   4,	   0,	  62,	  36,	  50,
-	  47,	   4,	   0,	  62,	  34,	  50,	  47,	   4,	   0,
-	  51,	  50,	   1,	   0,	  34,	  50,	   1,	   0,	  51,
-	  50,	  29,	   0,	  33,	  50,	  29,	   0,	  64,	  50,
-	  51,	  20,	   1,	   0,	  64,	  50,	  20,	   1,	   0,
-	  64,	  50,	  22,	   1,	   0,	  31,	  41,	   0,	  23,
-	  41,	  43,	  60,	   0,	  56,	   0,	  31,	  41,	  43,
-	  60,	   0,	  28,	  53,	   0,	  25,	  50,	  64,	  46,
-	  20,	  43,	   1,	   0,	  25,	  50,	  43,	   0,	  24,
-	  50,	  43,	   0,	  62,	  50,	  64,	  18,	  41,	   1,
-	   4,	   0,	  62,	  35,	  50,	   4,	   0,	  62,	  33,
-	  50,	   4,	   0,	  50,	  64,	  46,	  20,	   1,	   0,
-	  50,	   1,	   0,	  33,	  50,	   1,	   0,	  50,	  64,
-	  46,	  29,	   0,	  50,	  29,	   0,	  33,	  50,	  29,
-	   0,	  31,	  41,	  60,	   0,	  25,	  43,	   0,	  35,
-	   0,	  35,	   0,	  30,	  50,	  64,	  46,	  54,	   1,
-	  20,	   0,	  30,	  50,	  54,	   0,	  27,	  50,	  54,
-	   0,	  30,	  50,	  64,	  54,	  46,	   1,	  20,	   0,
-	  30,	  50,	  54,	   0,	  27,	  50,	  54,	   0,	  50,
-	  64,	  46,	  20,	   1,	   0,	  50,	   1,	   0,	  27,
-	  50,	   1,	   0,	  50,	  64,	  46,	  29,	   0,	  50,
-	  29,	   0,	  27,	  50,	  29,	   0,	  26,	  41,	  60,
-	   0,	  28,	  52,	   0,	  50,	   0,	  33,	  50,	   0,
-	  62,	  50,	  64,	  18,	  41,	  47,	   1,	   4,	   0,
-	  62,	  35,	  47,	  50,	   4,	   0,	  62,	  33,	  47,
-	  50,	   4,	   0,	  50,	  64,	  46,	  20,	   1,	   0,
-	  50,	   1,	   0,	  33,	  50,	   1,	   0,	  50,	  64,
-	  46,	  29,	   0,	  50,	  29,	   0,	  33,	  50,	  29,
-	   0,	  23,	  41,	  60,	  0
-};
-
-static short int pseudo_code_idx [ ] ={
-	   0,	   1,	   7,	  16,	  18,	  20,	  22,	  24,	  26,
-	  28,	  30,	  35,	  43,	  48,	  50,	  52,	  55,	  58,
-	  60,	  67,	  69,	  71,	  73,	  76,	  78,	  84,	  92,
-	  96,	 100,	 103,	 105,	 110,	 112,	 118,	 126,	 130,
-	 134,	 137,	 139,	 144,	 146,	 149,	 151,	 153,	 155,
-	 157,	 162,	 164,	 168,	 172,	 175,	 180,	 183,	 185,
-	 189,	 192,	 198,	 205,	 209,	 213,	 218,	 221,	 227,
-	 233,	 239,	 245,	 249,	 253,	 256,	 260,	 263,	 269,
-	 273,	 277,	 284,	 291,	 296,	 301,	 305,	 309,	 313,
-	 317,	 323,	 328,	 333,	 336,	 338,	 342,	 346,	 349,
-	 353,	 356,	 360,	 362,	 366,	 368,	 374,	 378,	 382,
-	 387,	 394,	 399,	 403,	 407,	 411,	 415,	 421,	 426,
-	 432,	 435,	 437,	 441,	 443,	 445,	 449,	 452,	 456,
-	 459,	 463,	 466,	 474,	 480,	 486,	 490,	 494,	 498,
-	 502,	 508,	 513,	 518,	 521,	 526,	 528,	 533,	 536,
-	 544,	 548,	 552,	 560,	 565,	 570,	 576,	 579,	 583,
-	 588,	 591,	 595,	 599,	 602,	 604,	 606,	 614,	 618,
-	 622,	 630,	 634,	 638,	 644,	 647,	 651,	 656,	 659,
-	 663,	 667,	 670,	 672,	 675,	 684,	 690,	 696,	 702,
-	 705,	 709,	 714,	 717,	 721,	  0
-};
-
-#define NOP        	   0 
-#define ADM1       	   1 
-#define ADM2       	   2 
-#define ADM3       	   3 
-#define ADM4       	   4 
-#define ADM5       	   5 
-#define CONN2      	   6 
-#define CONN3      	   7 
-#define CONN4      	   8 
-#define CONN5      	   9 
-#define RESWAIT1   	  10 
-#define RESWAIT2   	  11 
-#define RESWAIT3   	  12 
-#define RESWAIT4   	  13 
-#define RESWAIT5   	  14 
-#define RESWAIT6   	  15 
-#define RESWAIT7   	  16 
-#define RESWAIT8   	  17 
-#define RESCHK1    	  18 
-#define RESCHK2    	  19 
-#define RESCHK3    	  20 
-#define RESCHK4    	  21 
-#define RESCHK5    	  22 
-#define RESCHK6    	  23 
-#define SETUP1     	  24 
-#define SETUP2     	  25 
-#define SETUP3     	  26 
-#define SETUP4     	  27 
-#define SETUP5     	  28 
-#define SETUP6     	  29 
-#define SETUP7     	  30 
-#define SETUP8     	  31 
-#define RESET1     	  32 
-#define RESET2     	  33 
-#define RESET3     	  34 
-#define RESET4     	  35 
-#define RESET5     	  36 
-#define RESET6     	  37 
-#define RESET7     	  38 
-#define RESET8     	  39 
-#define D_CONN1    	  40 
-#define D_CONN2    	  41 
-#define D_CONN3    	  42 
-#define D_CONN4    	  43 
-#define D_CONN5    	  44 
-#define D_CONN6    	  45 
-#define D_CONN7    	  46 
-#define ERR1       	  47 
-#define ERR2       	  48 
-#define ERR3       	  49 
-#define ERR4       	  50 
-#define ERR5       	  51 
-#define ERR6       	  52 
-#define ERR7       	  53 
-#define ERR8       	  54 
-#define SH1        	  55 
-#define SH2        	  56 
-#define SH3        	  57 
-#define SH4        	  58 
-#define SH5        	  59 
-#define SH6        	  60 
-#define SH7        	  61 
-#define SH8        	  62 
-#define SH9        	  63 
-#define SH10       	  64 
-#define SH11       	  65 
-#define NORMAL1    	  66 
-#define NORMAL2    	  67 
-#define NORMAL3    	  68 
-#define NORMAL4    	  69 
-#define NORMAL5    	  70 
-#define NORMAL6    	  71 
-#define NORMAL7    	  72 
-#define NORMAL8A   	  73 
-#define NORMAL8B   	  74 
-#define NORMAL9    	  75 
-#define NORMAL10   	  76 
-#define NORMAL11   	  77 
-#define NORMAL12   	  78 
-#define NORMAL13   	  79 
-#define NORMAL14   	  80 
-#define NORMAL15   	  81 
-#define NORMAL16   	  82 
-#define NORMAL17   	  83 
-#define NORMAL18   	  84 
-#define NORMAL19   	  85 
-#define NORMAL20   	  86 
-#define BUSY1      	  87 
-#define BUSY2      	  88 
-#define BUSY3      	  89 
-#define BUSY4      	  90 
-#define BUSY5      	  91 
-#define BUSY6      	  92 
-#define BUSY7      	  93 
-#define BUSY8      	  94 
-#define BUSY9      	  95 
-#define BUSY10     	  96 
-#define BUSY11     	  97 
-#define BUSY12     	  98 
-#define BUSY13     	  99 
-#define BUSY14     	 100 
-#define BUSY15     	 101 
-#define BUSY16     	 102 
-#define BUSY17     	 103 
-#define BUSY18     	 104 
-#define BUSY19     	 105 
-#define BUSY20     	 106 
-#define BUSY21     	 107 
-#define BUSY22     	 108 
-#define BUSY23     	 109 
-#define BUSY24     	 110 
-#define BUSY25     	 111 
-#define BUSY26     	 112 
-#define REJECT1    	 113 
-#define REJECT2    	 114 
-#define REJECT3    	 115 
-#define REJECT4    	 116 
-#define REJECT5    	 117 
-#define REJECT6    	 118 
-#define REJECT7    	 119 
-#define REJECT8    	 120 
-#define REJECT9    	 121 
-#define REJECT10   	 122 
-#define REJECT11   	 123 
-#define REJECT12   	 124 
-#define REJECT13   	 125 
-#define REJECT14   	 126 
-#define REJECT15   	 127 
-#define REJECT16   	 128 
-#define REJECT17   	 129 
-#define REJECT18   	 130 
-#define REJECT19   	 131 
-#define REJECT20   	 132 
-#define AWAIT1     	 133 
-#define AWAIT2     	 134 
-#define AWAIT3     	 135 
-#define AWAIT4     	 136 
-#define AWAIT5     	 137 
-#define AWAIT6     	 138 
-#define AWAIT7     	 139 
-#define AWAIT8     	 140 
-#define AWAIT9     	 141 
-#define AWAIT10    	 142 
-#define AWAIT11    	 143 
-#define AWAIT12    	 144 
-#define AWAIT13    	 145 
-#define AWAIT14    	 146 
-#define AWAIT_BUSY1 	 147 
-#define AWAIT_BUSY2 	 148 
-#define AWAIT_BUSY3 	 149 
-#define AWAIT_BUSY4 	 150 
-#define AWAIT_BUSY5 	 151 
-#define AWAIT_BUSY6 	 152 
-#define AWAIT_BUSY7 	 153 
-#define AWAIT_BUSY8 	 154 
-#define AWAIT_BUSY9 	 155 
-#define AWAIT_BUSY10 	 156 
-#define AWAIT_BUSY11 	 157 
-#define AWAIT_BUSY12 	 158 
-#define AWAIT_BUSY13 	 159 
-#define AWAIT_BUSY14 	 160 
-#define AWAIT_BUSY15 	 161 
-#define AWAIT_BUSY16 	 162 
-#define AWAIT_REJECT1 	 163 
-#define AWAIT_REJECT2 	 164 
-#define AWAIT_REJECT3 	 165 
-#define AWAIT_REJECT4 	 166 
-#define AWAIT_REJECT5 	 167 
-#define AWAIT_REJECT6 	 168 
-#define AWAIT_REJECT7 	 169 
-#define AWAIT_REJECT8 	 170 
-#define AWAIT_REJECT9 	 171 
-#define AWAIT_REJECT10 	 172 
-#define AWAIT_REJECT11 	 173 
-#define AWAIT_REJECT12 	 174 
-#define AWAIT_REJECT13 	 175 
-
diff -Nru a/net/802/transit/Makefile b/net/802/transit/Makefile
--- a/net/802/transit/Makefile	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,13 +0,0 @@
-include $(TOPDIR)/Rules.make
-
-all:	pdutr.h timertr.h
-
-pdutr.h: pdutr.pre compile.awk			
-	awk -f ./compile.awk pdutr.pre > pdutr.h
-
-timertr.h: timertr.pre compile.awk
-	awk -f ./compile.awk timertr.pre > timertr.h
-
-clean:
-	touch pdutr.h timertr.h
-	rm pdutr.h timertr.h
diff -Nru a/net/802/transit/pdutr.h b/net/802/transit/pdutr.h
--- a/net/802/transit/pdutr.h	Thu Jun 20 15:54:00 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,309 +0,0 @@
-
-/* this file was generated on Thu Jan  8 00:21:19 GMT 1998  */
-
-/* index name #defines: */
-
-#define ADM            0
-#define CONN           1
-#define RESET_WAIT     2
-#define RESET_CHECK    3
-#define SETUP          4
-#define RESET          5
-#define D_CONN         6
-#define ERROR          7
-#define NORMAL         8
-#define BUSY           9
-#define REJECT        10
-#define AWAIT         11
-#define AWAIT_BUSY    12
-#define AWAIT_REJECT  13
-
-
-/* size of transition table is 1684 bytes */
-
-static short int pdutr_offset [ ] ={
-      0,   54,   82,  110,  138,  192,  246,  300,  328,  554,
-    780, 1006, 1232, 1458 };
-
-static char pdutr_entry [ ] = {
-   ADM5          , ADM           , ADM4          , ADM           , ADM5          , ADM           ,
-   ADM4          , ADM           , ADM5          , ADM           , ADM4          , ADM           ,
-   ADM5          , ADM           , ADM4          , ADM           , ADM3          , ADM           ,
-   ADM3          , ADM           , ADM2          , CONN          , ADM2          , CONN          ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   CONN5         , CONN          , CONN5         , CONN          , CONN5         , CONN          ,
-   CONN5         , CONN          , CONN5         , CONN          , CONN3         , CONN          ,
-   CONN5         , CONN          , CONN5         , CONN          , CONN5         , CONN          ,
-   CONN5         , CONN          , CONN5         , CONN          , CONN4         , ADM           ,
-   CONN5         , CONN          , CONN5         , CONN          , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT8      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT7      , RESET_WAIT    , RESWAIT6      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT8      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT8      , RESET_WAIT    , RESWAIT5      , ADM           , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT8      , RESET_WAIT    , RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   ,
-   RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   , RESCHK5       , ADM           ,
-   RESCHK4       , RESET_CHECK   , RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   ,
-   RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   ,
-   RESCHK3       , ADM           , RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP4        , ADM           ,
-   SETUP4        , ADM           , SETUP1        , SETUP         , SETUP1        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP2        , NORMAL        , SETUP5        , ADM           , SETUP5        , ADM           ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET4        , ADM           ,
-   RESET4        , ADM           , RESET1        , RESET         , RESET1        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET2        , NORMAL        , RESET5        , ADM           , RESET5        , ADM           ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN3       , D_CONN        ,
-   D_CONN3       , D_CONN        , D_CONN1       , ADM           , D_CONN1       , ADM           ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN4       , ADM           , D_CONN4       , ADM           , D_CONN5       , ADM           ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   ERR5          , ERROR         , ERR5          , ERROR         , ERR5          , ERROR         ,
-   ERR5          , ERROR         , ERR2          , ADM           , ERR1          , RESET_CHECK   ,
-   ERR6          , ERROR         , ERR6          , ERROR         , ERR6          , ERROR         ,
-   ERR6          , ERROR         , ERR6          , ERROR         , ERR3          , ADM           ,
-   ERR4          , RESET_WAIT    , ERR4          , RESET_WAIT    , NORMAL8B      , NORMAL        ,
-   NORMAL9       , NORMAL        , NORMAL10      , NORMAL        , NORMAL10      , NORMAL        ,
-   NORMAL5       , REJECT        , NORMAL6       , REJECT        , NORMAL7       , REJECT        ,
-   NORMAL7       , REJECT        , NORMAL11      , NORMAL        , NORMAL11      , NORMAL        ,
-   NORMAL12      , NORMAL        , NORMAL12      , NORMAL        , NORMAL11      , NORMAL        ,
-   NORMAL11      , NORMAL        , NORMAL12      , NORMAL        , NORMAL12      , NORMAL        ,
-   NORMAL13      , NORMAL        , NORMAL13      , NORMAL        , NORMAL14      , NORMAL        ,
-   NORMAL14      , NORMAL        , NORMAL13      , NORMAL        , NORMAL13      , NORMAL        ,
-   NORMAL14      , NORMAL        , NORMAL14      , NORMAL        , NORMAL15      , NORMAL        ,
-   NORMAL16      , NORMAL        , NORMAL17      , NORMAL        , NORMAL17      , NORMAL        ,
-   NORMAL15      , NORMAL        , NORMAL16      , NORMAL        , NORMAL17      , NORMAL        ,
-   NORMAL17      , NORMAL        , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , NORMAL8B      , NORMAL        ,
-   NORMAL9       , NORMAL        , SH10          , ERROR         , NORMAL8A      , NORMAL        ,
-   NORMAL5       , REJECT        , NORMAL6       , REJECT        , SH10          , ERROR         ,
-   NORMAL5       , REJECT        , NORMAL11      , NORMAL        , NORMAL11      , NORMAL        ,
-   SH10          , ERROR         , NORMAL11      , NORMAL        , NORMAL11      , NORMAL        ,
-   NORMAL11      , NORMAL        , SH10          , ERROR         , NORMAL11      , NORMAL        ,
-   NORMAL13      , NORMAL        , NORMAL13      , NORMAL        , SH10          , ERROR         ,
-   NORMAL13      , NORMAL        , NORMAL13      , NORMAL        , NORMAL13      , NORMAL        ,
-   SH10          , ERROR         , NORMAL13      , NORMAL        , NORMAL15      , NORMAL        ,
-   NORMAL16      , NORMAL        , SH10          , ERROR         , NORMAL15      , NORMAL        ,
-   NORMAL15      , NORMAL        , NORMAL16      , NORMAL        , SH10          , ERROR         ,
-   NORMAL15      , NORMAL        , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , BUSY13        , BUSY          , BUSY14        , BUSY          ,
-   BUSY12        , BUSY          , BUSY12        , BUSY          , BUSY9         , BUSY          ,
-   BUSY10        , BUSY          , BUSY11        , BUSY          , BUSY11        , BUSY          ,
-   BUSY15        , BUSY          , BUSY15        , BUSY          , BUSY16        , BUSY          ,
-   BUSY16        , BUSY          , BUSY15        , BUSY          , BUSY15        , BUSY          ,
-   BUSY16        , BUSY          , BUSY16        , BUSY          , BUSY17        , BUSY          ,
-   BUSY17        , BUSY          , BUSY18        , BUSY          , BUSY18        , BUSY          ,
-   BUSY17        , BUSY          , BUSY17        , BUSY          , BUSY18        , BUSY          ,
-   BUSY18        , BUSY          , BUSY19        , BUSY          , BUSY20        , BUSY          ,
-   BUSY21        , BUSY          , BUSY21        , BUSY          , BUSY19        , BUSY          ,
-   BUSY20        , BUSY          , BUSY21        , BUSY          , BUSY21        , BUSY          ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , BUSY13        , BUSY          , BUSY14        , BUSY          ,
-   SH10          , ERROR         , BUSY13        , BUSY          , BUSY9         , BUSY          ,
-   BUSY10        , BUSY          , SH10          , ERROR         , BUSY9         , BUSY          ,
-   BUSY15        , BUSY          , BUSY15        , BUSY          , SH10          , ERROR         ,
-   BUSY15        , BUSY          , BUSY15        , BUSY          , BUSY15        , BUSY          ,
-   SH10          , ERROR         , BUSY15        , BUSY          , BUSY17        , BUSY          ,
-   BUSY17        , BUSY          , SH10          , ERROR         , BUSY17        , BUSY          ,
-   BUSY17        , BUSY          , BUSY17        , BUSY          , SH10          , ERROR         ,
-   BUSY17        , BUSY          , BUSY19        , BUSY          , BUSY20        , BUSY          ,
-   SH10          , ERROR         , BUSY19        , BUSY          , BUSY19        , BUSY          ,
-   BUSY20        , BUSY          , SH10          , ERROR         , BUSY19        , BUSY          ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   REJECT7       , REJECT        , REJECT8       , REJECT        , REJECT9       , REJECT        ,
-   REJECT9       , REJECT        , REJECT5       , REJECT        , REJECT5       , REJECT        ,
-   REJECT6       , REJECT        , REJECT6       , REJECT        , REJECT10      , REJECT        ,
-   REJECT10      , REJECT        , REJECT11      , REJECT        , REJECT11      , REJECT        ,
-   REJECT10      , REJECT        , REJECT10      , REJECT        , REJECT11      , REJECT        ,
-   REJECT11      , REJECT        , REJECT12      , REJECT        , REJECT12      , REJECT        ,
-   REJECT13      , REJECT        , REJECT13      , REJECT        , REJECT12      , REJECT        ,
-   REJECT12      , REJECT        , REJECT13      , REJECT        , REJECT13      , REJECT        ,
-   REJECT14      , REJECT        , REJECT15      , REJECT        , REJECT16      , REJECT        ,
-   REJECT16      , REJECT        , REJECT14      , REJECT        , REJECT15      , REJECT        ,
-   REJECT16      , REJECT        , REJECT16      , REJECT        , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   REJECT7       , REJECT        , REJECT8       , REJECT        , SH10          , ERROR         ,
-   REJECT7       , REJECT        , REJECT5       , REJECT        , REJECT5       , REJECT        ,
-   SH10          , ERROR         , REJECT5       , REJECT        , REJECT10      , REJECT        ,
-   REJECT10      , REJECT        , SH10          , ERROR         , REJECT10      , REJECT        ,
-   REJECT10      , REJECT        , REJECT10      , REJECT        , SH10          , ERROR         ,
-   REJECT10      , REJECT        , REJECT12      , REJECT        , REJECT12      , REJECT        ,
-   SH10          , ERROR         , REJECT12      , REJECT        , REJECT12      , REJECT        ,
-   REJECT12      , REJECT        , SH10          , ERROR         , REJECT12      , REJECT        ,
-   REJECT14      , REJECT        , REJECT15      , REJECT        , SH10          , ERROR         ,
-   REJECT14      , REJECT        , REJECT14      , REJECT        , REJECT15      , REJECT        ,
-   SH10          , ERROR         , REJECT14      , REJECT        , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , AWAIT6        , AWAIT         ,
-   AWAIT6        , AWAIT         , AWAIT7        , AWAIT         , AWAIT7        , AWAIT         ,
-   AWAIT3        , AWAIT_REJECT  , AWAIT3        , AWAIT_REJECT  , AWAIT4        , AWAIT_REJECT  ,
-   AWAIT4        , AWAIT_REJECT  , AWAIT9        , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT10       , AWAIT         , AWAIT10       , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT9        , AWAIT         , AWAIT10       , AWAIT         , AWAIT10       , AWAIT         ,
-   AWAIT12       , AWAIT         , AWAIT12       , AWAIT         , AWAIT13       , AWAIT         ,
-   AWAIT13       , AWAIT         , AWAIT12       , AWAIT         , AWAIT12       , AWAIT         ,
-   AWAIT13       , AWAIT         , AWAIT13       , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT9        , AWAIT         , AWAIT10       , AWAIT         , AWAIT10       , AWAIT         ,
-   AWAIT9        , AWAIT         , AWAIT9        , AWAIT         , AWAIT10       , AWAIT         ,
-   AWAIT10       , AWAIT         , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , AWAIT6        , AWAIT         ,
-   AWAIT6        , AWAIT         , SH10          , ERROR         , AWAIT5        , NORMAL        ,
-   AWAIT3        , AWAIT_REJECT  , AWAIT3        , AWAIT_REJECT  , SH10          , ERROR         ,
-   AWAIT2        , REJECT        , AWAIT9        , AWAIT         , AWAIT9        , AWAIT         ,
-   SH10          , ERROR         , AWAIT8        , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT9        , AWAIT         , SH10          , ERROR         , AWAIT8        , AWAIT         ,
-   AWAIT12       , AWAIT         , AWAIT12       , AWAIT         , SH10          , ERROR         ,
-   AWAIT11       , AWAIT         , AWAIT12       , AWAIT         , AWAIT12       , AWAIT         ,
-   SH10          , ERROR         , AWAIT11       , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT9        , AWAIT         , SH10          , ERROR         , AWAIT8        , AWAIT         ,
-   AWAIT9        , AWAIT         , AWAIT9        , AWAIT         , SH10          , ERROR         ,
-   AWAIT8        , AWAIT         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , AWAIT_BUSY8   , AWAIT_BUSY    , AWAIT_BUSY8   , AWAIT_BUSY    ,
-   AWAIT_BUSY9   , AWAIT_BUSY    , AWAIT_BUSY9   , AWAIT_BUSY    , AWAIT_BUSY5   , AWAIT_BUSY    ,
-   AWAIT_BUSY5   , AWAIT_BUSY    , AWAIT_BUSY6   , AWAIT_BUSY    , AWAIT_BUSY6   , AWAIT_BUSY    ,
-   AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    ,
-   AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY14  , AWAIT_BUSY    ,
-   AWAIT_BUSY14  , AWAIT_BUSY    , AWAIT_BUSY15  , AWAIT_BUSY    , AWAIT_BUSY15  , AWAIT_BUSY    ,
-   AWAIT_BUSY14  , AWAIT_BUSY    , AWAIT_BUSY14  , AWAIT_BUSY    , AWAIT_BUSY15  , AWAIT_BUSY    ,
-   AWAIT_BUSY15  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , AWAIT_BUSY8   , AWAIT_BUSY    , AWAIT_BUSY8   , AWAIT_BUSY    ,
-   SH10          , ERROR         , AWAIT_BUSY7   , BUSY          , AWAIT_BUSY5   , AWAIT_BUSY    ,
-   AWAIT_BUSY5   , AWAIT_BUSY    , SH10          , ERROR         , AWAIT_BUSY4   , BUSY          ,
-   AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    , SH10          , ERROR         ,
-   AWAIT_BUSY10  , BUSY          , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   SH10          , ERROR         , AWAIT_BUSY10  , BUSY          , AWAIT_BUSY14  , AWAIT_BUSY    ,
-   AWAIT_BUSY14  , AWAIT_BUSY    , SH10          , ERROR         , AWAIT_BUSY13  , BUSY          ,
-   AWAIT_BUSY14  , AWAIT_BUSY    , AWAIT_BUSY14  , AWAIT_BUSY    , SH10          , ERROR         ,
-   AWAIT_BUSY13  , BUSY          , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   SH10          , ERROR         , AWAIT_BUSY10  , BUSY          , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   AWAIT_BUSY11  , AWAIT_BUSY    , SH10          , ERROR         , AWAIT_BUSY10  , BUSY          ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   AWAIT_REJECT5 , AWAIT         , AWAIT_REJECT5 , AWAIT         , AWAIT_REJECT6 , AWAIT         ,
-   AWAIT_REJECT6 , AWAIT         , AWAIT_REJECT2 , AWAIT_REJECT  , AWAIT_REJECT2 , AWAIT_REJECT  ,
-   AWAIT_REJECT3 , AWAIT_REJECT  , AWAIT_REJECT3 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  ,
-   AWAIT_REJECT9 , AWAIT_REJECT  , AWAIT_REJECT11, AWAIT_REJECT  , AWAIT_REJECT11, AWAIT_REJECT  ,
-   AWAIT_REJECT12, AWAIT_REJECT  , AWAIT_REJECT12, AWAIT_REJECT  , AWAIT_REJECT11, AWAIT_REJECT  ,
-   AWAIT_REJECT11, AWAIT_REJECT  , AWAIT_REJECT12, AWAIT_REJECT  , AWAIT_REJECT12, AWAIT_REJECT  ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  ,
-   AWAIT_REJECT9 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  ,
-   AWAIT_REJECT9 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   AWAIT_REJECT5 , AWAIT         , AWAIT_REJECT5 , AWAIT         , SH10          , ERROR         ,
-   AWAIT_REJECT4 , NORMAL        , AWAIT_REJECT2 , AWAIT_REJECT  , AWAIT_REJECT2 , AWAIT_REJECT  ,
-   SH10          , ERROR         , AWAIT_REJECT4 , NORMAL        , AWAIT_REJECT8 , AWAIT_REJECT  ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , SH10          , ERROR         , AWAIT_REJECT7 , REJECT        ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , SH10          , ERROR         ,
-   AWAIT_REJECT7 , REJECT        , AWAIT_REJECT11, AWAIT_REJECT  , AWAIT_REJECT11, AWAIT_REJECT  ,
-   SH10          , ERROR         , AWAIT_REJECT10, REJECT        , AWAIT_REJECT11, AWAIT_REJECT  ,
-   AWAIT_REJECT11, AWAIT_REJECT  , SH10          , ERROR         , AWAIT_REJECT10, REJECT        ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , SH10          , ERROR         ,
-   AWAIT_REJECT7 , REJECT        , AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  ,
-   SH10          , ERROR         , AWAIT_REJECT7 , REJECT        , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR          };
diff -Nru a/net/802/transit/timertr.h b/net/802/transit/timertr.h
--- a/net/802/transit/timertr.h	Thu Jun 20 15:54:01 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,157 +0,0 @@
-
-/* this file was generated on Thu Jan  8 00:21:21 GMT 1998  */
-
-
-/* size of transition table is 898 bytes */
-
-static char timertr_entry [ ] = {
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , SETUP7        , SETUP         ,
-   SETUP7        , SETUP         , SETUP3        , NORMAL        , SETUP3        , NORMAL        ,
-   SETUP8        , ADM           , SETUP8        , ADM           , SETUP3        , NORMAL        ,
-   SETUP3        , NORMAL        , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , RESET7        , RESET         , RESET7        , RESET         ,
-   RESET3        , NORMAL        , RESET3        , NORMAL        , RESET8        , ADM           ,
-   RESET8        , ADM           , RESET3        , NORMAL        , RESET3        , NORMAL        ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   D_CONN6       , D_CONN        , D_CONN6       , D_CONN        , D_CONN6       , D_CONN        ,
-   D_CONN6       , D_CONN        , D_CONN7       , ADM           , D_CONN7       , ADM           ,
-   D_CONN7       , ADM           , D_CONN7       , ADM           , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , ERR7          , ERROR         ,
-   ERR7          , ERROR         , ERR7          , ERROR         , ERR7          , ERROR         ,
-   ERR8          , RESET_WAIT    , ERR8          , RESET_WAIT    , ERR8          , RESET_WAIT    ,
-   ERR8          , RESET_WAIT    , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NORMAL20      , AWAIT         , NOP           , NORMAL        ,
-   NORMAL20      , AWAIT         , NOP           , NORMAL        , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NORMAL19      , NORMAL        , NORMAL19      , NORMAL        , NORMAL19      , NORMAL        ,
-   NORMAL19      , NORMAL        , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , NORMAL        ,
-   NOP           , NORMAL        , NOP           , NORMAL        , NOP           , NORMAL        ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NORMAL20      , AWAIT         , NOP           , NORMAL        ,
-   NORMAL20      , AWAIT         , NOP           , NORMAL        , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   BUSY24        , AWAIT_BUSY    , NOP           , BUSY          , BUSY24        , AWAIT_BUSY    ,
-   NOP           , BUSY          , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , BUSY23        , BUSY          ,
-   BUSY23        , BUSY          , BUSY23        , BUSY          , BUSY23        , BUSY          ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , BUSY25        , BUSY          , BUSY26        , BUSY          ,
-   BUSY25        , BUSY          , BUSY26        , BUSY          , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , BUSY          , NOP           , BUSY          , NOP           , BUSY          ,
-   NOP           , BUSY          , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , REJECT        ,
-   NOP           , REJECT        , NOP           , REJECT        , NOP           , REJECT        ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , REJECT        , NOP           , REJECT        ,
-   NOP           , REJECT        , NOP           , REJECT        , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , REJECT        , NOP           , REJECT        , NOP           , REJECT        ,
-   NOP           , REJECT        , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , REJECT        ,
-   NOP           , REJECT        , NOP           , REJECT        , NOP           , REJECT        ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , AWAIT         , NOP           , AWAIT         ,
-   NOP           , AWAIT         , NOP           , AWAIT         , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , AWAIT         , NOP           , AWAIT         , NOP           , AWAIT         ,
-   NOP           , AWAIT         , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , AWAIT         ,
-   NOP           , AWAIT         , NOP           , AWAIT         , NOP           , AWAIT         ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , AWAIT         , NOP           , AWAIT         ,
-   NOP           , AWAIT         , NOP           , AWAIT         , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    ,
-   NOP           , AWAIT_BUSY    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , AWAIT_BUSY    ,
-   NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    ,
-   NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    ,
-   NOP           , AWAIT_BUSY    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , AWAIT_REJECT  ,
-   NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  ,
-   NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  ,
-   NOP           , AWAIT_REJECT  , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , AWAIT_REJECT  ,
-   NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT     };
diff -Nru a/net/Config.in b/net/Config.in
--- a/net/Config.in	Thu Jun 20 15:54:00 2002
+++ b/net/Config.in	Thu Jun 20 15:54:00 2002
@@ -34,14 +34,14 @@
    bool 'Asynchronous Transfer Mode (ATM) (EXPERIMENTAL)' CONFIG_ATM
    if [ "$CONFIG_ATM" = "y" ]; then
       if [ "$CONFIG_INET" = "y" ]; then
-	 bool '  Classical IP over ATM' CONFIG_ATM_CLIP
+	 bool '  Classical IP over ATM (EXPERIMENTAL)' CONFIG_ATM_CLIP
 	 if [ "$CONFIG_ATM_CLIP" = "y" ]; then
-	    bool '    Do NOT send ICMP if no neighbour' CONFIG_ATM_CLIP_NO_ICMP
+	    bool '    Do NOT send ICMP if no neighbour (EXPERIMENTAL)' CONFIG_ATM_CLIP_NO_ICMP
 	 fi
       fi
-      tristate '  LAN Emulation (LANE) support' CONFIG_ATM_LANE
+      tristate '  LAN Emulation (LANE) support (EXPERIMENTAL)' CONFIG_ATM_LANE
       if [ "$CONFIG_INET" = "y" -a "$CONFIG_ATM_LANE" != "n" ]; then
-	 tristate '    Multi-Protocol Over ATM (MPOA) support' CONFIG_ATM_MPOA
+	 tristate '    Multi-Protocol Over ATM (MPOA) support (EXPERIMENTAL)' CONFIG_ATM_MPOA
       fi
    fi
 fi
diff -Nru a/net/Makefile b/net/Makefile
--- a/net/Makefile	Thu Jun 20 15:54:01 2002
+++ b/net/Makefile	Thu Jun 20 15:54:01 2002
@@ -14,16 +14,8 @@
 
 obj-$(CONFIG_NET)		+= ethernet/ 802/ sched/ netlink/
 obj-$(CONFIG_INET)		+= ipv4/
-obj-$(CONFIG_NETFILTER)		+= ipv4/netfilter/
 obj-$(CONFIG_UNIX)		+= unix/
 obj-$(CONFIG_IPV6)		+= ipv6/
-
-ifneq ($(CONFIG_IPV6),n)
-ifneq ($(CONFIG_IPV6),)
-obj-$(CONFIG_NETFILTER)		+= ipv6/netfilter/
-endif
-endif
-
 obj-$(CONFIG_KHTTPD)		+= khttpd/
 obj-$(CONFIG_PACKET)		+= packet/
 obj-$(CONFIG_NET_SCHED)		+= sched/
diff -Nru a/net/core/dev.c b/net/core/dev.c
--- a/net/core/dev.c	Thu Jun 20 15:54:01 2002
+++ b/net/core/dev.c	Thu Jun 20 15:54:01 2002
@@ -2427,7 +2427,7 @@
  *	will not get the same name.
  */
 
-int net_dev_init(void);
+static int net_dev_init(void);
 
 int register_netdevice(struct net_device *dev)
 {
@@ -2693,7 +2693,7 @@
  *       Callers must hold the rtnl semaphore.  See the comment at the
  *       end of Space.c for details about the locking.
  */
-int __init net_dev_init(void)
+static int __init net_dev_init(void)
 {
 	struct net_device *dev, **dp;
 	int i;
@@ -2833,6 +2833,8 @@
 
 	return 0;
 }
+
+__initcall(net_dev_init);
 
 #ifdef CONFIG_HOTPLUG
 
diff -Nru a/net/ipv4/Makefile b/net/ipv4/Makefile
--- a/net/ipv4/Makefile	Thu Jun 20 15:54:00 2002
+++ b/net/ipv4/Makefile	Thu Jun 20 15:54:00 2002
@@ -18,5 +18,6 @@
 obj-$(CONFIG_NET_IPGRE) += ip_gre.o
 obj-$(CONFIG_SYN_COOKIES) += syncookies.o
 obj-$(CONFIG_IP_PNP) += ipconfig.o
+obj-$(CONFIG_NETFILTER)	+= netfilter/
 
 include $(TOPDIR)/Rules.make
diff -Nru a/net/ipv6/Makefile b/net/ipv6/Makefile
--- a/net/ipv6/Makefile	Thu Jun 20 15:54:01 2002
+++ b/net/ipv6/Makefile	Thu Jun 20 15:54:01 2002
@@ -13,5 +13,6 @@
 		ip6_flowlabel.o ipv6_syms.o
 
 #obj-$(CONFIG_IPV6_FIREWALL) += ip6_fw.o
+obj-$(CONFIG_NETFILTER)	+= netfilter/
 
 include $(TOPDIR)/Rules.make
diff -Nru a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
--- a/net/ipv6/addrconf.c	Thu Jun 20 15:54:01 2002
+++ b/net/ipv6/addrconf.c	Thu Jun 20 15:54:01 2002
@@ -90,7 +90,7 @@
 /* Protects inet6 devices */
 rwlock_t addrconf_lock = RW_LOCK_UNLOCKED;
 
-void addrconf_verify(unsigned long);
+static void addrconf_verify(unsigned long);
 
 static struct timer_list addr_chk_timer = { function: addrconf_verify };
 
@@ -588,7 +588,7 @@
 	return err;
 }
 
-int ipv6_count_addresses(struct inet6_dev *idev)
+static int ipv6_count_addresses(struct inet6_dev *idev)
 {
 	int cnt = 0;
 	struct inet6_ifaddr *ifp;
@@ -1613,7 +1613,7 @@
  *	Periodic address status verification
  */
 
-void addrconf_verify(unsigned long foo)
+static void addrconf_verify(unsigned long foo)
 {
 	struct inet6_ifaddr *ifp;
 	unsigned long now = jiffies;
diff -Nru a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
--- a/net/ipv6/af_inet6.c	Thu Jun 20 15:54:01 2002
+++ b/net/ipv6/af_inet6.c	Thu Jun 20 15:54:01 2002
@@ -547,7 +547,7 @@
 	sendpage:	sock_no_sendpage,
 };
 
-struct net_proto_family inet6_family_ops = {
+static struct net_proto_family inet6_family_ops = {
 	family:	PF_INET6,
 	create:	inet6_create,
 };
diff -Nru a/net/ipv6/exthdrs.c b/net/ipv6/exthdrs.c
--- a/net/ipv6/exthdrs.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/exthdrs.c	Thu Jun 20 15:54:00 2002
@@ -77,7 +77,7 @@
 
 /* An unknown option is detected, decide what to do */
 
-int ip6_tlvopt_unknown(struct sk_buff *skb, int optoff)
+static int ip6_tlvopt_unknown(struct sk_buff *skb, int optoff)
 {
 	switch ((skb->nh.raw[optoff] & 0xC0) >> 6) {
 	case 0: /* ignore */
@@ -159,7 +159,7 @@
   Destination options header.
  *****************************/
 
-struct tlvtype_proc tlvprocdestopt_lst[] = {
+static struct tlvtype_proc tlvprocdestopt_lst[] = {
 	/* No destination options are defined now */
 	{-1,			NULL}
 };
@@ -425,7 +425,7 @@
    generate error.
  */
 
-struct hdrtype_proc hdrproc_lst[] = {
+static struct hdrtype_proc hdrproc_lst[] = {
 	{NEXTHDR_FRAGMENT,	ipv6_reassembly},
 	{NEXTHDR_ROUTING,	ipv6_routing_header},
 	{NEXTHDR_DEST,		ipv6_dest_opt},
@@ -512,7 +512,7 @@
 	return 0;
 }
 
-struct tlvtype_proc tlvprochopopt_lst[] = {
+static struct tlvtype_proc tlvprochopopt_lst[] = {
 	{IPV6_TLV_ROUTERALERT,	ipv6_hop_ra},
 	{IPV6_TLV_JUMBO,	ipv6_hop_jumbo},
 	{-1,			NULL}
@@ -536,7 +536,7 @@
  *	for headers.
  */
 
-u8 *ipv6_build_rthdr(struct sk_buff *skb, u8 *prev_hdr,
+static u8 *ipv6_build_rthdr(struct sk_buff *skb, u8 *prev_hdr,
 		     struct ipv6_rt_hdr *opt, struct in6_addr *addr)
 {
 	struct rt0_hdr *phdr, *ihdr;
diff -Nru a/net/ipv6/icmp.c b/net/ipv6/icmp.c
--- a/net/ipv6/icmp.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/icmp.c	Thu Jun 20 15:54:00 2002
@@ -68,7 +68,7 @@
 
 struct socket *icmpv6_socket;
 
-int icmpv6_rcv(struct sk_buff *skb);
+static int icmpv6_rcv(struct sk_buff *skb);
 
 static struct inet6_protocol icmpv6_protocol = 
 {
@@ -204,7 +204,7 @@
 	return 0;
 }
 
-int sysctl_icmpv6_time = 1*HZ; 
+static int sysctl_icmpv6_time = 1*HZ; 
 
 /* 
  * Check the ICMP output rate limit 
@@ -491,7 +491,7 @@
  *	Handle icmp messages
  */
 
-int icmpv6_rcv(struct sk_buff *skb)
+static int icmpv6_rcv(struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
 	struct in6_addr *saddr, *daddr;
diff -Nru a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
--- a/net/ipv6/ipv6_sockglue.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/ipv6_sockglue.c	Thu Jun 20 15:54:00 2002
@@ -53,7 +53,7 @@
 
 struct ipv6_mib ipv6_statistics[NR_CPUS*2];
 
-struct packet_type ipv6_packet_type =
+static struct packet_type ipv6_packet_type =
 {
 	__constant_htons(ETH_P_IPV6), 
 	NULL,					/* All devices */
diff -Nru a/net/ipv6/mcast.c b/net/ipv6/mcast.c
--- a/net/ipv6/mcast.c	Thu Jun 20 15:54:01 2002
+++ b/net/ipv6/mcast.c	Thu Jun 20 15:54:01 2002
@@ -65,7 +65,7 @@
 
 static void igmp6_join_group(struct ifmcaddr6 *ma);
 static void igmp6_leave_group(struct ifmcaddr6 *ma);
-void igmp6_timer_handler(unsigned long data);
+static void igmp6_timer_handler(unsigned long data);
 
 #define IGMP6_UNSOLICITED_IVAL	(10*HZ)
 
@@ -492,7 +492,7 @@
 	return 0;
 }
 
-void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
+static void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
 {
 	struct sock *sk = igmp6_socket->sk;
         struct sk_buff *skb;
@@ -608,7 +608,7 @@
 	spin_unlock_bh(&ma->mca_lock);
 }
 
-void igmp6_timer_handler(unsigned long data)
+static void igmp6_timer_handler(unsigned long data)
 {
 	struct ifmcaddr6 *ma = (struct ifmcaddr6 *) data;
 
diff -Nru a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
--- a/net/ipv6/ndisc.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/ndisc.c	Thu Jun 20 15:54:00 2002
@@ -312,7 +312,7 @@
  *	Send a Neighbour Advertisement
  */
 
-void ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
+static void ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
 		   struct in6_addr *daddr, struct in6_addr *solicited_addr,
 		   int router, int solicited, int override, int inc_opt) 
 {
diff -Nru a/net/ipv6/proc.c b/net/ipv6/proc.c
--- a/net/ipv6/proc.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/proc.c	Thu Jun 20 15:54:00 2002
@@ -56,7 +56,7 @@
 }
 
 
-struct snmp6_item
+static struct snmp6_item
 {
 	char *name;
 	unsigned long *ptr;
diff -Nru a/net/ipv6/raw.c b/net/ipv6/raw.c
--- a/net/ipv6/raw.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/raw.c	Thu Jun 20 15:54:00 2002
@@ -354,7 +354,7 @@
  *	we return it, otherwise we block.
  */
 
-int rawv6_recvmsg(struct sock *sk, struct msghdr *msg, int len,
+static int rawv6_recvmsg(struct sock *sk, struct msghdr *msg, int len,
 		  int noblock, int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
diff -Nru a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c
--- a/net/ipv6/reassembly.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/reassembly.c	Thu Jun 20 15:54:00 2002
@@ -46,10 +46,10 @@
 #include <net/ndisc.h>
 #include <net/addrconf.h>
 
-int sysctl_ip6frag_high_thresh = 256*1024;
-int sysctl_ip6frag_low_thresh = 192*1024;
+static int sysctl_ip6frag_high_thresh = 256*1024;
+static int sysctl_ip6frag_low_thresh = 192*1024;
 
-int sysctl_ip6frag_time = IPV6_FRAG_TIMEOUT;
+static int sysctl_ip6frag_time = IPV6_FRAG_TIMEOUT;
 
 struct ip6frag_skb_cb
 {
diff -Nru a/net/ipv6/route.c b/net/ipv6/route.c
--- a/net/ipv6/route.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/route.c	Thu Jun 20 15:54:00 2002
@@ -59,13 +59,13 @@
 #endif
 
 
-int ip6_rt_max_size = 4096;
-int ip6_rt_gc_min_interval = 5*HZ;
-int ip6_rt_gc_timeout = 60*HZ;
+static int ip6_rt_max_size = 4096;
+static int ip6_rt_gc_min_interval = 5*HZ;
+static int ip6_rt_gc_timeout = 60*HZ;
 int ip6_rt_gc_interval = 30*HZ;
-int ip6_rt_gc_elasticity = 9;
-int ip6_rt_mtu_expires = 10*60*HZ;
-int ip6_rt_min_advmss = IPV6_MIN_MTU - 20 - 40;
+static int ip6_rt_gc_elasticity = 9;
+static int ip6_rt_mtu_expires = 10*60*HZ;
+static int ip6_rt_min_advmss = IPV6_MIN_MTU - 20 - 40;
 
 static struct rt6_info * ip6_rt_copy(struct rt6_info *ort);
 static struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
@@ -77,7 +77,7 @@
 static int		ip6_pkt_discard(struct sk_buff *skb);
 static void		ip6_link_failure(struct sk_buff *skb);
 
-struct dst_ops ip6_dst_ops = {
+static struct dst_ops ip6_dst_ops = {
 	AF_INET6,
 	__constant_htons(ETH_P_IPV6),
 	1024,
@@ -820,7 +820,7 @@
 	return err;
 }
 
-int ip6_route_del(struct in6_rtmsg *rtmsg)
+static int ip6_route_del(struct in6_rtmsg *rtmsg)
 {
 	struct fib6_node *fn;
 	struct rt6_info *rt;
diff -Nru a/net/ipv6/sit.c b/net/ipv6/sit.c
--- a/net/ipv6/sit.c	Thu Jun 20 15:54:01 2002
+++ b/net/ipv6/sit.c	Thu Jun 20 15:54:01 2002
@@ -146,7 +146,7 @@
 	*tp = t;
 }
 
-struct ip_tunnel * ipip6_tunnel_locate(struct ip_tunnel_parm *parms, int create)
+static struct ip_tunnel * ipip6_tunnel_locate(struct ip_tunnel_parm *parms, int create)
 {
 	u32 remote = parms->iph.daddr;
 	u32 local = parms->iph.saddr;
@@ -231,7 +231,7 @@
 }
 
 
-void ipip6_err(struct sk_buff *skb, u32 info)
+static void ipip6_err(struct sk_buff *skb, u32 info)
 {
 #ifndef I_WISH_WORLD_WERE_PERFECT
 
@@ -381,7 +381,7 @@
 		IP6_ECN_set_ce(skb->nh.ipv6h);
 }
 
-int ipip6_rcv(struct sk_buff *skb)
+static int ipip6_rcv(struct sk_buff *skb)
 {
 	struct iphdr *iph;
 	struct ip_tunnel *tunnel;
diff -Nru a/net/ipv6/sysctl_net_ipv6.c b/net/ipv6/sysctl_net_ipv6.c
--- a/net/ipv6/sysctl_net_ipv6.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/sysctl_net_ipv6.c	Thu Jun 20 15:54:00 2002
@@ -22,17 +22,14 @@
 
 #ifdef MODULE
 static struct ctl_table_header *ipv6_sysctl_header;
-static struct ctl_table ipv6_root_table[];
-static struct ctl_table ipv6_net_table[];
 
-
-ctl_table ipv6_root_table[] = {
-	{CTL_NET, "net", NULL, 0, 0555, ipv6_net_table},
+static ctl_table ipv6_net_table[] = {
+	{NET_IPV6, "ipv6", NULL, 0, 0555, ipv6_table},
         {0}
 };
 
-ctl_table ipv6_net_table[] = {
-	{NET_IPV6, "ipv6", NULL, 0, 0555, ipv6_table},
+static ctl_table ipv6_root_table[] = {
+	{CTL_NET, "net", NULL, 0, 0555, ipv6_net_table},
         {0}
 };
 
diff -Nru a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
--- a/net/ipv6/tcp_ipv6.c	Thu Jun 20 15:54:01 2002
+++ b/net/ipv6/tcp_ipv6.c	Thu Jun 20 15:54:01 2002
@@ -712,7 +712,7 @@
 	return err;
 }
 
-void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
+static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		int type, int code, int offset, __u32 info)
 {
 	struct ipv6hdr *hdr = (struct ipv6hdr*)skb->data;
@@ -1576,7 +1576,7 @@
 	return 0;
 }
 
-int tcp_v6_rcv(struct sk_buff *skb)
+static int tcp_v6_rcv(struct sk_buff *skb)
 {
 	struct tcphdr *th;	
 	struct sock *sk;
diff -Nru a/net/ipv6/udp.c b/net/ipv6/udp.c
--- a/net/ipv6/udp.c	Thu Jun 20 15:54:00 2002
+++ b/net/ipv6/udp.c	Thu Jun 20 15:54:00 2002
@@ -371,7 +371,7 @@
  * 	return it, otherwise we block.
  */
 
-int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, int len,
+static int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, int len,
 		  int noblock, int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
@@ -470,7 +470,7 @@
 	goto out_free;
 }
 
-void udpv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
+static void udpv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 	       int type, int code, int offset, __u32 info)
 {
 	struct ipv6_pinfo *np;
@@ -603,7 +603,7 @@
 	read_unlock(&udp_hash_lock);
 }
 
-int udpv6_rcv(struct sk_buff *skb)
+static int udpv6_rcv(struct sk_buff *skb)
 {
 	struct sock *sk;
   	struct udphdr *uh;
diff -Nru a/net/irda/af_irda.c b/net/irda/af_irda.c
--- a/net/irda/af_irda.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/af_irda.c	Thu Jun 20 15:54:00 2002
@@ -48,27 +48,17 @@
 #include <linux/socket.h>
 #include <linux/sockios.h>
 #include <linux/init.h>
-#include <linux/if_arp.h>
 #include <linux/net.h>
 #include <linux/irda.h>
 #include <linux/poll.h>
 
+#include <asm/ioctls.h>		/* TIOCOUTQ, TIOCINQ */
 #include <asm/uaccess.h>
 
 #include <net/sock.h>
 #include <net/tcp.h>
 
-#include <net/irda/irda.h>
-#include <net/irda/iriap.h>
-#include <net/irda/irias_object.h>
-#include <net/irda/irlmp.h>
-#include <net/irda/irttp.h>
-#include <net/irda/discovery.h>
-
-extern int  irda_init(void);
-extern void irda_cleanup(void);
-extern int  irlap_driver_rcv(struct sk_buff *, struct net_device *,
-			     struct packet_type *);
+#include <net/irda/af_irda.h>
 
 static int irda_create(struct socket *sock, int protocol);
 
@@ -83,10 +73,6 @@
 
 #define IRDA_MAX_HEADER (TTP_MAX_HEADER)
 
-#ifdef CONFIG_IRDA_DEBUG
-__u32 irda_debug = IRDA_DEBUG_LEVEL;
-#endif
-
 /*
  * Function irda_data_indication (instance, sap, skb)
  *
@@ -140,8 +126,10 @@
 		dev_kfree_skb(skb);
 
 	sk = self->sk;
-	if (sk == NULL)
+	if (sk == NULL) {
+		IRDA_DEBUG(0, __FUNCTION__ "(%p) : BUG : sk is NULL\n", self);
 		return;
+	}
 
 	/* Prevent race conditions with irda_release() and irda_shutdown() */
 	if ((!sk->dead) && (sk->state != TCP_CLOSE)) {
@@ -1317,12 +1305,12 @@
 		len = self->max_data_size;
 	}
 
-	skb = sock_alloc_send_skb(sk, len + self->max_header_size,
+	skb = sock_alloc_send_skb(sk, len + self->max_header_size + 16, 
 				  msg->msg_flags & MSG_DONTWAIT, &err);
 	if (!skb)
 		return -ENOBUFS;
 
-	skb_reserve(skb, self->max_header_size);
+	skb_reserve(skb, self->max_header_size + 16);
 
 	asmptr = skb->h.raw = skb_put(skb, len);
 	memcpy_fromiovec(asmptr, msg->msg_iov, len);
@@ -1395,30 +1383,6 @@
 }
 
 /*
- * Function irda_data_wait (sk)
- *
- *    Sleep until data has arrive. But check for races..
- *
- *    The caller is expected to deal with the situation when we return
- *    due to pending signals. And even if not, the peeked skb might have
- *    been already dequeued due to concurrent operation.
- *    Currently irda_recvmsg_stream() is the only caller and is ok.
- * Return 0 if condition packet has arrived, -ERESTARTSYS if signal_pending()
- * Only used once in irda_recvmsg_stream() -> inline
- */
-static inline int irda_data_wait(struct sock *sk)
-{
-	int ret = 0;
-	if (!skb_peek(&sk->receive_queue)) {
-		set_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
-		__wait_event_interruptible(*(sk->sleep),
-			(skb_peek(&sk->receive_queue)!=NULL), ret);
-		clear_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
-	}
-	return(ret);
-}
-
-/*
  * Function irda_recvmsg_stream (sock, msg, size, flags, scm)
  */
 static int irda_recvmsg_stream(struct socket *sock, struct msghdr *msg,
@@ -1429,6 +1393,7 @@
 	int noblock = flags & MSG_DONTWAIT;
 	int copied = 0;
 	int target = 1;
+	DECLARE_WAITQUEUE(waitq, current);
 
 	IRDA_DEBUG(3, __FUNCTION__ "()\n");
 
@@ -1451,25 +1416,43 @@
 
 		skb=skb_dequeue(&sk->receive_queue);
 		if (skb==NULL) {
+			int ret = 0;
+
 			if (copied >= target)
 				break;
 
+			/* The following code is a cut'n'paste of the
+			 * wait_event_interruptible() macro.
+			 * We don't us the macro because the test condition
+			 * is messy. - Jean II */
+			set_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
+			add_wait_queue(sk->sleep, &waitq);
+			set_current_state(TASK_INTERRUPTIBLE);
+
 			/*
 			 *	POSIX 1003.1g mandates this order.
 			 */
+			if (sk->err)
+				ret = sock_error(sk);
+			else if (sk->shutdown & RCV_SHUTDOWN)
+				;
+			else if (noblock)
+				ret = -EAGAIN;
+			else if (signal_pending(current))
+				ret = -ERESTARTSYS;
+			else if (skb_peek(&sk->receive_queue) == NULL)
+				/* Wait process until data arrives */
+				schedule();
 
-			if (sk->err) {
-				return sock_error(sk);
-			}
+			current->state = TASK_RUNNING;
+			remove_wait_queue(sk->sleep, &waitq);
+			clear_bit(SOCK_ASYNC_WAITDATA, &sk->socket->flags);
 
+			if(ret)
+				return(ret);
 			if (sk->shutdown & RCV_SHUTDOWN)
 				break;
 
-			if (noblock)
-				return -EAGAIN;
-			/* Wait process until data arrives */
-			if (irda_data_wait(sk))
-				return -ERESTARTSYS;
 			continue;
 		}
 
@@ -2383,11 +2366,11 @@
 				   "(), nothing discovered yet, going to sleep...\n");
 
 			/* Set watchdog timer to expire in <val> ms. */
+			self->errno = 0;
 			self->watchdog.function = irda_discovery_timeout;
 			self->watchdog.data = (unsigned long) self;
 			self->watchdog.expires = jiffies + (val * HZ/1000);
 			add_timer(&(self->watchdog));
-			self->errno = 0;
 
 			/* Wait for IR-LMP to call us back */
 			__wait_event_interruptible(self->query_wait,
@@ -2530,118 +2513,27 @@
 #endif /* CONFIG_IRDA_ULTRA */
 
 /*
- * Function irda_device_event (this, event, ptr)
+ * Function irsock_init (pro)
  *
- *    Called when a device is taken up or down
+ *    Initialize IrDA protocol
  *
  */
-static int irda_device_event(struct notifier_block *this, unsigned long event,
-			     void *ptr)
-{
-	struct net_device *dev = (struct net_device *) ptr;
-
-        /* Reject non IrDA devices */
-	if (dev->type != ARPHRD_IRDA)
-		return NOTIFY_DONE;
-
-        switch (event) {
-	case NETDEV_UP:
-		IRDA_DEBUG(3, __FUNCTION__ "(), NETDEV_UP\n");
-		/* irda_dev_device_up(dev); */
-		break;
-	case NETDEV_DOWN:
-		IRDA_DEBUG(3, __FUNCTION__ "(), NETDEV_DOWN\n");
-		/* irda_kill_by_device(dev); */
-		/* irda_rt_device_down(dev); */
-		/* irda_dev_device_down(dev); */
-		break;
-	default:
-		break;
-        }
-
-        return NOTIFY_DONE;
-}
-
-static struct packet_type irda_packet_type =
-{
-	0,	/* MUTTER ntohs(ETH_P_IRDA),*/
-	NULL,
-	irlap_driver_rcv,
-	NULL,
-	NULL,
-};
-
-static struct notifier_block irda_dev_notifier = {
-	irda_device_event,
-	NULL,
-	0
-};
-
-/*
- * Function irda_proc_modcount (inode, fill)
- *
- *    Use by the proc file system functions to prevent the irda module
- *    being removed while the use is standing in the net/irda directory
- */
-void irda_proc_modcount(struct inode *inode, int fill)
-{
-#ifdef MODULE
-#ifdef CONFIG_PROC_FS
-	if (fill)
-		MOD_INC_USE_COUNT;
-	else
-		MOD_DEC_USE_COUNT;
-#endif /* CONFIG_PROC_FS */
-#endif /* MODULE */
-}
-
-/*
- * Function irda_proto_init (pro)
- *
- *    Initialize IrDA protocol layer
- *
- */
-int __init irda_proto_init(void)
+int __init irsock_init(void)
 {
 	sock_register(&irda_family_ops);
 
-	irda_packet_type.type = htons(ETH_P_IRDA);
-        dev_add_pack(&irda_packet_type);
-
-	register_netdevice_notifier(&irda_dev_notifier);
-
-	irda_init();
-	irda_device_init();
 	return 0;
 }
 
-late_initcall(irda_proto_init);
-
 /*
- * Function irda_proto_cleanup (void)
+ * Function irsock_cleanup (void)
  *
- *    Remove IrDA protocol layer
+ *    Remove IrDA protocol
  *
  */
-#ifdef MODULE
-void irda_proto_cleanup(void)
+void __exit irsock_cleanup(void)
 {
-	irda_packet_type.type = htons(ETH_P_IRDA);
-        dev_remove_pack(&irda_packet_type);
-
-        unregister_netdevice_notifier(&irda_dev_notifier);
-
 	sock_unregister(PF_IRDA);
-	irda_cleanup();
 
         return;
 }
-module_exit(irda_proto_cleanup);
-
-MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
-MODULE_DESCRIPTION("The Linux IrDA Protocol Subsystem");
-MODULE_LICENSE("GPL");
-#ifdef CONFIG_IRDA_DEBUG
-MODULE_PARM(irda_debug, "1l");
-#endif
-#endif /* MODULE */
diff -Nru a/net/irda/ircomm/ircomm_core.c b/net/irda/ircomm/ircomm_core.c
--- a/net/irda/ircomm/ircomm_core.c	Thu Jun 20 15:53:59 2002
+++ b/net/irda/ircomm/ircomm_core.c	Thu Jun 20 15:53:59 2002
@@ -76,8 +76,7 @@
 	return 0;
 }
 
-#ifdef MODULE
-void ircomm_cleanup(void)
+void __exit ircomm_cleanup(void)
 {
 	IRDA_DEBUG(2, __FUNCTION__ "()\n");
 
@@ -87,7 +86,6 @@
 	remove_proc_entry("ircomm", proc_irda);
 #endif /* CONFIG_PROC_FS */
 }
-#endif /* MODULE */
 
 /*
  * Function ircomm_open (client_notify)
@@ -543,18 +541,9 @@
 }
 #endif /* CONFIG_PROC_FS */
 
-#ifdef MODULE
 MODULE_AUTHOR("Dag Brattli <dag@brattli.net>");
 MODULE_DESCRIPTION("IrCOMM protocol");
 MODULE_LICENSE("GPL");
 
-int init_module(void) 
-{
-	return ircomm_init();
-}
-	
-void cleanup_module(void)
-{
-	ircomm_cleanup();
-}
-#endif /* MODULE */
+module_init(ircomm_init);
+module_exit(ircomm_cleanup);
diff -Nru a/net/irda/ircomm/ircomm_lmp.c b/net/irda/ircomm/ircomm_lmp.c
--- a/net/irda/ircomm/ircomm_lmp.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/ircomm/ircomm_lmp.c	Thu Jun 20 15:54:00 2002
@@ -35,6 +35,7 @@
 #include <net/irda/irda.h>
 #include <net/irda/irlmp.h>
 #include <net/irda/iriap.h>
+#include <net/irda/irda_device.h>	/* struct irda_skb_cb */
 
 #include <net/irda/ircomm_event.h>
 #include <net/irda/ircomm_lmp.h>
diff -Nru a/net/irda/ircomm/ircomm_param.c b/net/irda/ircomm/ircomm_param.c
--- a/net/irda/ircomm/ircomm_param.c	Thu Jun 20 15:54:01 2002
+++ b/net/irda/ircomm/ircomm_param.c	Thu Jun 20 15:54:01 2002
@@ -29,6 +29,7 @@
  ********************************************************************/
 
 #include <linux/sched.h>
+#include <linux/tqueue.h>
 #include <linux/interrupt.h>
 
 #include <net/irda/irda.h>
diff -Nru a/net/irda/ircomm/ircomm_tty.c b/net/irda/ircomm/ircomm_tty.c
--- a/net/irda/ircomm/ircomm_tty.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/ircomm/ircomm_tty.c	Thu Jun 20 15:54:00 2002
@@ -141,8 +141,7 @@
 	return 0;
 }
 
-#ifdef MODULE
-static void __ircomm_tty_cleanup(struct ircomm_tty_cb *self)
+static void __exit __ircomm_tty_cleanup(struct ircomm_tty_cb *self)
 {
 	IRDA_DEBUG(0, __FUNCTION__ "()\n");
 
@@ -161,7 +160,7 @@
  *    Remove IrCOMM TTY layer/driver
  *
  */
-void ircomm_tty_cleanup(void)
+void __exit ircomm_tty_cleanup(void)
 {
 	int ret;
 
@@ -175,7 +174,6 @@
 
 	hashbin_delete(ircomm_tty, (FREE_FUNC) __ircomm_tty_cleanup);
 }
-#endif /* MODULE */
 
 /*
  * Function ircomm_startup (self)
@@ -1390,23 +1388,9 @@
 }
 #endif /* CONFIG_PROC_FS */
 
-#ifdef MODULE
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("IrCOMM serial TTY driver");
 MODULE_LICENSE("GPL");
 
-int init_module(void) 
-{
-	return ircomm_tty_init();
-}
-
-void cleanup_module(void)
-{
-	ircomm_tty_cleanup();
-}
-
-#endif /* MODULE */
-
-
-
-
+module_init(ircomm_tty_init);
+module_exit(ircomm_tty_cleanup);
diff -Nru a/net/irda/irda_device.c b/net/irda/irda_device.c
--- a/net/irda/irda_device.c	Thu Jun 20 15:54:01 2002
+++ b/net/irda/irda_device.c	Thu Jun 20 15:54:01 2002
@@ -55,19 +55,6 @@
 #include <net/irda/timer.h>
 #include <net/irda/wrapper.h>
 
-extern int irtty_init(void);
-extern int nsc_ircc_init(void);
-extern int ircc_init(void);
-extern int toshoboe_init(void);
-extern int litelink_init(void);
-extern int w83977af_init(void);
-extern int esi_init(void);
-extern int tekram_init(void);
-extern int actisys_init(void);
-extern int girbil_init(void);
-extern int sa1100_irda_init(void);
-extern int ep7211_ir_init(void);
-
 static void __irda_task_delete(struct irda_task *task);
 
 static hashbin_t *dongles = NULL;
@@ -116,53 +103,13 @@
 		return -ENOMEM;
 	}
 
-	/*
-	 * Call the init function of the device drivers that has not been
-	 * compiled as a module
-	 */
-#ifdef CONFIG_IRTTY_SIR
-	irtty_init();
-#endif
-#ifdef CONFIG_WINBOND_FIR
-	w83977af_init();
-#endif
-#ifdef CONFIG_SA1100_FIR
-	sa1100_irda_init();
-#endif
-#ifdef CONFIG_NSC_FIR
-	nsc_ircc_init();
-#endif
-#ifdef CONFIG_TOSHIBA_FIR
-	toshoboe_init();
-#endif
-#ifdef CONFIG_SMC_IRCC_FIR
-	ircc_init();
-#endif
-#ifdef CONFIG_ESI_DONGLE
-	esi_init();
-#endif
-#ifdef CONFIG_TEKRAM_DONGLE
-	tekram_init();
-#endif
-#ifdef CONFIG_ACTISYS_DONGLE
-	actisys_init();
-#endif
-#ifdef CONFIG_GIRBIL_DONGLE
-	girbil_init();
-#endif
-#ifdef CONFIG_LITELINK_DONGLE
-	litelink_init();
-#endif
-#ifdef CONFIG_OLD_BELKIN
-	old_belkin_init();
-#endif
-#ifdef CONFIG_EP7211_IR
-	ep7211_ir_init();
-#endif
+	/* We no longer initialise the driver ourselves here, we let
+	 * the system do it for us... - Jean II */
+
 	return 0;
 }
 
-void irda_device_cleanup(void)
+void __exit irda_device_cleanup(void)
 {
 	IRDA_DEBUG(4, __FUNCTION__ "()\n");
 
diff -Nru a/net/irda/iriap.c b/net/irda/iriap.c
--- a/net/irda/iriap.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/iriap.c	Thu Jun 20 15:54:00 2002
@@ -35,7 +35,6 @@
 
 #include <net/irda/irda.h>
 #include <net/irda/irttp.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irlmp.h>
 #include <net/irda/irias_object.h>
 #include <net/irda/iriap_event.h>
@@ -142,7 +141,7 @@
  *    Initializes the IrIAP layer, called by the module cleanup code in
  *    irmod.c
  */
-void iriap_cleanup(void)
+void __exit iriap_cleanup(void)
 {
 	irlmp_unregister_service(service_handle);
 
diff -Nru a/net/irda/irias_object.c b/net/irda/irias_object.c
--- a/net/irda/irias_object.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/irias_object.c	Thu Jun 20 15:54:00 2002
@@ -26,7 +26,6 @@
 #include <linux/socket.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irias_object.h>
 
 hashbin_t *objects = NULL;
diff -Nru a/net/irda/irlan/irlan_common.c b/net/irda/irlan/irlan_common.c
--- a/net/irda/irlan/irlan_common.c	Thu Jun 20 15:53:59 2002
+++ b/net/irda/irlan/irlan_common.c	Thu Jun 20 15:53:59 2002
@@ -155,7 +155,7 @@
 	return 0;
 }
 
-void irlan_cleanup(void) 
+void __exit irlan_cleanup(void) 
 {
 	IRDA_DEBUG(4, __FUNCTION__ "()\n");
 
@@ -1194,8 +1194,6 @@
 #endif
 }
 
-#ifdef MODULE
-
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("The Linux IrDA LAN protocol"); 
 MODULE_LICENSE("GPL");
@@ -1211,10 +1209,7 @@
  *    Initialize the IrLAN module, this function is called by the
  *    modprobe(1) program.
  */
-int init_module(void) 
-{
-	return irlan_init();
-}
+module_init(irlan_init);
 
 /*
  * Function cleanup_module (void)
@@ -1222,11 +1217,5 @@
  *    Remove the IrLAN module, this function is called by the rmmod(1)
  *    program
  */
-void cleanup_module(void) 
-{
-	/* Free some memory */
- 	irlan_cleanup();
-}
-
-#endif /* MODULE */
+module_exit(irlan_cleanup);
 
diff -Nru a/net/irda/irlap.c b/net/irda/irlap.c
--- a/net/irda/irlap.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/irlap.c	Thu Jun 20 15:54:00 2002
@@ -89,7 +89,7 @@
 	return 0;
 }
 
-void irlap_cleanup(void)
+void __exit irlap_cleanup(void)
 {
 	ASSERT(irlap != NULL, return;);
 
diff -Nru a/net/irda/irlap_event.c b/net/irda/irlap_event.c
--- a/net/irda/irlap_event.c	Thu Jun 20 15:54:01 2002
+++ b/net/irda/irlap_event.c	Thu Jun 20 15:54:01 2002
@@ -39,6 +39,7 @@
 #include <net/irda/irlap_frame.h>
 #include <net/irda/qos.h>
 #include <net/irda/parameters.h>
+#include <net/irda/irlmp.h>		/* irlmp_flow_indication(), ... */
 
 #include <net/irda/irda_device.h>
 
diff -Nru a/net/irda/irlmp.c b/net/irda/irlmp.c
--- a/net/irda/irlmp.c	Thu Jun 20 15:54:01 2002
+++ b/net/irda/irlmp.c	Thu Jun 20 15:54:01 2002
@@ -35,7 +35,6 @@
 #include <linux/random.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/timer.h>
 #include <net/irda/qos.h>
 #include <net/irda/irlap.h>
@@ -108,7 +107,7 @@
  *    Remove IrLMP layer
  *
  */
-void irlmp_cleanup(void)
+void __exit irlmp_cleanup(void) 
 {
 	/* Check for main structure */
 	ASSERT(irlmp != NULL, return;);
@@ -648,6 +647,9 @@
 	ASSERT(self->lap->lsaps != NULL, return -1;);
 
 	lsap = hashbin_remove(self->lap->lsaps, (int) self, NULL);
+#ifdef CONFIG_IRDA_CACHE_LAST_LSAP
+	self->lap->cache.valid = FALSE;
+#endif
 
 	ASSERT(lsap != NULL, return -1;);
 	ASSERT(lsap->magic == LMP_LSAP_MAGIC, return -1;);
diff -Nru a/net/irda/irnet/irnet.h b/net/irda/irnet/irnet.h
--- a/net/irda/irnet/irnet.h	Thu Jun 20 15:54:01 2002
+++ b/net/irda/irnet/irnet.h	Thu Jun 20 15:54:01 2002
@@ -222,6 +222,9 @@
  *	o Fix race condition in irnet_connect_indication().
  *	  If the socket was already trying to connect, drop old connection
  *	  and use new one only if acting as primary. See comments.
+ *
+ * v13 - 30.5.02 - Jean II
+ *	o Update module init code
  */
 
 /***************************** INCLUDES *****************************/
@@ -239,6 +242,7 @@
 #include <linux/config.h>
 #include <linux/ctype.h>	/* isspace() */
 #include <asm/uaccess.h>
+#include <linux/init.h>
 
 #include <linux/ppp_defs.h>
 #include <linux/if_ppp.h>
@@ -502,16 +506,11 @@
 	irda_irnet_init(void);		/* Initialise IrDA part of IrNET */
 extern void
 	irda_irnet_cleanup(void);	/* Teardown IrDA part of IrNET */
-/* --------------------------- PPP PART --------------------------- */
-extern int
-	ppp_irnet_init(void);		/* Initialise PPP part of IrNET */
-extern void
-	ppp_irnet_cleanup(void);	/* Teardown PPP part of IrNET */
 /* ---------------------------- MODULE ---------------------------- */
 extern int
-	init_module(void);		/* Initialise IrNET module */
+	irnet_init(void);		/* Initialise IrNET module */
 extern void
-	cleanup_module(void);		/* Teardown IrNET module  */
+	irnet_cleanup(void);		/* Teardown IrNET module */
 
 /**************************** VARIABLES ****************************/
 
diff -Nru a/net/irda/irnet/irnet_irda.c b/net/irda/irnet/irnet_irda.c
--- a/net/irda/irnet/irnet_irda.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/irnet/irnet_irda.c	Thu Jun 20 15:54:00 2002
@@ -1801,7 +1801,7 @@
 /*
  * Prepare the IrNET layer for operation...
  */
-int
+int __init
 irda_irnet_init(void)
 {
   int		err = 0;
@@ -1844,7 +1844,7 @@
 /*
  * Cleanup at exit...
  */
-void
+void __exit
 irda_irnet_cleanup(void)
 {
   DENTER(MODULE_TRACE, "()\n");
diff -Nru a/net/irda/irnet/irnet_ppp.c b/net/irda/irnet/irnet_ppp.c
--- a/net/irda/irnet/irnet_ppp.c	Thu Jun 20 15:54:01 2002
+++ b/net/irda/irnet/irnet_ppp.c	Thu Jun 20 15:54:01 2002
@@ -1040,7 +1040,7 @@
  * Hook our device callbacks in the filesystem, to connect our code
  * to /dev/irnet
  */
-int
+static inline int __init
 ppp_irnet_init(void)
 {
   int err = 0;
@@ -1058,7 +1058,7 @@
 /*
  * Cleanup at exit...
  */
-void
+static inline void __exit
 ppp_irnet_cleanup(void)
 {
   DENTER(MODULE_TRACE, "()\n");
@@ -1069,13 +1069,12 @@
   DEXIT(MODULE_TRACE, "\n");
 }
 
-#ifdef MODULE
 /*------------------------------------------------------------------*/
 /*
  * Module main entry point
  */
-int
-init_module(void)
+int __init
+irnet_init(void)
 {
   int err;
 
@@ -1090,11 +1089,19 @@
 /*
  * Module exit
  */
-void
-cleanup_module(void)
+void __exit
+irnet_cleanup(void)
 {
   irda_irnet_cleanup();
   return ppp_irnet_cleanup();
 }
-#endif /* MODULE */
+
+/*------------------------------------------------------------------*/
+/*
+ * Module magic
+ */
+module_init(irnet_init);
+module_exit(irnet_cleanup);
+MODULE_AUTHOR("Jean Tourrilhes <jt@hpl.hp.com>");
+MODULE_DESCRIPTION("IrNET : Synchronous PPP over IrDA"); 
 MODULE_LICENSE("GPL");
diff -Nru a/net/irda/irproc.c b/net/irda/irproc.c
--- a/net/irda/irproc.c	Thu Jun 20 15:53:59 2002
+++ b/net/irda/irproc.c	Thu Jun 20 15:53:59 2002
@@ -27,9 +27,9 @@
 #include <linux/proc_fs.h>
 #define __NO_VERSION__
 #include <linux/module.h>
+#include <linux/init.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irlap.h>
 #include <net/irda/irlmp.h>
 
@@ -62,7 +62,7 @@
  *    Register irda entry in /proc file system
  *
  */
-void irda_proc_register(void) 
+void __init irda_proc_register(void) 
 {
 	int i;
 
@@ -81,7 +81,7 @@
  *    Unregister irda entry in /proc file system
  *
  */
-void irda_proc_unregister(void) 
+void __exit irda_proc_unregister(void) 
 {
 	int i;
 
diff -Nru a/net/irda/irqueue.c b/net/irda/irqueue.c
--- a/net/irda/irqueue.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/irqueue.c	Thu Jun 20 15:54:00 2002
@@ -36,7 +36,6 @@
 
 #include <net/irda/irda.h>
 #include <net/irda/irqueue.h>
-#include <net/irda/irmod.h>
 
 static irda_queue_t *dequeue_general( irda_queue_t **queue, irda_queue_t* element);
 static __u32 hash( char* name);
diff -Nru a/net/irda/irsyms.c b/net/irda/irsyms.c
--- a/net/irda/irsyms.c	Thu Jun 20 15:54:01 2002
+++ b/net/irda/irsyms.c	Thu Jun 20 15:54:01 2002
@@ -30,10 +30,9 @@
 #include <linux/poll.h>
 #include <linux/proc_fs.h>
 #include <linux/smp_lock.h>
-
+#include <linux/if_arp.h>		/* ARPHRD_IRDA */
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irlap.h>
 #include <net/irda/irlmp.h>
 #include <net/irda/iriap.h>
@@ -63,6 +62,11 @@
 extern int irlpt_client_init(void);
 extern int irlpt_server_init(void);
 
+extern int  irsock_init(void);
+extern void irsock_cleanup(void);
+extern int  irlap_driver_rcv(struct sk_buff *, struct net_device *, 
+			     struct packet_type *);
+
 /* IrTTP */
 EXPORT_SYMBOL(irttp_open_tsap);
 EXPORT_SYMBOL(irttp_close_tsap);
@@ -168,45 +172,142 @@
 EXPORT_SYMBOL(irtty_set_packet_mode);
 #endif
 
+#ifdef CONFIG_IRDA_DEBUG
+__u32 irda_debug = IRDA_DEBUG_LEVEL;
+#endif
+
+static struct packet_type irda_packet_type = 
+{
+	0,	/* MUTTER ntohs(ETH_P_IRDA),*/
+	NULL,
+	irlap_driver_rcv,
+	NULL,
+	NULL,
+};
+
+/*
+ * Function irda_device_event (this, event, ptr)
+ *
+ *    Called when a device is taken up or down
+ *
+ */
+static int irda_device_event(struct notifier_block *this, unsigned long event,
+			     void *ptr)
+{
+	struct net_device *dev = (struct net_device *) ptr;
+	
+        /* Reject non IrDA devices */
+	if (dev->type != ARPHRD_IRDA) 
+		return NOTIFY_DONE;
+	
+        switch (event) {
+	case NETDEV_UP:
+		IRDA_DEBUG(3, __FUNCTION__ "(), NETDEV_UP\n");
+		/* irda_dev_device_up(dev); */
+		break;
+	case NETDEV_DOWN:
+		IRDA_DEBUG(3, __FUNCTION__ "(), NETDEV_DOWN\n");
+		/* irda_kill_by_device(dev); */
+		/* irda_rt_device_down(dev); */
+		/* irda_dev_device_down(dev); */
+		break;
+	default:
+		break;
+        }
+
+        return NOTIFY_DONE;
+}
+
+static struct notifier_block irda_dev_notifier = {
+	irda_device_event,
+	NULL,
+	0
+};
+
+/*
+ * Function irda_notify_init (notify)
+ *
+ *    Used for initializing the notify structure
+ *
+ */
+void irda_notify_init(notify_t *notify)
+{
+	notify->data_indication = NULL;
+	notify->udata_indication = NULL;
+	notify->connect_confirm = NULL;
+	notify->connect_indication = NULL;
+	notify->disconnect_indication = NULL;
+	notify->flow_indication = NULL;
+	notify->status_indication = NULL;
+	notify->instance = NULL;
+	strncpy(notify->name, "Unknown", NOTIFY_MAX_NAME);
+}
+
+/*
+ * Function irda_init (void)
+ *
+ *  Protocol stack intialisation entry point.
+ *  Initialise the various components of the IrDA stack
+ */
 int __init irda_init(void)
 {
 	IRDA_DEBUG(0, __FUNCTION__ "()\n");
 
+	/* Lower layer of the stack */
  	irlmp_init();
 	irlap_init();
 	
+	/* Higher layers of the stack */
 	iriap_init();
  	irttp_init();
+	irsock_init();
 	
+	/* Add IrDA packet type (Start receiving packets) */
+	irda_packet_type.type = htons(ETH_P_IRDA);
+        dev_add_pack(&irda_packet_type);
+
+	/* Notifier for Interface changes */
+	register_netdevice_notifier(&irda_dev_notifier);
+
+	/* External APIs */
 #ifdef CONFIG_PROC_FS
 	irda_proc_register();
 #endif
 #ifdef CONFIG_SYSCTL
 	irda_sysctl_register();
 #endif
-	/* 
-	 * Initialize modules that got compiled into the kernel 
-	 */
-#ifdef CONFIG_IRLAN
-	irlan_init();
-#endif
-#ifdef CONFIG_IRCOMM
-	ircomm_init();
-	ircomm_tty_init();
-#endif
+
+	/* Driver/dongle support */
+ 	irda_device_init();
+
 	return 0;
 }
 
+/*
+ * Function irda_cleanup (void)
+ *
+ *  Protocol stack cleanup/removal entry point.
+ *  Cleanup the various components of the IrDA stack
+ */
 void __exit irda_cleanup(void)
 {
+	/* Remove External APIs */
 #ifdef CONFIG_SYSCTL
 	irda_sysctl_unregister();
 #endif	
-
 #ifdef CONFIG_PROC_FS
 	irda_proc_unregister();
 #endif
+
+	/* Remove IrDA packet type (stop receiving packets) */
+	irda_packet_type.type = htons(ETH_P_IRDA);
+        dev_remove_pack(&irda_packet_type);
+	
+	/* Stop receiving interfaces notifications */
+        unregister_netdevice_notifier(&irda_dev_notifier);
+	
 	/* Remove higher layers */
+	irsock_cleanup();
 	irttp_cleanup();
 	iriap_cleanup();
 
@@ -219,21 +320,24 @@
 }
 
 /*
- * Function irda_notify_init (notify)
+ * The IrDA stack must be initialised *before* drivers get initialised,
+ * and *before* higher protocols (IrLAN/IrCOMM/IrNET) get initialised,
+ * otherwise bad things will happen (hashbins will be NULL for example).
+ * Those modules are at module_init()/device_initcall() level.
  *
- *    Used for initializing the notify structure
+ * On the other hand, it needs to be initialised *after* the basic
+ * networking, the /proc/net filesystem and sysctl module. Those are
+ * currently initialised in .../init/main.c (before initcalls).
+ * Also, it needs to be initialised *after* the random number generator.
  *
+ * Jean II
  */
-void irda_notify_init(notify_t *notify)
-{
-	notify->data_indication = NULL;
-	notify->udata_indication = NULL;
-	notify->connect_confirm = NULL;
-	notify->connect_indication = NULL;
-	notify->disconnect_indication = NULL;
-	notify->flow_indication = NULL;
-	notify->status_indication = NULL;
-	notify->instance = NULL;
-	strncpy(notify->name, "Unknown", NOTIFY_MAX_NAME);
-}
-
+subsys_initcall(irda_init);
+module_exit(irda_cleanup);
+ 
+MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no> & Jean Tourrilhes <jt@hpl.hp.com>");
+MODULE_DESCRIPTION("The Linux IrDA Protocol Stack"); 
+MODULE_LICENSE("GPL");
+#ifdef CONFIG_IRDA_DEBUG
+MODULE_PARM(irda_debug, "1l");
+#endif
diff -Nru a/net/irda/irsysctl.c b/net/irda/irsysctl.c
--- a/net/irda/irsysctl.c	Thu Jun 20 15:54:00 2002
+++ b/net/irda/irsysctl.c	Thu Jun 20 15:54:00 2002
@@ -27,6 +27,7 @@
 #include <linux/mm.h>
 #include <linux/ctype.h>
 #include <linux/sysctl.h>
+#include <linux/init.h>
 
 #include <net/irda/irda.h>
 #include <net/irda/irias_object.h>
@@ -156,7 +157,7 @@
  *    Register our sysctl interface
  *
  */
-int irda_sysctl_register(void)
+int __init irda_sysctl_register(void)
 {
 	irda_table_header = register_sysctl_table(irda_root_table, 0);
 	if (!irda_table_header)
@@ -171,7 +172,7 @@
  *    Unregister our sysctl interface
  *
  */
-void irda_sysctl_unregister(void) 
+void __exit irda_sysctl_unregister(void) 
 {
 	unregister_sysctl_table(irda_table_header);
 }
diff -Nru a/net/irda/irttp.c b/net/irda/irttp.c
--- a/net/irda/irttp.c	Thu Jun 20 15:54:01 2002
+++ b/net/irda/irttp.c	Thu Jun 20 15:54:01 2002
@@ -32,7 +32,6 @@
 #include <asm/unaligned.h>
 
 #include <net/irda/irda.h>
-#include <net/irda/irmod.h>
 #include <net/irda/irlap.h>
 #include <net/irda/irlmp.h>
 #include <net/irda/parameters.h>
@@ -107,8 +106,7 @@
  *    Called by module destruction/cleanup code
  *
  */
-#ifdef MODULE
-void irttp_cleanup(void)
+void __exit irttp_cleanup(void) 
 {
 	/* Check for main structure */
 	ASSERT(irttp != NULL, return;);
@@ -126,7 +124,6 @@
 
 	irttp = NULL;
 }
-#endif
 
 /*************************** SUBROUTINES ***************************/
 
diff -Nru a/net/irda/timer.c b/net/irda/timer.c
--- a/net/irda/timer.c	Thu Jun 20 15:54:01 2002
+++ b/net/irda/timer.c	Thu Jun 20 15:54:01 2002
@@ -11,7 +11,7 @@
  * 
  *     Copyright (c) 1997, 1999 Dag Brattli <dagb@cs.uit.no>, 
  *     All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2000-2002 Jean Tourrilhes <jt@hpl.hp.com>
  *     
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -32,7 +32,7 @@
 #include <net/irda/irda.h>
 #include <net/irda/irtty.h>
 #include <net/irda/irlap.h>
-#include <net/irda/irlmp_event.h>
+#include <net/irda/irlmp.h>
 
 static void irlap_slot_timer_expired(void* data);
 static void irlap_query_timer_expired(void* data);
diff -Nru a/net/khttpd/Makefile b/net/khttpd/Makefile
--- a/net/khttpd/Makefile	Thu Jun 20 15:54:01 2002
+++ b/net/khttpd/Makefile	Thu Jun 20 15:54:01 2002
@@ -12,7 +12,11 @@
 
 include $(TOPDIR)/Rules.make
 
-rfc_time.o: times.h
+# Dependencies on generated files need to be listed explicitly
 
-times.h: make_times_h
-	./make_times_h
+$(obj)/rfc_time.o: $(obj)/times.h
+
+# Generated files
+
+$(obj)/times.h: $(obj)/make_times_h
+	$< >$@
diff -Nru a/net/khttpd/make_times_h.c b/net/khttpd/make_times_h.c
--- a/net/khttpd/make_times_h.c	Thu Jun 20 15:54:00 2002
+++ b/net/khttpd/make_times_h.c	Thu Jun 20 15:54:00 2002
@@ -64,59 +64,52 @@
 int main(void)
 {
 	int M,Y;
-	FILE *file;
-	
-	file=fopen("times.h","w");
-	
-	if (file==NULL) 
-		return 0; 
-	
-	fprintf(file,"static time_t TimeDays[10][13] = { \n");
+
+	printf("static time_t TimeDays[10][13] = { \n");
 	
 	Y=1997;
 	while (Y<2007)
 	{
 		M=0;
-		fprintf(file," { ");
+		printf(" { ");
 		while (M<12)
 		{
-			fprintf(file,"%i",(int)GetDay(1,M,Y));
-     		  	fprintf(file,",\t");
+			printf("%i",(int)GetDay(1,M,Y));
+     		  	printf(",\t");
 		
 			M++;
 		}
 		
-		fprintf(file,"%i } ",(int)GetDay(1,0,Y+1));
-		if (Y!=2006) fprintf(file,",");
-		fprintf(file,"\n");
+		printf("%i } ",(int)GetDay(1,0,Y+1));
+		if (Y!=2006) printf(",");
+		printf("\n");
 		Y++;
 	}
-	fprintf(file,"};\n");
+	printf("};\n");
 
-	fprintf(file,"static int WeekDays[10][13] = { \n");
+	printf("static int WeekDays[10][13] = { \n");
 	
 	Y=1997;
 	while (Y<2007)
 	{
 		M=0;
-		fprintf(file," { ");
+		printf(" { ");
 		while (M<12)
 		{
-			fprintf(file,"%i",(int)WeekGetDay(1,M,Y));
-     		  	fprintf(file,",\t");
+			printf("%i",(int)WeekGetDay(1,M,Y));
+     		  	printf(",\t");
 		
 			M++;
 		}
 		
-		fprintf(file,"%i } ",(int)WeekGetDay(1,0,Y+1));
-		if (Y!=2006) fprintf(file,",");
-		fprintf(file,"\n");
+		printf("%i } ",(int)WeekGetDay(1,0,Y+1));
+		if (Y!=2006) printf(",");
+		printf("\n");
 		Y++;
 	}
-	fprintf(file,"};\n");
-	fprintf(file,"#define KHTTPD_YEAROFFSET   1997\n");
-	fprintf(file,"#define KHTTPD_NUMYEARS     10\n");
-	(void)fclose(file);
+	printf("};\n");
+	printf("#define KHTTPD_YEAROFFSET   1997\n");
+	printf("#define KHTTPD_NUMYEARS     10\n");
 	
 	return 0;
 }
diff -Nru a/net/llc/Makefile b/net/llc/Makefile
--- a/net/llc/Makefile	Thu Jun 20 15:54:01 2002
+++ b/net/llc/Makefile	Thu Jun 20 15:54:01 2002
@@ -1,12 +1,6 @@
 ###########################################################################
 # Makefile for the Linux 802.2 LLC (fully-functional) layer.
 #
-# Note 1! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-# Note 2! The CFLAGS definition is now in the main makefile...
-#
 # Copyright (c) 1997 by Procom Technology,Inc.
 #		2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
 #
@@ -18,21 +12,15 @@
 # See the GNU General Public License for more details.
 ###########################################################################
 
-O_TARGET := llc.o
+obj-$(CONFIG_LLC) += llc.o
 
-obj-y := llc_if.o llc_c_ev.o llc_c_ac.o llc_mac.o llc_sap.o llc_s_st.o \
+llc-y := llc_if.o llc_c_ev.o llc_c_ac.o llc_mac.o llc_sap.o llc_s_st.o \
 	 llc_main.o llc_s_ac.o llc_conn.o llc_c_st.o llc_stat.o llc_actn.o \
 	 llc_s_ev.o llc_evnt.o llc_pdu.o
-
-ifeq ($(CONFIG_LLC_UI),y)
-  obj-y += llc_sock.o
-endif
+llc-$(CONFIG_LLC_UI)	+= llc_sock.o
+llc-objs	 	:= $(llc-y)
 
 # Objects that export symbols.
 export-objs := llc_if.o
-
-ifeq ($(CONFIG_LLC),m)
-  obj-m += $(O_TARGET)
-endif
 
 include $(TOPDIR)/Rules.make
diff -Nru a/scripts/patch-kernel b/scripts/patch-kernel
--- a/scripts/patch-kernel	Thu Jun 20 15:54:00 2002
+++ b/scripts/patch-kernel	Thu Jun 20 15:54:00 2002
@@ -68,7 +68,7 @@
 # ---------------------------------------------------------------------------
 # Find a file, first parameter is basename of file
 # it tries many compression mechanisms and sets variables to say how to get it
-function findFile {
+findFile () {
   filebase=$1;
 
   if [ -r ${filebase}.gz ]; then
@@ -106,7 +106,7 @@
 # Apply a patch and check it goes in cleanly
 # First param is patch name (e.g. patch-2.4.9-ac5) - without path or extension
 
-function applyPatch {
+applyPatch () {
   echo -n "Applying $1 (${name})... "
   if $uncomp ${patchdir}/$1${ext} | patch -p1 -s -N -E -d $sourcedir
   then
diff -Nru a/sound/arm/sa11xx-uda1341.c b/sound/arm/sa11xx-uda1341.c
--- a/sound/arm/sa11xx-uda1341.c	Thu Jun 20 15:54:00 2002
+++ b/sound/arm/sa11xx-uda1341.c	Thu Jun 20 15:54:00 2002
@@ -15,7 +15,7 @@
  * 2002-04-04   Tomas Kasparek  better rates handling (allow non-standard rates)
  */
 
-/* $Id$ */
+/* $Id$ */
 
 #include <sound/driver.h>
 #include <linux/module.h>
diff -Nru a/sound/core/Config.in b/sound/core/Config.in
--- a/sound/core/Config.in	Thu Jun 20 15:54:00 2002
+++ b/sound/core/Config.in	Thu Jun 20 15:54:00 2002
@@ -16,15 +16,11 @@
 dep_mbool '  OSS API emulation' CONFIG_SND_OSSEMUL $CONFIG_SND
 if [ "$CONFIG_SND_OSSEMUL" = "y" ]; then
   dep_tristate '    OSS Mixer API' CONFIG_SND_MIXER_OSS $CONFIG_SND
-  dep_tristate '    OSS PCM API' CONFIG_SND_PCM_OSS $CONFIG_SND
-  if [ "$CONFIG_SND_SEQUENCER" != "n" ]; then
-    dep_tristate '    OSS Sequencer API' CONFIG_SND_SEQUENCER_OSS $CONFIG_SND_SEQUENCER
-  fi
+  dep_tristate '    OSS PCM (digital audio) API' CONFIG_SND_PCM_OSS $CONFIG_SND
+  dep_mbool '    OSS Sequencer API' CONFIG_SND_SEQUENCER_OSS $CONFIG_SND_SEQUENCER
 fi
 dep_tristate '  RTC Timer support' CONFIG_SND_RTCTIMER $CONFIG_SND $CONFIG_RTC
 bool '  Verbose printk' CONFIG_SND_VERBOSE_PRINTK
 bool '  Debug' CONFIG_SND_DEBUG
-if [ "$CONFIG_SND_DEBUG" = "y" ]; then
-  bool '    Debug memory' CONFIG_SND_DEBUG_MEMORY
-  bool '    Debug detection' CONFIG_SND_DEBUG_DETECT
-fi
+dep_bool '    Debug memory' CONFIG_SND_DEBUG_MEMORY $CONFIG_SND_DEBUG
+dep_bool '    Debug detection' CONFIG_SND_DEBUG_DETECT $CONFIG_SND_DEBUG
diff -Nru a/sound/core/Makefile b/sound/core/Makefile
--- a/sound/core/Makefile	Thu Jun 20 15:54:00 2002
+++ b/sound/core/Makefile	Thu Jun 20 15:54:00 2002
@@ -25,6 +25,7 @@
   obj-$(CONFIG_SND_RTCTIMER) += snd-rtctimer.o
 endif
 obj-$(CONFIG_SND_HWDEP) += snd-hwdep.o
+
 obj-$(CONFIG_SND_MIXER_OSS) += oss/
 obj-$(CONFIG_SND_PCM_OSS) += snd-pcm.o snd-timer.o oss/
 obj-$(CONFIG_SND_SEQUENCER) += snd-timer.o seq/
@@ -58,8 +59,8 @@
 obj-$(CONFIG_SND_OPTI92X_CS4231) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o snd-hwdep.o
 obj-$(CONFIG_SND_OPTI93X) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o snd-hwdep.o
 obj-$(CONFIG_SND_SB8) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o snd-hwdep.o
-obj-$(CONFIG_SND_SB16) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o
-obj-$(CONFIG_SND_SBAWE) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o
+obj-$(CONFIG_SND_SB16) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o snd-hwdep.o
+obj-$(CONFIG_SND_SBAWE) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o snd-hwdep.o
 obj-$(CONFIG_SND_ES968) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o
 obj-$(CONFIG_SND_WAVEFRONT) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o snd-hwdep.o
 obj-$(CONFIG_SND_ALS4000) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o snd-hwdep.o
@@ -84,12 +85,16 @@
 obj-$(CONFIG_SND_KORG1212) += snd-pcm.o snd-timer.o snd.o
 obj-$(CONFIG_SND_NM256) += snd-pcm.o snd-timer.o snd.o
 obj-$(CONFIG_SND_RME9652) += snd-pcm.o snd-timer.o snd.o
+obj-$(CONFIG_SND_HDSP) += snd-pcm.o snd-timer.o snd.o
 obj-$(CONFIG_SND_TRIDENT) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o
 obj-$(CONFIG_SND_YMFPCI) += snd-pcm.o snd-timer.o snd.o snd-rawmidi.o snd-hwdep.o
 obj-$(CONFIG_SND_POWERMAC) += snd-pcm.o snd-timer.o snd.o
+obj-$(CONFIG_SND_SA11XX_UDA1341) += snd-pcm.o snd-timer.o snd.o
 ifeq ($(CONFIG_SND_SB16_CSP),y)
   obj-$(CONFIG_SND_SB16) += snd-hwdep.o
   obj-$(CONFIG_SND_SBAWE) += snd-hwdep.o
 endif
+
+obj-m := $(sort $(obj-m))
 
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/core/control.c b/sound/core/control.c
--- a/sound/core/control.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/control.c	Thu Jun 20 15:54:00 2002
@@ -144,7 +144,7 @@
 	
 	snd_runtime_check(card != NULL && id != NULL, return);
 	read_lock_irqsave(&card->control_rwlock, flags);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	card->mixer_oss_change_count++;
 #endif
 	list_for_each(flist, &card->ctl_files) {
diff -Nru a/sound/core/info.c b/sound/core/info.c
--- a/sound/core/info.c	Thu Jun 20 15:54:01 2002
+++ b/sound/core/info.c	Thu Jun 20 15:54:01 2002
@@ -105,7 +105,7 @@
 	if (buffer->stop || buffer->error)
 		return 0;
 	va_start(args, fmt);
-	res = vsprintf(sbuffer, fmt, args);
+	res = vsnprintf(sbuffer, sizeof(sbuffer), fmt, args);
 	va_end(args);
 	if (buffer->size + res >= buffer->len) {
 		buffer->stop = 1;
diff -Nru a/sound/core/init.c b/sound/core/init.c
--- a/sound/core/init.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/init.c	Thu Jun 20 15:54:00 2002
@@ -33,7 +33,7 @@
 snd_card_t *snd_cards[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = NULL};
 rwlock_t snd_card_rwlock = RW_LOCK_UNLOCKED;
 
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 int (*snd_mixer_oss_notify_callback)(snd_card_t *card, int free_flag);
 #endif
 
@@ -135,7 +135,7 @@
 	snd_cards[card->number] = NULL;
 	snd_cards_count--;
 	write_unlock(&snd_card_rwlock);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, 1);
 #endif
@@ -177,10 +177,15 @@
 	if ((err = snd_device_register_all(card)) < 0)
 		return err;
 	write_lock(&snd_card_rwlock);
+	if (snd_cards[card->number]) {
+		/* already registered */
+		write_unlock(&snd_card_rwlock);
+		return 0;
+	}
 	snd_cards[card->number] = card;
 	snd_cards_count++;
 	write_unlock(&snd_card_rwlock);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, 0);
 #endif
diff -Nru a/sound/core/ioctl32/ioctl32.c b/sound/core/ioctl32/ioctl32.c
--- a/sound/core/ioctl32/ioctl32.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/ioctl32/ioctl32.c	Thu Jun 20 15:54:00 2002
@@ -111,6 +111,11 @@
 			s32 step;
 		} integer;
 		struct {
+			u64 min;
+			u64 max;
+			u64 step;
+		} integer64;
+		struct {
 			u32 items;
 			u32 item;
 			char name[64];
@@ -145,6 +150,11 @@
 		data32.value.integer.max = data.value.integer.min;
 		data32.value.integer.step = data.value.integer.step;
 		break;
+	case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+		data32.value.integer64.min = data.value.integer64.min;
+		data32.value.integer64.max = data.value.integer64.min;
+		data32.value.integer64.step = data.value.integer64.step;
+		break;
 	case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
 		data32.value.enumerated.items = data.value.enumerated.items;
 		data32.value.enumerated.item = data.value.enumerated.item;
@@ -169,6 +179,10 @@
 			u32 value_ptr;
 		} integer;
 		union {
+			s64 value[64];
+			u32 value_ptr;
+		} integer64;
+		union {
 			u32 item[128];
 			u32 item_ptr;
 		} enumerated;
@@ -233,6 +247,10 @@
 			for (i = 0; i < 128; i++)
 				data.value.integer.value[i] = data32.value.integer.value[i];
 			break;
+		case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+			for (i = 0; i < 64; i++)
+				data.value.integer64.value[i] = data32.value.integer64.value[i];
+			break;
 		case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
 			for (i = 0; i < 128; i++)
 				data.value.enumerated.item[i] = data32.value.enumerated.item[i];
@@ -259,6 +277,10 @@
 		case SNDRV_CTL_ELEM_TYPE_INTEGER:
 			for (i = 0; i < 128; i++)
 				data.value.integer.value[i] = data32.value.integer.value[i];
+			break;
+		case SNDRV_CTL_ELEM_TYPE_INTEGER64:
+			for (i = 0; i < 64; i++)
+				data.value.integer64.value[i] = data32.value.integer64.value[i];
 			break;
 		case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
 			for (i = 0; i < 128; i++)
diff -Nru a/sound/core/memory.c b/sound/core/memory.c
--- a/sound/core/memory.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/memory.c	Thu Jun 20 15:54:00 2002
@@ -317,37 +317,13 @@
 #endif
 }
 
-#ifdef CONFIG_ISA
-
-#ifndef CONFIG_ISA_USE_PCI_ALLOC_CONSISTENT
-#ifdef CONFIG_PCI
-#define CONFIG_ISA_USE_PCI_ALLOC_CONSISTENT
-#endif
-#endif
+#if defined(CONFIG_ISA) && ! defined(CONFIG_PCI)
 
 void *snd_malloc_isa_pages(unsigned long size, dma_addr_t *dma_addr)
 {
 	void *dma_area;
-
-#ifndef CONFIG_ISA_USE_PCI_ALLOC_CONSISTENT
 	dma_area = snd_malloc_pages(size, GFP_ATOMIC|GFP_DMA);
 	*dma_addr = dma_area ? isa_virt_to_bus(dma_area) : 0UL;
-#else
-	{
-		int pg;
-		for (pg = 0; PAGE_SIZE * (1 << pg) < size; pg++);
-		dma_area = pci_alloc_consistent(NULL, size, dma_addr);
-		if (dma_area != NULL) {
-			struct page *page = virt_to_page(dma_area);
-			struct page *last_page = page + (1 << pg);
-			while (page < last_page)
-				SetPageReserved(page++);
-#ifdef CONFIG_SND_DEBUG_MEMORY
-			snd_alloc_pages += 1 << pg;
-#endif
-		}
-	}
-#endif
 	return dma_area;
 }
 
@@ -356,26 +332,12 @@
 				    unsigned long *res_size)
 {
 	void *dma_area;
-
-#ifndef CONFIG_ISA_USE_PCI_ALLOC_CONSISTENT
 	dma_area = snd_malloc_pages_fallback(size, GFP_ATOMIC|GFP_DMA, res_size);
 	*dma_addr = dma_area ? isa_virt_to_bus(dma_area) : 0UL;
 	return dma_area;
-#else
-	snd_assert(size > 0, return NULL);
-	snd_assert(res_size != NULL, return NULL);
-	do {
-		if ((dma_area = snd_malloc_isa_pages(size, dma_addr)) != NULL) {
-			*res_size = size;
-			return dma_area;
-		}
-		size >>= 1;
-	} while (size >= PAGE_SIZE);
-	return NULL;
-#endif
 }
 
-#endif
+#endif /* CONFIG_ISA && !CONFIG_PCI */
 
 #ifdef CONFIG_PCI
 
diff -Nru a/sound/core/misc.c b/sound/core/misc.c
--- a/sound/core/misc.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/misc.c	Thu Jun 20 15:54:00 2002
@@ -90,10 +90,10 @@
 	if (format[0] == '<' && format[1] >= '0' && format[1] <= '9' && format[2] == '>') {
 		char tmp[] = "<0>";
 		tmp[1] = format[1];
-		printk("%sALSA %s:%d: ", tmp, file, line);
+		printk("%sALSA: ", tmp);
 		format += 3;
 	} else {
-		printk(KERN_DEBUG "ALSA %s:%d: ", file, line);
+		printk(KERN_DEBUG "ALSA: ");
 	}
 	va_start(args, format);
 	vsnprintf(tmpbuf, sizeof(tmpbuf)-1, format, args);
diff -Nru a/sound/core/oss/pcm_oss.c b/sound/core/oss/pcm_oss.c
--- a/sound/core/oss/pcm_oss.c	Thu Jun 20 15:54:01 2002
+++ b/sound/core/oss/pcm_oss.c	Thu Jun 20 15:54:01 2002
@@ -446,8 +446,8 @@
 		vfree(runtime->oss.buffer);
 	runtime->oss.buffer = vmalloc(runtime->oss.period_bytes);
 	runtime->oss.buffer_used = 0;
-	snd_assert(runtime->dma_area != NULL, return -EIO);
-	snd_pcm_format_set_silence(runtime->format, runtime->dma_area, bytes_to_samples(runtime, runtime->dma_bytes));
+	if (runtime->dma_area)
+		snd_pcm_format_set_silence(runtime->format, runtime->dma_area, bytes_to_samples(runtime, runtime->dma_bytes));
 	return 0;
 }
 
diff -Nru a/sound/core/pcm.c b/sound/core/pcm.c
--- a/sound/core/pcm.c	Thu Jun 20 15:54:01 2002
+++ b/sound/core/pcm.c	Thu Jun 20 15:54:01 2002
@@ -231,7 +231,7 @@
 	return snd_pcm_state_names[state];
 }
 
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 #include <linux/soundcard.h>
 const char *snd_pcm_oss_format_name(int format)
 {
@@ -318,7 +318,7 @@
 	snd_iprintf(buffer, "period_size: %lu\n", runtime->period_size);	
 	snd_iprintf(buffer, "buffer_size: %lu\n", runtime->buffer_size);	
 	snd_iprintf(buffer, "tick_time: %u\n", runtime->tick_time);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
 		snd_iprintf(buffer, "OSS format: %s\n", snd_pcm_oss_format_name(runtime->oss.format));
 		snd_iprintf(buffer, "OSS channels: %u\n", runtime->oss.channels);	
@@ -537,7 +537,7 @@
 	int idx, err;
 	snd_pcm_substream_t *substream, *prev;
 
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	init_MUTEX(&pstr->oss.setup_mutex);
 #endif
 	pstr->stream = stream;
@@ -623,7 +623,7 @@
 static void snd_pcm_free_stream(snd_pcm_str_t * pstr)
 {
 	snd_pcm_substream_t *substream, *substream_next;
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	snd_pcm_oss_setup_t *setup, *setupn;
 #endif
 	substream = pstr->substream;
@@ -634,7 +634,7 @@
 		substream = substream_next;
 	}
 	snd_pcm_stream_proc_done(pstr);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	for (setup = pstr->oss.setup_list; setup; setup = setupn) {
 		setupn = setup->next;
 		kfree(setup->task_name);
@@ -968,6 +968,8 @@
 EXPORT_SYMBOL(snd_pcm_notify);
 EXPORT_SYMBOL(snd_pcm_open_substream);
 EXPORT_SYMBOL(snd_pcm_release_substream);
+EXPORT_SYMBOL(snd_pcm_format_name);
+EXPORT_SYMBOL(snd_pcm_subformat_name);
   /* pcm_native.c */
 EXPORT_SYMBOL(snd_pcm_start);
 #ifdef CONFIG_PM
diff -Nru a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
--- a/sound/core/pcm_lib.c	Thu Jun 20 15:54:01 2002
+++ b/sound/core/pcm_lib.c	Thu Jun 20 15:54:01 2002
@@ -1944,7 +1944,7 @@
 
 	snd_assert(substream->ffile != NULL, return -ENXIO);
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
 		snd_pcm_oss_setup_t *setup = substream->oss.setup;
 		if (setup != NULL) {
@@ -1956,7 +1956,8 @@
 	}
 #endif
 
-	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
+	    runtime->channels > 1)
 		return -EINVAL;
 	return snd_pcm_lib_write1(substream, buf, size, nonblock,
 				  snd_pcm_lib_write_transfer);
@@ -2017,7 +2018,7 @@
 
 	snd_assert(substream->ffile != NULL, return -ENXIO);
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
 		snd_pcm_oss_setup_t *setup = substream->oss.setup;
 		if (setup != NULL) {
@@ -2231,7 +2232,7 @@
 
 	snd_assert(substream->ffile != NULL, return -ENXIO);
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
 		snd_pcm_oss_setup_t *setup = substream->oss.setup;
 		if (setup != NULL) {
@@ -2298,7 +2299,7 @@
 
 	snd_assert(substream->ffile != NULL, return -ENXIO);
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
 		snd_pcm_oss_setup_t *setup = substream->oss.setup;
 		if (setup != NULL) {
diff -Nru a/sound/core/pcm_native.c b/sound/core/pcm_native.c
--- a/sound/core/pcm_native.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/pcm_native.c	Thu Jun 20 15:54:00 2002
@@ -305,7 +305,7 @@
 	default:
 		return -EBADFD;
 	}
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (!substream->oss.oss)
 #endif
 		if (atomic_read(&runtime->mmap_count))
@@ -495,10 +495,14 @@
 		if (runtime->status->state == SNDRV_PCM_STATE_RUNNING ||
 		    runtime->status->state == SNDRV_PCM_STATE_DRAINING)
 			status->delay = runtime->buffer_size - status->avail;
+		else
+			status->delay = 0;
 	} else {
 		status->avail = snd_pcm_capture_avail(runtime);
 		if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 			status->delay = status->avail;
+		else
+			status->delay = 0;
 	}
 	status->avail_max = runtime->avail_max;
 	status->overrange = runtime->overrange;
@@ -652,7 +656,8 @@
 static inline int snd_pcm_pre_stop(snd_pcm_substream_t *substream, int state)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
-	if (!snd_pcm_running(substream))
+	if (substream->runtime->status->state != SNDRV_PCM_STATE_RUNNING &&
+	    substream->runtime->status->state != SNDRV_PCM_STATE_DRAINING)
 		return -EBADFD;
 	runtime->trigger_master = substream;
 	return 0;
@@ -2573,10 +2578,8 @@
 
 static void snd_pcm_mmap_data_open(struct vm_area_struct *area)
 {
-#if 0
 	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
 	atomic_inc(&substream->runtime->mmap_count);
-#endif
 }
 
 static void snd_pcm_mmap_data_close(struct vm_area_struct *area)
diff -Nru a/sound/core/rawmidi.c b/sound/core/rawmidi.c
--- a/sound/core/rawmidi.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/rawmidi.c	Thu Jun 20 15:54:00 2002
@@ -143,7 +143,7 @@
 			break;
 		}
 		if (runtime->avail < runtime->buffer_size && !timeout) {
-			snd_printk(KERN_WARNING "rawmidi drain error (avail = %i, buffer_size = %i)\n", runtime->avail, runtime->buffer_size);
+			snd_printk(KERN_WARNING "rawmidi drain error (avail = %li, buffer_size = %li)\n", (long)runtime->avail, (long)runtime->buffer_size);
 			err = -EIO;
 			break;
 		}
diff -Nru a/sound/core/seq/Makefile b/sound/core/seq/Makefile
--- a/sound/core/seq/Makefile	Thu Jun 20 15:54:01 2002
+++ b/sound/core/seq/Makefile	Thu Jun 20 15:54:01 2002
@@ -4,7 +4,9 @@
 #
 
 obj-$(CONFIG_SND) += instr/
-obj-$(CONFIG_SND_SEQUENCER_OSS) += oss/
+ifeq ($(CONFIG_SND_SEQUENCER_OSS),y)
+  obj-$(CONFIG_SND_SEQUENCER) += oss/
+endif
 
 export-objs  := seq_device.o seq.o seq_ports.o seq_instr.o seq_midi_emul.o \
 		seq_midi_event.o seq_virmidi.o
@@ -21,7 +23,9 @@
 snd-seq-virmidi-objs := seq_virmidi.o
 
 obj-$(CONFIG_SND_SEQUENCER) += snd-seq.o snd-seq-device.o
-obj-$(CONFIG_SND_SEQUENCER_OSS) += snd-seq-midi-event.o
+ifeq ($(CONFIG_SND_SEQUENCER_OSS),y)
+obj-$(CONFIG_SND_SEQUENCER) += snd-seq-midi-event.o
+endif
 obj-$(CONFIG_SND_SEQ_DUMMY) += snd-seq-dummy.o
 
 # Toplevel Module Dependency
@@ -69,5 +73,7 @@
 obj-$(CONFIG_SND_EMU10K1) += snd-seq-midi.o snd-seq.o snd-seq-device.o snd-seq-midi-event.o snd-seq-midi-emul.o snd-seq-virmidi.o
 obj-$(CONFIG_SND_TRIDENT) += snd-seq-midi.o snd-seq.o snd-seq-device.o snd-seq-midi-event.o snd-seq-midi-emul.o snd-seq-instr.o
 obj-$(CONFIG_SND_YMFPCI) += snd-seq-midi.o snd-seq.o snd-seq-device.o snd-seq-midi-event.o snd-seq-midi-emul.o snd-seq-instr.o
+
+obj-m := $(sort $(obj-m))
 
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/core/seq/instr/Makefile b/sound/core/seq/instr/Makefile
--- a/sound/core/seq/instr/Makefile	Thu Jun 20 15:54:00 2002
+++ b/sound/core/seq/instr/Makefile	Thu Jun 20 15:54:00 2002
@@ -41,4 +41,6 @@
 obj-$(CONFIG_SND_TRIDENT) += snd-ainstr-simple.o
 obj-$(CONFIG_SND_YMFPCI) += snd-ainstr-fm.o
 
+obj-m := $(sort $(obj-m))
+
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/core/seq/oss/Makefile b/sound/core/seq/oss/Makefile
--- a/sound/core/seq/oss/Makefile	Thu Jun 20 15:54:01 2002
+++ b/sound/core/seq/oss/Makefile	Thu Jun 20 15:54:01 2002
@@ -7,6 +7,8 @@
 		     seq_oss_event.o seq_oss_rw.o seq_oss_synth.o \
 		     seq_oss_midi.o seq_oss_readq.o seq_oss_writeq.o
 
-obj-$(CONFIG_SND_SEQUENCER_OSS) += snd-seq-oss.o
+obj-$(CONFIG_SND_SEQUENCER) += snd-seq-oss.o
 
-include $(TOPDIR)/Rules.make
+ifeq ($(CONFIG_SND_SEQUENCER_OSS),y)
+  include $(TOPDIR)/Rules.make
+endif
diff -Nru a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c
--- a/sound/core/seq/seq_clientmgr.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/seq/seq_clientmgr.c	Thu Jun 20 15:54:00 2002
@@ -1102,7 +1102,7 @@
 	strcpy(info->name, cptr->name);
 	info->filter = cptr->filter;
 	info->event_lost = cptr->event_lost;
-	*info->event_filter = *cptr->event_filter;
+	memcpy(info->event_filter, cptr->event_filter, 32);
 	info->num_ports = cptr->num_ports;
 	memset(info->reserved, 0, sizeof(info->reserved));
 }
@@ -1151,7 +1151,7 @@
 	}
 	client->filter = client_info.filter;
 	client->event_lost = client_info.event_lost;
-	*client->event_filter = *client_info.event_filter;
+	memcpy(client->event_filter, client_info.event_filter, 32);
 
 	return 0;
 }
diff -Nru a/sound/core/seq/seq_clientmgr.h b/sound/core/seq/seq_clientmgr.h
--- a/sound/core/seq/seq_clientmgr.h	Thu Jun 20 15:54:00 2002
+++ b/sound/core/seq/seq_clientmgr.h	Thu Jun 20 15:54:00 2002
@@ -53,7 +53,6 @@
 	char name[64];		/* client name */
 	int number;		/* client number */
 	unsigned int filter;	/* filter flags */
-	bitmap_member(client_filter, 256);
 	bitmap_member(event_filter, 256);
 	snd_use_lock_t use_lock;
 	int event_lost;
diff -Nru a/sound/core/seq/seq_queue.h b/sound/core/seq/seq_queue.h
--- a/sound/core/seq/seq_queue.h	Thu Jun 20 15:54:00 2002
+++ b/sound/core/seq/seq_queue.h	Thu Jun 20 15:54:00 2002
@@ -51,7 +51,7 @@
 	spinlock_t check_lock;
 
 	/* clients which uses this queue (bitmap) */
-	bitmap_member(clients_bitmap,SNDRV_SEQ_MAX_CLIENTS);
+	bitmap_member(clients_bitmap, SNDRV_SEQ_MAX_CLIENTS);
 	unsigned int clients;	/* users of this queue */
 	struct semaphore timer_mutex;
 
diff -Nru a/sound/core/sound.c b/sound/core/sound.c
--- a/sound/core/sound.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/sound.c	Thu Jun 20 15:54:00 2002
@@ -426,7 +426,7 @@
 EXPORT_SYMBOL(snd_malloc_pages);
 EXPORT_SYMBOL(snd_malloc_pages_fallback);
 EXPORT_SYMBOL(snd_free_pages);
-#ifdef CONFIG_ISA
+#if defined(CONFIG_ISA) && ! defined(CONFIG_PCI)
 EXPORT_SYMBOL(snd_malloc_isa_pages);
 EXPORT_SYMBOL(snd_malloc_isa_pages_fallback);
 #endif
@@ -440,7 +440,7 @@
   /* init.c */
 EXPORT_SYMBOL(snd_cards_count);
 EXPORT_SYMBOL(snd_cards);
-#ifdef CONFIG_SND_OSSEMUL
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
 #endif
 EXPORT_SYMBOL(snd_card_new);
diff -Nru a/sound/core/timer.c b/sound/core/timer.c
--- a/sound/core/timer.c	Thu Jun 20 15:54:00 2002
+++ b/sound/core/timer.c	Thu Jun 20 15:54:00 2002
@@ -385,7 +385,7 @@
 /*
  * stop the timer instance.
  *
- * FIXME: do not call this from the timer callback!
+ * do not call this from the timer callback!
  */
 int snd_timer_stop(snd_timer_instance_t * timeri)
 {
@@ -407,9 +407,12 @@
 	timer = timeri->timer;
 	if (! timer)
 		return -EINVAL;
-	while (atomic_read(&timeri->in_use))
-		udelay(10);
 	spin_lock_irqsave(&timer->lock, flags);
+	while (atomic_read(&timeri->in_use)) {
+		spin_unlock_irqrestore(&timer->lock, flags);
+		udelay(10);
+		spin_lock_irqsave(&timer->lock, flags);
+	}
 	if (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {
 		timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
 		list_del_init(&timeri->active_list);
@@ -424,12 +427,49 @@
 				}
 			}
 		}
+	} else if (timeri->flags & SNDRV_TIMER_IFLG_START) {
+		timeri->flags &= ~SNDRV_TIMER_IFLG_START;
+		list_del_init(&timeri->active_list);
 	}
 	spin_unlock_irqrestore(&timer->lock, flags);
 	return 0;
 }
 
 /*
+ * delete the timer instance from active list.
+ *
+ * call this from the timer callback only!
+ */
+int snd_timer_del(snd_timer_instance_t * timeri)
+{
+	snd_timer_t *timer;
+
+	snd_assert(timeri != NULL, return -ENXIO);
+
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
+		timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+		list_del_init(&timeri->active_list);
+		return 0;
+	}
+
+	timer = timeri->timer;
+	if (! timer)
+		return -EINVAL;
+	spin_lock(&timer->lock);
+	if (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {
+		timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+		list_del_init(&timeri->active_list);
+		if (!(--timer->running))
+			timer->hw.stop(timer);
+	} else if (timeri->flags & SNDRV_TIMER_IFLG_START) {
+		timeri->flags &= ~SNDRV_TIMER_IFLG_START;
+		list_del_init(&timeri->active_list);
+	}
+	spin_unlock(&timer->lock);
+	return 0;
+}
+
+/*
  * start again..  the tick is kept.
  */
 int snd_timer_continue(snd_timer_instance_t * timeri)
@@ -558,7 +598,8 @@
 		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, active_list);
 		/* append to active_list */
 		list_del(p);
-		list_add_tail(p, &timer->active_list_head);
+		if (ti->flags & SNDRV_TIMER_IFLG_RUNNING)
+			list_add_tail(p, &timer->active_list_head);
 		spin_unlock(&timer->lock);
 		if (ti->callback)
 			ti->callback(ti, resolution, ti->ticks, ti->callback_data);
@@ -570,8 +611,8 @@
 				ts->callback(ts, resolution, ti->ticks, ts->callback_data);
 		}
 		spin_unlock(&slave_active_lock);
-		atomic_dec(&ti->in_use);
 		spin_lock(&timer->lock);
+		atomic_dec(&ti->in_use);
 	}
 	spin_unlock(&timer->lock);
 }
@@ -1352,6 +1393,7 @@
 EXPORT_SYMBOL(snd_timer_resolution);
 EXPORT_SYMBOL(snd_timer_start);
 EXPORT_SYMBOL(snd_timer_stop);
+EXPORT_SYMBOL(snd_timer_del);
 EXPORT_SYMBOL(snd_timer_continue);
 EXPORT_SYMBOL(snd_timer_new);
 EXPORT_SYMBOL(snd_timer_global_new);
diff -Nru a/sound/drivers/dummy.c b/sound/drivers/dummy.c
--- a/sound/drivers/dummy.c	Thu Jun 20 15:54:00 2002
+++ b/sound/drivers/dummy.c	Thu Jun 20 15:54:00 2002
@@ -20,7 +20,11 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/jiffies.h>
+#else
+#include <linux/sched.h>
+#endif
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/wait.h>
diff -Nru a/sound/drivers/mpu401/Makefile b/sound/drivers/mpu401/Makefile
--- a/sound/drivers/mpu401/Makefile	Thu Jun 20 15:54:01 2002
+++ b/sound/drivers/mpu401/Makefile	Thu Jun 20 15:54:01 2002
@@ -40,4 +40,6 @@
 obj-$(CONFIG_SND_TRIDENT) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_YMFPCI) += snd-mpu401-uart.o
 
+obj-m := $(sort $(obj-m))
+
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/drivers/opl3/Makefile b/sound/drivers/opl3/Makefile
--- a/sound/drivers/opl3/Makefile	Thu Jun 20 15:54:00 2002
+++ b/sound/drivers/opl3/Makefile	Thu Jun 20 15:54:00 2002
@@ -6,10 +6,12 @@
 export-objs  := opl3_lib.o
 
 snd-opl3-lib-objs := opl3_lib.o opl3_synth.o
-snd-opl3-synth-objs := opl3_seq.o opl3_midi.o opl3_drums.o
 ifeq ($(subst m,y,$(CONFIG_SND_SEQUENCER)),y)
+snd-opl3-synth-objs := opl3_seq.o opl3_midi.o opl3_drums.o
+ifeq ($(CONFIG_SND_SEQUENCER_OSS),y)
 snd-opl3-synth-objs += opl3_oss.o
 endif
+endif
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_ALS100) += snd-opl3-lib.o
@@ -62,5 +64,7 @@
   obj-$(CONFIG_SND_SONICVIBES) += snd-opl3-synth.o
   obj-$(CONFIG_SND_YMFPCI) += snd-opl3-synth.o
 endif
+
+obj-m := $(sort $(obj-m))
 
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
--- a/sound/drivers/opl3/opl3_seq.c	Thu Jun 20 15:54:00 2002
+++ b/sound/drivers/opl3/opl3_seq.c	Thu Jun 20 15:54:00 2002
@@ -272,7 +272,7 @@
 	spin_lock_init(&opl3->sys_timer_lock);
 	opl3->sys_timer_status = 0;
 
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	snd_opl3_init_seq_oss(opl3, cinfo.name);
 #endif
 	return 0;
@@ -286,7 +286,7 @@
 	if (opl3 == NULL)
 		return -EINVAL;
 
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	snd_opl3_free_seq_oss(opl3);
 #endif
 	if (opl3->seq_client >= 0) {
diff -Nru a/sound/drivers/opl3/opl3_voice.h b/sound/drivers/opl3/opl3_voice.h
--- a/sound/drivers/opl3/opl3_voice.h	Thu Jun 20 15:54:01 2002
+++ b/sound/drivers/opl3/opl3_voice.h	Thu Jun 20 15:54:01 2002
@@ -44,7 +44,7 @@
 void snd_opl3_drum_switch(opl3_t *opl3, int note, int on_off, int vel, snd_midi_channel_t *chan);
 
 /* Prototypes for opl3_oss.c */
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 void snd_opl3_init_seq_oss(opl3_t *opl3, char *name);
 void snd_opl3_free_seq_oss(opl3_t *opl3);
 #endif
diff -Nru a/sound/i2c/Makefile b/sound/i2c/Makefile
--- a/sound/i2c/Makefile	Thu Jun 20 15:54:01 2002
+++ b/sound/i2c/Makefile	Thu Jun 20 15:54:01 2002
@@ -9,7 +9,9 @@
 snd-cs8427-objs := cs8427.o
 snd-tea6330t-objs := tea6330t.o
 
-obj-$(CONFIG_SND) += l3/
+ifeq ($(subst m,y,$(CONFIG_L3)),y)
+  obj-$(CONFIG_L3) += l3/
+endif
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_INTERWAVE_STB) += snd-tea6330t.o snd-i2c.o
diff -Nru a/sound/isa/Makefile b/sound/isa/Makefile
--- a/sound/isa/Makefile	Thu Jun 20 15:54:00 2002
+++ b/sound/isa/Makefile	Thu Jun 20 15:54:00 2002
@@ -3,6 +3,8 @@
 # Copyright (c) 2001 by Jaroslav Kysela <perex@suse.cz>
 #
 
+mod-subdirs  := ad1816a ad1848 cs423x es1688 gus opti9xx sb wavefront
+
 snd-als100-objs := als100.o
 snd-azt2320-objs := azt2320.o
 snd-cmi8330-objs := cmi8330.o
diff -Nru a/sound/isa/ad1848/Makefile b/sound/isa/ad1848/Makefile
--- a/sound/isa/ad1848/Makefile	Thu Jun 20 15:54:00 2002
+++ b/sound/isa/ad1848/Makefile	Thu Jun 20 15:54:00 2002
@@ -14,4 +14,6 @@
 obj-$(CONFIG_SND_AD1848) += snd-ad1848.o snd-ad1848-lib.o
 obj-$(CONFIG_SND_OPTI92X_AD1848) += snd-ad1848-lib.o
 
+obj-m := $(sort $(obj-m))
+
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/isa/cs423x/Makefile b/sound/isa/cs423x/Makefile
--- a/sound/isa/cs423x/Makefile	Thu Jun 20 15:54:01 2002
+++ b/sound/isa/cs423x/Makefile	Thu Jun 20 15:54:01 2002
@@ -23,4 +23,6 @@
 obj-$(CONFIG_SND_OPTI92X_CS4231) += snd-cs4231-lib.o
 obj-$(CONFIG_SND_WAVEFRONT) += snd-cs4231-lib.o
 
+obj-m := $(sort $(obj-m))
+
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/isa/cs423x/cs4236.c b/sound/isa/cs423x/cs4236.c
--- a/sound/isa/cs423x/cs4236.c	Thu Jun 20 15:54:00 2002
+++ b/sound/isa/cs423x/cs4236.c	Thu Jun 20 15:54:00 2002
@@ -229,6 +229,8 @@
 	ISAPNP_CS4232('C','S','C',0x4536,0x0000,0x0010,0x0003),
 	/* TerraTec AudioSystem EWS64XL - CS4236B */
 	ISAPNP_CS4232('C','S','C',0xa836,0xa800,0xa810,0xa803),
+	/* TerraTec AudioSystem EWS64XL - CS4236B */
+	ISAPNP_CS4232_WOMPU('C','S','C',0xa836,0xa800,0xa810),
 	/* Crystal Semiconductors CS4237B */
 	ISAPNP_CS4232('C','S','C',0x4637,0x0000,0x0010,0x0003),
 	/* NewClear 3D - CX4237B-XQ3 */
@@ -259,6 +261,8 @@
 	ISAPNP_CS4232('C','S','C',0xd937,0x0000,0x0010,0x0003),
 	/* CS4235 without MPU401 */
 	ISAPNP_CS4232_WOMPU('C','S','C',0xe825,0x0100,0x0110),
+	/* Some noname CS4236 based card */
+	ISAPNP_CS4232('C','S','C',0xe936,0x0000,0x0010,0x0003),
 	/* CS4236B */
 	ISAPNP_CS4232('C','S','C',0xf235,0x0000,0x0010,0x0003),
 	/* CS4236B */
@@ -326,20 +330,22 @@
 	snd_printdd("isapnp WSS: irq=%i, dma1=%i, dma2=%i\n",
 			snd_irq[dev], snd_dma1[dev], snd_dma2[dev]);
 	/* CTRL initialization */
-	pdev = acard->ctrl;
-	if (pdev->prepare(pdev) < 0) {
-		acard->wss->deactivate(acard->wss);
-		return -EAGAIN;
-	}
-	if (snd_cport[dev] != SNDRV_AUTO_PORT)
-		isapnp_resource_change(&pdev->resource[0], snd_cport[dev], 8);
-	if (pdev->activate(pdev)<0) {
-		printk(KERN_ERR IDENT " isapnp configure failed for control (out of resources?)\n");
-		acard->wss->deactivate(acard->wss);
-		return -EBUSY;
+	if (acard->ctrl && snd_cport[dev] >= 0) {
+		pdev = acard->ctrl;
+		if (pdev->prepare(pdev) < 0) {
+			acard->wss->deactivate(acard->wss);
+			return -EAGAIN;
+		}
+		if (snd_cport[dev] != SNDRV_AUTO_PORT)
+			isapnp_resource_change(&pdev->resource[0], snd_cport[dev], 8);
+		if (pdev->activate(pdev)<0) {
+			printk(KERN_ERR IDENT " isapnp configure failed for control (out of resources?)\n");
+			acard->wss->deactivate(acard->wss);
+			return -EBUSY;
+		}
+		snd_cport[dev] = pdev->resource[0].start;
+		snd_printdd("isapnp CTRL: control port=0x%lx\n", snd_cport[dev]);
 	}
-	snd_cport[dev] = pdev->resource[0].start;
-	snd_printdd("isapnp CTRL: control port=0x%lx\n", snd_cport[dev]);
 	/* MPU initialization */
 	if (acard->mpu && snd_mpu_port[dev] >= 0) {
 		pdev = acard->mpu;
diff -Nru a/sound/isa/gus/Makefile b/sound/isa/gus/Makefile
--- a/sound/isa/gus/Makefile	Thu Jun 20 15:54:01 2002
+++ b/sound/isa/gus/Makefile	Thu Jun 20 15:54:01 2002
@@ -33,4 +33,6 @@
   obj-$(CONFIG_SND_INTERWAVE_STB) += snd-gus-synth.o
 endif
 
+obj-m := $(sort $(obj-m))
+
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/isa/gus/gus_pcm.c b/sound/isa/gus/gus_pcm.c
--- a/sound/isa/gus/gus_pcm.c	Thu Jun 20 15:54:01 2002
+++ b/sound/isa/gus/gus_pcm.c	Thu Jun 20 15:54:01 2002
@@ -622,7 +622,7 @@
 	info:			SNDRV_PCM_INFO_NONINTERLEAVED,
 	formats:		(SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |
 				 SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE),
-	rates:			SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_44100,
+	rates:			SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
 	rate_min:		5510,
 	rate_max:		48000,
 	channels_min:		1,
diff -Nru a/sound/isa/gus/gus_synth.c b/sound/isa/gus/gus_synth.c
--- a/sound/isa/gus/gus_synth.c	Thu Jun 20 15:54:01 2002
+++ b/sound/isa/gus/gus_synth.c	Thu Jun 20 15:54:01 2002
@@ -64,6 +64,7 @@
 		voice = snd_gf1_alloc_voice(gus, SNDRV_GF1_VOICE_TYPE_SYNTH, info->sender.client, info->sender.port);
 		if (voice == NULL) {
 			snd_gus_synth_free_voices(gus, info->sender.client, info->sender.port);
+			snd_gus_use_dec(gus);
 			up(&gus->register_mutex);
 			return -EBUSY;
 		}
@@ -80,6 +81,7 @@
 
 	down(&gus->register_mutex);
 	snd_gus_synth_free_voices(gus, info->sender.client, info->sender.port);
+	snd_gus_use_dec(gus);
 	up(&gus->register_mutex);
 	return 0;
 }
diff -Nru a/sound/isa/gus/interwave.c b/sound/isa/gus/interwave.c
--- a/sound/isa/gus/interwave.c	Thu Jun 20 15:53:59 2002
+++ b/sound/isa/gus/interwave.c	Thu Jun 20 15:53:59 2002
@@ -803,7 +803,7 @@
 		return err;
 	}
 	sprintf(pcm->name + strlen(pcm->name), " rev %c", gus->revision + 'A');
-	strcat(pcm->name, " (chip)");
+	strcat(pcm->name, " (codec)");
 	if ((err = snd_cs4231_timer(cs4231, 2, NULL)) < 0) {
 		snd_card_free(card);
 		return err;
diff -Nru a/sound/isa/sb/Makefile b/sound/isa/sb/Makefile
--- a/sound/isa/sb/Makefile	Thu Jun 20 15:54:01 2002
+++ b/sound/isa/sb/Makefile	Thu Jun 20 15:54:01 2002
@@ -12,7 +12,7 @@
 snd-sb8-objs := sb8.o
 snd-sb16-objs := sb16.o
 snd-sbawe-objs := sbawe.o emu8000.o
-snd-emu8000-synth-objs := emu8000_synth.o emu8000_callback.o emu8000_patch.o
+snd-emu8000-synth-objs := emu8000_synth.o emu8000_callback.o emu8000_patch.o emu8000_pcm.o
 snd-es968-objs := es968.o
 
 # Toplevel Module Dependency
@@ -31,5 +31,7 @@
 ifeq ($(subst m,y,$(CONFIG_SND_SEQUENCER)),y)
   obj-$(CONFIG_SND_SBAWE) += snd-emu8000-synth.o
 endif
+
+obj-m := $(sort $(obj-m))
 
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/isa/sb/emu8000.c b/sound/isa/sb/emu8000.c
--- a/sound/isa/sb/emu8000.c	Thu Jun 20 15:54:00 2002
+++ b/sound/isa/sb/emu8000.c	Thu Jun 20 15:54:00 2002
@@ -109,6 +109,8 @@
 /*exported*/ void
 snd_emu8000_dma_chan(emu8000_t *emu, int ch, int mode)
 {
+	unsigned right_bit = (mode & EMU8000_RAM_RIGHT) ? 0x01000000 : 0;
+	mode &= EMU8000_RAM_MODE_MASK;
 	if (mode == EMU8000_RAM_CLOSE) {
 		EMU8000_CCCA_WRITE(emu, ch, 0);
 		EMU8000_DCYSUSV_WRITE(emu, ch, 0x807F);
@@ -122,9 +124,9 @@
 	EMU8000_PSST_WRITE(emu, ch, 0);
 	EMU8000_CSL_WRITE(emu, ch, 0);
 	if (mode == EMU8000_RAM_WRITE) /* DMA write */
-		EMU8000_CCCA_WRITE(emu, ch, 0x06000000);
+		EMU8000_CCCA_WRITE(emu, ch, 0x06000000 | right_bit);
 	else	   /* DMA read */
-		EMU8000_CCCA_WRITE(emu, ch, 0x04000000);
+		EMU8000_CCCA_WRITE(emu, ch, 0x04000000 | right_bit);
 }
 
 /*
diff -Nru a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
--- a/sound/isa/sb/emu8000_callback.c	Thu Jun 20 15:54:00 2002
+++ b/sound/isa/sb/emu8000_callback.c	Thu Jun 20 15:54:00 2002
@@ -34,7 +34,7 @@
 static void reset_voice(snd_emux_t *emu, int ch);
 static void terminate_voice(snd_emux_voice_t *vp);
 static void sysex(snd_emux_t *emu, char *buf, int len, int parsed, snd_midi_channel_set_t *chset);
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 static int oss_ioctl(snd_emux_t *emu, int cmd, int p1, int p2);
 #endif
 static int load_fx(snd_emux_t *emu, int type, int mode, const void *buf, long len);
@@ -73,7 +73,7 @@
 	sample_reset:	snd_emu8000_sample_reset,
 	load_fx:	load_fx,
 	sysex:		sysex,
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	oss_ioctl:	oss_ioctl,
 #endif
 };
@@ -474,7 +474,7 @@
 }
 
 
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 /*
  * OSS ioctl callback
  */
diff -Nru a/sound/isa/sb/emu8000_local.h b/sound/isa/sb/emu8000_local.h
--- a/sound/isa/sb/emu8000_local.h	Thu Jun 20 15:53:59 2002
+++ b/sound/isa/sb/emu8000_local.h	Thu Jun 20 15:53:59 2002
@@ -39,4 +39,7 @@
 /* emu8000_callback.c */
 void snd_emu8000_ops_setup(emu8000_t *emu);
 
+/* emu8000_pcm.c */
+int snd_emu8000_pcm_new(snd_card_t *card, emu8000_t *emu, int index);
+
 #endif	/* __EMU8000_LOCAL_H */
diff -Nru a/sound/isa/sb/emu8000_pcm.c b/sound/isa/sb/emu8000_pcm.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/sound/isa/sb/emu8000_pcm.c	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,709 @@
+/*
+ * pcm emulation on emu8000 wavetable
+ *
+ *  Copyright (C) 2002 Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "emu8000_local.h"
+#include <linux/init.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+
+#define chip_t emu8000_t
+
+/*
+ * define the following if you want to use this pcm with non-interleaved mode
+ */
+/* #define USE_NONINTERLEAVE */
+
+/* NOTE: for using the non-interleaved mode with alsa-lib, you have to set
+ * mmap_emulation flag to 1 in your .asoundrc, such like
+ *
+ *	pcm.emu8k {
+ *		type plug
+ *		slave.pcm {
+ *			type hw
+ *			card 0
+ *			device 1
+ *			mmap_emulation 1
+ *		}
+ *	}
+ *
+ * besides, for the time being, the non-interleaved mode doesn't work well on
+ * alsa-lib...
+ */
+
+
+typedef struct snd_emu8k_pcm emu8k_pcm_t;
+
+struct snd_emu8k_pcm {
+	emu8000_t *emu;
+	snd_pcm_substream_t *substream;
+
+	unsigned int allocated_bytes;
+	snd_util_memblk_t *block;
+	unsigned int offset;
+	unsigned int buf_size;
+	unsigned int period_size;
+	unsigned int loop_start[2];
+	unsigned int pitch;
+	int panning[2];
+	int last_ptr;
+	int period_pos;
+	int voices;
+	unsigned int dram_opened: 1;
+	unsigned int running: 1;
+	unsigned int timer_running: 1;
+	struct timer_list timer;
+	spinlock_t timer_lock;
+};
+
+#define LOOP_BLANK_SIZE		8
+
+
+/*
+ * open up channels for the simultaneous data transfer and playback
+ */
+static int
+emu8k_open_dram_for_pcm(emu8000_t *emu, int channels)
+{
+	int i;
+
+	/* reserve up to 2 voices for playback */
+	snd_emux_lock_voice(emu->emu, 0);
+	if (channels > 1)
+		snd_emux_lock_voice(emu->emu, 1);
+
+	/* reserve 28 voices for loading */
+	for (i = channels + 1; i < EMU8000_DRAM_VOICES; i++) {
+		unsigned int mode = EMU8000_RAM_WRITE;
+		snd_emux_lock_voice(emu->emu, i);
+#ifndef USE_NONINTERLEAVE
+		if (channels > 1 && (i & 1) != 0)
+			mode |= EMU8000_RAM_RIGHT;
+#endif
+		snd_emu8000_dma_chan(emu, i, mode);
+	}
+
+	/* assign voice 31 and 32 to ROM */
+	EMU8000_VTFT_WRITE(emu, 30, 0);
+	EMU8000_PSST_WRITE(emu, 30, 0x1d8);
+	EMU8000_CSL_WRITE(emu, 30, 0x1e0);
+	EMU8000_CCCA_WRITE(emu, 30, 0x1d8);
+	EMU8000_VTFT_WRITE(emu, 31, 0);
+	EMU8000_PSST_WRITE(emu, 31, 0x1d8);
+	EMU8000_CSL_WRITE(emu, 31, 0x1e0);
+	EMU8000_CCCA_WRITE(emu, 31, 0x1d8);
+
+	return 0;
+}
+
+/*
+ */
+static void
+snd_emu8000_write_wait(emu8000_t *emu)
+{
+	while ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+		if (signal_pending(current))
+			break;
+	}
+}
+
+/*
+ * close all channels
+ */
+static void
+emu8k_close_dram(emu8000_t *emu)
+{
+	int i;
+
+	for (i = 0; i < 2; i++)
+		snd_emux_unlock_voice(emu->emu, i);
+	for (; i < EMU8000_DRAM_VOICES; i++) {
+		snd_emu8000_dma_chan(emu, i, EMU8000_RAM_CLOSE);
+		snd_emux_unlock_voice(emu->emu, i);
+	}
+}
+
+/*
+ * convert Hz to AWE32 rate offset (see emux/soundfont.c)
+ */
+
+#define OFFSET_SAMPLERATE	1011119		/* base = 44100 */
+#define SAMPLERATE_RATIO	4096
+
+static int calc_rate_offset(int hz)
+{
+	return snd_sf_linear_to_log(hz, OFFSET_SAMPLERATE, SAMPLERATE_RATIO);
+}
+
+
+/*
+ */
+
+static snd_pcm_hardware_t emu8k_pcm_hw = {
+#ifdef USE_NONINTERLEAVE
+	info:			SNDRV_PCM_INFO_NONINTERLEAVED,
+#else
+	info:			SNDRV_PCM_INFO_INTERLEAVED,
+#endif
+	formats:		SNDRV_PCM_FMTBIT_S16_LE,
+	rates:			SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	rate_min:		4000,
+	rate_max:		48000,
+	channels_min:		1,
+	channels_max:		2,
+	buffer_bytes_max:	(128*1024),
+	period_bytes_min:	1024,
+	period_bytes_max:	(128*1024),
+	periods_min:		2,
+	periods_max:		1024,
+	fifo_size:		0,
+
+};
+
+/*
+ * get the current position at the given channel from CCCA register
+ */
+static inline int emu8k_get_curpos(emu8k_pcm_t *rec, int ch)
+{
+	int val = EMU8000_CCCA_READ(rec->emu, ch) & 0xfffffff;
+	val -= rec->loop_start[ch] - 1;
+	return val;
+}
+
+
+/*
+ * timer interrupt handler
+ * check the current position and update the period if necessary.
+ */
+static void emu8k_pcm_timer_func(unsigned long data)
+{
+	emu8k_pcm_t *rec = (emu8k_pcm_t *)data;
+	int ptr, delta;
+
+	spin_lock(&rec->timer_lock);
+	/* update the current pointer */
+	ptr = emu8k_get_curpos(rec, 0);
+	if (ptr < rec->last_ptr)
+		delta = ptr + rec->buf_size - rec->last_ptr;
+	else
+		delta = ptr - rec->last_ptr;
+	rec->period_pos += delta;
+	rec->last_ptr = ptr;
+
+	/* reprogram timer */
+	rec->timer.expires = jiffies + 1;
+	add_timer(&rec->timer);
+
+	/* update period */
+	if (rec->period_pos >= rec->period_size) {
+		rec->period_pos %= rec->period_size;
+		spin_unlock(&rec->timer_lock);
+		snd_pcm_period_elapsed(rec->substream);
+		return;
+	}
+	spin_unlock(&rec->timer_lock);
+}
+
+
+/*
+ * open pcm
+ * creating an instance here
+ */
+static int emu8k_pcm_open(snd_pcm_substream_t *subs)
+{
+	emu8000_t *emu = snd_pcm_substream_chip(subs);
+	emu8k_pcm_t *rec;
+	snd_pcm_runtime_t *runtime = subs->runtime;
+
+	rec = snd_kcalloc(sizeof(*rec), GFP_KERNEL);
+	if (! rec)
+		return -ENOMEM;
+
+	rec->emu = emu;
+	rec->substream = subs;
+	runtime->private_data = rec;
+
+	spin_lock_init(&rec->timer_lock);
+	init_timer(&rec->timer);
+	rec->timer.function = emu8k_pcm_timer_func;
+	rec->timer.data = (unsigned long)rec;
+
+	runtime->hw = emu8k_pcm_hw;
+	runtime->hw.buffer_bytes_max = emu->mem_size - LOOP_BLANK_SIZE * 3;
+	runtime->hw.period_bytes_max = runtime->hw.buffer_bytes_max / 2;
+
+	/* use timer to update periods.. (specified in msec) */
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME,
+				     (1000000 + HZ - 1) / HZ, UINT_MAX);
+
+	return 0;
+}
+
+static int emu8k_pcm_close(snd_pcm_substream_t *subs)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+	if (rec)
+		kfree(rec);
+	subs->runtime->private_data = 0;
+	return 0;
+}
+
+/*
+ * calculate pitch target
+ */
+static int calc_pitch_target(int pitch)
+{
+	int ptarget = 1 << (pitch >> 12);
+	if (pitch & 0x800) ptarget += (ptarget * 0x102e) / 0x2710;
+	if (pitch & 0x400) ptarget += (ptarget * 0x764) / 0x2710;
+	if (pitch & 0x200) ptarget += (ptarget * 0x389) / 0x2710;
+	ptarget += (ptarget >> 1);
+	if (ptarget > 0xffff) ptarget = 0xffff;
+	return ptarget;
+}
+
+/*
+ * set up the voice
+ */
+static void setup_voice(emu8k_pcm_t *rec, int ch)
+{
+	emu8000_t *hw = rec->emu;
+	unsigned int temp;
+
+	/* channel to be silent and idle */
+	EMU8000_DCYSUSV_WRITE(hw, ch, 0x0080);
+	EMU8000_VTFT_WRITE(hw, ch, 0x0000FFFF);
+	EMU8000_CVCF_WRITE(hw, ch, 0x0000FFFF);
+	EMU8000_PTRX_WRITE(hw, ch, 0);
+	EMU8000_CPF_WRITE(hw, ch, 0);
+
+	/* pitch offset */
+	EMU8000_IP_WRITE(hw, ch, rec->pitch);
+	/* set envelope parameters */
+	EMU8000_ENVVAL_WRITE(hw, ch, 0x8000);
+	EMU8000_ATKHLD_WRITE(hw, ch, 0x7f7f);
+	EMU8000_DCYSUS_WRITE(hw, ch, 0x7f7f);
+	EMU8000_ENVVOL_WRITE(hw, ch, 0x8000);
+	EMU8000_ATKHLDV_WRITE(hw, ch, 0x7f7f);
+	/* decay/sustain parameter for volume envelope is used
+	   for triggerg the voice */
+	/* modulation envelope heights */
+	EMU8000_PEFE_WRITE(hw, ch, 0x0);
+	/* lfo1/2 delay */
+	EMU8000_LFO1VAL_WRITE(hw, ch, 0x8000);
+	EMU8000_LFO2VAL_WRITE(hw, ch, 0x8000);
+	/* lfo1 pitch & cutoff shift */
+	EMU8000_FMMOD_WRITE(hw, ch, 0);
+	/* lfo1 volume & freq */
+	EMU8000_TREMFRQ_WRITE(hw, ch, 0);
+	/* lfo2 pitch & freq */
+	EMU8000_FM2FRQ2_WRITE(hw, ch, 0);
+	/* pan & loop start */
+	temp = rec->panning[ch];
+	temp = (temp <<24) | ((unsigned int)rec->loop_start[ch] - 1);
+	EMU8000_PSST_WRITE(hw, ch, temp);
+	/* chorus & loop end (chorus 8bit, MSB) */
+	temp = 0; // chorus
+	temp = (temp << 24) | ((unsigned int)rec->loop_start[ch] + rec->buf_size - 1);
+	EMU8000_CSL_WRITE(hw, ch, temp);
+	/* Q & current address (Q 4bit value, MSB) */
+	temp = 0; // filterQ
+	temp = (temp << 28) | ((unsigned int)rec->loop_start[ch] - 1);
+	EMU8000_CCCA_WRITE(hw, ch, temp);
+	/* clear unknown registers */
+	EMU8000_00A0_WRITE(hw, ch, 0);
+	EMU8000_0080_WRITE(hw, ch, 0);
+}
+
+/*
+ * trigger the voice
+ */
+static void start_voice(emu8k_pcm_t *rec, int ch)
+{
+	unsigned long flags;
+	emu8000_t *hw = rec->emu;
+	unsigned int temp, aux;
+	int pt = calc_pitch_target(rec->pitch);
+
+	/* cutoff and volume */
+	EMU8000_IFATN_WRITE(hw, ch, 0xff00);
+	EMU8000_VTFT_WRITE(hw, ch, 0xffff);
+	EMU8000_CVCF_WRITE(hw, ch, 0xffff);
+	/* trigger envelope */
+	EMU8000_DCYSUSV_WRITE(hw, ch, 0x7f7f);
+	/* set reverb and pitch target */
+	temp = 0; // reverb
+	if (rec->panning[ch] == 0)
+		aux = 0xff;
+	else
+		aux = (-rec->panning[ch]) & 0xff;
+	temp = (temp << 8) | (pt << 16) | aux;
+	EMU8000_PTRX_WRITE(hw, ch, temp);
+	EMU8000_CPF_WRITE(hw, ch, pt << 16);
+
+	/* start timer */
+	spin_lock_irqsave(&rec->timer_lock, flags);
+	if (! rec->timer_running) {
+		rec->timer.expires = jiffies + 1;
+		add_timer(&rec->timer);
+		rec->timer_running = 1;
+	}
+	spin_unlock_irqrestore(&rec->timer_lock, flags);
+}
+
+/*
+ * stop the voice immediately
+ */
+static void stop_voice(emu8k_pcm_t *rec, int ch)
+{
+	unsigned long flags;
+	emu8000_t *hw = rec->emu;
+
+	EMU8000_DCYSUSV_WRITE(hw, ch, 0x807F);
+
+	/* stop timer */
+	spin_lock_irqsave(&rec->timer_lock, flags);
+	if (rec->timer_running) {
+		del_timer(&rec->timer);
+		rec->timer_running = 0;
+	}
+	spin_unlock_irqrestore(&rec->timer_lock, flags);
+}
+
+static int emu8k_pcm_trigger(snd_pcm_substream_t *subs, int cmd)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+	int ch;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		for (ch = 0; ch < rec->voices; ch++)
+			start_voice(rec, ch);
+		rec->running = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		rec->running = 0;
+		for (ch = 0; ch < rec->voices; ch++)
+			stop_voice(rec, ch);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+/*
+ * copy / silence ops
+ */
+
+/*
+ * this macro should be inserted in the copy/silence loops
+ * to reduce the latency.  without this, the system will hang up
+ * during the whole loop.
+ */
+#define CHECK_SCHEDULER() \
+do { \
+	if (need_resched()) {\
+		if (current->state != TASK_RUNNING)\
+			set_current_state(TASK_RUNNING);\
+		schedule();\
+		if (signal_pending(current))\
+			return -EAGAIN;\
+	}\
+} while (0)
+
+
+#ifdef USE_NONINTERLEAVE
+/* copy one channel block */
+static int emu8k_transfer_block(emu8000_t *emu, int offset, unsigned short *buf, int count)
+{
+	EMU8000_SMALW_WRITE(emu, offset);
+	while (count > 0) {
+		unsigned short sval;
+		CHECK_SCHEDULER();
+		get_user(sval, buf);
+		EMU8000_SMLD_WRITE(emu, sval);
+		buf++;
+		count--;
+	}
+	return 0;
+}
+
+static int emu8k_pcm_copy(snd_pcm_substream_t *subs,
+			  int voice,
+			  snd_pcm_uframes_t pos,
+			  void *src,
+			  snd_pcm_uframes_t count)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+	emu8000_t *emu = rec->emu;
+
+	snd_emu8000_write_wait(emu);
+	if (voice == -1) {
+		unsigned short *buf = src;
+		int i, err;
+		count /= rec->voices;
+		for (i = 0; i < rec->voices; i++) {
+			err = emu8k_transfer_block(emu, pos + rec->loop_start[i], buf, count);
+			if (err < 0)
+				return err;
+			buf += count;
+		}
+		return 0;
+	} else {
+		return emu8k_transfer_block(emu, pos + rec->loop_start[voice], src, count);
+	}
+}
+
+/* make a channel block silence */
+static int emu8k_silence_block(emu8000_t *emu, int offset, int count)
+{
+	EMU8000_SMALW_WRITE(emu, offset);
+	while (count > 0) {
+		CHECK_SCHEDULER();
+		EMU8000_SMLD_WRITE(emu, 0);
+		count--;
+	}
+	return 0;
+}
+
+static int emu8k_pcm_silence(snd_pcm_substream_t *subs,
+			     int voice,
+			     snd_pcm_uframes_t pos,
+			     snd_pcm_uframes_t count)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+	emu8000_t *emu = rec->emu;
+
+	snd_emu8000_write_wait(emu);
+	if (voice == -1 && rec->voices == 1)
+		voice = 0;
+	if (voice == -1) {
+		int err;
+		err = emu8k_silence_block(emu, pos + rec->loop_start[0], count / 2);
+		if (err < 0)
+			return err;
+		return emu8k_silence_block(emu, pos + rec->loop_start[1], count / 2);
+	} else {
+		return emu8k_silence_block(emu, pos + rec->loop_start[voice], count);
+	}
+}
+
+#else /* interleave */
+
+/*
+ * copy the interleaved data can be done easily by using
+ * DMA "left" and "right" channels on emu8k engine.
+ */
+static int emu8k_pcm_copy(snd_pcm_substream_t *subs,
+			  int voice,
+			  snd_pcm_uframes_t pos,
+			  void *src,
+			  snd_pcm_uframes_t count)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+	emu8000_t *emu = rec->emu;
+	unsigned short *buf = src;
+
+	snd_emu8000_write_wait(emu);
+	EMU8000_SMALW_WRITE(emu, pos + rec->loop_start[0]);
+	if (rec->voices > 1)
+		EMU8000_SMARW_WRITE(emu, pos + rec->loop_start[1]);
+
+	while (count-- > 0) {
+		unsigned short sval;
+		CHECK_SCHEDULER();
+		get_user(sval, buf);
+		EMU8000_SMLD_WRITE(emu, sval);
+		buf++;
+		if (rec->voices > 1) {
+			CHECK_SCHEDULER();
+			get_user(sval, buf);
+			EMU8000_SMRD_WRITE(emu, sval);
+			buf++;
+		}
+	}
+	return 0;
+}
+
+static int emu8k_pcm_silence(snd_pcm_substream_t *subs,
+			     int voice,
+			     snd_pcm_uframes_t pos,
+			     snd_pcm_uframes_t count)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+	emu8000_t *emu = rec->emu;
+
+	snd_emu8000_write_wait(emu);
+	EMU8000_SMALW_WRITE(emu, rec->loop_start[0] + pos);
+	if (rec->voices > 1)
+		EMU8000_SMARW_WRITE(emu, rec->loop_start[1] + pos);
+	while (count-- > 0) {
+		CHECK_SCHEDULER();
+		EMU8000_SMLD_WRITE(emu, 0);
+		if (rec->voices > 1) {
+			CHECK_SCHEDULER();
+			EMU8000_SMRD_WRITE(emu, 0);
+		}
+	}
+	return 0;
+}
+#endif
+
+
+/*
+ * allocate a memory block
+ */
+static int emu8k_pcm_hw_params(snd_pcm_substream_t *subs,
+			       snd_pcm_hw_params_t *hw_params)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+
+	if (rec->block) {
+		/* reallocation - release the old block */
+		snd_util_mem_free(rec->emu->memhdr, rec->block);
+		rec->block = NULL;
+	}
+
+	rec->allocated_bytes = params_buffer_bytes(hw_params) + LOOP_BLANK_SIZE * 4;
+	rec->block = snd_util_mem_alloc(rec->emu->memhdr, rec->allocated_bytes);
+	if (! rec->block)
+		return -ENOMEM;
+	rec->offset = EMU8000_DRAM_OFFSET + (rec->block->offset >> 1); /* in word */
+	/* at least dma_bytes must be set for non-interleaved mode */
+	subs->dma_bytes = params_buffer_bytes(hw_params);
+
+	return 0;
+}
+
+/*
+ * free the memory block
+ */
+static int emu8k_pcm_hw_free(snd_pcm_substream_t *subs)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+
+	if (rec->block) {
+		int ch;
+		for (ch = 0; ch < rec->voices; ch++)
+			stop_voice(rec, ch); // to be sure
+		if (rec->dram_opened)
+			emu8k_close_dram(rec->emu);
+		snd_util_mem_free(rec->emu->memhdr, rec->block);
+		rec->block = NULL;
+	}
+	return 0;
+}
+
+/*
+ */
+static int emu8k_pcm_prepare(snd_pcm_substream_t *subs)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+
+	rec->pitch = 0xe000 + calc_rate_offset(subs->runtime->rate);
+	rec->last_ptr = 0;
+	rec->period_pos = 0;
+
+	rec->buf_size = subs->runtime->buffer_size;
+	rec->period_size = subs->runtime->period_size;
+	rec->voices = subs->runtime->channels;
+	rec->loop_start[0] = rec->offset + LOOP_BLANK_SIZE;
+	if (rec->voices > 1)
+		rec->loop_start[1] = rec->loop_start[0] + rec->buf_size + LOOP_BLANK_SIZE;
+	if (rec->voices > 1) {
+		rec->panning[0] = 0xff;
+		rec->panning[1] = 0x00;
+	} else
+		rec->panning[0] = 0x80;
+
+	if (! rec->dram_opened) {
+		int err, i, ch;
+
+		snd_emux_terminate_all(rec->emu->emu);
+		if ((err = emu8k_open_dram_for_pcm(rec->emu, rec->voices)) != 0)
+			return err;
+		rec->dram_opened = 1;
+
+		/* clear loop blanks */
+		snd_emu8000_write_wait(rec->emu);
+		EMU8000_SMALW_WRITE(rec->emu, rec->offset);
+		for (i = 0; i < LOOP_BLANK_SIZE; i++)
+			EMU8000_SMLD_WRITE(rec->emu, 0);
+		for (ch = 0; ch < rec->voices; ch++) {
+			EMU8000_SMALW_WRITE(rec->emu, rec->loop_start[ch] + rec->buf_size);
+			for (i = 0; i < LOOP_BLANK_SIZE; i++)
+				EMU8000_SMLD_WRITE(rec->emu, 0);
+		}
+	}
+
+	setup_voice(rec, 0);
+	if (rec->voices > 1)
+		setup_voice(rec, 1);
+	return 0;
+}
+
+static snd_pcm_uframes_t emu8k_pcm_pointer(snd_pcm_substream_t *subs)
+{
+	emu8k_pcm_t *rec = subs->runtime->private_data;
+	if (rec->running)
+		return emu8k_get_curpos(rec, 0);
+	return 0;
+}
+
+
+static snd_pcm_ops_t emu8k_pcm_ops = {
+	open:		emu8k_pcm_open,
+	close:		emu8k_pcm_close,
+	ioctl:		snd_pcm_lib_ioctl,
+	hw_params:	emu8k_pcm_hw_params,
+	hw_free:	emu8k_pcm_hw_free,
+	prepare:	emu8k_pcm_prepare,
+	trigger:	emu8k_pcm_trigger,
+	pointer:	emu8k_pcm_pointer,
+	copy:		emu8k_pcm_copy,
+	silence:	emu8k_pcm_silence,
+};
+
+
+static void snd_emu8000_pcm_free(snd_pcm_t *pcm)
+{
+	emu8000_t *emu = pcm->private_data;
+	emu->pcm = NULL;
+}
+
+int snd_emu8000_pcm_new(snd_card_t *card, emu8000_t *emu, int index)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(card, "Emu8000 PCM", index, 1, 0, &pcm)) < 0)
+		return err;
+	pcm->private_data = emu;
+	pcm->private_free = snd_emu8000_pcm_free;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &emu8k_pcm_ops);
+	emu->pcm = pcm;
+
+	snd_device_register(card, pcm);
+
+	return 0;
+}
diff -Nru a/sound/isa/sb/emu8000_synth.c b/sound/isa/sb/emu8000_synth.c
--- a/sound/isa/sb/emu8000_synth.c	Thu Jun 20 15:54:00 2002
+++ b/sound/isa/sb/emu8000_synth.c	Thu Jun 20 15:54:00 2002
@@ -70,6 +70,7 @@
 	emu->memhdr = hw->memhdr;
 	emu->midi_ports = hw->seq_ports < 2 ? hw->seq_ports : 2; /* number of virmidi ports */
 	emu->midi_devidx = 1;
+	emu->linear_panning = 1;
 
 	if (snd_emux_register(emu, dev->card, hw->index, "Emu8000") < 0) {
 		snd_emux_free(emu);
@@ -79,6 +80,9 @@
 		return -ENOMEM;
 	}
 
+	if (hw->mem_size > 0)
+		snd_emu8000_pcm_new(dev->card, hw, 1);
+
 	dev->driver_data = hw;
 
 	return 0;
@@ -96,6 +100,8 @@
 		return 0; /* no synth was allocated actually */
 
 	hw = dev->driver_data;
+	if (hw->pcm)
+		snd_device_free(dev->card, hw->pcm);
 	if (hw->emu)
 		snd_emux_free(hw->emu);
 	if (hw->memhdr)
diff -Nru a/sound/isa/sb/es968.c b/sound/isa/sb/es968.c
--- a/sound/isa/sb/es968.c	Thu Jun 20 15:54:01 2002
+++ b/sound/isa/sb/es968.c	Thu Jun 20 15:54:01 2002
@@ -152,7 +152,7 @@
 }
 #endif	/* __ISAPNP__ */
 
-static void __exit snd_card_es968_free(snd_card_t *card)
+static void snd_card_es968_free(snd_card_t *card)
 {
 	struct snd_card_es968 *acard = (struct snd_card_es968 *)card->private_data;
 
diff -Nru a/sound/isa/sb/sb16_csp.c b/sound/isa/sb/sb16_csp.c
--- a/sound/isa/sb/sb16_csp.c	Thu Jun 20 15:54:01 2002
+++ b/sound/isa/sb/sb16_csp.c	Thu Jun 20 15:54:01 2002
@@ -215,7 +215,7 @@
 		info.run_width = p->run_width;
 		info.version = p->version;
 		info.state = p->running;
-		err = copy_to_user((void *) arg, &info, sizeof(info)) ? -EFAULT : 0;
+		err = copy_to_user((void *) arg, &info, sizeof(info));
 		break;
 
 		/* load CSP microcode */
diff -Nru a/sound/last.c b/sound/last.c
--- a/sound/last.c	Thu Jun 20 15:54:00 2002
+++ b/sound/last.c	Thu Jun 20 15:54:00 2002
@@ -19,10 +19,9 @@
  *
  */
 
-#include <linux/init.h>
-
 #define SNDRV_MAIN_OBJECT_FILE
 #include <sound/driver.h>
+#include <linux/init.h>
 #include <sound/core.h>
 
 static int __init alsa_sound_last_init(void)
diff -Nru a/sound/oss/Config.in b/sound/oss/Config.in
--- a/sound/oss/Config.in	Thu Jun 20 15:54:01 2002
+++ b/sound/oss/Config.in	Thu Jun 20 15:54:01 2002
@@ -31,7 +31,7 @@
     fi
 fi
 dep_tristate '  Creative SBLive! (EMU10K1)' CONFIG_SOUND_EMU10K1 $CONFIG_SOUND $CONFIG_PCI
-dep_mbool    '    Creative SBLive! MIDI' CONFIG_MIDI_EMU10K1 $CONFIG_SOUND_EMU10K1 $CONFIG_EXPERIMENTAL
+dep_mbool    '    Creative SBLive! MIDI (EXPERIMENTAL)' CONFIG_MIDI_EMU10K1 $CONFIG_SOUND_EMU10K1 $CONFIG_EXPERIMENTAL
 dep_tristate '  Crystal SoundFusion (CS4280/461x)' CONFIG_SOUND_FUSION $CONFIG_SOUND
 dep_tristate '  Crystal Sound CS4281' CONFIG_SOUND_CS4281 $CONFIG_SOUND
 dep_tristate '  Ensoniq AudioPCI (ES1370)' CONFIG_SOUND_ES1370 $CONFIG_SOUND $CONFIG_PCI $CONFIG_SOUND_GAMEPORT
@@ -40,7 +40,7 @@
 dep_tristate '  ESS Maestro, Maestro2, Maestro2E driver' CONFIG_SOUND_MAESTRO $CONFIG_SOUND
 dep_tristate '  ESS Maestro3/Allegro driver (EXPERIMENTAL)' CONFIG_SOUND_MAESTRO3 $CONFIG_SOUND $CONFIG_PCI $CONFIG_EXPERIMENTAL
 dep_tristate '  Intel ICH (i8xx) audio support' CONFIG_SOUND_ICH $CONFIG_PCI
-dep_tristate '  RME Hammerfall (RME96XX) support' CONFIG_SOUND_RME96XX $CONFIG_SOUND $CONFIG_PCI $CONFIG_EXPERIMENTAL
+dep_tristate '  RME Hammerfall (RME96XX) support (EXPERIMENTAL)' CONFIG_SOUND_RME96XX $CONFIG_SOUND $CONFIG_PCI $CONFIG_EXPERIMENTAL
 dep_tristate '  S3 SonicVibes' CONFIG_SOUND_SONICVIBES $CONFIG_SOUND $CONFIG_SOUND_GAMEPORT
 if [ "$CONFIG_VISWS" = "y" ]; then
     dep_tristate '  SGI Visual Workstation Sound' CONFIG_SOUND_VWSND $CONFIG_SOUND
diff -Nru a/sound/oss/Makefile b/sound/oss/Makefile
--- a/sound/oss/Makefile	Thu Jun 20 15:54:00 2002
+++ b/sound/oss/Makefile	Thu Jun 20 15:54:00 2002
@@ -108,127 +108,67 @@
 
 # Turtle Beach Maui / Tropez
 
-maui.o: maui_boot.h
+$(obj)/maui.o: $(obj)/maui_boot.h
 
 ifeq ($(CONFIG_MAUI_HAVE_BOOT),y)
-    maui_boot.h: $(patsubst "%", %, $(CONFIG_MAUI_BOOT_FILE)) bin2hex
-	./bin2hex -i maui_os < $(CONFIG_MAUI_BOOT_FILE) > $@
+    $(obj)/maui_boot.h: $(patsubst "%", %, $(CONFIG_MAUI_BOOT_FILE)) $(obj)/bin2hex
+	$(obj)/bin2hex -i maui_os < $< > $@
 else
-    maui_boot.h:
+    $(obj)/maui_boot.h:
 	(							\
 	    echo 'static unsigned char * maui_os = NULL;';	\
 	    echo 'static int maui_osLen = 0;';			\
 	) > $@
 endif
-	@ ( \
-	    echo 'ifeq ($(strip $(CONFIG_MAUI_HAVE_BOOT) $(CONFIG_MAUI_BOOT_FILE)),$$(strip $$(CONFIG_MAUI_HAVE_BOOT) $$(CONFIG_MAUI_BOOT_FILE)))'; \
-	    echo 'FILES_BOOT_UP_TO_DATE += $@'; \
-	    echo 'endif' \
-	) > .$@.boot
-
-
 
 # Turtle Beach MultiSound
 
 ifeq ($(CONFIG_MSNDCLAS_HAVE_BOOT),y)
-    msnd_classic.o: msndperm.c msndinit.c
+    $(obj)/msnd_classic.o: $(obj)/msndperm.c $(obj)/msndinit.c
+
+    $(obj)/msndperm.c: $(patsubst "%", %, $(CONFIG_MSNDCLAS_PERM_FILE)) $(obj)/bin2hex
+	$(obj)/bin2hex msndperm < $< > $@
 
-    msndperm.c: $(patsubst "%", %, $(CONFIG_MSNDCLAS_PERM_FILE)) bin2hex
-	./bin2hex msndperm < $(CONFIG_MSNDCLAS_PERM_FILE) > $@
-	@ ( \
-	    echo 'ifeq ($(strip $(CONFIG_MSNDCLAS_HAVE_BOOT) $(CONFIG_MSNDCLAS_PERM_FILE)),$$(strip $$(CONFIG_MSNDCLAS_HAVE_BOOT) $$(CONFIG_MSNDCLAS_PERM_FILE)))'; \
-	    echo 'FILES_BOOT_UP_TO_DATE += $@'; \
-	    echo 'endif' \
-	) > .$@.boot
-
-    msndinit.c: $(patsubst "%", %, $(CONFIG_MSNDCLAS_INIT_FILE)) bin2hex
-	./bin2hex msndinit < $(CONFIG_MSNDCLAS_INIT_FILE) > $@
-	@ ( \
-	    echo 'ifeq ($(strip $(CONFIG_MSNDCLAS_HAVE_BOOT) $(CONFIG_MSNDCLAS_INIT_FILE)),$$(strip $$(CONFIG_MSNDCLAS_HAVE_BOOT) $$(CONFIG_MSNDCLAS_INIT_FILE)))'; \
-	    echo 'FILES_BOOT_UP_TO_DATE += $@'; \
-	    echo 'endif' \
-	) > .$@.boot
+    $(obj)/msndinit.c: $(patsubst "%", %, $(CONFIG_MSNDCLAS_INIT_FILE)) $(obj)/bin2hex
+	$(obj)/bin2hex msndinit < $< > $@
 endif
 
 ifeq ($(CONFIG_MSNDPIN_HAVE_BOOT),y)
-    msnd_pinnacle.o: pndsperm.c pndspini.c
-
-    pndsperm.c: $(patsubst "%", %, $(CONFIG_MSNDPIN_PERM_FILE)) bin2hex
-	./bin2hex pndsperm < $(CONFIG_MSNDPIN_PERM_FILE) > $@
-	@ ( \
-	    echo 'ifeq ($(strip $(CONFIG_MSNDPIN_HAVE_BOOT) $(CONFIG_MSNDPIN_PERM_FILE)),$$(strip $$(CONFIG_MSNDPIN_HAVE_BOOT) $$(CONFIG_MSNDPIN_PERM_FILE)))'; \
-	    echo 'FILES_BOOT_UP_TO_DATE += $@'; \
-	    echo 'endif' \
-	) > .$@.boot
-
-    pndspini.c: $(patsubst "%", %, $(CONFIG_MSNDPIN_INIT_FILE)) bin2hex
-	./bin2hex pndspini < $(CONFIG_MSNDPIN_INIT_FILE) > $@
-	@ ( \
-	    echo 'ifeq ($(strip $(CONFIG_MSNDPIN_HAVE_BOOT) $(CONFIG_MSNDPIN_INIT_FILE)),$$(strip $$(CONFIG_MSNDPIN_HAVE_BOOT) $$(CONFIG_MSNDPIN_INIT_FILE)))'; \
-	    echo 'FILES_BOOT_UP_TO_DATE += $@'; \
-	    echo 'endif' \
-	) > .$@.boot
-endif
+    $(obj)/msnd_pinnacle.o: $(obj)/pndsperm.c $(obj)/pndspini.c
 
+    $(obj)/pndsperm.c: $(patsubst "%", %, $(CONFIG_MSNDPIN_PERM_FILE)) $(obj)/bin2hex
+	$(obj)/bin2hex pndsperm < $< > $@
 
+    $(obj)/pndspini.c: $(patsubst "%", %, $(CONFIG_MSNDPIN_INIT_FILE)) $(obj)/bin2hex
+	$(obj)/bin2hex pndspini < $< > $@
+endif
 
 # PSS (ECHO-ADI2111)
 
-pss.o: pss_boot.h
+$(obj)/pss.o: $(obj)/pss_boot.h
 
 ifeq ($(CONFIG_PSS_HAVE_BOOT),y)
-    pss_boot.h: $(patsubst "%", %, $(CONFIG_PSS_BOOT_FILE)) bin2hex
-	./bin2hex pss_synth < $(CONFIG_PSS_BOOT_FILE) > $@
+    $(obj)/pss_boot.h: $(patsubst "%", %, $(CONFIG_PSS_BOOT_FILE)) $(obj)/bin2hex
+	$(obj)/bin2hex pss_synth < $< > $@
 else
-    pss_boot.h:
+    $(obj)/pss_boot.h:
 	(							\
 	    echo 'static unsigned char * pss_synth = NULL;';	\
 	    echo 'static int pss_synthLen = 0;';		\
 	) > $@
 endif
-	@ ( \
-	    echo 'ifeq ($(strip $(CONFIG_PSS_HAVE_BOOT) $(CONFIG_PSS_BOOT_FILE)),$$(strip $$(CONFIG_PSS_HAVE_BOOT) $$(CONFIG_PSS_BOOT_FILE)))'; \
-	    echo 'FILES_BOOT_UP_TO_DATE += $@'; \
-	    echo 'endif' \
-	) > .$@.boot
-
-
 
 # MediaTrix AudioTrix Pro
 
-trix.o: trix_boot.h
+$(obj)/trix.o: $(obj)/trix_boot.h
 
 ifeq ($(CONFIG_TRIX_HAVE_BOOT),y)
-    trix_boot.h: $(patsubst "%", %, $(CONFIG_TRIX_BOOT_FILE)) hex2hex
-	./hex2hex -i trix_boot < $(CONFIG_TRIX_BOOT_FILE) > $@
+    $(obj)/trix_boot.h: $(patsubst "%", %, $(CONFIG_TRIX_BOOT_FILE)) $(obj)/hex2hex
+	$(obj)/hex2hex -i trix_boot < $< > $@
 else
-    trix_boot.h:
+    $(obj)/trix_boot.h:
 	(							\
 	    echo 'static unsigned char * trix_boot = NULL;';	\
 	    echo 'static int trix_boot_len = 0;';		\
 	) > $@
-endif
-	@ ( \
-	    echo 'ifeq ($(strip $(CONFIG_TRIX_HAVE_BOOT) $(CONFIG_TRIX_BOOT_FILE)),$$(strip $$(CONFIG_TRIX_HAVE_BOOT) $$(CONFIG_TRIX_BOOT_FILE)))'; \
-	    echo 'FILES_BOOT_UP_TO_DATE += $@'; \
-	    echo 'endif' \
-	) > .$@.boot
-
-
-
-# Find boot files whose source file names have changed and force rebuild.
-
-FILES_BOOT_UP_TO_DATE :=
-
-FILES_BOOT_EXIST := $(wildcard .*.boot)
-ifneq ($(FILES_BOOT_EXIST),)
-include $(FILES_BOOT_EXIST)
-endif
-
-FILES_BOOT_CHANGED := $(strip \
-    $(filter-out $(FILES_BOOT_UP_TO_DATE), \
-	maui_boot.h pss_boot.h trix_boot.h))
-
-ifneq ($(FILES_BOOT_CHANGED),)
-$(FILES_BOOT_CHANGED): FORCE
 endif
diff -Nru a/sound/pci/Config.help b/sound/pci/Config.help
--- a/sound/pci/Config.help	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/Config.help	Thu Jun 20 15:54:00 2002
@@ -30,6 +30,10 @@
   Say 'Y' or 'M' to include support for RME Hammerfall (RME Digi9652 /
   Digi9636) soundcards.
 
+CONFIG_SND_HDSP
+  Say 'Y' or 'M' to include support for RME Hammerfall DSP Audio
+  soundcards.
+
 CONFIG_SND_TRIDENT
 
 CONFIG_SND_YMFPCI
diff -Nru a/sound/pci/Config.in b/sound/pci/Config.in
--- a/sound/pci/Config.in	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/Config.in	Thu Jun 20 15:54:01 2002
@@ -14,6 +14,7 @@
 dep_tristate 'RME Digi32, 32/8, 32 PRO' CONFIG_SND_RME32 $CONFIG_SND
 dep_tristate 'RME Digi96, 96/8, 96/8 PRO' CONFIG_SND_RME96 $CONFIG_SND
 dep_tristate 'RME Digi9652 (Hammerfall)' CONFIG_SND_RME9652 $CONFIG_SND
+dep_tristate 'RME Hammerfall DSP Audio' CONFIG_SND_HDSP $CONFIG_SND
 dep_tristate 'Trident 4D-Wave DX/NX; SiS 7018' CONFIG_SND_TRIDENT $CONFIG_SND
 dep_tristate 'Yamaha YMF724/740/744/754' CONFIG_SND_YMFPCI $CONFIG_SND
 dep_tristate 'Avance Logic ALS4000' CONFIG_SND_ALS4000 $CONFIG_SND
diff -Nru a/sound/pci/ac97/Makefile b/sound/pci/ac97/Makefile
--- a/sound/pci/ac97/Makefile	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/ac97/Makefile	Thu Jun 20 15:54:00 2002
@@ -26,4 +26,6 @@
 obj-$(CONFIG_SND_TRIDENT) += snd-ac97-codec.o
 obj-$(CONFIG_SND_YMFPCI) += snd-ac97-codec.o
 
+obj-m := $(sort $(obj-m))
+
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/pci/ac97/ac97_codec.c b/sound/pci/ac97/ac97_codec.c
--- a/sound/pci/ac97/ac97_codec.c	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/ac97/ac97_codec.c	Thu Jun 20 15:54:00 2002
@@ -60,7 +60,7 @@
 static int patch_sigmatel_stac9744(ac97_t * ac97);
 static int patch_sigmatel_stac9756(ac97_t * ac97);
 static int patch_cirrus_cs4299(ac97_t * ac97);
-static int patch_cirrus_cs4205(ac97_t * ac97);
+static int patch_cirrus_spdif(ac97_t * ac97);
 static int patch_ad1819(ac97_t * ac97);
 static int patch_ad1881(ac97_t * ac97);
 static int patch_ad1886(ac97_t * ac97);
@@ -107,14 +107,18 @@
 { 0x414c4300, 0xfffffff0, "RL5306",	 	NULL },
 { 0x414c4310, 0xfffffff0, "RL5382", 		NULL },
 { 0x414c4320, 0xfffffff0, "RL5383", 		NULL },
-{ 0x414c4710, 0xffffffff, "ALC200/200P",	NULL },
+{ 0x414c4710, 0xfffffff0, "ALC200/200P",	NULL },
+{ 0x414c4720, 0xfffffff0, "ALC650",		NULL },
+{ 0x414c4730, 0xffffffff, "ALC101",		NULL },
+{ 0x414c4740, 0xfffffff0, "ALC202",		NULL },
+{ 0x414c4750, 0xfffffff0, "ALC250",		NULL },
 { 0x43525900, 0xfffffff8, "CS4297",		NULL },
-{ 0x43525910, 0xfffffff8, "CS4297A",		NULL },
+{ 0x43525910, 0xfffffff8, "CS4297A",		patch_cirrus_spdif },
 { 0x42525920, 0xfffffff8, "CS4294/4298",	NULL },
 { 0x42525928, 0xfffffff8, "CS4294",		NULL },
 { 0x43525930, 0xfffffff8, "CS4299",		patch_cirrus_cs4299 },
 { 0x43525948, 0xfffffff8, "CS4201",		NULL },
-{ 0x43525958, 0xfffffff8, "CS4205",		patch_cirrus_cs4205 },
+{ 0x43525958, 0xfffffff8, "CS4205",		patch_cirrus_spdif },
 { 0x43525960, 0xfffffff8, "CS4291",		NULL },
 { 0x48525300, 0xffffff00, "HMP9701",		NULL },
 { 0x49434501, 0xffffffff, "ICE1230",		NULL },
@@ -158,9 +162,10 @@
 #define AC97_ID_STAC9721	0x83847609
 #define AC97_ID_STAC9744	0x83847644
 #define AC97_ID_STAC9756	0x83847656
-
-#define SPDIF_CS4205            0x68
-#define MODE_CS4205            0x5e
+#define AC97_ID_CS4297A		0x43525910
+#define AC97_ID_CS4299		0x43525930
+#define AC97_ID_CS4201		0x43525948
+#define AC97_ID_CS4205		0x43525958
 
 static const char *snd_ac97_stereo_enhancements[] =
 {
@@ -760,7 +765,7 @@
 		case 2: x = 0; break;  // 48.0
 		default: x = 0; break; // illegal.
 		}
-		change = snd_ac97_update_bits(ac97, SPDIF_CS4205, 0x3fff, ((val & 0xcfff) | (x << 12)));
+		change = snd_ac97_update_bits(ac97, AC97_CSR_SPDIF, 0x3fff, ((val & 0xcfff) | (x << 12)));
 	} else {
 		change = snd_ac97_update_bits(ac97, AC97_SPDIF, 0x3fff, val);
 	}
@@ -798,9 +803,9 @@
 	AC97_SINGLE(SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "AC97-SPSA",AC97_EXTENDED_STATUS, 4, 3, 0)
 };
 
-static const snd_kcontrol_new_t snd_ac97_cs4205_controls_spdif[2] = {
-    AC97_SINGLE(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH),SPDIF_CS4205, 15, 1, 0),
-    AC97_SINGLE(SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "AC97-SPSA",MODE_CS4205, 0, 3, 0)
+static const snd_kcontrol_new_t snd_ac97_cirrus_controls_spdif[2] = {
+    AC97_SINGLE(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH), AC97_CSR_SPDIF, 15, 1, 0),
+    AC97_SINGLE(SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "AC97-SPSA", AC97_CSR_ACMODE, 0, 3, 0)
 };
 
 #define AD18XX_PCM_BITS(xname, codec, shift, mask) \
@@ -1007,6 +1012,21 @@
 	snd_ac97_write_cache(ac97, reg, 0x8080);
 }
 
+static void snd_ac97_change_volume_params3(ac97_t * ac97, int reg, unsigned char *max)
+{
+	unsigned short val, val1;
+
+	*max = 31;
+	val = 0x8000 | 0x0010;
+	snd_ac97_write(ac97, reg, val);
+	val1 = snd_ac97_read(ac97, reg);
+	if (val != val1) {
+		*max = 15;
+	}
+	/* reset volume to zero */
+	snd_ac97_write_cache(ac97, reg, 0x8000);
+}
+
 static inline int printable(unsigned int x)
 {
 	x &= 0xff;
@@ -1034,7 +1054,7 @@
 	unsigned char max;
 
 	/* build master controls */
-	/* AD claims to remove this control from AD1887, although spec v2.2 don't allow this */
+	/* AD claims to remove this control from AD1887, although spec v2.2 does not allow this */
 	if (snd_ac97_try_volume_mix(ac97, AC97_MASTER)) {
 		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_master[0], ac97))) < 0)
 			return err;
@@ -1127,17 +1147,27 @@
 	
 	/* build Phone controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_PHONE)) {
-		for (idx = 0; idx < 2; idx++)
-			if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_phone[idx], ac97))) < 0)
-				return err;
-		snd_ac97_write_cache(ac97, AC97_PHONE, 0x801f);
+		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_phone[0], ac97))) < 0)
+			return err;
+		if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_phone[1], ac97))) < 0)
+			return err;
+		snd_ac97_change_volume_params3(ac97, AC97_PHONE, &max);
+		kctl->private_value &= ~(0xff << 16);
+		kctl->private_value |= (int)max << 16;
+		snd_ac97_write_cache(ac97, AC97_PHONE, 0x8000 | max);
 	}
 	
 	/* build MIC controls */
-	for (idx = 0; idx < 3; idx++)
-		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_mic[idx], ac97))) < 0)
-			return err;
-	snd_ac97_write_cache(ac97, AC97_MIC, 0x801f);
+	snd_ac97_change_volume_params3(ac97, AC97_MIC, &max);
+	for (idx = 0; idx < 3; idx++) {
+		if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_mic[idx], ac97))) < 0)
+			return err;
+		if (idx == 1) {		// volume
+			kctl->private_value &= ~(0xff << 16);
+			kctl->private_value |= (int)max << 16;
+		}
+	}
+	snd_ac97_write_cache(ac97, AC97_MIC, 0x8000 | max);
 
 	/* build Line controls */
 	for (idx = 0; idx < 2; idx++)
@@ -1301,21 +1331,25 @@
 			for (idx = 0; idx < 3; idx++)
 				if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_spdif[idx], ac97))) < 0)
 					return err;
-			for (idx = 0; idx < 2; idx++)
-				if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_cs4205_controls_spdif[idx], ac97))) < 0)
+			if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_cirrus_controls_spdif[0], ac97))) < 0)
+				return err;
+			switch (ac97->id) {
+			case AC97_ID_CS4205:
+				if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_cirrus_controls_spdif[1], ac97))) < 0)
 					return err;
+				break;
+			}
+			/* set default PCM S/PDIF params */
+			/* consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz */
+			snd_ac97_write_cache(ac97, AC97_CSR_SPDIF, 0x0a20);
 		} else {
 			for (idx = 0; idx < 5; idx++)
 				if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_spdif[idx], ac97))) < 0)
 					return err;
-		}
-
-		/* set default PCM S/PDIF params */
-		/* consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz */
-	        if (ac97->flags & AC97_CS_SPDIF)
-			snd_ac97_write_cache(ac97, SPDIF_CS4205, 0x0a20);
-		else 
+			/* set default PCM S/PDIF params */
+			/* consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz */
 			snd_ac97_write_cache(ac97, AC97_SPDIF, 0x2a20);
+		}
 
 		ac97->spdif_status = SNDRV_PCM_DEFAULT_CON_SPDIF;
 	}
@@ -1650,7 +1684,7 @@
 	}
 	if ((ext & 0x0004) || (ac97->flags & AC97_CS_SPDIF)) {
 	        if (ac97->flags & AC97_CS_SPDIF)
-			val = snd_ac97_read(ac97, SPDIF_CS4205);
+			val = snd_ac97_read(ac97, AC97_CSR_SPDIF);
 		else
 			val = snd_ac97_read(ac97, AC97_SPDIF);
 
@@ -1741,9 +1775,12 @@
 static void snd_ac97_proc_init(snd_card_t * card, ac97_t * ac97)
 {
 	snd_info_entry_t *entry;
-	char name[12];
+	char name[32];
 
-	sprintf(name, "ac97#%d", ac97->addr);
+	if (ac97->num)
+		sprintf(name, "ac97#%d-%d", ac97->addr, ac97->num);
+	else
+		sprintf(name, "ac97#%d", ac97->addr);
 	if ((entry = snd_info_create_card_entry(card, name, card->proc_root)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = ac97;
@@ -1756,7 +1793,10 @@
 		}
 	}
 	ac97->proc_entry = entry;
-	sprintf(name, "ac97#%dregs", ac97->addr);
+	if (ac97->num)
+		sprintf(name, "ac97#%d-%dregs", ac97->addr, ac97->num);
+	else
+		sprintf(name, "ac97#%dregs", ac97->addr);
 	if ((entry = snd_info_create_card_entry(card, name, card->proc_root)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = ac97;
@@ -1903,30 +1943,31 @@
 	return 0;
 }
 
-static int patch_cirrus_cs4299(ac97_t * ac97)
-{
-	ac97->flags |= AC97_HAS_PC_BEEP;	/* force the detection of PC Beep */
-	
-	return 0;
-}
-
-static int patch_cirrus_cs4205(ac97_t * ac97)
+static int patch_cirrus_spdif(ac97_t * ac97)
 {
-  /* Basically, the cs4205 has non-standard sp/dif registers.
-     WHY CAN'T ANYONE FOLLOW THE BLOODY SPEC?  *sigh*
-      - sp/dif EA ID is not set, but sp/dif is always present.
-        - enable/disable is spdif register bit 15.
-      - sp/dif control register is 0x68.  differs from AC97:
-        - valid is bit 14 (vs 15)
-	- no DRS
-	- only 44.1/48k [00 = 48, 01=44,1] (AC97 is 00=44.1, 10=48)
-      - sp/dif ssource select is in 0x5e bits 0,1.
-  */
+	/* Basically, the cs4201/cs4205/cs4297a has non-standard sp/dif registers.
+	   WHY CAN'T ANYONE FOLLOW THE BLOODY SPEC?  *sigh*
+	   - sp/dif EA ID is not set, but sp/dif is always present.
+	   - enable/disable is spdif register bit 15.
+	   - sp/dif control register is 0x68.  differs from AC97:
+	   - valid is bit 14 (vs 15)
+	   - no DRS
+	   - only 44.1/48k [00 = 48, 01=44,1] (AC97 is 00=44.1, 10=48)
+	   - sp/dif ssource select is in 0x5e bits 0,1.
+	*/
 
 	ac97->flags |= AC97_CS_SPDIF; 
         ac97->ext_id |= AC97_EA_SPDIF;	/* force the detection of spdif */
-	snd_ac97_write_cache(ac97, MODE_CS4205, 0x0080);
+	snd_ac97_write_cache(ac97, AC97_CSR_ACMODE, 0x0080);
 	return 0;
+}
+
+static int patch_cirrus_cs4299(ac97_t * ac97)
+{
+	/* force the detection of PC Beep */
+	ac97->flags |= AC97_HAS_PC_BEEP;
+	
+	return patch_cirrus_spdif(ac97);
 }
 
 static int patch_ad1819(ac97_t * ac97)
diff -Nru a/sound/pci/cmipci.c b/sound/pci/cmipci.c
--- a/sound/pci/cmipci.c	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/cmipci.c	Thu Jun 20 15:54:00 2002
@@ -113,7 +113,7 @@
 #define CM_SPDIF_SELECT1	0x00080000	/* for model <= 037 ? */
 #define CM_AC3EN1		0x00100000	/* enable AC3: model 037 */
 #define CM_SPD24SEL		0x00020000	/* 24bit spdif: model 037 */
-#define CM_SPDIF_INVERSE	0x00010000
+/* #define CM_SPDIF_INVERSE	0x00010000 */ /* ??? */
 
 #define CM_ADCBITLEN_MASK	0x0000C000	
 #define CM_ADCBITLEN_16		0x00000000
@@ -256,7 +256,8 @@
 
 #define CM_REG_MISC		0x27
 #define CM_XGPO1		0x20
-#define CM_XGPBIO		0x04
+// #define CM_XGPBIO		0x04
+#define CM_SPDIF_INVERSE	0x04	/* spdif input phase inverse (model 037) */
 #define CM_SPDVALID		0x02	/* spdif input valid check */
 #define CM_DMAUTO		0x01
 
@@ -2034,7 +2035,7 @@
 	CMIPCI_DOUBLE("Mic Capture Switch", SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, 0, 0, 1, 0, 0),
 	CMIPCI_SB_VOL_MONO("PC Speaker Playback Volume", SB_DSP4_SPEAKER_DEV, 6, 3),
 	CMIPCI_MIXER_VOL_STEREO("Aux Playback Volume", CM_REG_AUX_VOL, 4, 0, 15),
-	CMIPCI_MIXER_SW_STEREO("Aux Playback Switch", CM_REG_MIXER2, CM_VAUXLM_SHIFT, CM_VAUXRM_SHIFT, 1),
+	CMIPCI_MIXER_SW_STEREO("Aux Playback Switch", CM_REG_MIXER2, CM_VAUXLM_SHIFT, CM_VAUXRM_SHIFT, 0),
 	CMIPCI_MIXER_SW_STEREO("Aux Capture Switch", CM_REG_MIXER2, CM_RAUXLEN_SHIFT, CM_RAUXREN_SHIFT, 0),
 	CMIPCI_MIXER_SW_MONO("Mic Boost", CM_REG_MIXER2, CM_MICGAINZ_SHIFT, 1),
 	CMIPCI_MIXER_VOL_MONO("Mic Capture Volume", CM_REG_MIXER2, CM_VADMIC_SHIFT, 7),
@@ -2156,7 +2157,8 @@
 DEFINE_SWITCH_ARG(spdo_5v, CM_REG_MISC_CTRL, CM_SPDO5V, 0, 0, 0); /* inverse: 0 = 5V */
 DEFINE_BIT_SWITCH_ARG(spdif_loop, CM_REG_FUNCTRL1, CM_SPDFLOOP, 0, 1);
 DEFINE_BIT_SWITCH_ARG(spdi_monitor, CM_REG_MIXER1, CM_CDPLAY, 1, 0);
-DEFINE_BIT_SWITCH_ARG(spdi_phase, CM_REG_CHFORMAT, CM_SPDIF_INVERSE, 0, 0);
+/* DEFINE_BIT_SWITCH_ARG(spdi_phase, CM_REG_CHFORMAT, CM_SPDIF_INVERSE, 0, 0); */
+DEFINE_BIT_SWITCH_ARG(spdi_phase, CM_REG_MISC, CM_SPDIF_INVERSE, 1, 0);
 DEFINE_BIT_SWITCH_ARG(spdi_phase2, CM_REG_CHFORMAT, CM_SPDIF_INVERSE2, 0, 0);
 #if CM_CH_PLAY == 1
 DEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, 0, 0, 0); /* reversed */
diff -Nru a/sound/pci/cs4281.c b/sound/pci/cs4281.c
--- a/sound/pci/cs4281.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/cs4281.c	Thu Jun 20 15:54:01 2002
@@ -48,6 +48,7 @@
 static int snd_index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *snd_id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int snd_enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
+static int snd_dual_codec[SNDRV_CARDS];	/* dual codec */
 
 MODULE_PARM(snd_index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(snd_index, "Index value for CS4281 soundcard.");
@@ -58,6 +59,9 @@
 MODULE_PARM(snd_enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(snd_enable, "Enable CS4281 soundcard.");
 MODULE_PARM_SYNTAX(snd_enable, SNDRV_ENABLE_DESC);
+MODULE_PARM(snd_dual_codec, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+MODULE_PARM_DESC(snd_dual_codec, "Secondary Codec ID (0 = disabled).");
+MODULE_PARM_SYNTAX(snd_dual_codec, SNDRV_ENABLED ",allows:{{0,3}}");
 
 /*
  *
@@ -471,7 +475,10 @@
 	struct resource *ba0_res;
 	struct resource *ba1_res;
 
+	int dual_codec;
+
 	ac97_t *ac97;
+	ac97_t *ac97_secondary;
 
 	struct pci_dev *pci;
 	snd_card_t *card;
@@ -575,7 +582,7 @@
 	snd_cs4281_pokeBA0(chip, BA0_ACCAD, reg);
 	snd_cs4281_pokeBA0(chip, BA0_ACCDA, val);
 	snd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_DCV | BA0_ACCTL_VFRM |
-				            BA0_ACCTL_ESYN);
+				            BA0_ACCTL_ESYN | (ac97->num ? BA0_ACCTL_TC : 0));
 	for (count = 0; count < 2000; count++) {
 		/*
 		 *  First, we want to wait for a short time.
@@ -589,7 +596,7 @@
 			return;
 		}
 	}
-	snd_printk("AC'97 write problem, reg = 0x%x, val = 0x%x\n", reg, val);
+	snd_printk(KERN_ERR "AC'97 write problem, reg = 0x%x, val = 0x%x\n", reg, val);
 }
 
 static unsigned short snd_cs4281_ac97_read(ac97_t *ac97,
@@ -608,7 +615,7 @@
 	 *  6. Read ACSTS = Status Register = 464h, check VSTS bit
 	 */
 
-	snd_cs4281_peekBA0(chip, BA0_ACSDA);
+	snd_cs4281_peekBA0(chip, ac97->num ? BA0_ACSDA2 : BA0_ACSDA);
 
 	/*
 	 *  Setup the AC97 control registers on the CS461x to send the
@@ -626,7 +633,8 @@
 	snd_cs4281_pokeBA0(chip, BA0_ACCAD, reg);
 	snd_cs4281_pokeBA0(chip, BA0_ACCDA, 0);
 	snd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_DCV | BA0_ACCTL_CRW |
-					    BA0_ACCTL_VFRM | BA0_ACCTL_ESYN);
+					    BA0_ACCTL_VFRM | BA0_ACCTL_ESYN |
+			   (ac97->num ? BA0_ACCTL_TC : 0));
 
 
 	/*
@@ -645,7 +653,7 @@
 			goto __ok1;
 	}
 
-	snd_printk("AC'97 read problem (ACCTL_DCV), reg = 0x%x\n", reg);
+	snd_printk(KERN_ERR "AC'97 read problem (ACCTL_DCV), reg = 0x%x\n", reg);
 	result = 0xffff;
 	goto __end;
 	
@@ -659,12 +667,12 @@
 		 *  ACSTS = Status Register = 464h
 		 *  VSTS - Valid Status
 		 */
-		if (snd_cs4281_peekBA0(chip, BA0_ACSTS) & BA0_ACSTS_VSTS)
+		if (snd_cs4281_peekBA0(chip, ac97->num ? BA0_ACSTS2 : BA0_ACSTS) & BA0_ACSTS_VSTS)
 			goto __ok2;
 		udelay(10);
 	}
 	
-	snd_printk("AC'97 read problem (ACSTS_VSTS), reg = 0x%x\n", reg);
+	snd_printk(KERN_ERR "AC'97 read problem (ACSTS_VSTS), reg = 0x%x\n", reg);
 	result = 0xffff;
 	goto __end;
 
@@ -673,7 +681,7 @@
 	 *  Read the data returned from the AC97 register.
 	 *  ACSDA = Status Data Register = 474h
 	 */
-	result = snd_cs4281_peekBA0(chip, BA0_ACSDA);
+	result = snd_cs4281_peekBA0(chip, ac97->num ? BA0_ACSDA2 : BA0_ACSDA);
 
       __end:
 	return result;
@@ -883,10 +891,10 @@
 				 SNDRV_PCM_INFO_PAUSE |
 				 SNDRV_PCM_INFO_SYNC_START),
 	formats:		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
-				SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_LE |
-				SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S16_BE |
-				SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_LE |
-				SNDRV_PCM_FMTBIT_S32_BE | SNDRV_PCM_FMTBIT_S32_BE,
+				SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
+				SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE,
 	rates:			SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
 	rate_min:		4000,
 	rate_max:		48000,
@@ -896,7 +904,7 @@
 	period_bytes_min:	64,
 	period_bytes_max:	(512*1024),
 	periods_min:		1,
-	periods_max:		1024,
+	periods_max:		2,
 	fifo_size:		CS4281_FIFO_SIZE,
 };
 
@@ -1019,7 +1027,10 @@
 static void snd_cs4281_mixer_free_ac97(ac97_t *ac97)
 {
 	cs4281_t *chip = snd_magic_cast(cs4281_t, ac97->private_data, return);
-	chip->ac97 = NULL;
+	if (ac97->num)
+		chip->ac97_secondary = NULL;
+	else
+		chip->ac97 = NULL;
 }
 
 static int __devinit snd_cs4281_mixer(cs4281_t * chip)
@@ -1035,6 +1046,11 @@
 	ac97.private_free = snd_cs4281_mixer_free_ac97;
 	if ((err = snd_ac97_mixer(card, &ac97, &chip->ac97)) < 0)
 		return err;
+	if (chip->dual_codec) {
+		ac97.num = 1;
+		if ((err = snd_ac97_mixer(card, &ac97, &chip->ac97_secondary)) < 0)
+			return err;
+	}
 	return 0;
 }
 
@@ -1250,7 +1266,7 @@
 	cs4281_gameport_t *gp;
 	gp = kmalloc(sizeof(*gp), GFP_KERNEL);
 	if (! gp) {
-		snd_printk("cannot allocate gameport area\n");
+		snd_printk(KERN_ERR "cannot allocate gameport area\n");
 		return;
 	}
 	memset(gp, 0, sizeof(*gp));
@@ -1322,7 +1338,8 @@
 
 static int __devinit snd_cs4281_create(snd_card_t * card,
 				    struct pci_dev *pci,
-				    cs4281_t ** rchip)
+				    cs4281_t ** rchip,
+				       int dual_codec)
 {
 	cs4281_t *chip;
 	unsigned int tmp;
@@ -1345,20 +1362,25 @@
 	chip->ba0_addr = pci_resource_start(pci, 0);
 	chip->ba1_addr = pci_resource_start(pci, 1);
 	pci_set_master(pci);
+	if (dual_codec < 0 || dual_codec > 3) {
+		snd_printk(KERN_ERR "invalid snd_dual_codec option %d\n", dual_codec);
+		dual_codec = 0;
+	}
+	chip->dual_codec = dual_codec;
 
 	if ((chip->ba0_res = request_mem_region(chip->ba0_addr, CS4281_BA0_SIZE, "CS4281 BA0")) == NULL) {
 		snd_cs4281_free(chip);
-		snd_printk("unable to grab memory region 0x%lx-0x%lx\n", chip->ba0_addr, chip->ba0_addr + CS4281_BA0_SIZE - 1);
+		snd_printk(KERN_ERR "unable to grab memory region 0x%lx-0x%lx\n", chip->ba0_addr, chip->ba0_addr + CS4281_BA0_SIZE - 1);
 		return -ENOMEM;
 	}
 	if ((chip->ba1_res = request_mem_region(chip->ba1_addr, CS4281_BA1_SIZE, "CS4281 BA1")) == NULL) {
 		snd_cs4281_free(chip);
-		snd_printk("unable to grab memory region 0x%lx-0x%lx\n", chip->ba1_addr, chip->ba1_addr + CS4281_BA1_SIZE - 1);
+		snd_printk(KERN_ERR "unable to grab memory region 0x%lx-0x%lx\n", chip->ba1_addr, chip->ba1_addr + CS4281_BA1_SIZE - 1);
 		return -ENOMEM;
 	}
 	if (request_irq(pci->irq, snd_cs4281_interrupt, SA_INTERRUPT|SA_SHIRQ, "CS4281", (void *)chip)) {
 		snd_cs4281_free(chip);
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -ENOMEM;
 	}
 	chip->irq = pci->irq;
@@ -1375,7 +1397,7 @@
 		snd_cs4281_pokeBA0(chip, BA0_CFLR, BA0_CFLR_DEFAULT);
 		tmp = snd_cs4281_peekBA0(chip, BA0_CFLR);
 		if (tmp != BA0_CFLR_DEFAULT) {
-			snd_printk("CFLR setup failed (0x%x)\n", tmp);
+			snd_printk(KERN_ERR "CFLR setup failed (0x%x)\n", tmp);
 			snd_cs4281_free(chip);
 			return -EIO;
 		}
@@ -1387,12 +1409,12 @@
 	snd_cs4281_pokeBA0(chip, BA0_CWPR, 0x4281);
 	
 	if ((tmp = snd_cs4281_peekBA0(chip, BA0_SERC1)) != (BA0_SERC1_SO1EN | BA0_SERC1_AC97)) {
-		snd_printk("SERC1 AC'97 check failed (0x%x)\n", tmp);
+		snd_printk(KERN_ERR "SERC1 AC'97 check failed (0x%x)\n", tmp);
 		snd_cs4281_free(chip);
 		return -EIO;
 	}
 	if ((tmp = snd_cs4281_peekBA0(chip, BA0_SERC2)) != (BA0_SERC2_SI1EN | BA0_SERC2_AC97)) {
-		snd_printk("SERC2 AC'97 check failed (0x%x)\n", tmp);
+		snd_printk(KERN_ERR "SERC2 AC'97 check failed (0x%x)\n", tmp);
 		snd_cs4281_free(chip);
 		return -EIO;
 	}
@@ -1424,10 +1446,15 @@
 	snd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN);
 	snd_cs4281_delay(50000);
 
+	if (chip->dual_codec)
+		snd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN | BA0_SPMC_ASDI2E);
+
 	/*
 	 *  Set the serial port timing configuration.
 	 */
-	snd_cs4281_pokeBA0(chip, BA0_SERMC, BA0_SERMC_TCID(1) | BA0_SERMC_PTC_AC97 | BA0_SERMC_MSPE);
+	snd_cs4281_pokeBA0(chip, BA0_SERMC,
+			   (chip->dual_codec ? BA0_SERMC_TCID(chip->dual_codec) : BA0_SERMC_TCID(1)) |
+			   BA0_SERMC_PTC_AC97 | BA0_SERMC_MSPE);
 
 	/*
 	 *  Start the DLL Clock logic.
@@ -1451,7 +1478,7 @@
 		schedule_timeout(1);
         } while (end_time - (signed long)jiffies >= 0);
 
-	snd_printk("DLLRDY not seen\n");
+	snd_printk(KERN_ERR "DLLRDY not seen\n");
 	snd_cs4281_free(chip);
 	return -EIO;
 
@@ -1479,11 +1506,23 @@
 		schedule_timeout(1);
         } while (end_time - (signed long)jiffies >= 0);
 
-	snd_printk("never read codec ready from AC'97 (0x%x)\n", snd_cs4281_peekBA0(chip, BA0_ACSTS));
+	snd_printk(KERN_ERR "never read codec ready from AC'97 (0x%x)\n", snd_cs4281_peekBA0(chip, BA0_ACSTS));
 	snd_cs4281_free(chip);
 	return -EIO;
 
       __ok1:
+	if (chip->dual_codec) {
+		end_time = (jiffies + (3 * HZ) / 4) + 1;
+		do {
+			if (snd_cs4281_peekBA0(chip, BA0_ACSTS2) & BA0_ACSTS_CRDY)
+				goto __codec2_ok;
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1);
+		} while (end_time - (signed long)jiffies >= 0);
+		snd_printk(KERN_INFO "secondary codec doesn't respond. disable it...\n");
+		chip->dual_codec = 0;
+	__codec2_ok: ;
+	}
 
 	/*
 	 *  Assert the valid frame signal so that we can start sending commands
@@ -1509,7 +1548,7 @@
                 schedule_timeout(1);
         } while (end_time - (signed long)jiffies >= 0);
 
-	snd_printk("never read ISV3 and ISV4 from AC'97\n");
+	snd_printk(KERN_ERR "never read ISV3 and ISV4 from AC'97\n");
 	snd_cs4281_free(chip);
 	return -EIO;
 
@@ -1834,7 +1873,7 @@
 	if (card == NULL)
 		return -ENOMEM;
 
-	if ((err = snd_cs4281_create(card, pci, &chip)) < 0) {
+	if ((err = snd_cs4281_create(card, pci, &chip, snd_dual_codec[dev])) < 0) {
 		snd_card_free(card);
 		return err;
 	}
diff -Nru a/sound/pci/cs46xx/cs46xx.c b/sound/pci/cs46xx/cs46xx.c
--- a/sound/pci/cs46xx/cs46xx.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/cs46xx/cs46xx.c	Thu Jun 20 15:54:01 2002
@@ -28,7 +28,6 @@
 #include <sound/driver.h>
 #include <linux/pci.h>
 #include <linux/time.h>
-#include <linux/init.h>
 #include <sound/core.h>
 #include <sound/cs46xx.h>
 #define SNDRV_GET_ID
diff -Nru a/sound/pci/emu10k1/emu10k1_synth.c b/sound/pci/emu10k1/emu10k1_synth.c
--- a/sound/pci/emu10k1/emu10k1_synth.c	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/emu10k1/emu10k1_synth.c	Thu Jun 20 15:54:00 2002
@@ -57,6 +57,7 @@
 	emu->memhdr = hw->memhdr;
 	emu->midi_ports = arg->seq_ports < 2 ? arg->seq_ports : 2; /* maximum two ports */
 	emu->midi_devidx = hw->audigy ? 2 : 1; /* audigy has two external midis */
+	emu->linear_panning = 0;
 
 	if (snd_emux_register(emu, dev->card, arg->index, "Emu10k1") < 0) {
 		snd_emux_free(emu);
@@ -94,7 +95,6 @@
 	snd_emux_free(emu);
 	return 0;
 }
-
 
 /*
  *  INIT part
diff -Nru a/sound/pci/emu10k1/emufx.c b/sound/pci/emu10k1/emufx.c
--- a/sound/pci/emu10k1/emufx.c	Thu Jun 20 15:53:59 2002
+++ b/sound/pci/emu10k1/emufx.c	Thu Jun 20 15:53:59 2002
@@ -1271,8 +1271,8 @@
 	gpr += 2;
 
 	/* Surround Playback */
-	A_OP(icode, &ptr, iMAC0, A_GPR(playback+2), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_REAR));
-	A_OP(icode, &ptr, iMAC0, A_GPR(playback+3), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT_REAR));
+	A_OP(icode, &ptr, iMAC0, A_GPR(playback+2), A_GPR(playback+2), A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_REAR));
+	A_OP(icode, &ptr, iMAC0, A_GPR(playback+3), A_GPR(playback+3), A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT_REAR));
 	snd_emu10k1_init_stereo_control(&controls[nctl++], "Surround Playback Volume", gpr, 80);
 	gpr += 2;
 
diff -Nru a/sound/pci/es1968.c b/sound/pci/es1968.c
--- a/sound/pci/es1968.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/es1968.c	Thu Jun 20 15:54:01 2002
@@ -1971,7 +1971,7 @@
 	val = chip->ac97->regs[AC97_MASTER];
 	if (x & 1) {
 		/* mute */
-		snd_ac97_write_cache(chip->ac97, 0, val ^ 0x8000);
+		snd_ac97_write_cache(chip->ac97, AC97_MASTER, val ^ 0x8000);
 		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->master_switch->id);
 	} else {
@@ -1980,7 +1980,7 @@
 			/* volume up */
 			if ((val & 0xff) > 0)
 				val--;
-			if ((val & 0xff00) > 0x100)
+			if ((val & 0xff00) > 0)
 				val -= 0x0100;
 		} else {
 			/* volume down */
@@ -1989,7 +1989,7 @@
 			if ((val & 0xff00) < 0x1f00)
 				val += 0x0100;
 		}
-		snd_ac97_write_cache(chip->ac97, 0, val);
+		snd_ac97_write_cache(chip->ac97, AC97_MASTER, val);
 		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->master_volume->id);
 	}
diff -Nru a/sound/pci/ice1712.c b/sound/pci/ice1712.c
--- a/sound/pci/ice1712.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/ice1712.c	Thu Jun 20 15:54:01 2002
@@ -1206,6 +1206,7 @@
 	outb(val, ICEMT(ice, RATE));
 	switch (ice->eeprom.subvendor) {
 	case ICE1712_SUBDEVICE_DELTA1010:
+	case ICE1712_SUBDEVICE_DELTA1010LT:	// check it --jk
 	case ICE1712_SUBDEVICE_DELTADIO2496:
 	case ICE1712_SUBDEVICE_DELTA66:
 	case ICE1712_SUBDEVICE_DELTA44:
@@ -3770,6 +3771,7 @@
 		has_i2c = 1;
 		/* follow thru */
 	case ICE1712_SUBDEVICE_DELTA1010:
+	case ICE1712_SUBDEVICE_STDSP24:
 		ice->num_adcs = ice->num_dacs = ice->num_total_dacs = 8;
 		break;
 	case ICE1712_SUBDEVICE_EWS88D:
diff -Nru a/sound/pci/intel8x0.c b/sound/pci/intel8x0.c
--- a/sound/pci/intel8x0.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/intel8x0.c	Thu Jun 20 15:54:01 2002
@@ -44,11 +44,11 @@
 MODULE_DESCRIPTION("Intel 82801AA,82901AB,i810,i820,i830,i840,MX440; SiS 7012");
 MODULE_LICENSE("GPL");
 MODULE_CLASSES("{sound}");
-MODULE_DEVICES("{{Intel,82801AA},"
-		"{Intel,82901AB},"
-		"{Intel,82801BA},"
-		"{Intel,ICH3},"
-		"{Intel,ICH4},"
+MODULE_DEVICES("{{Intel,82801AA-ICH},"
+		"{Intel,82901AB-ICH0},"
+		"{Intel,82801BA-ICH2},"
+		"{Intel,82801CA-ICH3},"
+		"{Intel,82801DB-ICH4},"
 		"{Intel,MX440},"
 		"{SiS,SI7012},"
 		"{NVidia,NForce Audio},"
@@ -1403,11 +1403,12 @@
 	unsigned int id;
 	const char *s;
 } shortnames[] __devinitdata = {
-	{ PCI_DEVICE_ID_INTEL_82801, "Intel ICH 82801AA" },
-	{ PCI_DEVICE_ID_INTEL_82901, "Intel ICH 82901AB" },
+	{ PCI_DEVICE_ID_INTEL_82801, "Intel 82801AA-ICH" },
+	{ PCI_DEVICE_ID_INTEL_82901, "Intel 82901AB-ICH0" },
+	{ PCI_DEVICE_ID_INTEL_82801BA, "Intel 82801BA-ICH2" },
 	{ PCI_DEVICE_ID_INTEL_440MX, "Intel 440MX" },
-	{ PCI_DEVICE_ID_INTEL_ICH3, "Intel ICH3" },
-	{ PCI_DEVICE_ID_INTEL_ICH4, "Intel ICH4" },
+	{ PCI_DEVICE_ID_INTEL_ICH3, "Intel 82801CA-ICH3" },
+	{ PCI_DEVICE_ID_INTEL_ICH4, "Intel 82801DB-ICH4" },
 	{ PCI_DEVICE_ID_SI_7012, "SiS SI7012" },
 	{ PCI_DEVICE_ID_NVIDIA_MCP_AUDIO, "NVidia NForce" },
 	{ 0x764d, "AMD AMD8111" },
diff -Nru a/sound/pci/korg1212/korg1212.c b/sound/pci/korg1212/korg1212.c
--- a/sound/pci/korg1212/korg1212.c	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/korg1212/korg1212.c	Thu Jun 20 15:54:00 2002
@@ -32,9 +32,17 @@
 #define SNDRV_GET_ID
 #include <sound/initval.h>
 
-#define DEBUG                    1
-//#define LARGEALLOC               1
-#define PRINTK	printk
+// ----------------------------------------------------------------------------
+// Debug Stuff
+// ----------------------------------------------------------------------------
+#define K1212_DEBUG_LEVEL		0
+#define K1212_DEBUG_PRINTK		printk
+
+// ----------------------------------------------------------------------------
+// Record/Play Buffer Allocation Method. If K1212_LARGEALLOC is defined all 
+// buffers are alocated as a large piece inside KorgSharedBuffer.
+// ----------------------------------------------------------------------------
+//#define K1212_LARGEALLOC		1
 
 // ----------------------------------------------------------------------------
 // the following enum defines the valid states of the Korg 1212 I/O card.
@@ -273,7 +281,7 @@
 } KorgAudioBuffer;
 
 typedef struct KorgSharedBuffer {
-#ifdef LARGEALLOC
+#ifdef K1212_LARGEALLOC
    KorgAudioBuffer   playDataBufs[kNumBuffers];
    KorgAudioBuffer   recordDataBufs[kNumBuffers];
 #endif
@@ -521,8 +529,8 @@
         u16 mailBox3Lo;
 
         if (korg1212->outDoorbellPtr) {
-#ifdef DEBUG
-		PRINTK("DEBUG: Card <- 0x%08x 0x%08x [%s]\n", doorbellVal, mailBox0Val, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: Card <- 0x%08x 0x%08x [%s]\n", doorbellVal, mailBox0Val, stateName[korg1212->cardState]);
 #endif
                 for (retryCount = 0; retryCount < MAX_COMMAND_RETRIES; retryCount++) {
 
@@ -569,9 +577,9 @@
 {
         unsigned long endtime = jiffies + 20 * HZ;
 
-#ifdef DEBUG
-        PRINTK("DEBUG: WaitForCardStopAck [%s]\n", stateName[korg1212->cardState]);
-#endif // DEBUG
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: WaitForCardStopAck [%s]\n", stateName[korg1212->cardState]);
+#endif
 
         if (korg1212->inIRQ)
                 return;
@@ -623,8 +631,8 @@
 
 static int snd_korg1212_OpenCard(korg1212_t * korg1212)
 {
-#ifdef DEBUG
-	PRINTK("DEBUG: OpenCard [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	K1212_DEBUG_PRINTK("K1212_DEBUG: OpenCard [%s]\n", stateName[korg1212->cardState]);
 #endif
         snd_korg1212_setCardState(korg1212, K1212_STATE_OPEN);
         return 1;
@@ -632,15 +640,15 @@
 
 static int snd_korg1212_CloseCard(korg1212_t * korg1212)
 {
-#ifdef DEBUG
-	PRINTK("DEBUG: CloseCard [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	K1212_DEBUG_PRINTK("K1212_DEBUG: CloseCard [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         if (korg1212->cardState == K1212_STATE_SETUP) {
                 rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SelectPlayMode,
                                 K1212_MODE_StopPlay, 0, 0, 0);
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: CloseCard - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: CloseCard - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
                 if (rc != K1212_CMDRET_Success)
@@ -658,16 +666,16 @@
 
 static int snd_korg1212_SetupForPlay(korg1212_t * korg1212)
 {
-#ifdef DEBUG
-	PRINTK("DEBUG: SetupForPlay [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	K1212_DEBUG_PRINTK("K1212_DEBUG: SetupForPlay [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         snd_korg1212_setCardState(korg1212, K1212_STATE_SETUP);
         rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SelectPlayMode,
                                         K1212_MODE_SetupPlay, 0, 0, 0);
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: SetupForPlay - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: SetupForPlay - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
         if (rc != K1212_CMDRET_Success) {
                 return 0;
@@ -677,15 +685,15 @@
 
 static int snd_korg1212_TriggerPlay(korg1212_t * korg1212)
 {
-#ifdef DEBUG
-	PRINTK("DEBUG: TriggerPlay [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	K1212_DEBUG_PRINTK("K1212_DEBUG: TriggerPlay [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         snd_korg1212_setCardState(korg1212, K1212_STATE_PLAYING);
         rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_TriggerPlay, 0, 0, 0, 0);
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: TriggerPlay - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: TriggerPlay - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
         if (rc != K1212_CMDRET_Success) {
@@ -696,8 +704,8 @@
 
 static int snd_korg1212_StopPlay(korg1212_t * korg1212)
 {
-#ifdef DEBUG
-	PRINTK("DEBUG: StopPlay [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	K1212_DEBUG_PRINTK("K1212_DEBUG: StopPlay [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         if (korg1212->cardState != K1212_STATE_ERRORSTOP) {
@@ -721,8 +729,8 @@
 
 static int snd_korg1212_SetMonitorMode(korg1212_t *korg1212, MonitorModeSelector mode)
 {
-#ifdef DEBUG
-	PRINTK("DEBUG: SetMonitorMode [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	K1212_DEBUG_PRINTK("K1212_DEBUG: SetMonitorMode [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         switch (mode) {
@@ -790,8 +798,8 @@
 					  ClockSourceSelector[korg1212->clkSrcRate],
 					  0, 0, 0);
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: Set Clock Source Selector - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Set Clock Source Selector - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
         return 0;
@@ -826,8 +834,8 @@
                                    //  the card's eeprom control register.
         u16       count;
 
-#ifdef DEBUG
-	PRINTK("DEBUG: WriteADCSensivity [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	K1212_DEBUG_PRINTK("K1212_DEBUG: WriteADCSensivity [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         // ----------------------------------------------------------------------------
@@ -951,8 +959,8 @@
         if (monModeSet) {
                 rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SelectPlayMode,
                                 K1212_MODE_MonitorOn, 0, 0, 0);
-#ifdef DEBUG
-	        if (rc) PRINTK("DEBUG: WriteADCSensivity - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	        if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: WriteADCSensivity - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
         }
@@ -964,8 +972,8 @@
 {
         int channel;
 
-#ifdef DEBUG
-        PRINTK("DEBUG: DSP download is complete. [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: DSP download is complete. [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         // ----------------------------------------------------
@@ -973,8 +981,8 @@
         // ----------------------------------------------------
         rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_BootFromDSPPage4, 0, 0, 0, 0);
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: Boot from Page 4 - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Boot from Page 4 - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 	mdelay(DSP_BOOT_DELAY_IN_MS);
 
@@ -990,8 +998,8 @@
                         0
         );
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: Configure Buffer Memory - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Configure Buffer Memory - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
         TickDelay(INTERCOMMAND_DELAY);
@@ -1004,8 +1012,8 @@
                         0
         );
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: Configure Misc Memory - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Configure Misc Memory - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
 
@@ -1026,14 +1034,14 @@
 	rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SetClockSourceRate,
 					  ClockSourceSelector[korg1212->clkSrcRate],
 					  0, 0, 0);
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: Set Clock Source Selector - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Set Clock Source Selector - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
 	snd_korg1212_setCardState(korg1212, K1212_STATE_READY);
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: Set Monitor On - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Set Monitor On - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
         wake_up_interruptible(&korg1212->wait);
@@ -1062,8 +1070,8 @@
 
         switch (doorbellValue) {
                 case K1212_DB_DSPDownloadDone:
-#ifdef DEBUG
-                        PRINTK("DEBUG: IRQ DNLD count - %ld, %x, [%s].\n", korg1212->irqcount, doorbellValue, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+                        K1212_DEBUG_PRINTK("K1212_DEBUG: IRQ DNLD count - %ld, %x, [%s].\n", korg1212->irqcount, doorbellValue, stateName[korg1212->cardState]);
 #endif
                         if (korg1212->cardState == K1212_STATE_DSP_IN_PROCESS) {
                                         snd_korg1212_setCardState(korg1212, K1212_STATE_DSP_COMPLETE);
@@ -1075,8 +1083,8 @@
                 // an error occurred - stop the card
                 // ------------------------------------------------------------------------
                 case K1212_ISRCODE_DMAERROR:
-#ifdef DEBUG
-                        PRINTK("DEBUG: IRQ DMAE count - %ld, %x, [%s].\n", korg1212->irqcount, doorbellValue, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+                        K1212_DEBUG_PRINTK("K1212_DEBUG: IRQ DMAE count - %ld, %x, [%s].\n", korg1212->irqcount, doorbellValue, stateName[korg1212->cardState]);
 #endif
                         writel(0, &korg1212->sharedBufferPtr->cardCommand);
                         break;
@@ -1086,15 +1094,15 @@
                 // the semaphore in case someone is waiting for this.
                 // ------------------------------------------------------------------------
                 case K1212_ISRCODE_CARDSTOPPED:
-#ifdef DEBUG
-                        PRINTK("DEBUG: IRQ CSTP count - %ld, %x, [%s].\n", korg1212->irqcount, doorbellValue, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+                        K1212_DEBUG_PRINTK("K1212_DEBUG: IRQ CSTP count - %ld, %x, [%s].\n", korg1212->irqcount, doorbellValue, stateName[korg1212->cardState]);
 #endif
                         writel(0, &korg1212->sharedBufferPtr->cardCommand);
                         break;
 
                 default:
-#ifdef XDEBUG
-                        PRINTK("DEBUG: IRQ DFLT count - %ld, %x, cpos=%d [%s].\n", korg1212->irqcount, doorbellValue, 
+#if K1212_DEBUG_LEVEL > 1
+                        K1212_DEBUG_PRINTK("K1212_DEBUG: IRQ DFLT count - %ld, %x, cpos=%d [%s].\n", korg1212->irqcount, doorbellValue, 
 				korg1212->currentBuffer, stateName[korg1212->cardState]);
 #endif
                         if ((korg1212->cardState > K1212_STATE_SETUP) || korg1212->idleMonitorOn) {
@@ -1123,8 +1131,8 @@
 static int snd_korg1212_downloadDSPCode(korg1212_t *korg1212)
 {
 
-#ifdef DEBUG
-        PRINTK("DEBUG: DSP download is starting... [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: DSP download is starting... [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         // ---------------------------------------------------------------
@@ -1142,8 +1150,8 @@
                                      UpperWordSwap(korg1212->dspMemPhy),
                                      0, 0, 0);
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: Start DSP Download RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Start DSP Download RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
         interruptible_sleep_on_timeout(&korg1212->wait, HZ * 4);
@@ -1195,8 +1203,8 @@
 {
         korg1212_t *korg1212 = (korg1212_t *) pcm->private_data;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_free_pcm [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_free_pcm [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         korg1212->pcm16 = NULL;
@@ -1218,8 +1226,8 @@
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
         snd_pcm_runtime_t *runtime = substream->runtime;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_playback_open [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_playback_open [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         spin_lock_irqsave(&korg1212->lock, flags);
@@ -1248,8 +1256,8 @@
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
         snd_pcm_runtime_t *runtime = substream->runtime;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_capture_open [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_capture_open [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         spin_lock_irqsave(&korg1212->lock, flags);
@@ -1277,8 +1285,8 @@
         unsigned long flags;
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_playback_close [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_playback_close [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         spin_lock_irqsave(&korg1212->lock, flags);
@@ -1297,8 +1305,8 @@
         unsigned long flags;
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_capture_close [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_capture_close [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         spin_lock_irqsave(&korg1212->lock, flags);
@@ -1327,8 +1335,8 @@
         // }
         info->step = sizeof(KorgAudioFrame) * 8;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_channel_info %d:, offset=%ld, first=%d, step=%d\n", chn, info->offset, info->first, info->step);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_channel_info %d:, offset=%ld, first=%d, step=%d\n", chn, info->offset, info->first, info->step);
 #endif
 
 	return 0;
@@ -1337,8 +1345,8 @@
 static int snd_korg1212_ioctl(snd_pcm_substream_t *substream,
 			     unsigned int cmd, void *arg)
 {
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_ioctl: cmd=%d\n", cmd);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_ioctl: cmd=%d\n", cmd);
 #endif
 	if (cmd == SNDRV_PCM_IOCTL1_CHANNEL_INFO ) {
 		snd_pcm_channel_info_t *info = arg;
@@ -1355,8 +1363,8 @@
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
         int err;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_hw_params [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_hw_params [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         spin_lock_irqsave(&korg1212->lock, flags);
@@ -1382,8 +1390,8 @@
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
         unsigned long flags;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_prepare [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_prepare [%s]\n", stateName[korg1212->cardState]);
 #endif
 
         spin_lock_irqsave(&korg1212->lock, flags);
@@ -1401,8 +1409,8 @@
 {
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_trigger [%s] cmd=%d\n", stateName[korg1212->cardState], cmd);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_trigger [%s] cmd=%d\n", stateName[korg1212->cardState], cmd);
 #endif
 
         switch (cmd) {
@@ -1432,8 +1440,8 @@
 
 	pos = korg1212->currentBuffer * kPlayBufferFrames;
 
-#ifdef XDEBUG
-		PRINTK("DEBUG: snd_korg1212_pointer [%s] %ld\n", stateName[korg1212->cardState], pos);
+#if K1212_DEBUG_LEVEL > 1
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_pointer [%s] %ld\n", stateName[korg1212->cardState], pos);
 #endif
 
         return pos;
@@ -1448,13 +1456,13 @@
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
 	KorgAudioFrame * dst = korg1212->playDataBufsPtr[0].bufferData + pos;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_playback_copy [%s] %ld %ld\n", stateName[korg1212->cardState], pos, count);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_playback_copy [%s] %ld %ld\n", stateName[korg1212->cardState], pos, count);
 #endif
  
 	snd_assert(pos + count <= K1212_MAX_SAMPLES, return -EINVAL);
 
-        return copy_from_user(dst, src, count * K1212_FRAME_SIZE) : -EFAULT : 0;
+        return copy_from_user(dst, src, count * K1212_FRAME_SIZE) ? -EFAULT : 0;
 }
 
 static int snd_korg1212_capture_copy(snd_pcm_substream_t *substream,
@@ -1466,8 +1474,8 @@
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
 	KorgAudioFrame * src = korg1212->recordDataBufsPtr[0].bufferData + pos;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_capture_copy [%s] %ld %ld\n", stateName[korg1212->cardState], pos, count);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_capture_copy [%s] %ld %ld\n", stateName[korg1212->cardState], pos, count);
 #endif
 
 	snd_assert(pos + count <= K1212_MAX_SAMPLES, return -EINVAL);
@@ -1483,8 +1491,8 @@
         korg1212_t *korg1212 = _snd_pcm_substream_chip(substream);
 	KorgAudioFrame * dst = korg1212->playDataBufsPtr[0].bufferData + pos;
 
-#ifdef DEBUG
-		PRINTK("DEBUG: snd_korg1212_playback_silence [%s]\n", stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+		K1212_DEBUG_PRINTK("K1212_DEBUG: snd_korg1212_playback_silence [%s]\n", stateName[korg1212->cardState]);
 #endif
 
 	snd_assert(pos + count <= K1212_MAX_SAMPLES, return -EINVAL);
@@ -1935,8 +1943,8 @@
 	ioport_size = pci_resource_len(korg1212->pci, 1);
 	iomem2_size = pci_resource_len(korg1212->pci, 2);
 
-#ifdef DEBUG
-        PRINTK("DEBUG: resources:\n"
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: resources:\n"
                    "    iomem = 0x%lx (%d)\n"
 		   "    ioport  = 0x%lx (%d)\n"
                    "    iomem = 0x%lx (%d)\n"
@@ -2000,8 +2008,8 @@
         korg1212->sensRegPtr = (u16 *) (korg1212->iobase + SENS_CONTROL_OFFSET);
         korg1212->idRegPtr = (u32 *) (korg1212->iobase + DEV_VEND_ID_OFFSET);
 
-#ifdef DEBUG
-        PRINTK("DEBUG: card registers:\n"
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: card registers:\n"
                    "    Status register = 0x%p\n"
                    "    OutDoorbell     = 0x%p\n"
                    "    InDoorbell      = 0x%p\n"
@@ -2034,11 +2042,11 @@
                 return -ENOMEM;
         }
 
-#ifdef DEBUG
-        PRINTK("DEBUG: Shared Buffer Area = 0x%p (0x%08lx), %d bytes\n", korg1212->sharedBufferPtr, korg1212->sharedBufferPhy, sizeof(KorgSharedBuffer));
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: Shared Buffer Area = 0x%p (0x%08lx), %d bytes\n", korg1212->sharedBufferPtr, korg1212->sharedBufferPhy, sizeof(KorgSharedBuffer));
 #endif
 
-#ifndef LARGEALLOC
+#ifndef K1212_LARGEALLOC
 
         korg1212->DataBufsSize = sizeof(KorgAudioBuffer) * kNumBuffers;
 
@@ -2050,8 +2058,8 @@
                 return -ENOMEM;
         }
 
-#ifdef DEBUG
-        PRINTK("DEBUG: Play Data Area = 0x%p (0x%08x), %d bytes\n",
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: Play Data Area = 0x%p (0x%08x), %d bytes\n",
 		korg1212->playDataBufsPtr, korg1212->PlayDataPhy, korg1212->DataBufsSize);
 #endif
 
@@ -2063,19 +2071,19 @@
                 return -ENOMEM;
         }
 
-#ifdef DEBUG
-        PRINTK("DEBUG: Record Data Area = 0x%p (0x%08x), %d bytes\n",
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: Record Data Area = 0x%p (0x%08x), %d bytes\n",
 		korg1212->recordDataBufsPtr, korg1212->RecDataPhy, korg1212->DataBufsSize);
 #endif
 
-#else // LARGEALLOC
+#else // K1212_LARGEALLOC
 
         korg1212->recordDataBufsPtr = korg1212->sharedBufferPtr->recordDataBufs;
         korg1212->playDataBufsPtr = korg1212->sharedBufferPtr->playDataBufs;
         korg1212->PlayDataPhy = (u32) &((KorgSharedBuffer *) korg1212->sharedBufferPhy)->playDataBufs;
         korg1212->RecDataPhy  = (u32) &((KorgSharedBuffer *) korg1212->sharedBufferPhy)->recordDataBufs;
 
-#endif // LARGEALLOC
+#endif // K1212_LARGEALLOC
 
         korg1212->dspCodeSize = sizeof (dspCode);
 
@@ -2091,16 +2099,16 @@
                 return -ENOMEM;
         }
 
-#ifdef DEBUG
-        PRINTK("DEBUG: DSP Code area = 0x%p (0x%08x) %d bytes [%s]\n",
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: DSP Code area = 0x%p (0x%08x) %d bytes [%s]\n",
 		   korg1212->dspMemPtr, korg1212->dspMemPhy, korg1212->dspCodeSize,
 		   stateName[korg1212->cardState]);
 #endif
 
 	rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_RebootCard, 0, 0, 0, 0);
 
-#ifdef DEBUG
-	if (rc) PRINTK("DEBUG: Reboot Card - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
+#if K1212_DEBUG_LEVEL > 0
+	if (rc) K1212_DEBUG_PRINTK("K1212_DEBUG: Reboot Card - RC = %d [%s]\n", rc, stateName[korg1212->cardState]);
 #endif
 
 	snd_korg1212_EnableCardInterrupts(korg1212);
@@ -2197,7 +2205,7 @@
                 korg1212->dspCodeSize = 0;
         }
 
-#ifndef LARGEALLOC
+#ifndef K1212_LARGEALLOC
 
         // ------------------------------------------------------
         // free up memory resources used for the Play/Rec Buffers
@@ -2235,8 +2243,8 @@
 
 static void snd_korg1212_card_free(snd_card_t *card)
 {
-#ifdef DEBUG
-        PRINTK("DEBUG: Freeing card\n");
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: Freeing card\n");
 #endif
 	snd_korg1212_free(card->private_data);
 }
@@ -2276,8 +2284,8 @@
 	sprintf(card->longname, "%s at 0x%lx, irq %d", card->shortname,
 		korg1212->iomem, korg1212->irq);
 
-#ifdef DEBUG
-        PRINTK("DEBUG: %s\n", card->longname);
+#if K1212_DEBUG_LEVEL > 0
+        K1212_DEBUG_PRINTK("K1212_DEBUG: %s\n", card->longname);
 #endif
 
 	if ((err = snd_card_register(card)) < 0) {
diff -Nru a/sound/pci/rme32.c b/sound/pci/rme32.c
--- a/sound/pci/rme32.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/rme32.c	Thu Jun 20 15:54:01 2002
@@ -23,12 +23,8 @@
  *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  * 
  * 
- *   ToDo: - Switching to Mono (32, 32/8, 32Pro)
- *         - ADAT (32/8)
- *         - Doublespeed-Bit, 96kHz (32Pro)
- *         - DAC (32Pro)
- *         - full duplex should be possible
- *         - testing, testing, testing ....
+ *   ToDo: - ADAT (32/8)
+ *         - full duplex (32, 32/8, 32Pro)
  */
 
 #include <sound/driver.h>
@@ -65,7 +61,6 @@
 MODULE_DEVICES("{{RME,Digi32}," "{RME,Digi32/8}," "{RME,Digi32 PRO}}");
 
 /* Defines for RME Digi32 series */
-#define RME32_DRIVER_VERSION "0.3.2"
 #define RME32_SPDIF_NCHANNELS 2
 
 /* Playback and capture buffer size */
@@ -83,7 +78,14 @@
 
 /* Write control register bits */
 #define RME32_WCR_START     (1 << 0)
-#define RME32_WCR_MONO      (1 << 1)
+#define RME32_WCR_MONO      (1 << 1)    /* 0: stereo, 1: mono
+                                           Setting the whole card to mono
+                                           don't seems to be very useful.
+                                           A software-solution can handle 
+                                           full-duplex with one direction in
+                                           stereo and the other way in mono. 
+                                           So, the hardware should work all 
+                                           the time in stereo! */
 #define RME32_WCR_MODE24    (1 << 2)
 #define RME32_WCR_SEL       (1 << 3)
 #define RME32_WCR_FREQ_0    (1 << 4)
@@ -93,7 +95,7 @@
 #define RME32_WCR_RESET     (1 << 8)
 #define RME32_WCR_MUTE      (1 << 9)
 #define RME32_WCR_PRO       (1 << 10)
-#define RME32_WCR_DS_BM     (1 << 11)	/* only PRO-Version */
+#define RME32_WCR_DS_BM     (1 << 11)	/* only PRO/Adat-Version */
 #define RME32_WCR_ADAT      (1 << 12)	/* only Adat-Version */
 #define RME32_WCR_AUTOSYNC  (1 << 13)
 #define RME32_WCR_PD        (1 << 14)	/* only PRO-Version */
@@ -169,9 +171,6 @@
 
 	u8 rev;			/* card revision number */
 
-	pid_t capture_pid;
-	pid_t playback_pid;
-
 	snd_pcm_substream_t *playback_substream;
 	snd_pcm_substream_t *capture_substream;
 
@@ -224,7 +223,7 @@
 static snd_pcm_uframes_t
 snd_rme32_capture_pointer(snd_pcm_substream_t * substream);
 
-static void __init snd_rme32_proc_init(rme32_t * rme32);
+static void snd_rme32_proc_init(rme32_t * rme32);
 
 static void snd_rme32_proc_done(rme32_t * rme32);
 
@@ -261,8 +260,9 @@
 	rme32_t *rme32 = _snd_pcm_substream_chip(substream);
 	count <<= rme32->playback_frlog;
 	pos <<= rme32->playback_frlog;
-	copy_from_user_toio(rme32->iobase + RME32_IO_DATA_BUFFER + pos,
-			    src, count);
+	if (copy_from_user_toio(rme32->iobase + RME32_IO_DATA_BUFFER + pos,
+			    src, count))
+		return -EFAULT;
 	return 0;
 }
 
@@ -273,9 +273,10 @@
 	rme32_t *rme32 = _snd_pcm_substream_chip(substream);
 	count <<= rme32->capture_frlog;
 	pos <<= rme32->capture_frlog;
-	copy_to_user_fromio(dst,
+	if (copy_to_user_fromio(dst,
 			    rme32->iobase + RME32_IO_DATA_BUFFER + pos,
-			    count);
+			    count))
+		return -EFAULT;
 	return 0;
 }
 
@@ -285,10 +286,13 @@
 static snd_pcm_hardware_t snd_rme32_playback_spdif_info = {
 	info:		(SNDRV_PCM_INFO_MMAP |
 			 SNDRV_PCM_INFO_MMAP_VALID |
-			 SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_PAUSE),
-	formats:	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE),
+			 SNDRV_PCM_INFO_INTERLEAVED | 
+			 SNDRV_PCM_INFO_PAUSE),
+	formats:	(SNDRV_PCM_FMTBIT_S16_LE | 
+			 SNDRV_PCM_FMTBIT_S32_LE),
 	rates:		(SNDRV_PCM_RATE_32000 |
-			 SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000),
+			 SNDRV_PCM_RATE_44100 | 
+			 SNDRV_PCM_RATE_48000),
 	rate_min:	32000,
 	rate_max:	48000,
 	channels_min:	2,
@@ -323,6 +327,13 @@
 	fifo_size:	0,
 };
 
+static void snd_rme32_reset_dac(rme32_t *rme32)
+{
+        writel(rme32->wcreg | RME32_WCR_PD,
+               rme32->iobase + RME32_IO_CONTROL_REGISTER);
+        writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+}
+
 static int snd_rme32_playback_getrate(rme32_t * rme32)
 {
 	int rate;
@@ -342,7 +353,7 @@
 	default:
 		return -1;
 	}
-	return rate;
+	return (rme32->wcreg & RME32_WCR_DS_BM) ? rate << 1 : rate;
 }
 
 static int snd_rme32_capture_getrate(rme32_t * rme32, int *is_adat)
@@ -403,20 +414,57 @@
 
 static int snd_rme32_playback_setrate(rme32_t * rme32, int rate)
 {
+        int ds;
+
+        ds = rme32->wcreg & RME32_WCR_DS_BM;
 	switch (rate) {
 	case 32000:
-		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & ~RME32_WCR_FREQ_1;
+		rme32->wcreg &= ~RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & 
+			~RME32_WCR_FREQ_1;
 		break;
 	case 44100:
-		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) & ~RME32_WCR_FREQ_0;
+		rme32->wcreg &= ~RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) & 
+			~RME32_WCR_FREQ_0;
 		break;
 	case 48000:
-		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | RME32_WCR_FREQ_1;
+		rme32->wcreg &= ~RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | 
+			RME32_WCR_FREQ_1;
+		break;
+	case 64000:
+		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+			return -EINVAL;
+		rme32->wcreg |= RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & 
+			~RME32_WCR_FREQ_1;
+		break;
+	case 88200:
+		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+			return -EINVAL;
+		rme32->wcreg |= RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) & 
+			~RME32_WCR_FREQ_0;
+		break;
+	case 96000:
+		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+			return -EINVAL;
+		rme32->wcreg |= RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | 
+			RME32_WCR_FREQ_1;
 		break;
 	default:
 		return -EINVAL;
 	}
-	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+        if ((!ds && rme32->wcreg & RME32_WCR_DS_BM) ||
+            (ds && !(rme32->wcreg & RME32_WCR_DS_BM)))
+        {
+                /* change to/from double-speed: reset the DAC (if available) */
+                snd_rme32_reset_dac(rme32);
+        } else {
+                writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	}
 	return 0;
 }
 
@@ -424,16 +472,20 @@
 {
 	switch (mode) {
 	case RME32_CLOCKMODE_SLAVE:
-		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) & ~RME32_WCR_FREQ_1;
+		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) & 
+			~RME32_WCR_FREQ_1;
 		break;
 	case RME32_CLOCKMODE_MASTER_32:
-		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & ~RME32_WCR_FREQ_1;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & 
+			~RME32_WCR_FREQ_1;
 		break;
 	case RME32_CLOCKMODE_MASTER_44:
-		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) | RME32_WCR_FREQ_1;
+		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) | 
+			RME32_WCR_FREQ_1;
 		break;
 	case RME32_CLOCKMODE_MASTER_48:
-		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | RME32_WCR_FREQ_1;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | 
+			RME32_WCR_FREQ_1;
 		break;
 	default:
 		return -EINVAL;
@@ -452,16 +504,20 @@
 {
 	switch (type) {
 	case RME32_INPUT_OPTICAL:
-		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) & ~RME32_WCR_INP_1;
+		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) & 
+			~RME32_WCR_INP_1;
 		break;
 	case RME32_INPUT_COAXIAL:
-		rme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) & ~RME32_WCR_INP_1;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) & 
+			~RME32_WCR_INP_1;
 		break;
 	case RME32_INPUT_INTERNAL:
-		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) | RME32_WCR_INP_1;
+		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) | 
+			RME32_WCR_INP_1;
 		break;
 	case RME32_INPUT_XLR:
-		rme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) | RME32_WCR_INP_1;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) | 
+			RME32_WCR_INP_1;
 		break;
 	default:
 		return -EINVAL;
@@ -702,12 +758,13 @@
 	rme32->playback_substream = substream;
 	rme32->playback_last_appl_ptr = 0;
 	rme32->playback_ptr = 0;
+	spin_unlock_irqrestore(&rme32->lock, flags);
 
 	runtime->hw = snd_rme32_playback_spdif_info;
-	rme32->playback_pid = current->pid;
-	rme32->playback_substream = substream;
-
-	spin_unlock_irqrestore(&rme32->lock, flags);
+	if (rme32->pci->device == PCI_DEVICE_ID_DIGI32_PRO) {
+		runtime->hw.rates |= SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000;
+		runtime->hw.rate_max = 96000;
+	}
 
 	snd_pcm_hw_constraint_minmax(runtime,
 				     SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
@@ -743,7 +800,6 @@
 
 	spin_lock_irqsave(&rme32->lock, flags);
 
-	rme32->capture_pid = current->pid;
 	rme32->capture_substream = substream;
 	rme32->capture_ptr = 0;
 	spin_unlock_irqrestore(&rme32->lock, flags);
@@ -768,7 +824,6 @@
 	int spdif = 0;
 
 	spin_lock_irqsave(&rme32->lock, flags);
-	rme32->playback_pid = -1;
 	rme32->playback_substream = NULL;
 	rme32->playback_periodsize = 0;
 	spdif = (rme32->wcreg & RME32_WCR_ADAT) == 0;
@@ -788,7 +843,6 @@
 	rme32_t *rme32 = _snd_pcm_substream_chip(substream);
 
 	spin_lock_irqsave(&rme32->lock, flags);
-	rme32->capture_pid = -1;
 	rme32->capture_substream = NULL;
 	rme32->capture_periodsize = 0;
 	spin_unlock_irqrestore(&rme32->lock, flags);
@@ -829,7 +883,6 @@
 snd_rme32_playback_trigger(snd_pcm_substream_t * substream, int cmd)
 {
 	rme32_t *rme32 = _snd_pcm_substream_chip(substream);
-	spin_lock(&rme32->lock);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		if (!RME32_ISWORKING(rme32)) {
@@ -864,7 +917,6 @@
 	default:
 		return -EINVAL;
 	}
-	spin_unlock(&rme32->lock);
 	return 0;
 }
 
@@ -1011,7 +1063,7 @@
 	snd_pcm_lib_preallocate_free_for_all(pcm);
 }
 
-static int __init snd_rme32_create(rme32_t * rme32)
+static int __devinit snd_rme32_create(rme32_t * rme32)
 {
 	struct pci_dev *pci = rme32->pci;
 	int err;
@@ -1077,6 +1129,9 @@
 	snd_rme32_playback_stop(rme32);
 	snd_rme32_capture_stop(rme32);
 
+        /* reset DAC */
+        snd_rme32_reset_dac(rme32);
+
 	/* reset buffer pointer */
 	writel(0, rme32->iobase + RME32_IO_RESET_POS);
 
@@ -1095,8 +1150,6 @@
 	/* init proc interface */
 	snd_rme32_proc_init(rme32);
 
-	rme32->playback_pid = -1;
-	rme32->capture_pid = -1;
 	rme32->capture_substream = NULL;
 	rme32->playback_substream = NULL;
 
@@ -1119,8 +1172,6 @@
 	snd_iprintf(buffer, " (index #%d)\n", rme32->card->number + 1);
 
 	snd_iprintf(buffer, "\nGeneral settings\n");
-	snd_iprintf(buffer, "  driver version: %s\n",
-		    RME32_DRIVER_VERSION);
 	if (RME32_PRO_WITH_8414(rme32)) {
 		snd_iprintf(buffer, "  receiver: CS8414\n");
 	} else {
@@ -1200,7 +1251,7 @@
 	}
 }
 
-static void __init snd_rme32_proc_init(rme32_t * rme32)
+static void __devinit snd_rme32_proc_init(rme32_t * rme32)
 {
 	snd_info_entry_t *entry;
 
@@ -1596,7 +1647,7 @@
 	snd_rme32_free(card->private_data);
 }
 
-static int __init
+static int __devinit
 snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *id)
 {
 	static int dev = 0;
@@ -1650,7 +1701,7 @@
 	return 0;
 }
 
-static void __exit snd_rme32_remove(struct pci_dev *pci)
+static void __devexit snd_rme32_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1660,7 +1711,7 @@
 	name:		"RME Digi32",
 	id_table:	snd_rme32_ids,
 	probe:		snd_rme32_probe,
-	remove:		snd_rme32_remove,
+	remove:		__devexit_p(snd_rme32_remove),
 };
 
 static int __init alsa_card_rme32_init(void)
diff -Nru a/sound/pci/rme96.c b/sound/pci/rme96.c
--- a/sound/pci/rme96.c	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/rme96.c	Thu Jun 20 15:54:00 2002
@@ -37,6 +37,8 @@
 #define SNDRV_GET_ID
 #include <sound/initval.h>
 
+/* note, two last pcis should be equal, it is not a bug */
+
 MODULE_AUTHOR("Anders Torger <torger@ludd.luth.se>");
 MODULE_DESCRIPTION("RME Digi96, Digi96/8, Digi96/8 PRO, Digi96/8 PST, "
 		   "Digi96/8 PAD");
diff -Nru a/sound/pci/rme9652/Makefile b/sound/pci/rme9652/Makefile
--- a/sound/pci/rme9652/Makefile	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/rme9652/Makefile	Thu Jun 20 15:54:00 2002
@@ -3,12 +3,14 @@
 # Copyright (c) 2001 by Jaroslav Kysela <perex@suse.cz>
 #
 
-export-objs  := rme9652_mem.o
+export-objs  := hammerfall_mem.o
 
-snd-rme9652-mem-objs := rme9652_mem.o
+snd-hammerfall-mem-objs := hammerfall_mem.o
 snd-rme9652-objs := rme9652.o
+snd-hdsp-objs := hdsp.o
 
 # Toplevel Module Dependency
-obj-$(CONFIG_SND_RME9652) += snd-rme9652.o snd-rme9652-mem.o
+obj-$(CONFIG_SND_RME9652) += snd-rme9652.o snd-hammerfall-mem.o
+obj-$(CONFIG_SND_HDSP) += snd-hdsp.o snd-hammerfall-mem.o
 
 include $(TOPDIR)/Rules.make
diff -Nru a/sound/pci/rme9652/digiface_firmware.dat b/sound/pci/rme9652/digiface_firmware.dat
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/sound/pci/rme9652/digiface_firmware.dat	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,4072 @@
+/* stored in little-endian */
+static u32 digiface_firmware[97652] __devinitdata = {
+0xffffffff, 0x66aa9955, 0x8001000c, 0xe0000000, 0x8006800c, 0xb0000000,
+0x8004800c, 0xb4fc0100, 0x8003000c, 0x00000000, 0x8001000c, 0x90000000,
+0x8004000c, 0x00000000, 0x8001000c, 0x80000000, 0x0002000c, 0x581a000a,
+0x00044800, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00800000,
+0x00000120, 0x00000000, 0x00044800, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x40800000, 0x00000120, 0x00000000, 0x00024001, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000100, 0x00000000,
+0x00004000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000100, 0x00000000, 0x00004008, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000900, 0x00000000, 0x0000c008, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000320, 0x00000000,
+0x00004801, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000120, 0x00000000, 0x438048f6, 0x78011e00, 0x8005e001, 0x015c001f,
+0x11e000f8, 0x9e004f80, 0xe005f801, 0x002f8019, 0x057801be, 0x778005e0,
+0xd800fe00, 0xbc0f6002, 0x00000123, 0x00000000, 0x040fb003, 0x03cd803f,
+0x3cc40fb2, 0xfc20ff00, 0xc00ff083, 0x20ff083f, 0x0f3003ec, 0xff0837ca,
+0xf003fc00, 0x113e820f, 0x0bcc40fb, 0x0fc0c311, 0x00000e00, 0x00000000,
+0x00870001, 0x0844a03f, 0x044001f1, 0x74000e08, 0x4201f000, 0x001d0007,
+0x01500074, 0x1d100740, 0xd0007400, 0x01854143, 0x0bc40051, 0x0440c1b0,
+0x00000c20, 0x00000000, 0x0043a011, 0x0a24000d, 0x304808d0, 0x1420cd20,
+0x400cd003, 0x00c10013, 0x0c158314, 0xc5001340, 0xd0033440, 0x04915004,
+0x1b060049, 0x44404019, 0x00000e80, 0x00000000, 0x09058803, 0x81643155,
+0x04410550, 0x76201d00, 0x4001d900, 0x001d9827, 0x01590034, 0x1c002700,
+0xd8007600, 0x00275009, 0x030608c1, 0x0c402414, 0x00000620, 0x00000000,
+0x0037a802, 0x0166011d, 0x54d00d90, 0x7c001f02, 0xc201f080, 0x33df0027,
+0x0110006c, 0x5f0277c2, 0xf0807428, 0x0026c209, 0x034c52db, 0x02d01910,
+0x00000e20, 0x00000000, 0x003d8007, 0x02d4202f, 0x6f8803f2, 0xfc00f720,
+0xc00f7003, 0x083f101f, 0x0fb003f8, 0xbf100fc0, 0xf003fc01, 0x0818c006,
+0x83fd80ff, 0x1ec093f0, 0x00000602, 0x00000000, 0x00150802, 0x904e8397,
+0x17c089b0, 0x7c001f01, 0xc0417020, 0x00db0107, 0x01f0007c, 0x5f0117c8,
+0x30007c18, 0x0804c001, 0x034c00d3, 0x08c06bb0, 0x00000420, 0x00000000,
+0x0c14a013, 0x0b4c21dd, 0x2740a514, 0x6001d601, 0x803d1003, 0x09152077,
+0xbdd10774, 0x9d006748, 0x402b7c42, 0x04fe400f, 0x03c400d1, 0x4c913910,
+0x00000200, 0x00000000, 0x00428007, 0x07048085, 0x63403510, 0x0405cd00,
+0x421c901b, 0x220120b3, 0x0cd04f34, 0x8920e340, 0x90073443, 0x0972580c,
+0x032400c1, 0x1c403410, 0x00000a00, 0x00000000, 0x00488004, 0x24a409ad,
+0x5b408a10, 0x94312508, 0x411290a4, 0x91e10249, 0x92d0a4b4, 0x6d0c5b40,
+0xd0140425, 0x000a0010, 0x07a400c1, 0x1a409e14, 0x00000200, 0x00000000,
+0x00300012, 0x62460097, 0x23c00034, 0x7d00cf00, 0x400cf403, 0x04034417,
+0x0cf0433c, 0x8f2043c1, 0xb0673400, 0x0314c004, 0x036c48c3, 0x48c08130,
+0x00000040, 0x00000000, 0x003da802, 0x21dc20ff, 0x17c0cf70, 0xec883f00,
+0x80037200, 0x00f7a82f, 0x03f2007c, 0x7f203fc2, 0x70807c84, 0x016dc88b,
+0x0bdc0cbf, 0x09c08771, 0x00000660, 0x00000000, 0x0027aa15, 0x014c049f,
+0x05401530, 0x5c001300, 0xc0113004, 0x00170024, 0x01300044, 0x1f0024d0,
+0xf0005c00, 0x0027c0e9, 0x236c00df, 0x54c01f10, 0x00000e00, 0x00000000,
+0x10298812, 0x02ec08fd, 0x38600a10, 0x3c00eb28, 0xc40eb303, 0x00eb0012,
+0x0fb00384, 0xf90018c0, 0xd103bc00, 0x005b4146, 0x038440ad, 0x48400c12,
+0x00000620, 0x00000000, 0x00790003, 0x048400ad, 0x40401283, 0xb4012508,
+0x40109004, 0x01210048, 0x12900404, 0x2d004a40, 0xd0048441, 0x024b4052,
+0x173401ed, 0x0d411e13, 0x00000402, 0x00000000, 0x04b32012, 0x030449cd,
+0x31400c90, 0x3448cd10, 0x452c984b, 0x00c98232, 0x2c900f04, 0xc9203061,
+0xd8cb0512, 0x8033601d, 0x031403cd, 0x49403c10, 0x00000c20, 0x00000000,
+0x01dda017, 0x09c4827f, 0x14d005b4, 0x5c035702, 0x4865b019, 0x40510054,
+0x65903545, 0x5d1016c2, 0xf0195402, 0x0113e055, 0x017c117f, 0x5dd03730,
+0x00000620, 0x00000000, 0x20030012, 0x407c301f, 0x8ac80373, 0xdc063b10,
+0xc023f208, 0x023e008f, 0x03f008bc, 0x3b000fc0, 0xf000fe02, 0x000fea23,
+0x0024001f, 0x4a0061f4, 0x00000c00, 0x00000000, 0x00270010, 0x020c0883,
+0x67c04930, 0x7c419300, 0xc0599016, 0x05830161, 0x4830066c, 0x8720a0c0,
+0x308a2e41, 0x3824cc59, 0x026d5097, 0x43c01930, 0x00000c20, 0x00000000,
+0x38662801, 0x16540091, 0x27644950, 0x5c009500, 0x40499012, 0x839500e7,
+0x7952165c, 0x9510e540, 0x520e5403, 0x00244009, 0x02640091, 0x07407950,
+0x00000800, 0x00000000, 0x0224a018, 0x12440091, 0x2f400912, 0xe488b902,
+0x400bd082, 0x00bd002f, 0x0b1822c4, 0xb1102c40, 0x1002c408, 0x902e002b,
+0x0245008d, 0x63444910, 0x00000200, 0x00000000, 0x48202010, 0x0a140281,
+0xab402a50, 0x8402ad00, 0x442a910a, 0xc2a528ab, 0x2a528a94, 0xa538b944,
+0x520b9402, 0x022a528a, 0x12040089, 0x43408850, 0x00000080, 0x00000000,
+0x0506b01d, 0x504e0013, 0x17400030, 0x7c205b20, 0xc001f000, 0x004b2017,
+0x0130004e, 0x570004c0, 0x30006c00, 0x0d8ec161, 0x2c6c1e0f, 0x77c16130,
+0x00000ac0, 0x00000000, 0x002f9019, 0x02fc42ff, 0xa7c029f1, 0x70029720,
+0xc029f00a, 0x029f10b7, 0x29f00a5c, 0x9f00a7c2, 0xf00a7c82, 0x0125c049,
+0x267c81b7, 0x67c24bb4, 0x00000e60, 0x00000000, 0x012fa818, 0x0a4c14bf,
+0x24c129b0, 0x4c089e05, 0x89693222, 0x149325a4, 0x29321246, 0x93022480,
+0xb04a6802, 0x002fc94b, 0x026c009d, 0x67c10bf0, 0x00000e00, 0x00000000,
+0x8087081c, 0x006c461d, 0x86c02110, 0x6c421d30, 0xc461b008, 0x42111186,
+0x01113844, 0x1b938440, 0x1100ec80, 0x01074060, 0x28440e17, 0x734021e0,
+0x00000c22, 0x00000000, 0x00a3a010, 0x1284108d, 0x2b604a50, 0x8606ad84,
+0x600ad81a, 0x10a58028, 0x6a584296, 0xad802942, 0x98129446, 0x04a24908,
+0x5224108d, 0x434148d0, 0x00000e80, 0x00000000, 0x01a5a018, 0x0224009d,
+0x2f440b10, 0xa400bd00, 0x420bd002, 0x60b5182a, 0x0a5103c4, 0xb91c2d40,
+0x1002f420, 0x00276409, 0x82640095, 0x63414950, 0x00000620, 0x00000000,
+0x00a7a005, 0x064c029d, 0x25c009b4, 0x4c009f00, 0xc009f402, 0x00974024,
+0x09540255, 0x9d00a5d0, 0xb0025420, 0x0126c909, 0x026c049f, 0x17c039d0,
+0x00000e20, 0x00000000, 0x00258014, 0x0e7c029f, 0x26c099f0, 0x7c008f00,
+0xc4093082, 0x009b3827, 0x09b3026c, 0x9b0026c0, 0xf0026c00, 0x0427e809,
+0x025c0587, 0x53c019f0, 0x00000600, 0x00000000, 0x00050014, 0x00cc0217,
+0x0cc30238, 0xcc103340, 0xc4023000, 0x8037048f, 0x03f280cc, 0x2b0088c0,
+0xf000f800, 0x2084c001, 0x80480213, 0x53c021d2, 0x00000420, 0x00000000,
+0x0014a814, 0x0145015d, 0x95431558, 0x54025100, 0x44355021, 0x1b570017,
+0x85d18970, 0x5d201540, 0xd001f40a, 0x009c4007, 0x01440055, 0x530067d0,
+0x00000200, 0x00000000, 0x0032a014, 0x038401dd, 0xba601e12, 0xb628e904,
+0x43ae90a3, 0x23fd20bb, 0x0e904fe4, 0xed0c7860, 0xd087d48a, 0x08b3420c,
+0x830400c9, 0x53413cd0, 0x00000a00, 0x00000000, 0x10388005, 0x038402ed,
+0xfb400c50, 0x3400e900, 0x400ed203, 0x00e5003a, 0x2ed00bb4, 0xed843940,
+0xd00ba440, 0x0043421e, 0x138404ed, 0x17400ed0, 0x00000200, 0x00000000,
+0x00681015, 0x070c81ff, 0x7ec01e18, 0xbc01cb18, 0xc01eb007, 0x21c7007b,
+0x1cf187ac, 0xeb0078c0, 0xf0079c01, 0x007bc01e, 0x178e01fb, 0x57c01af0,
+0x00000040, 0x00000000, 0x0035b010, 0x007c00df, 0x05c001f0, 0x5c001710,
+0xc0016000, 0x001f0017, 0x01f0005c, 0x1f1007c8, 0xf0007c00, 0x0804c00d,
+0x1b7d0ad7, 0x43c003f0, 0x00000660, 0x00000000, 0x007ba000, 0x07c804f3,
+0x7c801f30, 0xc801f300, 0xc01fb007, 0x09da0274, 0x1fe007dc, 0xf2027f80,
+0xf087f809, 0x005cc09d, 0x4f5403df, 0x0bc097f0, 0x00000e00, 0x00000000,
+0x00398815, 0x138410ab, 0x3ac04e10, 0x8444f100, 0x440ef113, 0x27ef0078,
+0x0ef023b4, 0xeb10b9c0, 0xd0033408, 0x0408441e, 0x079421fd, 0x57c00ad0,
+0x00000620, 0x00000000, 0x00290000, 0x83040081, 0x38400e12, 0xa400e102,
+0x400e9843, 0x08ed0138, 0x0ed003b4, 0xe9003b40, 0xd047b400, 0x001a408c,
+0x038700ed, 0x236006d0, 0x00000400, 0x00000000, 0x30332804, 0x8c240099,
+0xc260a010, 0x340a0120, 0x40315a08, 0x420d1210, 0xe0402834, 0x01428540,
+0xd004344e, 0x0040489c, 0x030413dd, 0x194020d0, 0x00000c20, 0x00000000,
+0x0035a815, 0x634c01d1, 0xf4c83d10, 0x6d03d349, 0x507d900b, 0x92d90064,
+0x3dd00f5e, 0xd900f7c0, 0xd0077c03, 0x00c4c00d, 0x03dd12ff, 0x57400dd0,
+0x00000620, 0x00000000, 0x28260001, 0x015c00df, 0xb7c02df0, 0x4c00df00,
+0xc02df10b, 0xc2d700a7, 0x2df0037c, 0xdf08b7c4, 0xf2037c42, 0x0497d00c,
+0x037400df, 0x27007ff2, 0x00000c00, 0x00000000, 0x006b0880, 0x02a400f3,
+0x7ec10c30, 0xfc11ff04, 0xc19ff057, 0x15f7046c, 0x9ff0c3c4, 0xf3043e00,
+0x7063cc42, 0x000cc103, 0x03cd00f3, 0x04c01af1, 0x00000c20, 0x00000000,
+0x00262081, 0x034400d1, 0x85404110, 0x74041d10, 0x4031d10c, 0x401e2404,
+0x51d00874, 0x1110c740, 0x10045401, 0x43514031, 0x034080d5, 0x254059d0,
+0x00000802, 0x00000000, 0x02342001, 0x1b5400d1, 0x04404110, 0x74081d06,
+0x41015840, 0x201c2204, 0x01d0a044, 0x01020640, 0x500224b0, 0x0024538d,
+0x834000d1, 0x044085d0, 0x00000200, 0x00000000, 0x00202010, 0x01140081,
+0x01400010, 0x34000c00, 0x5000d800, 0x24090100, 0x00d10036, 0x01400340,
+0x10023400, 0x0010410c, 0x030404c1, 0x404004d2, 0x00000080, 0x00000000,
+0x00269000, 0x025c0093, 0x00c00110, 0x7c801f08, 0xc8007080, 0x011f0844,
+0x01f2004e, 0x120202c2, 0x70826c80, 0x0024c011, 0x17cc01f3, 0x04c001f0,
+0x00000ac0, 0x00000000, 0x802fb005, 0x03cc00bf, 0x3fc40fd0, 0xfc00ff10,
+0xc00ff103, 0x08f7022f, 0x0ff003fc, 0xff097fc0, 0xf045dc00, 0x001fc403,
+0xa3fc08ff, 0x17c003f0, 0x00000e40, 0x00000000, 0x000fa003, 0x23fc00ff,
+0x3cc00f31, 0xcc00fd30, 0xc00ff003, 0x40ff002d, 0x0f7803cc, 0xfa003fc4,
+0xf081cc80, 0x083fc00f, 0x03cc04f3, 0x0cc06f74, 0x00000e00, 0x00000000,
+0x04870801, 0x0274121d, 0x054001b8, 0x6c801f00, 0x4001d200, 0xc0170807,
+0x01520044, 0x05280740, 0xd0026c80, 0x00b7400d, 0x03948ae1, 0x04404e10,
+0x00000c20, 0x00000000, 0x0303a011, 0x01160ccd, 0x02460090, 0x04800d00,
+0x44005800, 0x000d0001, 0x00900005, 0x05200140, 0x50022420, 0x60b14008,
+0x033400c9, 0x44406c10, 0x00000e80, 0x00000000, 0x0005a803, 0x0336289d,
+0x07428110, 0x6400152c, 0x4241d080, 0x20151207, 0x81504054, 0x15000646,
+0xd1826420, 0x0037420d, 0x033400d9, 0x0c400d12, 0x00000620, 0x00000000,
+0x0637a802, 0x077c00df, 0x06c82190, 0x4c0b1d08, 0xc131f01c, 0x041f0145,
+0x21b3084c, 0x1704c7c4, 0xf0046c49, 0x0237c00d, 0x037c00db, 0x08c00d10,
+0x00000e20, 0x00000000, 0x003d8007, 0x0efca07e, 0x3dc80ff2, 0xfc21ff0a,
+0xc01ff013, 0x04ff1027, 0x0df023ec, 0xf500bb80, 0xf027fc00, 0x0077400f,
+0x03dc60f7, 0x1fc00f80, 0x00000600, 0x00000000, 0x10350802, 0x017c08df,
+0x37c02cf0, 0x7c02c300, 0xc00df083, 0x20d70027, 0x2df00b3c, 0xc34236c0,
+0xb1034c80, 0x0437c04d, 0x035c00c3, 0x08c00db4, 0x00000420, 0x00000000,
+0x0ef4a213, 0x03460bd9, 0x37400dd0, 0x6403d5a0, 0xc10dd007, 0x18d50c24,
+0x5de0c364, 0xd0087542, 0x500f4401, 0x00b7043d, 0x03c407f1, 0x4c400f50,
+0x00000200, 0x00000000, 0x0022a007, 0x2014230d, 0x034000d0, 0x342501a0,
+0x6330d06c, 0x011104d2, 0x00904824, 0x05048141, 0x116c0413, 0x40b7402c,
+0x030513c9, 0x1c400d10, 0x00000a00, 0x00000000, 0x00688004, 0x07844129,
+0x73401ed1, 0xb499e520, 0x645ed007, 0x01e50178, 0xded007a4, 0xe5027940,
+0x53170411, 0x147b415e, 0x27a481e9, 0x10401e50, 0x00000200, 0x00000000,
+0x00301012, 0x0b140a1f, 0x33c28cf1, 0x3c02c100, 0xc00cf023, 0x00c70033,
+0x6cf0333c, 0xc72035c0, 0x30030d0c, 0x00238008, 0x031c80cb, 0x48c00c32,
+0x00000040, 0x00000000, 0x003db802, 0x23dc00bb, 0x3fc20ff0, 0xec20ff00,
+0xc24ff0a3, 0x00de0136, 0x4f70a3ec, 0xfb003dc0, 0x73177c28, 0x002fc24f,
+0x83dc40f7, 0x0bc00f71, 0x00000660, 0x00000000, 0x0027a015, 0x007c001f,
+0x05c201f0, 0x4d001f00, 0xc2013100, 0x001b0054, 0x11f2007c, 0x1b0804c8,
+0x30047c00, 0x0834c01d, 0x434485d1, 0x54c13d34, 0x00000e00, 0x00000000,
+0x00298812, 0x03b4006c, 0x39c00ed0, 0x8400e320, 0x400e9803, 0x80e12038,
+0x0ec803b4, 0xeb083040, 0xb003b400, 0x2038440f, 0x138414fb, 0x49404e50,
+0x00000620, 0x00000000, 0x00f90003, 0x07b4012d, 0x79401e50, 0x8401ed00,
+0x401e1007, 0x01e10078, 0x1ed007b4, 0xe408f848, 0x50473401, 0x2061401e,
+0x27850ce1, 0x0c549c50, 0x00000400, 0x00000000, 0x01b30812, 0x03b600cd,
+0xbd407ed0, 0x8407f500, 0x401e904f, 0x8ae100b8, 0x1ed02fb4, 0xed08f844,
+0xd003b440, 0x0021501c, 0x030400c9, 0x49400c58, 0x00000c20, 0x00000000,
+0x005da817, 0x0174117f, 0xd5c11470, 0x4c115f04, 0xd1953049, 0x015b4094,
+0x65f00d7c, 0x570014d0, 0x7001f405, 0x0015c115, 0x014c0053, 0x5cc00550,
+0x00000620, 0x00000000, 0x10830012, 0x08fe001f, 0x0dc403f2, 0xfc423304,
+0xc022b188, 0x063f210f, 0x63f148f4, 0x3ba08fc4, 0x9008fc02, 0x1006c001,
+0x007c821b, 0x4ac001a2, 0x00000c00, 0x00000000, 0x00270810, 0x061c0293,
+0x26c00970, 0x4c019300, 0xc019b0a6, 0x059f0024, 0x5930163c, 0x9304a7c0,
+0xf0227c99, 0x0223c009, 0x020c0583, 0x43c009b4, 0x00000c20, 0x00000000,
+0x00260001, 0x1a4c0091, 0x25c08950, 0x44129520, 0x01b9140e, 0x279d0025,
+0x49529e74, 0x9101a748, 0xd00a7403, 0x00e74009, 0x02440495, 0x0740091c,
+0x00000800, 0x00000000, 0x8024a018, 0x22540089, 0x2c400f10, 0x8404b120,
+0x000b1242, 0x00bd022c, 0x0b1002f4, 0xf0002b46, 0xd082f490, 0x04270089,
+0x02444091, 0x63400914, 0x00000200, 0x00000000, 0x42302010, 0x22a40281,
+0xa9480a50, 0x8502a500, 0x422a100a, 0x02ad00a9, 0x2a500ab4, 0xa140aa40,
+0xd10bb402, 0x05a34028, 0x12040685, 0x43404812, 0x00000080, 0x00000000,
+0x0586b01d, 0x085e8013, 0x04c00170, 0x4c000300, 0xc8003000, 0x801f0810,
+0x0030807c, 0x120007c0, 0xf000fc00, 0x0107c005, 0x2c0c0113, 0x77c0b134,
+0x00000ac0, 0x00000000, 0x012fb819, 0x1a4c02bf, 0xa5c029f0, 0x7c429f00,
+0xc429f10a, 0x029f00a7, 0x29f10a7c, 0x9f00a7c0, 0xf20a7c02, 0x002fc00b,
+0x267c289d, 0x67c099f0, 0x00000e60, 0x00000000, 0x01afa818, 0x1a6c06b7,
+0xa4c04b70, 0x4c869e01, 0x4009b032, 0x109f0027, 0x6930124c, 0x9f2327c0,
+0xb0027000, 0x09254489, 0x1a7c8093, 0x63c00932, 0x00000e00, 0x00000000,
+0x0183081c, 0x184c8617, 0x84c021d0, 0x5c021b21, 0xc0417008, 0x44170014,
+0x05a20144, 0x1f001740, 0x10a8742a, 0x03874000, 0x90740a31, 0x7341e110,
+0x00000c20, 0x00000000, 0x00a30010, 0x1a260285, 0xa2502850, 0x8602ad10,
+0x412a911a, 0x10ad04ab, 0x2a825a85, 0xad01ab48, 0x1442b494, 0x442b444a,
+0x1a3414a1, 0x43400854, 0x00000e80, 0x00000000, 0x01258018, 0x43440295,
+0x254109d0, 0xd4009590, 0x630b5022, 0xa0a50a2c, 0x8b102284, 0xb52a2f48,
+0x1142f4d0, 0x283b600b, 0x027400b1, 0x63400950, 0x00000620, 0x00000000,
+0x0027a005, 0x0e6c0097, 0x64c03970, 0x4c189d01, 0xc039b046, 0x079f2027,
+0x0994024c, 0x9d00e7c0, 0xb2027420, 0x1065c209, 0x027c4091, 0x17420970,
+0x00000e20, 0x00000000, 0x00258014, 0x135c009f, 0x24c088f0, 0x5c019b32,
+0xc08970c2, 0x84970026, 0x09f2426c, 0x9c8027c1, 0xf0267c19, 0x0926c029,
+0x027c009b, 0x53c00920, 0x00000600, 0x00000000, 0x00050014, 0x007c000b,
+0x87c001f0, 0xcc003b80, 0xc0033000, 0x5033000c, 0x03b000cc, 0x3c000cc0,
+0xf108cc02, 0x020ed003, 0x003c003b, 0x50c00130, 0x00000420, 0x00000000,
+0x001ca814, 0x6d440071, 0x174005d0, 0x54005f20, 0x4015b019, 0x035b00d5,
+0x05f0096c, 0x5d0017c0, 0xd2215413, 0x20144225, 0x01740175, 0x50400500,
+0x00000200, 0x00000000, 0x0072a014, 0x031410c1, 0x33400cd0, 0xa400f100,
+0x61ae500b, 0x2be103fa, 0x0e102bb4, 0xe9333840, 0xd007e402, 0x8cf842fe,
+0x033481e1, 0x50500c00, 0x00000a00, 0x00000000, 0x20f88005, 0x038400c1,
+0x72400ed8, 0x3400cd08, 0x6c1cd107, 0x00e9007b, 0x3ed203a4, 0xed203a40,
+0xd0439401, 0x0030481e, 0x13b442e5, 0x14405e10, 0x00000200, 0x00000000,
+0x40781015, 0x279c01a1, 0xfb401ad0, 0xa401e104, 0xc01e7007, 0x61c30072,
+0x1c3407d8, 0xfa1078cc, 0xf1078c81, 0x08788a1e, 0x073c01e3, 0x54c05c36,
+0x00000040, 0x00000000, 0x0015b010, 0x134c0097, 0xb7c009d0, 0x5c001901,
+0xcc01b000, 0x001f0005, 0x0530006c, 0x1d0807c6, 0xf1007c20, 0x0805c001,
+0x2b7c0017, 0x43c0edf1, 0x00000660, 0x00000000, 0x906fa200, 0x07fc0573,
+0x7ec01f70, 0xcc01f700, 0x001f3407, 0x41f7427f, 0x1bfa377c, 0xff027cd0,
+0x7427fc81, 0x027fc09f, 0x0fcc41f3, 0x03c03f32, 0x00000e00, 0x00000000,
+0x003c8815, 0x02bc006b, 0x3de00eb0, 0xd410f12a, 0xc00e7083, 0x20e1033d,
+0x6bd817b4, 0xed02b941, 0x100bb400, 0x0b3b44ce, 0x23d440ef, 0x57404eb0,
+0x00000620, 0x00000000, 0x00290000, 0x01340621, 0x3a408a90, 0x8400e500,
+0x410e1063, 0x08e1003b, 0x0a5203a4, 0xed0a3840, 0x1203b400, 0x803b480e,
+0x038401e5, 0x03600e90, 0x00000400, 0x00000000, 0x08132804, 0x08140001,
+0x71481811, 0x14010100, 0x4001104c, 0x60010241, 0x00d00034, 0x0d090040,
+0x1028340b, 0x00034200, 0x0354600d, 0x13400c80, 0x00000c20, 0x00000000,
+0x3015a815, 0x65744091, 0xbec1b914, 0x4c43d522, 0xc2bd1107, 0x53d720b7,
+0x2d784b74, 0xdd04f4c0, 0x708f7c8a, 0x0037804d, 0x03cc00d3, 0x57c00f9c,
+0x00000620, 0x00000000, 0x08270201, 0x097c015f, 0x37c209f0, 0x3c905f22,
+0xc80d7083, 0xd0df21b7, 0x0df0137c, 0xdd00b7c1, 0xf10b7c02, 0x00b7c02d,
+0x037c00da, 0x07c00df0, 0x00000c00, 0x00000000, 0x009b0880, 0x0cfc00b3,
+0x3fc80bf0, 0xec00bb10, 0xc21fb20f, 0x03ef017c, 0x0ff023cc, 0xee013f48,
+0xf047cc00, 0x0074c08f, 0x03f801df, 0x03c00ff8, 0x00000c22, 0x00000000,
+0x84c62081, 0x00740051, 0x374019d2, 0x4c40d518, 0x40117094, 0x021d00c5,
+0x25d04854, 0x1d204740, 0xd0005426, 0x00454310, 0x03742017, 0x07400d50,
+0x00000802, 0x00000000, 0x0804a001, 0x01748191, 0x33484990, 0x7486d900,
+0x40615200, 0x501d0885, 0x01d08054, 0x14000640, 0xd0204604, 0x09064001,
+0x0374649d, 0x07400dd8, 0x00000200, 0x00000000, 0x00202010, 0x00240141,
+0x32400898, 0x04004100, 0x4000d100, 0x40082000, 0x00824014, 0x0d000248,
+0xd0001400, 0x00014001, 0x03340085, 0x43400c18, 0x00000080, 0x00000000,
+0x4006b000, 0x007c0091, 0x3fc009f0, 0x7c209b00, 0xd0017200, 0x801e0005,
+0x01d0945c, 0x1e9007c0, 0xe2000c00, 0x00048401, 0x03fc009f, 0x03c00ff0,
+0x00000ac0, 0x00000000, 0x000f9005, 0x00fc407f, 0x3fc40be1, 0xdc20ff00,
+0xc40f7083, 0x80fe083f, 0x0bf003fc, 0xff003fc8, 0xf003fc00, 0x003fc20f,
+0x03fc0077, 0x17c00ff0, 0x00000e60, 0x00000000, 0x010fa803, 0x03ec04ff,
+0x3fc00ff0, 0xfc00ff00, 0xc20ff003, 0x00df0037, 0x0fb003ec, 0xf70037c0,
+0xf003fc60, 0x006fc015, 0x236c079f, 0x0cd08fb0, 0x00000e00, 0x00000000,
+0x05a70801, 0x0044321d, 0x05c001d2, 0x74000700, 0x4201d000, 0x001d0007,
+0x01140044, 0x1d200740, 0xd1007420, 0x0292c085, 0x9b84825d, 0x04486f10,
+0x00000c20, 0x00000000, 0x0213a011, 0x82248c0d, 0x134008d1, 0x3400cd00,
+0x400cd003, 0x20cd2012, 0x0c100114, 0xcd083344, 0xd0013400, 0x20034004,
+0xa304868d, 0x44446c10, 0x00000e80, 0x00000000, 0x3225a003, 0x417400cd,
+0x274005d8, 0x74001d00, 0x4001d800, 0x000d0027, 0x01030254, 0x1d040740,
+0xd0027422, 0x00354005, 0x0364005d, 0x0c400c14, 0x00000620, 0x00000000,
+0x2147a002, 0x036c00df, 0x37c805f0, 0x7412df00, 0xc53df04b, 0x005f2237,
+0x0130075d, 0x970277c0, 0xf0077c82, 0x000f400f, 0x036d00bf, 0x00c00db2,
+0x00000e20, 0x00000000, 0x006d8007, 0x00c8803d, 0x0d800bd0, 0xfc183702,
+0xc083f0a0, 0x08bf044f, 0x0ff010ec, 0x7f204fc0, 0xf220fc00, 0x003ec00f,
+0x83dc006e, 0x1fc80ff0, 0x00000602, 0x00000000, 0x40150002, 0x465c2413,
+0x17c10170, 0x6c02df08, 0xc12d700b, 0x205f2214, 0x01b0310c, 0x9d0037c0,
+0xf3014c10, 0x4406c8cd, 0x034c0093, 0x09c00d70, 0x00000420, 0x00000000,
+0x2024a013, 0x014400d1, 0x67425d18, 0x44011d09, 0x4821d088, 0x0b9d00a5,
+0x5dd08244, 0x59008746, 0xd0064c01, 0x0034402d, 0x03c40051, 0x4c40af10,
+0x00000200, 0x00000000, 0x0202a807, 0x811422c1, 0xa3400c50, 0x04210d04,
+0x40a0d030, 0x238c0822, 0x2c900e06, 0x4d048341, 0xd0622400, 0x08404014,
+0x03440080, 0x1c409c10, 0x00000a00, 0x00000000, 0x11508004, 0x26840121,
+0x5a401290, 0x8611ed01, 0x401ed007, 0x956d015a, 0x92d00586, 0xa9047b40,
+0x920584e1, 0x01784c56, 0x07840541, 0x18401c10, 0x00000200, 0x00000000,
+0x00101012, 0x201c0013, 0x43c04878, 0x0d000f21, 0x50417200, 0x019f2042,
+0x8cb2b00d, 0x5f2343c0, 0xf2002914, 0x8480d055, 0x070d0583, 0x49c28c70,
+0x00000040, 0x00000000, 0x011db802, 0x23be00ff, 0x3fc00770, 0xdc00ff00,
+0xc00ff223, 0x407f003d, 0x81f0a37c, 0xbb0037c0, 0xf027fcc0, 0x013dc007,
+0x23fc097f, 0x0bc00ff4, 0x00000660, 0x00000000, 0x0067a815, 0x814c81d3,
+0x65c00570, 0x7c001300, 0xc001f800, 0x001f0027, 0x11f0027c, 0x1f0004c2,
+0xf0827c20, 0x2007c00d, 0x0b4b0193, 0x57c0adf0, 0x00000e00, 0x00000000,
+0x10398812, 0x02ac0001, 0x18400a10, 0x9c00e100, 0xc20ed803, 0x00ed001b,
+0x0ed001b4, 0xe7003840, 0xd001b400, 0x1033480e, 0xcbac006b, 0x4b410ed0,
+0x00000620, 0x00000000, 0x00790003, 0x04840121, 0x49401250, 0xb4a12900,
+0x4812d884, 0x012d204b, 0x32d084b4, 0x2d20484a, 0xd284b4a1, 0x004b601e,
+0x87840081, 0x0f405ed1, 0x00000402, 0x00000000, 0x00332012, 0x032440c1,
+0x30402c10, 0x5400c900, 0x400cd003, 0x00cd0037, 0x3cd20336, 0xc5083041,
+0xd0033421, 0x2433486c, 0x03040049, 0x4b400cd8, 0x00000c20, 0x00000000,
+0x401d8017, 0x01440071, 0x15c02450, 0x7c005b40, 0xc005f001, 0x405f0017,
+0x05f0017c, 0x5f0014d0, 0xf081fc04, 0x0017c025, 0x01440073, 0x5fc005f0,
+0x00000620, 0x00000000, 0x00c70012, 0x00fc001f, 0x8ec103f8, 0xfc003700,
+0xc403f000, 0x063f000d, 0x23f000fe, 0x3f108fc4, 0xf000bc00, 0x000fc420,
+0x007c003f, 0x4bc001f0, 0x00000c00, 0x00000000, 0x02670010, 0x021c019f,
+0x66c059b1, 0x7c009f00, 0xc0093102, 0xc2930027, 0x19300a7e, 0x9f00e7c0,
+0x31027c04, 0x0060c019, 0x020c0083, 0x40c00830, 0x00000c20, 0x00000000,
+0x10262001, 0x0274419d, 0xe4401931, 0x74189d20, 0x4009120e, 0x03912027,
+0x39110e74, 0x9d002742, 0x142a7403, 0x00e4c039, 0x02442095, 0x04500950,
+0x00000800, 0x00000000, 0x0424a818, 0x0674049d, 0x2e400b10, 0xf400bd01,
+0x406b501a, 0x00b111af, 0x8b9002b4, 0xbd902f40, 0x108af490, 0x062c40a9,
+0x024400b1, 0x60408910, 0x00000200, 0x00000000, 0x02202010, 0x06b4038d,
+0xa8400a90, 0xb602ad00, 0x402a500a, 0x02a110ab, 0x2a900bb4, 0xad80bb40,
+0x100ab402, 0x00a84028, 0x920400a5, 0x4048d850, 0x00000080, 0x00000000,
+0x8d82b01d, 0x007c941f, 0x12c001b4, 0x7c801f00, 0xc8017400, 0x80524007,
+0x04b40070, 0x1f0007c2, 0x3000fc00, 0x0004d001, 0x2c4e2033, 0x74c03130,
+0x00000ac0, 0x00000000, 0x012fb819, 0x0a3c00bf, 0xb7c82878, 0x7c229f08,
+0xc229b20a, 0x029f00a7, 0x29720a7c, 0x9f10a7c0, 0xf08a7c42, 0x00a5c429,
+0x267c169f, 0x67c0c9f0, 0x00000e60, 0x00000000, 0x002fa018, 0x02cc20bf,
+0x27c24b30, 0x4c089f05, 0xc149f0b2, 0x089f2b24, 0xc9f0c25e, 0x932824c1,
+0x00227004, 0x0167c059, 0x124c0591, 0x67c14b30, 0x00000e00, 0x00000000,
+0x2487081c, 0x206c901d, 0x07400114, 0x14881f01, 0x4841d000, 0x82172300,
+0x21d2585c, 0x01078140, 0x30187484, 0x248dc921, 0x58440211, 0x736141b0,
+0x00000c22, 0x00000000, 0x0b23a010, 0x0224008c, 0x2b408810, 0x8480ad05,
+0x494ad232, 0x0cad1129, 0x0ad102b4, 0xa1112944, 0x961aa436, 0x00ab426a,
+0x32241689, 0x43400810, 0x00000e80, 0x00000000, 0x80258818, 0x0264409d,
+0x27600910, 0xd400bd00, 0x400ed002, 0x00b5002d, 0x0bd242f4, 0xb1002d40,
+0x1042f400, 0x202d400b, 0x02640099, 0x63600990, 0x00000620, 0x00000000,
+0x0a67a805, 0x064c339f, 0x27c00930, 0x4c009f08, 0xd009fa02, 0x009f04a5,
+0x09f00a7c, 0x93c025c8, 0xb8026c00, 0x4127c809, 0x026c009a, 0x17400930,
+0x00000e20, 0x00000000, 0x14258014, 0x223c058f, 0x27c039f0, 0x7c009700,
+0xc009b002, 0x009f0026, 0x09f0025c, 0x9f0827c0, 0xf0023c40, 0x0025c809,
+0x025c0097, 0x53c009f0, 0x00000600, 0x00000000, 0x00050814, 0x004c0217,
+0x8fc80134, 0xfc803340, 0xc8033400, 0x6c33448f, 0x03f000dc, 0x33240fc2,
+0x7088cd04, 0x000dc2c3, 0x003c0003, 0x53c101f0, 0x00000420, 0x00000000,
+0x049ca014, 0x85c43177, 0x17408711, 0x74055320, 0x49251201, 0x20541c97,
+0x25d03d5c, 0x51105743, 0x100d4401, 0x001f4025, 0x01740051, 0x534037d0,
+0x00000200, 0x00000000, 0x00f2a014, 0x030400c5, 0x3b420c12, 0xb407f100,
+0x407e9837, 0x03e1003b, 0x7fd08f96, 0xe100ff00, 0x11138441, 0x407d600e,
+0x033400c1, 0x53408cd0, 0x00000a00, 0x00000000, 0x08288005, 0x0b040065,
+0x7b400a10, 0xb400e120, 0x400e9007, 0x00e9007b, 0x0ed003a4, 0xe9143a44,
+0x10438403, 0x043b420e, 0x23b405e5, 0x17480ad0, 0x00000200, 0x00000000,
+0x00781015, 0x878c0107, 0x7f4c1e32, 0xbc01e310, 0xc01e3007, 0x81e3007b,
+0x1ef1079c, 0xe3407bc8, 0x7407cc81, 0x0871c41e, 0x07bc02e3, 0x57c016f0,
+0x00000040, 0x00000000, 0x00359810, 0x017d001f, 0x07c20dd1, 0x7c001700,
+0xc4017000, 0x00150007, 0x01f0015c, 0x170807c0, 0xf1007c00, 0x0007c001,
+0xcb7c01db, 0x43c003f0, 0x00000660, 0x00000000, 0x005f8800, 0x07cc01b3,
+0x7ec09732, 0x4881f300, 0xc09f9007, 0x01f30174, 0x1f3006dc, 0xfb127cc0,
+0xf0074c05, 0x093ec09f, 0x07cd01f3, 0x0bc01f30, 0x00000e00, 0x00000000,
+0x00899815, 0x03844a21, 0x30400ab0, 0x840aeb02, 0x408eb007, 0x02e90078,
+0x0e115694, 0xe30a7840, 0xf0578404, 0x003ac0ae, 0x038400fb, 0x57400a10,
+0x00000620, 0x00000000, 0x02290000, 0x23040021, 0x30610410, 0x0410c100,
+0x450c1803, 0x18cd0633, 0x0c103284, 0xc1893041, 0xd023a45c, 0x0070440e,
+0x039400e9, 0x23400610, 0x00000400, 0x00000000, 0x24e72004, 0x15041801,
+0xc0401c18, 0x04200109, 0x4120901c, 0x25098083, 0x60110854, 0x0112c040,
+0x51402400, 0x00c04000, 0x031002c1, 0x1b000110, 0x00000c20, 0x00000000,
+0x44b5a015, 0x154c01d0, 0xb4c01d11, 0x4c00d104, 0xc02d304b, 0x81d30a77,
+0x2d310b4c, 0xd302f4c0, 0xd0036c02, 0x04f4540d, 0x03dd0ff9, 0x77400d34,
+0x00000620, 0x00000000, 0x80270001, 0x037d025f, 0x15c021f0, 0x7c04df00,
+0xc00d7203, 0x20d210b4, 0x2df2436c, 0xdf0037c8, 0xf00b5c02, 0x0137c00c,
+0x036c00cf, 0x87c007f8, 0x00000c00, 0x00000000, 0x80170080, 0x058c2183,
+0x28c70a30, 0x8e01eb00, 0xc20e3023, 0x20e30038, 0x2e32035c, 0xeb0078c8,
+0x3217cc19, 0x00b8c05f, 0x034c00fb, 0x04c01bf0, 0x00000c20, 0x00000000,
+0x00962081, 0x0d440097, 0xf442b110, 0x44031100, 0x4411100c, 0x42150444,
+0x11f04968, 0x1108c6c0, 0x10005423, 0x0046c021, 0x034480db, 0x04c021d2,
+0x00000802, 0x00000000, 0x0014a001, 0x194508d9, 0xb4402510, 0x44041101,
+0x40411040, 0x08112204, 0x01100044, 0x11018441, 0x10401410, 0x10244001,
+0x834420d1, 0x0440add0, 0x00000200, 0x00000000, 0x00002010, 0x0304804d,
+0x10600010, 0x04400102, 0x40001040, 0x00011100, 0x00140004, 0x01210244,
+0x10001440, 0x80224000, 0x230408c9, 0x424008d0, 0x00000080, 0x00000000,
+0x0006b000, 0x014c00db, 0x24400132, 0x44001900, 0xc0013014, 0x08130b44,
+0x01101454, 0x1320c4c0, 0x34144480, 0x4024c280, 0x03cd00d3, 0x04e005f2,
+0x00000ac0, 0x00000000, 0x800fb805, 0x00fc00f7, 0x7fc003f0, 0xec00f701,
+0xc00fd203, 0x85ff037f, 0x0ff00a7c, 0xff05f5c0, 0xf00bec00, 0x001fc05f,
+0x17fc45ff, 0x15c003f1, 0x00000e60, 0x00000000, 0x040f9003, 0x10fc0433,
+0x0fc00ff0, 0xc400f300, 0xc00f3003, 0x00f30036, 0x0b3003cc, 0xfb003cc0,
+0xb003cc00, 0x003fc00f, 0x23cc0873, 0x0cc14371, 0x00000e00, 0x00000000,
+0x00870001, 0x08740811, 0xb0484fd8, 0x4d009f02, 0x4001b400, 0x00110004,
+0x01140044, 0x11400440, 0x10004500, 0x24074001, 0x83c44491, 0x04492110,
+0x00000c20, 0x00000000, 0x0523a011, 0x20340001, 0x15410cd0, 0x26004120,
+0x40009000, 0x00014000, 0x00d00006, 0x01800258, 0x10002400, 0x01034000,
+0x13240089, 0x45404c10, 0x00000e80, 0x00000000, 0x0025a803, 0x01740051,
+0x34400dd2, 0x2410c502, 0x40811060, 0x08110000, 0x01d0a806, 0x09000141,
+0x10086408, 0x22074001, 0x03640099, 0x0c400d14, 0x00000620, 0x00000000,
+0x0047a802, 0x007c4113, 0x81c00dd0, 0x4c83d100, 0xd0319108, 0x13130206,
+0x31f1084d, 0x1b0086c0, 0xb4286c04, 0x4107c0f1, 0x036d0019, 0x09c3b130,
+0x00000e20, 0x00000000, 0x08cd8007, 0x0efc04ff, 0x1f880ef2, 0xdc09bf00,
+0x800ed207, 0x61ee007f, 0x8b3007f8, 0xf7023ec0, 0xf0039c01, 0x007bc01f,
+0x035c84e7, 0x1fc012b2, 0x00000600, 0x00000000, 0x00310802, 0x077c8097,
+0x97208d32, 0x6c025700, 0xc00d302b, 0x60d302b7, 0x69301b7c, 0xd900b5c0,
+0x70035c08, 0x2234c0ad, 0x037c00de, 0x08c02f30, 0x00000420, 0x00000000,
+0x02b4a013, 0x03740add, 0x1f601f14, 0x6d02d100, 0x405d1487, 0x05d12077,
+0x0915177e, 0xd1017440, 0x14174501, 0x0076d01d, 0x03f480dd, 0x4c41ad14,
+0x00000200, 0x00000000, 0x0012a007, 0x00240009, 0xd3410c10, 0x04470111,
+0x4070581c, 0x070101c3, 0x35820c34, 0x0181c044, 0x101c0407, 0x01c24070,
+0x0374000d, 0x1c403090, 0x00000a00, 0x00000000, 0x20788004, 0x05b4012d,
+0x7b405e10, 0xb411e144, 0x401e5007, 0x01e1007b, 0x1c900794, 0xe1287041,
+0x10078401, 0x007a401e, 0x37b401ed, 0x10401290, 0x00000200, 0x00000000,
+0x00100012, 0x206c0047, 0x13400c39, 0x4c0cd710, 0xc0ac7023, 0x00c30377,
+0x0cb12370, 0xd34231d0, 0x70335c08, 0x0232c0cd, 0x133c00cf, 0x48d001b0,
+0x00000040, 0x00000000, 0x003da802, 0x01fc007f, 0x3fe04ff0, 0xcc08ff00,
+0xc00fb023, 0x00dfc037, 0x8f7003fc, 0xf7003fc0, 0xf023fc00, 0x023dc08f,
+0x13fc01fd, 0x0bc00370, 0x00000660, 0x00000000, 0x0007a015, 0x917c045f,
+0x30c1adf0, 0x7c801342, 0xc001e000, 0x401f0007, 0x0572007c, 0x170007c2,
+0xf0007c00, 0x0007c001, 0x1b4c001f, 0x57c00f30, 0x00000e00, 0x00000000,
+0x00298812, 0xa3b408ed, 0x78680ed0, 0xb400e100, 0x480e7203, 0x00ed103b,
+0x0ed003bc, 0xed203b40, 0xd203b400, 0x203bc00e, 0x4bac00ed, 0x4b400e10,
+0x00000620, 0x00000000, 0x00d90003, 0x07b681ed, 0x7c401ed3, 0xb401e900,
+0x411ed007, 0x21ed207b, 0x1ed007b4, 0xe5047b40, 0xd007b401, 0x007b403e,
+0x170411ed, 0x0f411e94, 0x00000400, 0x00000000, 0x00772812, 0x1b3400dd,
+0xb0440cd0, 0xb400e900, 0x400e500b, 0x12fd013b, 0x0ed10794, 0xed01bb44,
+0xd00fb400, 0x08b9404e, 0x032421fd, 0x4b422c90, 0x00000c20, 0x00000000,
+0x201da817, 0x117c265d, 0x9cd805d0, 0x7c005b00, 0xc015f041, 0x045f1417,
+0x25700170, 0x570857c0, 0xf0617418, 0x01d76625, 0x014cc17f, 0x5fc417b2,
+0x00000620, 0x00000000, 0x00070012, 0x807c121f, 0x87c020f2, 0xbc003700,
+0xc843f210, 0x003f000f, 0x43f030fc, 0x3f200fc6, 0xf000fc00, 0x098fe003,
+0x007c003f, 0x4bc12172, 0x00000c00, 0x00000000, 0x00270810, 0x036c05d3,
+0x60f049f0, 0x4c808b44, 0xc0093002, 0x00930060, 0x08b0020c, 0x830020c4,
+0xf3024c00, 0x1026c808, 0x825c009f, 0x43c00931, 0x00000c20, 0x00000000,
+0x42a62001, 0x02450791, 0x246829d0, 0x44009106, 0x44091002, 0x40911024,
+0x0910025d, 0x91102440, 0xd0024400, 0x10a54009, 0x0254009d, 0x07412910,
+0x00000800, 0x00000000, 0x0434a018, 0x02440091, 0x340709d0, 0xc4009980,
+0x500a1802, 0x00b0023c, 0x0b1002e4, 0xb1803c40, 0xd002c400, 0x102c400b,
+0x021400bd, 0x63420918, 0x00000200, 0x00000000, 0x12202010, 0x23040881,
+0xa04088d0, 0x8402a101, 0x402a140a, 0x02a150a8, 0x2a140aa4, 0xa100a858,
+0xd00a8502, 0x08a8502a, 0x120400ad, 0x43408818, 0x00000080, 0x00000000,
+0xa586b01d, 0x584c1613, 0x444020f0, 0x4d001b00, 0xc8013100, 0x40132004,
+0x0132006e, 0x534004c0, 0xf0004c80, 0x0016c401, 0x2c5c8a2f, 0x77c16132,
+0x00000ac0, 0x00000000, 0x012fb819, 0x127c049f, 0x2fc069f0, 0x7c029f22,
+0xc029f00a, 0x029f00a7, 0x2d700a5e, 0x9f80a7c0, 0xf08a7c02, 0x00a7e429,
+0x267c039f, 0x67c04bf4, 0x00000e60, 0x00000000, 0x012fa018, 0x32fc06bf,
+0xa4c429c0, 0x7c049f04, 0xc0093022, 0x009b0027, 0x29f00a6c, 0x9f0227c0,
+0x30027c02, 0x05a4c029, 0x5a7c009f, 0x63c00bb5, 0x00000e00, 0x00000000,
+0x0503081c, 0x08344657, 0x84aa61d0, 0x74001d00, 0x404112a8, 0x041d2107,
+0x00d0804e, 0x17128740, 0x10107400, 0x11ccc001, 0x8864141d, 0x73404110,
+0x00000c20, 0x00000000, 0x0323a010, 0x1a34028d, 0x284888d0, 0xb016ad20,
+0x452a9412, 0x12ad04ab, 0x2ad00ab4, 0xad012b40, 0x544ab402, 0x002a402a,
+0x1234028d, 0x43413890, 0x00000e80, 0x00000000, 0x0025a818, 0x42740895,
+0x264809d1, 0xe486bd08, 0x40af910a, 0x30bd0c2f, 0x0bd002f4, 0xb50c2e00,
+0x5002b400, 0x002e522a, 0x0274069d, 0x63400910, 0x00000620, 0x00000000,
+0x04a78805, 0x0a7c029f, 0x245009f2, 0x7c419f28, 0xc2099026, 0x039b00e7,
+0x19d04676, 0x9f00e784, 0x706e7c0e, 0x26e6c099, 0x027c009f, 0x174219b0,
+0x00000e20, 0x00000000, 0x01658014, 0x927c0097, 0x25cc0cf0, 0x3c019f01,
+0xc0197206, 0x089e3227, 0x89f01248, 0x9f2227c8, 0xb0067800, 0x2065c019,
+0x026c009f, 0x53c159f0, 0x00000600, 0x00000000, 0x01850814, 0x0c7c1013,
+0x0fc20134, 0xcc023f20, 0xc423f108, 0x4037000d, 0x033000ec, 0x37000dc0,
+0x3008cc00, 0x008cc023, 0x000c0013, 0x52c00131, 0x00000420, 0x00000000,
+0x00dca014, 0x91f40371, 0x17e01510, 0x44805d00, 0x4005d001, 0x00510014,
+0x0510095c, 0x5d101550, 0x10015400, 0x08154405, 0x01440055, 0x50501714,
+0x00000200, 0x00000000, 0x80f2a014, 0x073403c1, 0x33440c90, 0x0620cd00,
+0x480c9803, 0x24c90030, 0x0c101b04, 0xcd003062, 0x10030400, 0x0030600c,
+0x030400c0, 0x50401c10, 0x00000a00, 0x00000000, 0x80d88005, 0x06b41061,
+0x09410e10, 0x86012d00, 0x4012d000, 0x01210048, 0x121284a4, 0x2d100860,
+0x10009401, 0x01480002, 0x23040de1, 0x14411e10, 0x00000200, 0x00000000,
+0x40681015, 0x85bc81e3, 0x4b401e30, 0x8d01cf00, 0xd01cb187, 0x01c74061,
+0x1e34070d, 0x470078c0, 0x34070d01, 0x40d0d01c, 0x878d0dc3, 0x54c01c32,
+0x00000040, 0x00000000, 0x1005b810, 0x007c00df, 0x37c501e1, 0x7c201f00,
+0xc401d800, 0x001f1017, 0x01f0005c, 0x9f0007c0, 0xb0006c00, 0x0067c001,
+0x0b7c04df, 0x41c007f0, 0x00000660, 0x00000000, 0x007fa000, 0xa7cc29ff,
+0x7fc49ff8, 0xfc81f362, 0xc21ff087, 0x697f827e, 0x1ff005dc, 0xf3007ec0,
+0xf007fc01, 0x013fc01f, 0x0fcc01f3, 0x00c01330, 0x00000e00, 0x00000000,
+0x00398815, 0x32ac006d, 0x0f428e70, 0xb4002b00, 0x4803d080, 0x0cad1308,
+0x02d02286, 0x21048f40, 0xf000b400, 0x040fc102, 0x039400f1, 0x54400610,
+0x00000620, 0x00000000, 0x00190000, 0x01a4800d, 0x0b400ed0, 0xb400e108,
+0x400ed063, 0x606d2429, 0x0ed00184, 0x61003b41, 0xd003b418, 0x005b400e,
+0x238400e1, 0x00400a10, 0x00000400, 0x00000000, 0x00932804, 0xb804040d,
+0xb7420050, 0x300b094a, 0x52a0d00c, 0x088d01d0, 0x30d08a04, 0x8140c244,
+0x506c3401, 0x00e54030, 0x031426c1, 0x10400411, 0x00000c20, 0x00000000,
+0x0035a815, 0x0f65049e, 0x77c205f0, 0x70401320, 0xc231d004, 0x0b9f2096,
+0x21f00244, 0x93008780, 0xd2047c83, 0x40ef40a1, 0x03cc06f3, 0x54d00d34,
+0x00000620, 0x00000000, 0x0c170001, 0x033c001f, 0x07c20570, 0x7c42d708,
+0xc00df04b, 0x405f00a7, 0x6df0e169, 0x5f0137c0, 0xf0037010, 0x0417c02d,
+0x033c00df, 0x07c00bf3, 0x00000c00, 0x00000000, 0x006b0880, 0x13dc05f3,
+0x0fc00731, 0xec303304, 0xc323f208, 0x02bf000f, 0x23f006fc, 0x3f004fc0,
+0xf088fc02, 0x004fc023, 0x035c00f3, 0x03c00f70, 0x00000c22, 0x00000000,
+0x10062081, 0x134401d1, 0x3744b151, 0x7400d740, 0x401dd007, 0x01590037,
+0x3dd02574, 0xdd02f6e0, 0x920f7401, 0x027f421d, 0x037c00d5, 0x07420150,
+0x00000802, 0x00000000, 0x02248001, 0x00548081, 0x37482190, 0x74181900,
+0x4001d040, 0x001d0417, 0x21d00064, 0x9d000740, 0xd0887400, 0x28274101,
+0x034400c9, 0x07421150, 0x00000200, 0x00000000, 0x40202010, 0x00040001,
+0x03440011, 0x2600c100, 0x440c9103, 0x00c92823, 0x0cd20334, 0x4d183144,
+0x90033400, 0x0013400c, 0x032000cd, 0x43400010, 0x00000080, 0x00000000,
+0x0006b000, 0x005c2013, 0x07c00134, 0x74001b40, 0xc001f000, 0x000f0287,
+0x01f1007c, 0x1f000740, 0xf0007800, 0x0007c001, 0x03dc00fb, 0x03c00870,
+0x00000ac0, 0x00000000, 0x000fb805, 0x00fc403f, 0x3fc003f0, 0xfc00ff00,
+0xc00ff203, 0x00fb007f, 0x0ff003fc, 0xff003ec0, 0xf203fc00, 0x003fc00f,
+0x03fc00f7, 0x17c003f0, 0x00000e60, 0x00000000, 0x203fa003, 0x03fc00f1,
+0x3ec80fb2, 0xdc00dd00, 0x880ff203, 0x80dd0035, 0x0ff203f8, 0xff203f40,
+0x9001fc80, 0x001cc04b, 0x00cc003f, 0x0cc007b4, 0x00000e00, 0x00000000,
+0x00050801, 0x00740017, 0x07400170, 0x76801d00, 0x00019000, 0x001c0007,
+0x01d10074, 0x0d200740, 0x10017454, 0x801442e9, 0x137d00dd, 0x04510510,
+0x00000c20, 0x00000000, 0x00332011, 0x0714008d, 0x73481c50, 0x2601cd20,
+0x481c9007, 0x41cd1071, 0x1cd00134, 0xcd207148, 0x50003601, 0x00115908,
+0x4014800d, 0x445684d0, 0x00000e80, 0x00000000, 0x0805a807, 0x8074005d,
+0x07420152, 0x70001d00, 0x4001d000, 0x201d0807, 0x01d00674, 0x1d200740,
+0x10817400, 0x00154019, 0x835440dd, 0x0c4005d0, 0x00000620, 0x00000000,
+0x00a7a802, 0x027c005b, 0x26c009f0, 0x7e009f00, 0xc009d002, 0x009f0025,
+0x09f0037c, 0x9f0025c2, 0x308d7c20, 0x183dc119, 0x00d4003d, 0x08c425f0,
+0x00000e20, 0x00000000, 0x201d8003, 0x01fc80b3, 0x1fc007f0, 0xfc007f04,
+0xc807b001, 0x007f841f, 0x07f000fc, 0x7f001fc0, 0xf4156000, 0x003ec008,
+0x03bc00ef, 0x1fc00630, 0x00000600, 0x00000000, 0x80250802, 0x425c101f,
+0x27c28970, 0x7c049f00, 0xc009b002, 0x009f0025, 0x09f0017c, 0x9b8427c0,
+0xf0014d00, 0x0134c04d, 0x005c001f, 0x08c10374, 0x00000420, 0x00000000,
+0x00948013, 0x197412dd, 0x1640a570, 0x74045d01, 0x4005f105, 0x015d1097,
+0xa5d02e74, 0x5d04d740, 0xb003442a, 0x00f4553d, 0x836c40dd, 0x4c413530,
+0x00000200, 0x00000000, 0x0412a007, 0x093403c9, 0x13402450, 0x34004d80,
+0x4044d035, 0x0d4d0013, 0x24988224, 0x4d009340, 0x10016400, 0x1291480c,
+0x0014200d, 0x1c500450, 0x00000a00, 0x00000000, 0x02688004, 0x06b4012d,
+0x6a401a50, 0xb401ad00, 0x411ad006, 0x01ad006b, 0x9ad065b4, 0xad106b01,
+0x9005a401, 0x025a601e, 0x072409cd, 0x10409411, 0x00000200, 0x00000000,
+0x04101012, 0x011c008d, 0x13c00470, 0x3c014f10, 0xc004b011, 0x094d0751,
+0x04b0143c, 0x49001340, 0x30192c20, 0x0210c484, 0x001c080f, 0x48c02470,
+0x00000040, 0x00000000, 0x282cb802, 0x02fc007f, 0x2e400bf8, 0x7c08bf00,
+0xc00b7002, 0x089f0027, 0x0be103fc, 0xbf1027c2, 0xf001dc09, 0x8a1dc08d,
+0x037c08df, 0x0bc00770, 0x00000660, 0x00000000, 0x4007a815, 0x007c8053,
+0x44d00124, 0x4d001340, 0x9001f200, 0x801f0004, 0x0124066c, 0x1f0004d0,
+0xb0017c00, 0x0037c001, 0x044d0011, 0x54c00570, 0x00000e00, 0x00000000,
+0x003d9812, 0x03de00a3, 0x3c400f38, 0x8400fb00, 0xc00fd003, 0x80ed0038,
+0x0f1001f6, 0xed203840, 0x1003b400, 0x503b4802, 0x038400c1, 0x484806d0,
+0x00000620, 0x00000000, 0x00490003, 0x04b4412d, 0x4b4012d0, 0xb4012900,
+0x44121004, 0x012d0049, 0x129004b4, 0x25804848, 0x9805f481, 0x807b401e,
+0x00840121, 0x0d401850, 0x00000400, 0x00000000, 0x0a730012, 0x031402c1,
+0x30600c50, 0x1400c100, 0x400cd003, 0x00cd0031, 0x0c900334, 0xcd203040,
+0x10233400, 0x89b3400c, 0x034400c1, 0x495014d0, 0x00000c20, 0x00000000,
+0x0055a017, 0x01760253, 0x14c00570, 0x5c205900, 0xc0057001, 0x205f2815,
+0x05b00164, 0x7f0014c0, 0xb009bc20, 0x0097ec17, 0x014c0053, 0x5dc07770,
+0x00000620, 0x00000000, 0x008b0012, 0x00dc1037, 0x8fc02332, 0xe0003f00,
+0xc002f008, 0x022e200c, 0x037200fc, 0x3f900fc8, 0xf0047c00, 0x0003e081,
+0x00fc003f, 0x4ac101f2, 0x00000c00, 0x00000000, 0x00270010, 0x022c0083,
+0x64c00830, 0x0c018f00, 0xc0197082, 0x009f0026, 0x08f02648, 0x9b0024c0,
+0x70827c85, 0x2025c928, 0x024c0493, 0x40c018f0, 0x00000c20, 0x00000000,
+0x50a60005, 0x025d0091, 0x66d52914, 0x45009d02, 0x5009144a, 0x029d0024,
+0x29d00245, 0x9c10a450, 0x10827401, 0x01678109, 0x02540081, 0x04101914,
+0x00000800, 0x00000000, 0x0034a01c, 0x02c400b1, 0x2d400b10, 0xc408bd00,
+0x408b9002, 0x10bd002c, 0x0bda02c4, 0xbd00ac42, 0x50027420, 0x02264409,
+0x02c410b0, 0x60408910, 0x00000200, 0x00000000, 0x00b80010, 0x0aa402a1,
+0xab402a18, 0x8482ad28, 0x422a500a, 0x02ad20a8, 0x2ad80a94, 0xad90a840,
+0x125a7408, 0x112341c8, 0x329404a1, 0x40509810, 0x00000080, 0x00000000,
+0x00063019, 0x004c2013, 0x15c00130, 0x4c001f00, 0xc0017000, 0x401f0006,
+0x05f00042, 0x3b0004c0, 0x70107c02, 0x4045c061, 0x0ccc0113, 0x74d16170,
+0x00000ac0, 0x00000000, 0x00a7b819, 0x0a5c029f, 0xa4c029f0, 0x7c029f00,
+0xc029300a, 0x029f00a7, 0x29f08a6c, 0x9f00a7c0, 0xf202bc06, 0x2221c04f,
+0x327c089f, 0x67c04b70, 0x00000e60, 0x00000000, 0x04a7a818, 0x034c049b,
+0xb5c14df0, 0x5404d324, 0x408df213, 0x20d32434, 0x0d30426c, 0xf32437c0,
+0x301a4412, 0x016cc00b, 0x260c01b9, 0x63c06b30, 0x00000e00, 0x00000000,
+0x41871818, 0x384c0615, 0x076061d0, 0x74021140, 0x50a11008, 0x0a114084,
+0xa1b41845, 0x15008f44, 0x50284526, 0x02844861, 0x086c4211, 0x71ca6010,
+0x00000c20, 0x00000000, 0x802ba010, 0x428512a5, 0x29490ad0, 0x8412a110,
+0x644a144a, 0x54a12d28, 0x4a924294, 0x8d052b61, 0x10120404, 0x08214928,
+0x1a040289, 0x4340c858, 0x00000e80, 0x00000000, 0x0025a018, 0x02c600fd,
+0x2f600bd2, 0xf680f100, 0x600f1a02, 0x00b1802c, 0x0b1003d4, 0xdd002f48,
+0x54024400, 0x00254019, 0x02640091, 0x61402950, 0x00000620, 0x00000000,
+0x00278005, 0x024e0893, 0x25c009f0, 0x5c409100, 0x40095002, 0x00931024,
+0x09901a4c, 0x9f1027c0, 0x34424c00, 0x00255038, 0x024c009b, 0x17c8197c,
+0x00000e20, 0x00000000, 0x00218010, 0x027c8093, 0x23e209f0, 0x7c409f00,
+0xe4087002, 0x008f0823, 0x09f0020c, 0x836027ca, 0xf4227c00, 0x0026c009,
+0x027c009f, 0x53c059bc, 0x00000600, 0x00000000, 0x100d0014, 0x00dc0837,
+0x0fcc03f0, 0xfe003f08, 0x8003e000, 0x8037080f, 0x03f200cc, 0x132a0fc8,
+0x30007c00, 0x0241c021, 0x001c101f, 0x50c18130, 0x00000420, 0x00000000,
+0x0014a014, 0x017c005d, 0x15c115d1, 0x74005d00, 0x4005d101, 0x80511017,
+0x05d00144, 0x71405dc0, 0xb0817420, 0x009c4027, 0x01d4836d, 0x50503715,
+0x00000200, 0x00000000, 0x80328014, 0x4b3401dd, 0x32400cd0, 0x7480cd88,
+0x400c9103, 0x00c9d4b1, 0x0cd80311, 0xc5003720, 0x90037400, 0x087060fc,
+0x031508cd, 0x50401cd0, 0x00000a00, 0x00000000, 0x08088005, 0x08b4002d,
+0x0b400290, 0xb4002d00, 0x40029200, 0x8029200a, 0x02d00094, 0xec200100,
+0x9033b400, 0x0838104c, 0x139400cd, 0x14481e98, 0x00000200, 0x00000000,
+0x00581015, 0x879c81ef, 0x4bc416f0, 0xb401af00, 0xc01af085, 0x0179007f,
+0x16f3068c, 0xe7005bc0, 0xb017fc21, 0x0079c43a, 0x0f9c012f, 0x44c612b0,
+0x00000040, 0x00000000, 0x9024b810, 0x005c401f, 0x35c009f0, 0x7c005f20,
+0xc005f102, 0x80930807, 0x09f20164, 0xd3002780, 0x74837c00, 0x0035c01d,
+0x036c001f, 0x43c00373, 0x00000660, 0x00000000, 0x013fa000, 0x24ce49bf,
+0x7cc01b30, 0xfc89f300, 0x409f2027, 0x01fb225f, 0x1d3027f8, 0xff206dc0,
+0x3007c801, 0x0a7cca9f, 0x0fcc817f, 0x00c09f20, 0x00000e00, 0x00000000,
+0x02098815, 0x238c0867, 0x08040670, 0x84082100, 0xc28270b4, 0x102b146b,
+0x5230a00c, 0xe1061840, 0xb043ec00, 0x021ac0ce, 0x2384906d, 0x5440ce10,
+0x00000600, 0x00000000, 0x02190000, 0x0004808d, 0x03400051, 0x04488100,
+0x400adb21, 0x08611113, 0x44922234, 0xc1004260, 0x91838408, 0x8038460a,
+0x038400cd, 0x01402210, 0x00000420, 0x00000000, 0x00a30804, 0x0b050a4d,
+0xb2502c54, 0x05624148, 0x0024142a, 0x238140e1, 0x28140904, 0xd550b350,
+0x10034511, 0x0032512d, 0x070405cd, 0x00420114, 0x00000c20, 0x00000000,
+0x03e58815, 0x3f4e0a5f, 0xf6c0fd00, 0x4c0f5303, 0x44f5902a, 0x819122e7,
+0xf9823d7c, 0xdf02f7c0, 0x8c03c404, 0x0034c00f, 0x1bc403dd, 0x45400d34,
+0x00000620, 0x00000000, 0x10170001, 0x005c0297, 0x05c00130, 0x7c029f08,
+0xc029e081, 0x105f0017, 0x05700a70, 0x530004c0, 0xf0037c00, 0x00b5c00d,
+0x137c82df, 0x07c817f0, 0x00000c00, 0x00000000, 0x008f0880, 0x03cc4073,
+0x0fc00730, 0xce003300, 0xc003f200, 0x833b00ec, 0x033000cc, 0xb3801cca,
+0x2443cc02, 0x007d0219, 0x03fc00bf, 0x00c00d30, 0x00000c22, 0x00000000,
+0x00362081, 0x007c0291, 0x35400970, 0x4602d100, 0x422d3003, 0x01d10055,
+0x0d100b44, 0x119025c2, 0x10035c00, 0x00a440cd, 0x0334129d, 0x15400110,
+0x00000802, 0x00000000, 0x0020a001, 0x80040009, 0x30400810, 0x04004100,
+0x40041222, 0x00858000, 0x88100134, 0xd5082240, 0x50034420, 0x06354009,
+0x037400d9, 0x04401d10, 0x00000200, 0x00000000, 0x00102010, 0x032480c9,
+0x00400490, 0x04408100, 0x44085081, 0x00450330, 0x44110215, 0x40201008,
+0x58030480, 0x00316804, 0x033000c9, 0x51401c10, 0x00000080, 0x00000000,
+0x4006b000, 0x004d0019, 0x05d00134, 0x450a1340, 0x50017404, 0x02174044,
+0x1134004c, 0x924004d0, 0x70034d00, 0x0035c00d, 0x03be40db, 0x00c00130,
+0x00000a80, 0x00000000, 0x203fb805, 0x03dc00f7, 0x3fc00f70, 0x7c81ff00,
+0xc20f3023, 0x95fb2277, 0x8ff957ec, 0x37003dc8, 0xb803dc80, 0x003ec00f,
+0x03fc00ff, 0x17c003f0, 0x00000e20, 0x00000000, 0x823fa003, 0x20ec002f,
+0x3bc08fd2, 0xf000ff00, 0xc20ff203, 0x80f9003f, 0x0fc0038c, 0xf7003fc0,
+0xf023fc00, 0x003fc00f, 0x13cc00e3, 0x0cc54b90, 0x00000e00, 0x00000000,
+0x90b30801, 0x10440017, 0x074041d0, 0x74001308, 0x4001d000, 0x80113007,
+0x01d10074, 0x17200740, 0xd0107440, 0x40374001, 0x2bd444f1, 0x054069b0,
+0x00000c20, 0x00000000, 0x0233a011, 0x1026214d, 0x314040d0, 0x3600cd00,
+0x400cd003, 0x00c91031, 0x0cd00316, 0x4d803340, 0xd0033600, 0x0032400c,
+0x030410c1, 0x44410890, 0x00000e80, 0x00000000, 0x0035a803, 0x0044011d,
+0x07400dd0, 0x64001500, 0x4001d000, 0x00110007, 0x01d90874, 0x9d800640,
+0xd0006600, 0x00374001, 0x035400d1, 0x0d400990, 0x00000620, 0x00000000,
+0x0837a802, 0x446c808d, 0x27c00df0, 0x7c001f01, 0xc009f001, 0xa09b0021,
+0x49f00a5c, 0x9f0007c0, 0xd0127c00, 0x0037c049, 0x034c40d3, 0x08c089a1,
+0x00000e20, 0x00000000, 0x043d8007, 0x25fc00b5, 0x1fc003e0, 0xfc00f300,
+0xc207f00a, 0x407f141f, 0x07f001fc, 0x76003fc0, 0xf001f800, 0x003fc007,
+0x03fc20ff, 0x1ec00bf1, 0x00000600, 0x00000000, 0x00350802, 0x0a4c805b,
+0x27c011f0, 0x7c101700, 0xc009f001, 0x00971026, 0x0930425c, 0x1b0307c0,
+0xf0025c00, 0x0837c609, 0x034c40df, 0x0bc019f1, 0x00000420, 0x00000000,
+0x003ca013, 0x07441011, 0x17400dd0, 0x7012d100, 0x4205d006, 0x035d1897,
+0x05b01974, 0xd810f740, 0xd0017400, 0x007f4405, 0x03c420fd, 0x4f400992,
+0x00000200, 0x00000000, 0x0032a007, 0x03050101, 0x13400c90, 0x3403c504,
+0x4004d006, 0x0c450213, 0x04900934, 0xc800f360, 0xd0011400, 0x84344004,
+0x034481dd, 0x1f400958, 0x00000a00, 0x00000000, 0x24788004, 0x56840131,
+0x6b4012d1, 0xb4012188, 0x401ad045, 0x01ad016b, 0x9a9006b4, 0x29104b44,
+0xd006b421, 0x047b401a, 0x030401ed, 0x13403a18, 0x00000200, 0x00000000,
+0x00301012, 0x030cc003, 0x13c080b8, 0x3c00c500, 0xc044f002, 0x84470013,
+0x04b1213e, 0x4b1033e8, 0xf0011c00, 0x1033a804, 0x230c10cf, 0x4bc008f1,
+0x00000040, 0x00000000, 0x043db802, 0x92d00877, 0x2fc20ff0, 0xfc003f00,
+0xe80bf201, 0x00bf012f, 0x0974027c, 0xbf000fc2, 0xf002fc00, 0x203ec01b,
+0x13fc80ff, 0x0bc00bf0, 0x00000660, 0x00000000, 0x3077a015, 0x054e001b,
+0x05c00db0, 0x7c011f00, 0xc0017000, 0x00130047, 0x00f0005c, 0x931004c4,
+0x31007c00, 0x3274c001, 0x1b7e44d3, 0x54c01bf0, 0x00000e00, 0x00000000,
+0x21798812, 0x01840020, 0x39c00210, 0xb420ed00, 0xc00eb003, 0x00eb0033,
+0x0ed0038c, 0x6b003940, 0xb0033600, 0x103ec00c, 0x33b4aaeb, 0x4ac00af0,
+0x00000620, 0x00000000, 0x08710003, 0x878601b8, 0xc9401210, 0x34002500,
+0x40321004, 0xc12510cb, 0x32d904b4, 0x2580c840, 0x100cb403, 0x017a4032,
+0x279485ed, 0x0c401cd1, 0x00000400, 0x00000000, 0x00332812, 0x0b0404c1,
+0x31000c10, 0x3401cd00, 0x400cd01b, 0x01cd0033, 0x0cd00704, 0xd981b140,
+0x90037400, 0x0032420c, 0x033600cd, 0x4a5008d0, 0x00000c20, 0x00000000,
+0x0015a817, 0x15cd007b, 0x55c005b4, 0x34035f10, 0xc0153009, 0x05570057,
+0x14f0415c, 0x5700d0c0, 0x30057c01, 0x0014c017, 0x017c005f, 0x5cc005f0,
+0x00000620, 0x00000000, 0x00870012, 0x187c021f, 0x8fc003f0, 0xf8183f00,
+0xc0039208, 0x0039000d, 0x03f000dc, 0x3e200fc0, 0xf000fc00, 0x0087c003,
+0x007c021a, 0x49c00170, 0x00000c00, 0x00000000, 0x00270810, 0x166c039f,
+0x67c059f0, 0x4c009f80, 0xc809b006, 0x208f0067, 0x99f0064c, 0x9f0064c0,
+0x30027c00, 0x00e4c009, 0x027c009f, 0x43c00934, 0x00000c20, 0x00000000,
+0x01262001, 0x0e443299, 0xe74a09d0, 0x44809d06, 0x40a9300e, 0x419d2027,
+0x19700e54, 0x95102548, 0x51025400, 0x20654009, 0x0274009d, 0x07400951,
+0x00000800, 0x00000000, 0x1024a018, 0x0a64008d, 0x2e4009d0, 0xc400a900,
+0x430f9022, 0x04fd023f, 0x0bd052c4, 0xb1292c40, 0x1012c400, 0x0024400a,
+0x0234009d, 0x63400990, 0x00000200, 0x00000000, 0x07202210, 0x2204088d,
+0x2a408ad0, 0x8428ad00, 0x620a1083, 0x00ad082b, 0x0a500294, 0xa5002940,
+0x50029402, 0x0021402a, 0x1234088d, 0x434088d0, 0x00000080, 0x00000000,
+0x1186b01d, 0x582c021d, 0x07c021f1, 0x4c021d00, 0xc001b000, 0x001f0007,
+0x01f2004c, 0x1f0004c0, 0x30005c00, 0x0514c803, 0x2c7c025f, 0x77c161b0,
+0x00000ac0, 0x00000000, 0x2127b819, 0x12fc04ab, 0xa7c069f0, 0x7c069f00,
+0xc029f00a, 0x028d00a7, 0x29700a74, 0x9f00a3c0, 0xf05a7c02, 0x0527c029,
+0x267e269f, 0x67c04b70, 0x00000e60, 0x00000000, 0x01ada018, 0x326c02a3,
+0x2cc44bf0, 0xc410b300, 0xc14b3002, 0x34bf052c, 0x0b3002cc, 0x93002bc0,
+0x3062fcc2, 0x04afe049, 0x224c02bf, 0x63c14f30, 0x00000e00, 0x00000000,
+0x0007081c, 0x30440411, 0x06c301d0, 0x6c061b00, 0xc021b028, 0x021d1086,
+0x01b2806c, 0x1b0a8740, 0xb0907c24, 0x0085c0e1, 0x1844041d, 0x73406114,
+0x00000c20, 0x00000000, 0x02332010, 0x12040481, 0xa34868d0, 0x04508020,
+0x40081002, 0x808d0020, 0x28590a04, 0x8d202340, 0x18122646, 0x00234108,
+0x0a240685, 0x43410810, 0x00000e80, 0x00000000, 0x8025a818, 0x02440091,
+0x264009d2, 0x64809920, 0x48098003, 0x009d0826, 0x09900264, 0x9d002740,
+0x90825402, 0x00254009, 0x022620dd, 0x63420910, 0x00000620, 0x00000000,
+0x40278805, 0x124c1193, 0x2744e9e0, 0x4c009300, 0xc4092202, 0xa09f1024,
+0x09700244, 0x970027c0, 0x30026420, 0x20274009, 0x026d009f, 0x17c01930,
+0x00000e20, 0x00000000, 0x04218014, 0x035c089f, 0x274009f0, 0x7c009f10,
+0xc009d002, 0x409d0027, 0x09e0027c, 0x9b0027c0, 0xf0023c20, 0x0027c009,
+0x025c008f, 0x53c039f0, 0x00000600, 0x00000000, 0x00040814, 0x284c001f,
+0x01c80030, 0x3c000281, 0xc000f080, 0x100f2044, 0x01f02030, 0x170041c0,
+0x30007c00, 0x0007c001, 0x004c041f, 0x53c01130, 0x00000420, 0x00000000,
+0x089ca014, 0x2d55007d, 0xdce41511, 0xf4107594, 0x42a7d009, 0x607d909d,
+0x157001f4, 0x51109d45, 0xb0015480, 0x0a1dc205, 0x01540079, 0x53400750,
+0x00000200, 0x00000000, 0x80b2a014, 0x0304125d, 0xf3441c58, 0x3440c110,
+0x603cd04b, 0x02cd0000, 0x1cd09334, 0xc8002040, 0x90030400, 0x00f3420c,
+0x032408cd, 0x53400c90, 0x00000a00, 0x00000000, 0x00388005, 0x0714033d,
+0x32402ed0, 0xb6002500, 0x610cd003, 0x00ed0019, 0x1e5003a0, 0xe9003940,
+0x90039401, 0x00ab400e, 0x33b400e9, 0x17402ed0, 0x00000200, 0x00000000,
+0x00781015, 0x058d08af, 0x7bc01f74, 0xbc01e100, 0xc016f007, 0x01ed0058,
+0x1cf007b4, 0xcf0039c0, 0xb006dc15, 0x006bc83e, 0x172c03ef, 0x57c01eb0,
+0x00000040, 0x00000000, 0x0015b810, 0x097c009f, 0x35c00d30, 0x7c001f10,
+0x4205f102, 0x009f1017, 0x0df0017c, 0xd70037c0, 0xf0025c06, 0x2024c14d,
+0x0b5c40cf, 0x43c00f70, 0x00000660, 0x00000000, 0x024fa000, 0x8fc901a3,
+0x7bc01fb0, 0xcc09bb80, 0xc69a7007, 0x09e30068, 0x1f3007bc, 0xff006fc0,
+0x3027d411, 0x027c429f, 0x2ffc05f3, 0x03c01730, 0x00000e00, 0x00000000,
+0x023d8815, 0x128412a1, 0x1b408a10, 0xac08318a, 0xc0cab023, 0x086b2a1a,
+0x0eb023ac, 0xef209b42, 0x1033ec00, 0x008ac80f, 0x33dc00ab, 0x5749aa10,
+0x00000620, 0x00000000, 0x88090000, 0x010408b1, 0x0b400e18, 0x8400a900,
+0x600ed001, 0x08e10038, 0x8e100296, 0xed023b40, 0x53028408, 0x083a440e,
+0x03b404e1, 0x03400618, 0x00000400, 0x00000000, 0x00132804, 0x00042081,
+0x43401810, 0x24010100, 0x401c1000, 0x01090052, 0x1c900c14, 0xc5005340,
+0x58062401, 0x002641ac, 0x03140089, 0x13080810, 0x00000c20, 0x00000000,
+0x4035a815, 0x134c0183, 0xb7483d30, 0x44435b04, 0xc031d048, 0x031300c4,
+0x3d300754, 0xfd00f7c0, 0x740e4c03, 0x0006c03f, 0x03fc00f3, 0x57801914,
+0x00000620, 0x00000000, 0x00270001, 0x0b7c029f, 0x37c0cd70, 0x7c0c1f09,
+0xc0e1f011, 0x0cdf0307, 0xcdf02a64, 0xdf03b700, 0xa0327c0c, 0x0027c00d,
+0x035c02cf, 0x07c807f0, 0x00000c00, 0x00000000, 0x013f0880, 0x04cc00bf,
+0x7cc00af1, 0xcc006f01, 0xc0037002, 0x00330108, 0x1e3147bc, 0xe310f8c0,
+0xf006cc80, 0x0024c00e, 0x038c00f1, 0x00c08b30, 0x00000c22, 0x00000000,
+0x00462081, 0x0c54009d, 0x354089d0, 0x5c001d00, 0x4130d006, 0x10950005,
+0x8d500064, 0xd500b540, 0xd02654a0, 0x08ed500d, 0x035402d5, 0x044025b0,
+0x00000802, 0x00000000, 0x1004a001, 0x51440895, 0x26400dd8, 0x44101d00,
+0x4041d990, 0x041100a4, 0x0d102974, 0xd5003440, 0xd0024400, 0x0054480d,
+0x034400d5, 0x04400010, 0x00000200, 0x00000000, 0x00202210, 0x8014009d,
+0x01400890, 0x34000908, 0x4000d801, 0x00450021, 0x0c508026, 0xc5003140,
+0x90021440, 0x4000400c, 0x03040081, 0x40500090, 0x00000080, 0x00000000,
+0x0006b000, 0x004c00b7, 0x06c009f0, 0x4c001f00, 0xc401fb80, 0x00130024,
+0x0930007c, 0xe50034c0, 0xf1024c00, 0x2034c00f, 0x03cd0057, 0x00c60130,
+0x00000ac0, 0x00000000, 0x080f9805, 0x00fc00bf, 0x0fc00bf0, 0x9c003f00,
+0xc003d000, 0x003f002f, 0x0bf003fc, 0xf7003fc0, 0xf002fc00, 0x002fc00f,
+0x03fc003f, 0x17c003f0, 0x00000e60, 0x00000000, 0x003fa003, 0x03cc00f3,
+0x37c00ff0, 0xfc00f700, 0xc02df003, 0x00fb20bf, 0x2df023ec, 0xff003fc0,
+0xe003b842, 0x023fc94f, 0x00ec10f3, 0x0cd08ff0, 0x00000e00, 0x00000000,
+0x04050801, 0x4044101b, 0x07400150, 0x74001120, 0x4000d000, 0x14150004,
+0x01d00044, 0x1d810744, 0x91004444, 0x213f4021, 0x0a4422d3, 0x0c4029d0,
+0x00000c20, 0x00000000, 0x01012011, 0x133404c1, 0x21400052, 0x1400c500,
+0x40485001, 0x00c10131, 0x4c120114, 0xcd051144, 0x50031404, 0x0131400c,
+0x0b2481c9, 0x4c40ccd1, 0x00000e80, 0x00000000, 0x0837a803, 0x00250009,
+0x17420d10, 0x74001100, 0x4005d002, 0x00058004, 0x01d08245, 0x1d002740,
+0xd0004060, 0x10374001, 0x036400d1, 0x0c4009d0, 0x00000620, 0x00000000,
+0x1836a882, 0x017c0051, 0x37c00df0, 0x78001401, 0xc005f003, 0x201b0123,
+0x01f0027c, 0x9d0827c0, 0xf0927c04, 0x4037e429, 0x016c01db, 0x08c808d2,
+0x00000e22, 0x00000000, 0x00018007, 0x0ecc83bf, 0x0fc001f0, 0x7c00ff00,
+0xc40af010, 0x00df081f, 0x0ff001ec, 0x6f101fc0, 0xb281fc00, 0x003fc805,
+0x03dc04ef, 0x1fc80db0, 0x00000600, 0x00000000, 0x00050802, 0x017c0053,
+0x24c041f0, 0x7c081700, 0xc0c1b001, 0x00130025, 0x0130004c, 0x9d4007c0,
+0x70027c00, 0x8033c029, 0x034c31db, 0x29c119d0, 0x00000420, 0x00000000,
+0x0234a013, 0x82640095, 0x15413d50, 0x7400d900, 0xc00d5006, 0x00db0416,
+0x0db40b54, 0x5702f660, 0x1001443a, 0x007c4077, 0x136c03db, 0x4d422dd1,
+0x00000200, 0x00000000, 0x0032a007, 0x42340089, 0x14603c10, 0x2400c904,
+0x402c1006, 0x00c90050, 0x0c501324, 0x41803340, 0x10010500, 0x06314044,
+0x94040005, 0x5f420cd0, 0x00000a00, 0x00000000, 0x02488004, 0x05240165,
+0x29401258, 0xb4012d11, 0x40125045, 0x4529022b, 0xd202a494, 0xa9254a40,
+0x10069401, 0x0278401a, 0x06a449ad, 0x37401ad1, 0x00000200, 0x00000000,
+0x00001012, 0x0234408b, 0x44c00052, 0x3c00c40b, 0xc0181000, 0x0dc30351,
+0x5c40014c, 0x578a5740, 0x70011c08, 0x02358224, 0x230c00d7, 0x4bc20cf0,
+0x00000040, 0x00000000, 0x083db802, 0x01fc0077, 0x3fc00f70, 0x7c001303,
+0xc4077003, 0x201f0122, 0x83f002dc, 0xb7002ec0, 0xf4024c00, 0x02bd401b,
+0x03fc00fb, 0x08c00bf0, 0x00000660, 0x00000000, 0x00752014, 0x005c0013,
+0x10c40c62, 0x74001100, 0xe005f006, 0x001d0007, 0x01908274, 0x1d002642,
+0x14004400, 0x2137c001, 0x016c4093, 0x54c009e0, 0x00000e00, 0x00000000,
+0x0009091a, 0x038400fb, 0x2ac002d0, 0xb420e100, 0x420a2081, 0x00ed003b,
+0x0e5001f4, 0xe9201840, 0x1003b400, 0x20bb601e, 0x038400bf, 0x4c500e91,
+0x00000624, 0x00000000, 0x00410000, 0x04b50121, 0x484002d0, 0xb4012900,
+0x40125084, 0x012d004b, 0x129004b4, 0x2d004840, 0x10048401, 0x817b4092,
+0x87a6a1e1, 0x064018d0, 0x00000400, 0x00000000, 0x08312812, 0x034480c9,
+0x30480cd0, 0x340dc180, 0x602c9883, 0x02dd8a73, 0xdc180334, 0xcd003050,
+0x10033480, 0xa033400c, 0x030680d5, 0x4a400cd1, 0x00000c20, 0x00000000,
+0x0015a837, 0x017c0052, 0x144005f0, 0x7c005b00, 0x40055001, 0x045d0017,
+0x05b01174, 0x5d0116c0, 0x00114804, 0x001b2045, 0x45ec0271, 0x5e4107d0,
+0x00000620, 0x00000000, 0x108f0012, 0x00fc022f, 0x0fc002f0, 0xfc003f48,
+0xc1037000, 0x903f208f, 0x037208fc, 0x3b000fc0, 0xf000fc00, 0x00074003,
+0x807c011f, 0x49c801b1, 0x00000400, 0x00000000, 0x02670830, 0x424c129f,
+0x61e089b0, 0x4c008911, 0xc029f002, 0x00970261, 0x08300e0c, 0x970024c0,
+0x30027c00, 0x4126c009, 0x025c0193, 0x41c008f0, 0x00000c20, 0x00000000,
+0x04262001, 0x0254119d, 0x25400910, 0x54009d00, 0x44399042, 0x099d0027,
+0x29d0166c, 0x95402540, 0x10020580, 0x01244808, 0x0244a999, 0x054029d0,
+0x00000080, 0x00000000, 0x0024a018, 0x02c400bd, 0x2c400b94, 0xc404b500,
+0x400bd002, 0x00b1042f, 0x0b1202f4, 0xad002845, 0x1002d400, 0x0024608b,
+0x0654009d, 0x614029d8, 0x00000200, 0x00000000, 0x02282010, 0x229408ad,
+0xa9480a10, 0x9600a500, 0x488ed002, 0x08a5022b, 0x0ad222a4, 0xa1802940,
+0x100a8400, 0x8020408a, 0x26040489, 0x414088d8, 0x00000080, 0x00000000,
+0x0086b01d, 0x084c021f, 0x054401b0, 0x4c801f10, 0xc021f100, 0x02172087,
+0xa030087e, 0x1e0284c0, 0x32003c0a, 0x8502d167, 0x585c0b15, 0x75c161f0,
+0x00000ac0, 0x00000000, 0x01a7b911, 0x1a7c269f, 0xa7c429f4, 0x3c029f00,
+0xc069b10a, 0x069f01a7, 0x39701a4f, 0x9f00e7c0, 0xf40a6c03, 0x05278849,
+0x12fc09b7, 0x66e04bf8, 0x00000e64, 0x00000000, 0x012fa018, 0x02cc00b7,
+0x2f400a20, 0xf810b300, 0x4309e042, 0x80bf042c, 0x2930d2e8, 0x9320a680,
+0x70527014, 0x012ec14b, 0x1afc0cb3, 0x60c06bf0, 0x00000e00, 0x00000000,
+0x0097081c, 0xa86c2a01, 0x05c001b0, 0x74001b01, 0xc041d001, 0x0a100186,
+0xf010895c, 0x3a02d740, 0xb0186c17, 0x46854031, 0x04740e11, 0x71484190,
+0x00000c20, 0x00000000, 0x00a3a012, 0x02040085, 0xa3402858, 0x34008104,
+0x4108d002, 0x00852420, 0x08500200, 0xa5012b44, 0x10422400, 0x10204148,
+0x2234008d, 0x484868d2, 0x00000e80, 0x00000000, 0x0021a818, 0x02640091,
+0x25610dd0, 0x76009900, 0x6089d002, 0x00810036, 0x09548214, 0xb9802f40,
+0xd0024600, 0x00256001, 0x44740094, 0x61400990, 0x00000620, 0x00000000,
+0x02e7a805, 0x824c6097, 0x67462971, 0x74009100, 0x4019d00a, 0x009f0024,
+0x09500a44, 0x9500a7c4, 0x48026400, 0x00240a01, 0x0c7c079f, 0x14c009f1,
+0x00000e20, 0x00000000, 0x00658016, 0x023c108f, 0x65c049b0, 0x7c209f06,
+0xc01df102, 0x009f1027, 0x09b0027c, 0x9f0023c0, 0xb0022c00, 0x0021a100,
+0x007c099b, 0x5bc809f2, 0x00000600, 0x00000000, 0x00050814, 0x2064001b,
+0x02ca2170, 0x6c001f00, 0xc000f008, 0x001f0c07, 0x01f0087c, 0x3f008dc0,
+0x31007c00, 0x0005c401, 0x08481013, 0x50d01130, 0x00000420, 0x00000000,
+0x001ca014, 0x25d40071, 0x9c4027d0, 0xc6005d00, 0x41b51019, 0x3b7d009f,
+0x05d005f4, 0x510014e0, 0x3001c400, 0x001f4003, 0x6cec0178, 0x50482710,
+0x00000200, 0x00000000, 0x00322014, 0x0b2402c9, 0x72411c50, 0x0601cd80,
+0x480c1143, 0x00c90007, 0x0c100704, 0xc5103344, 0x54031400, 0x0831403c,
+0x033480c4, 0x51400d90, 0x00000a00, 0x00000000, 0x201a0005, 0x01a400e1,
+0xb8411ed0, 0x8411ed01, 0x400e1006, 0x80ed010b, 0x1ed041a4, 0x21280840,
+0x50238601, 0x411f410e, 0x273411e5, 0x14000390, 0x00000200, 0x00000000,
+0x00421015, 0x07ac012b, 0xeac01e70, 0x8481ef01, 0xc8166207, 0x01ad804b,
+0x167004bc, 0xf7007f42, 0x7047dc01, 0x00f9c09e, 0x07bc01f7, 0x55c016b0,
+0x00000040, 0x00000000, 0x0025b810, 0x015c001f, 0x24c00df0, 0x1c008f08,
+0xc1255002, 0x209f8247, 0x05d0027c, 0x37100ec0, 0x321b5c00, 0x0853c0cd,
+0x436d40d9, 0x43c00870, 0x00000660, 0x00000000, 0x007fa000, 0x24dc017f,
+0x7f009f72, 0xfc09bf12, 0xc41ff025, 0x013b024f, 0x1d30064c, 0xff0a7fc0,
+0xf007d809, 0x0276409e, 0x275c0dd3, 0x02c01f30, 0x00000e00, 0x00000000,
+0x061d8815, 0x02848061, 0x1a40c610, 0xbc01e116, 0xc382f00d, 0x101d0d43,
+0x9eb06494, 0x2f030342, 0xd003841c, 0x015c408e, 0x07848dbf, 0x54408210,
+0x00000620, 0x00000000, 0x00090000, 0x009400a5, 0x39600e52, 0xb400a500,
+0x4006d003, 0x0869020b, 0x06110184, 0xcc003b48, 0xd003b600, 0x2138638e,
+0x0b0400e5, 0x02500610, 0x00000400, 0x00000000, 0x00a72804, 0x4e041381,
+0x92493410, 0x14938124, 0x4020504f, 0x024d0c81, 0x34104b14, 0x05068341,
+0xd00b2412, 0x0010002c, 0x03040094, 0x10401852, 0x00000c20, 0x00000000,
+0x1a67a815, 0x4a5c1297, 0xddc12570, 0x7412df00, 0x409dd14b, 0x095900ff,
+0x2d120f44, 0xdd20f7c5, 0xf01ff403, 0x483e5aad, 0x0b4402d1, 0x56c01034,
+0x00000620, 0x00000000, 0x30058001, 0x007c0097, 0xb6c025f4, 0x3c00cf08,
+0xc00de00a, 0x004f0023, 0x0ef1813c, 0x3f000bc2, 0xf0131c00, 0x0011c00d,
+0x0b6d0458, 0x07c0a1b2, 0x00000c00, 0x00000000, 0x025d0880, 0x02fc0273,
+0x4fc007f0, 0xc400fd02, 0x80037009, 0x403300bf, 0x07b080cc, 0xf3003c80,
+0x3003fc00, 0x011fc00f, 0x03dc20fb, 0x01d001f0, 0x00000c22, 0x00000000,
+0x00760081, 0x24748051, 0xa5c8b5d0, 0x54009d04, 0x40115084, 0x001500f7,
+0x07508254, 0x35000d40, 0x50037400, 0x0027440d, 0x1b440351, 0x054041f1,
+0x00000800, 0x00000000, 0x0024a001, 0x01740011, 0x07000dd0, 0x54409d00,
+0x448d1100, 0x02910017, 0x0d100264, 0xd1003540, 0x90037400, 0x00b7401d,
+0x13541155, 0x054019d0, 0x00000200, 0x00000000, 0x80002010, 0x03248001,
+0x01440490, 0x1404c900, 0x40004010, 0x00850002, 0x4c501014, 0x05900142,
+0xd0833600, 0x0113621c, 0x13040481, 0x414000d1, 0x00000080, 0x00000000,
+0x0016b000, 0x013c00c3, 0x87c00df0, 0x5c019f02, 0xc0a16014, 0x8ad323f7,
+0x1531052c, 0xd10235c0, 0xb003fc00, 0x8557e00d, 0x075c1517, 0x01c001f2,
+0x00000ac0, 0x00000000, 0x003fb825, 0x03fc00fd, 0x49c003f0, 0x7c089f01,
+0xc013e320, 0x45ff8277, 0x977023fc, 0x3f014fc1, 0x7183fe00, 0x802fc00f,
+0x0bfc00b7, 0x16c00b70, 0x00000e60, 0x00000000, 0x030fa003, 0x02ec00fb,
+0x0cc043b0, 0xfc202300, 0xc00fb013, 0x00ff303f, 0x0ff103cc, 0xff002fc0,
+0xf003ed80, 0x400ec80f, 0x238c0021, 0x0cc00731, 0x00000e00, 0x00000000,
+0x01970801, 0x80c500f5, 0x26502510, 0xc4009140, 0x40057003, 0x401d3037,
+0x0dd10344, 0xfd002f40, 0xd0034400, 0x0007400f, 0x03ec8a93, 0x04490512,
+0x00000c20, 0x00000000, 0x2083a011, 0x023540c1, 0x32408499, 0x2400d100,
+0x400cd18b, 0x001d0033, 0x0cd00334, 0xcd002140, 0xd0030400, 0x0023400c,
+0x131555d1, 0x56408410, 0x00000e80, 0x00000000, 0x0031a803, 0x446400d5,
+0x36402d10, 0x6400d000, 0x400d5003, 0x045d0037, 0x0dd00364, 0xdd002744,
+0xd0134400, 0x0427400d, 0x037500d1, 0x1e418500, 0x00000620, 0x00000000,
+0x4087a802, 0x077c40d3, 0x14c001b0, 0x7c011300, 0xc009b003, 0x331f0037,
+0x0df0076c, 0xdf0027c2, 0xf0064c00, 0x4087c00d, 0x035c80d3, 0x02d03d34,
+0x00000e20, 0x00000000, 0x20dd8007, 0x038c20f3, 0x3dc00f70, 0xdc98bf00,
+0xc007f003, 0x00bf04ff, 0x9ff08bcd, 0xef082fc8, 0xd186fc00, 0x008f420f,
+0x43e800f3, 0x0dc01de0, 0x00000602, 0x00000000, 0x00050802, 0x0f6c00d3,
+0x34c025f0, 0x5c08df28, 0xc06d3023, 0x32df2034, 0x0d30037c, 0xd30026c0,
+0x30026c00, 0x0230d00d, 0x23cc80df, 0x09d02f34, 0x00000420, 0x00000000,
+0x84f4a013, 0x056407f1, 0xb4408fd0, 0xc402c104, 0x402db003, 0x01cd00f4,
+0x0d102370, 0xff00ac40, 0x100e4450, 0x026c440f, 0x0b8400cb, 0x4c400d30,
+0x00000200, 0x00000000, 0x2162a007, 0x020450d1, 0x044011d0, 0x14014511,
+0x448c914b, 0x890d1032, 0xc890ab34, 0xc511a044, 0x916f0447, 0x40c0444c,
+0x8f04a68d, 0x1d4005d0, 0x00000a00, 0x00000000, 0x20208004, 0x848400e1,
+0x6c50d6d0, 0x8401f900, 0x505e1417, 0x09ed006a, 0x1a9407b4, 0xe4426810,
+0x94878501, 0x600a001e, 0x078409b9, 0x18601e50, 0x00000200, 0x00000000,
+0x02001012, 0x222c08d1, 0x30c14df0, 0x5c00c708, 0xc00d9003, 0x088f0432,
+0x8d90137c, 0xd40424c0, 0xb0034c00, 0x0004810d, 0x030c08cf, 0x49c000f8,
+0x00000040, 0x00000000, 0x012cb802, 0x00fc14ff, 0x3bc24ff0, 0xfc00f702,
+0xc44ff013, 0x28ff003d, 0x8f70037c, 0xfb082dc0, 0x79237408, 0x00adc00f,
+0x23fc28ff, 0x0bc087b0, 0x00000660, 0x00000000, 0x3037a015, 0x926c16df,
+0x14c159f0, 0x4d005f00, 0xd0193477, 0x01534034, 0x09500749, 0xd30927c0,
+0x38075c17, 0x000700cd, 0x33cc40cb, 0x44c01d30, 0x00000e00, 0x00000000,
+0x00398812, 0xc08c04ed, 0x38402ed0, 0x8620ff00, 0x400e1013, 0x00e10038,
+0x0a100bac, 0xe5832340, 0x10038486, 0x400b408e, 0x438400e1, 0x48400e10,
+0x00000620, 0x00000000, 0x00590003, 0x07b401e5, 0x7a0c1e50, 0x8401ed04,
+0x403e5017, 0x01f18078, 0x1e1057a4, 0xe1036b4a, 0x10078441, 0x025b401e,
+0x078491f1, 0x0c400818, 0x00000402, 0x00000000, 0x22332812, 0x095400cd,
+0x72700cd0, 0x0400c500, 0x400c1003, 0x01c10234, 0x0c140704, 0xc5002340,
+0x14230500, 0x0233400c, 0x030440c1, 0x48400c10, 0x00000c20, 0x00000000,
+0x005da817, 0x65fc0057, 0x5ec22570, 0x4c007d00, 0xc0071001, 0x03730014,
+0x05300064, 0x538017c0, 0x10054400, 0x0057c005, 0x014c0273, 0x5cd02734,
+0x00000620, 0x00000000, 0x00070012, 0x004c001f, 0x05c301d0, 0x7c001f00,
+0xc021f008, 0x1a1f0087, 0x01f0886c, 0x1fc807c6, 0xf0087c02, 0x0007c001,
+0x003d0317, 0x4bc100f0, 0x00000c00, 0x00000000, 0x00270810, 0x166c0097,
+0x27c00d70, 0x4c009f11, 0xc439f186, 0x429300e7, 0x39f0147c, 0x930024c0,
+0xf0867481, 0x0130d009, 0x024c8181, 0x40c00934, 0x00000c20, 0x00000000,
+0x00a62001, 0x0274009d, 0x27404910, 0x45009d19, 0x40099002, 0x03914027,
+0x39d21274, 0x90402458, 0xd0027400, 0x08a40039, 0x0a540895, 0x04401930,
+0x00000800, 0x00000000, 0x00b4a018, 0x0244108d, 0x27408950, 0x44068d10,
+0x400d5022, 0x00910027, 0x08d00274, 0x990a2041, 0xd0225408, 0x00244088,
+0x0a44029d, 0x60401910, 0x00000200, 0x00000000, 0x02202010, 0x2214088d,
+0xa3402810, 0x04028d00, 0x402cd21b, 0x028100b3, 0x28d20a34, 0x8900b040,
+0xd00a3416, 0x80b06428, 0x0214048d, 0x40408810, 0x00000080, 0x00000000,
+0x3586b01d, 0x586c160f, 0x07c14070, 0x0c001f00, 0xc000f004, 0x20530003,
+0x01f0503c, 0x480004c0, 0xf0011c04, 0x0004c405, 0xa84c0b1f, 0x74c36130,
+0x00000ac0, 0x00000000, 0x012fb819, 0x13fc049f, 0x2fc809f2, 0x7c00bf00,
+0xc00b9822, 0x80af002f, 0x0bf200fc, 0x9700afc0, 0xf802fc00, 0x00b3c029,
+0x0e3c09b7, 0x67c04b70, 0x00000e60, 0x00000000, 0x00afa018, 0x1acc02bb,
+0x27c189f0, 0x7c829b00, 0xc2090032, 0x029f2022, 0x29308674, 0x9701a3c0,
+0xf00a7c00, 0x012cc089, 0x62cc06a1, 0x67440b30, 0x00000e00, 0x00000000,
+0x4007081c, 0x10450411, 0x070821d0, 0x74801321, 0xc9457208, 0x800d2105,
+0x01305064, 0x11208748, 0xd2107484, 0x0582c043, 0x08548015, 0x73404154,
+0x00000c22, 0x00000000, 0x00a3a010, 0x1a140681, 0x2f004ad0, 0xb400a904,
+0x400a5032, 0x00ad042b, 0x0a9082f4, 0xa5022b40, 0xd002a410, 0x4220402a,
+0x12042681, 0x43612c90, 0x00000e80, 0x00000000, 0x00a5a818, 0x12748091,
+0x2f4909d0, 0xf480b104, 0x488b5082, 0x42bd002d, 0x4b1202e4, 0xb5002f40,
+0xd002f400, 0x8036400b, 0x02540295, 0x634009d8, 0x00000620, 0x00000000,
+0x00a7a805, 0x865d0093, 0xe3c039f0, 0x7c1b9b00, 0xc0393802, 0x029f8027,
+0x09b0023c, 0x95002744, 0xf0027c00, 0x02a4c009, 0x024c0292, 0x17c059b2,
+0x00000e20, 0x00000000, 0x00258014, 0x024c1097, 0x27c089f0, 0x7c019b05,
+0xc009f002, 0x049f00e5, 0x0970266c, 0x9b0023c0, 0xf0027c00, 0x10630009,
+0x0238049f, 0x53c03930, 0x00000600, 0x00000000, 0x01850814, 0x006c0007,
+0x8cc20331, 0xfc023d00, 0x60032000, 0x0033410f, 0x03f080cc, 0x3a040fc8,
+0xf000fc08, 0x0004c002, 0x904c0913, 0x53c00130, 0x00000420, 0x00000000,
+0x015ca014, 0x0545227d, 0xd4500550, 0x74065d00, 0xc015502d, 0x00510817,
+0x75f08140, 0x51001740, 0xd0094c0b, 0x001d4007, 0x0dc4027f, 0x53400510,
+0x00000200, 0x00000000, 0x0076a014, 0x03040245, 0x78480e10, 0xb404ed80,
+0x404e9003, 0x52e1027b, 0x3ed13794, 0xe000bb4b, 0xd06bb402, 0x0132400e,
+0x0704001d, 0x53400c90, 0x00000a00, 0x00000000, 0x10388005, 0x0f840a6d,
+0x38401ed0, 0x3400e904, 0x410e500f, 0x01e1007c, 0x0e500795, 0xe1043f40,
+0xd0038400, 0x002b610c, 0x6384002d, 0x17400e90, 0x00000200, 0x00000000,
+0x00581015, 0x06c601c7, 0x78c01f30, 0xbc41ed00, 0x401eb007, 0x01e3007b,
+0x1ed0039c, 0xea407bc8, 0xf007bc41, 0xa07ac01e, 0x17cc816f, 0x57c81eb0,
+0x00000040, 0x00000000, 0xa015b810, 0x825400df, 0x07c00172, 0x7c001f08,
+0xc001c000, 0x005f0007, 0x01f0006c, 0x170007c0, 0xe0006c00, 0x882d4201,
+0x017d005f, 0x43c00f74, 0x00000660, 0x00000000, 0x027fa000, 0x26c8417f,
+0x7ec0df30, 0xdc01f302, 0xc09eb007, 0x29fe027c, 0x1ff007cc, 0xf3007fc0,
+0xf027dc81, 0x03dda49f, 0x07cc01f3, 0x08d01b30, 0x00000e00, 0x00000000,
+0x00098815, 0xb384046d, 0x38418eb2, 0xb488e102, 0xc28e7123, 0x0cff0b3a,
+0x0ef20384, 0xe1823b40, 0x7023ac08, 0x022b40ce, 0x119d00fb, 0x56c00a10,
+0x00000620, 0x00000000, 0x10390200, 0x828480ed, 0x38484e50, 0x9400e100,
+0x480fd003, 0x00ed203a, 0x8ed043a6, 0xc1003f40, 0xd203b400, 0x0139481e,
+0x832408e9, 0x60410f50, 0x00000400, 0x00000000, 0x00c32804, 0x020400cd,
+0x824010d0, 0x34000170, 0x40b05000, 0x83450202, 0x00500024, 0x01800340,
+0x50000480, 0x00274200, 0x831400c9, 0x18413c5c, 0x00000c20, 0x00000000,
+0x0425a815, 0x8b4c00ef, 0x34c0bc50, 0x5c00d200, 0xc03d9003, 0x069d0034,
+0x0dd20768, 0xd34037c0, 0xf0037400, 0x0275c00d, 0x02ec0a0b, 0x54481d74,
+0x00000620, 0x00000000, 0x04370001, 0x133c005f, 0xb5c825a0, 0x3c90df00,
+0xc84d700b, 0x909f2037, 0x2df20b5d, 0xdf20b7c8, 0xf20b7c80, 0x80e7c80d,
+0x037c001f, 0x27c00d90, 0x00000c00, 0x00000000, 0x000b0880, 0x024c22d3,
+0x3cc01930, 0xfc05ff0d, 0xc00fb007, 0x00bf013e, 0x1ff007fc, 0xf3007cc8,
+0xb003fc00, 0x402fc00f, 0x229c0075, 0x07c21a30, 0x00000c20, 0x00000000,
+0x00162081, 0x02540251, 0x05400d50, 0x74041d00, 0x40405000, 0x031d0105,
+0xc0d0605c, 0x11060140, 0x50283401, 0x40e74081, 0x016c0055, 0x04401934,
+0x00000802, 0x00000000, 0x0064a001, 0x02441099, 0x04406d90, 0x74001504,
+0x40411160, 0x141d0006, 0x01500070, 0x11000448, 0x90085438, 0x00764409,
+0x035480d5, 0x05404990, 0x00000200, 0x00000000, 0x40002010, 0x031400c1,
+0x01600550, 0x34000d30, 0x40015800, 0x000d0003, 0x01900016, 0x00600540,
+0x10006400, 0x80034008, 0x002401c5, 0x40400813, 0x00000080, 0x00000000,
+0x0026b000, 0x024c0093, 0x00400930, 0x7c001700, 0xc0013000, 0x001f0006,
+0x01f1007c, 0x10400448, 0xb0007c00, 0x002bc009, 0x035c00d7, 0x05c009b0,
+0x00000ac0, 0x00000000, 0x200fb805, 0x02fc00ff, 0x3fc00ff0, 0xfc00ff00,
+0xc00f7003, 0x20bf003c, 0x0ff003dc, 0xff003bc0, 0xd003fc00, 0x502fc007,
+0x02fc007f, 0x15c00af0, 0x00000e60, 0x00000000, 0x001fb003, 0x01dc20f7,
+0xbe408f70, 0xdc083301, 0xc08ff003, 0x4cfb0d3e, 0x0d30904c, 0xf60837c0,
+0xf202ec48, 0x1104e04f, 0x011c0c4f, 0x0cd08f70, 0x00000e00, 0x00000000,
+0x20a70001, 0x00c40201, 0x3c404f30, 0x6c041b40, 0x400dd1b3, 0x06510081,
+0xcf112850, 0xfd013dc1, 0x54124c04, 0x2985c08f, 0x0154025d, 0x04406810,
+0x00000c20, 0x00000000, 0x0217a211, 0x01140245, 0xb1400c14, 0x34004101,
+0x404c9041, 0x88414000, 0x0c185004, 0xcd043340, 0x10432404, 0x0710400c,
+0x0104228d, 0x45406810, 0x00000e80, 0x00000000, 0x0005a803, 0x09540095,
+0x35480d10, 0x44021100, 0x400dd041, 0x04c10035, 0x0d118010, 0xdd003540,
+0x50036400, 0x0c15400d, 0xc15000dd, 0x0d400910, 0x00000620, 0x00000000,
+0x0256a802, 0x055c0097, 0x35d00d30, 0x74029100, 0xc00dd002, 0x019a0036,
+0x0d340f4c, 0xcf0037c0, 0x30026c00, 0x0804c00d, 0x0c08124f, 0x09c00d34,
+0x00000e20, 0x00000000, 0x102d8007, 0x086c007a, 0x3ec00fb1, 0xfc207f20,
+0xc50ef026, 0x213f500b, 0x0ff00ffc, 0xff003fc2, 0xf0039c40, 0x0087c40f,
+0xc8fc147f, 0x9ec08ab0, 0x00000600, 0x00000000, 0x00350802, 0x091c081f,
+0x32c08cb0, 0x7c00df01, 0xe20d7408, 0x001f0107, 0x0df04f5c, 0xd30435c0,
+0xf0035c10, 0x2014c20c, 0x214c0097, 0x08c08930, 0x00000420, 0x00000000,
+0x03a0a013, 0x45440bd1, 0x7f402f90, 0x74105d01, 0x412f112c, 0x0a9111b7,
+0x1fd00b6c, 0xf1003ec0, 0xd0077d03, 0x0094402f, 0x09ec02f1, 0x4c40a910,
+0x00000200, 0x00000000, 0x0042a007, 0x113400d5, 0xb3490c90, 0x34d01900,
+0x401c4000, 0x088d0032, 0x8cd00004, 0xc1023261, 0x90060520, 0x118042dc,
+0x0d3000cd, 0x0c501890, 0x00000a00, 0x00000000, 0x00788004, 0x21a40921,
+0x7b401e94, 0x2401ad11, 0x401e1054, 0x8521024b, 0x5ed804a4, 0xc1003a40,
+0xd046b419, 0x11584c1f, 0x05f40df9, 0x00401e9c, 0x00000200, 0x00000000,
+0x00000012, 0x213c0047, 0x33400cb1, 0x34084e02, 0x440c7096, 0x001f0143,
+0x1df1271c, 0xc30b7664, 0xb0171d00, 0x0140c80c, 0x853c0dcf, 0x58d04cb0,
+0x00000040, 0x00000000, 0x2019a802, 0x11cc00bf, 0x37c00f70, 0xfc08be03,
+0xc00df022, 0x04bb203f, 0x0df0036c, 0xff3f3ec0, 0xf1137c00, 0x2025c00e,
+0xb1ec20f7, 0x0bc00f70, 0x00000660, 0x00000000, 0x0007a015, 0x434c009b,
+0x35c00df0, 0x5c00930c, 0xc00d3001, 0x00db0037, 0x4df0004c, 0xd32d37c8,
+0x72024c9d, 0x1006c12d, 0xa50d00df, 0x57c00938, 0x00000e08, 0x00000000,
+0x08398812, 0x03852041, 0x38412ed0, 0xb400e101, 0x400e1201, 0x004b000f,
+0xaed000ac, 0xf3313b40, 0x51038444, 0x1019424e, 0x03ac43fd, 0x4b400eb0,
+0x00000620, 0x00000000, 0x006d0003, 0x05844129, 0x7b405ed0, 0xb403e902,
+0x429e1407, 0x0161904b, 0x5ed007a0, 0xe9107b48, 0xd0873484, 0x0048449c,
+0x15c401ed, 0x0f441e14, 0x00000400, 0x00000000, 0x00332812, 0x030600c1,
+0x34400cd0, 0x3601c940, 0x680c1103, 0x01c92037, 0x0cd00744, 0xc1103344,
+0xd0073500, 0x0231440c, 0x0f0400dd, 0x5b400c90, 0x00000c20, 0x00000000,
+0x189da817, 0x01cc017b, 0x17c005f0, 0xfc037b00, 0xc4051041, 0x1073001f,
+0x05f01de1, 0x4b0013c0, 0xf0117c00, 0x005e0207, 0x21c0807f, 0x5fc40530,
+0x00000620, 0x00000000, 0x20070012, 0x007c0a1f, 0x07c601f0, 0x7c041700,
+0xc001f008, 0x001f0007, 0x01f1487c, 0x1f0007e0, 0x32084400, 0x0005e001,
+0x207c001f, 0x4bc02130, 0x00000c00, 0x00000000, 0x04230810, 0x460c008b,
+0x25c00834, 0x3c229310, 0xc0091022, 0x008f0024, 0x0932024c, 0x9b0127c4,
+0x30064c00, 0x3026c009, 0x82688197, 0x40c409f2, 0x00000c20, 0x00000000,
+0x40262001, 0x26458091, 0x24400910, 0x74409100, 0x4089144e, 0x00951025,
+0x09100a45, 0x91106740, 0x514e0440, 0x10254028, 0x02540197, 0x055129d0,
+0x00000800, 0x00000000, 0x0064a018, 0x02440091, 0x25400990, 0x54409100,
+0x4008d002, 0x10990024, 0x09100364, 0x91802540, 0x98226402, 0x20e44009,
+0x02740495, 0x604008d8, 0x00000200, 0x00000000, 0x00202010, 0x02240281,
+0x20400890, 0x34088902, 0x40085022, 0x088500a1, 0x08107300, 0x8d422360,
+0xd8226400, 0x1221448c, 0x42040885, 0x414088d9, 0x00000080, 0x00000000,
+0x0502b01d, 0x504c1453, 0x81c000b0, 0x1c001305, 0xc08172d8, 0x161f0504,
+0xe114186e, 0x1b0587c1, 0xb2586c9c, 0x0586e161, 0x047c9017, 0x74c161f2,
+0x00000ac0, 0x00000000, 0x002fb819, 0x02dc00b7, 0x27c92970, 0xfc04b769,
+0xc069b013, 0x04bb002f, 0x19f012fc, 0x93012380, 0x7012dc04, 0x012ff049,
+0x02fc00bf, 0x66c04bf0, 0x00000e60, 0x00000000, 0x002fa018, 0x025c009f,
+0x27c00970, 0x5c009f05, 0xcb69b00a, 0x009d0227, 0x69f04274, 0xbb132d44,
+0x3042dc06, 0x142cc04b, 0x12ec12bb, 0x63c009f0, 0x00000e00, 0x00000000,
+0x0007081c, 0x00440017, 0x87c06110, 0x44041d01, 0x40019000, 0xa0110107,
+0x43700874, 0x11000440, 0x50582c84, 0x4187c001, 0x006c065f, 0x734040d1,
+0x00000c20, 0x00000000, 0x002ba010, 0x0e9410ad, 0x2b418a50, 0x9410b904,
+0x400ad002, 0x00a9912a, 0x6ad052b0, 0x8101a140, 0x58023586, 0x24604568,
+0x0a040481, 0x414528d1, 0x00000e80, 0x00000000, 0x0425a818, 0x06c602b5,
+0x2f440f10, 0xc400bd10, 0x400bd002, 0x80b10c2f, 0x0b5002f6, 0x91002400,
+0x50926420, 0x40676809, 0x2264089d, 0x634019d0, 0x00000620, 0x00000000,
+0x00a78805, 0x025c029d, 0x27400970, 0x5c098f00, 0xc009f002, 0x109f40a7,
+0x09f19274, 0x914025c0, 0x70027c00, 0x20e44008, 0x064c0093, 0x15c209f0,
+0x00000e20, 0x00000000, 0x00248014, 0x027c0097, 0x25c009f0, 0x3c019f00,
+0xc2093002, 0x009f10e7, 0x0970267c, 0x970027c4, 0xf2067c00, 0x0027c009,
+0x027e008f, 0x53c00df8, 0x00000600, 0x00000000, 0x008d0814, 0x008c0223,
+0x0ce00330, 0xcc103f08, 0xc0033000, 0x403f000a, 0x027008f4, 0x072c0340,
+0x10005c88, 0x00464801, 0xe04c881b, 0x50c01130, 0x00000420, 0x00000000,
+0x0854a014, 0x01440051, 0x57e00550, 0x44005d00, 0x40051001, 0x01592017,
+0x0510014c, 0x7d201c40, 0x10a9fc00, 0x08984007, 0x05c40175, 0x50400510,
+0x00000200, 0x00000000, 0x4252a014, 0x00340901, 0x004a0012, 0x14000d08,
+0x40001800, 0x00055803, 0x10180014, 0x4d003240, 0xd0834430, 0x0030400c,
+0x070431cd, 0x50500c90, 0x00000a00, 0x00000000, 0x20708205, 0x033404c1,
+0x39401e50, 0x9408fd0c, 0x408e1203, 0x07c1013b, 0x4c405704, 0x4d213841,
+0xd003a100, 0x03185006, 0x068420f1, 0x14411290, 0x00000200, 0x00000000,
+0x00581015, 0x05bd01a3, 0x48405330, 0xdc056f0d, 0x48963047, 0x33ae144e,
+0x3234169c, 0x67217a80, 0xf1079c27, 0x014cc41f, 0x078800af, 0x54d016b4,
+0x00000040, 0x00000000, 0x0035b810, 0x024c2a5f, 0xb7c02df0, 0x6d468f22,
+0xc869f430, 0x065b0337, 0x1db0417c, 0x5e0827c8, 0x30827400, 0x0045c145,
+0x823c498f, 0x43c02970, 0x00000660, 0x00000000, 0x005fa000, 0x049c037f,
+0x5dc13330, 0x5c03bf00, 0xc213f104, 0x855a1046, 0x17d245fc, 0xfba67ec0,
+0xb227cd8d, 0x1078c81d, 0x244c01d3, 0x00c03b30, 0x00000e20, 0x00000000,
+0x01398815, 0x93ac20ad, 0xa9c04e10, 0x04046f00, 0x002fd017, 0x09ab0070,
+0x7bd0028c, 0xa3001842, 0xf0073c0c, 0x0fdbc076, 0x1eac0d6d, 0x54408610,
+0x00000660, 0x00000000, 0x00190200, 0x09d400ed, 0x1b40021a, 0xb410ed02,
+0x50065093, 0x00c90008, 0x56d003a6, 0x61003144, 0xd041844c, 0x010e404e,
+0x10e400a9, 0x00400210, 0x00000400, 0x00000000, 0x02b32804, 0x0204120d,
+0x23600d1c, 0x24000500, 0x4009d800, 0x120904f0, 0x08d00004, 0x01000040,
+0x42003440, 0x00c14005, 0x0224010d, 0x10420c10, 0x00000c00, 0x00000000,
+0x00b5a815, 0x0254113f, 0x2fc00f10, 0xfc003d00, 0xc00b7000, 0x823a217e,
+0x0bf080ec, 0xf3000dd4, 0xd0834c00, 0x002e4205, 0x016c81e3, 0x54f00d30,
+0x00000600, 0x00000000, 0x21170001, 0x0d7c00cf, 0x95c001f0, 0x5c00df00,
+0xc005f003, 0x80d70887, 0x05f2032c, 0x971035c4, 0xf1037d00, 0x0027c021,
+0x007d08d7, 0x07c011f5, 0x00000c00, 0x00000000, 0x023b08a0, 0x038c0093,
+0x28d29fb0, 0xfc307300, 0xc00ff003, 0x80b5007e, 0x0b3102ec, 0x43000bc0,
+0xa003ac00, 0x54dcd04f, 0x419000d3, 0x00c00530, 0x00000c02, 0x00000000,
+0x00162081, 0x10444051, 0x94403150, 0x74009500, 0x4421d100, 0x00550185,
+0x05108174, 0x1b006740, 0x50024438, 0x00d04021, 0x2c5410d5, 0x045009f0,
+0x00000802, 0x00000000, 0x00b4a001, 0x02440051, 0x34400d94, 0x74009500,
+0x4009d000, 0x80510231, 0x0d900174, 0xd122876c, 0x54836400, 0x00045205,
+0x015688d1, 0x06400892, 0x00000200, 0x00000000, 0x40102010, 0x01042081,
+0x00480011, 0x24004100, 0x4004d013, 0x04850001, 0x40950234, 0x01001240,
+0x50430500, 0x11004040, 0x600618c1, 0x42401c92, 0x00000080, 0x00000000,
+0x0036b000, 0x034d00f3, 0x3cc00fb4, 0xfc40e700, 0xc40fd037, 0x05f701f8,
+0xfdb023fc, 0x510207c5, 0x703d6c00, 0x2754c15e, 0x15582593, 0x02c401b0,
+0x00000ac0, 0x00000000, 0x100fb805, 0x00fc003f, 0x0fc003f0, 0xfc003f00,
+0xc003f0a4, 0x0837074d, 0x113004fc, 0x3f894fc0, 0xf0947840, 0x0057c003,
+0x14bc05bf, 0x15c00ff0, 0x00000e60, 0x00000000, 0x003f8003, 0x02f4003f,
+0x3cc00f50, 0xfc00ff00, 0xc80f3803, 0x00b1403f, 0x0f3003fc, 0xfd103fc0,
+0xb123fc00, 0x018acc27, 0x51fc90a2, 0x0cc02f34, 0x00000e00, 0x00000000,
+0x103f0801, 0x02748011, 0x05400911, 0x3c001d00, 0x48011200, 0x00110007,
+0x01520074, 0x1d000740, 0x10147400, 0x2364c858, 0x49740095, 0x04500f10,
+0x00000c20, 0x00000000, 0x0033a011, 0x02140001, 0x00600451, 0x36000d20,
+0x40001400, 0x40090003, 0x00940024, 0x0d000340, 0xd0101480, 0x80324008,
+0x11140009, 0x44404c90, 0x00000e80, 0x00000000, 0x0035a803, 0x02740211,
+0x05400d18, 0x74101d00, 0x40811020, 0x90190007, 0x01902034, 0x1d820740,
+0xd0083424, 0x10244049, 0x4174009d, 0x0c400d10, 0x00000620, 0x00000000,
+0x4037a802, 0x027c2313, 0x04cc2850, 0x78021f10, 0xc001100c, 0xa05b0047,
+0x21b0146c, 0x1f04c7c0, 0xf0245c41, 0x0806c011, 0x213c249b, 0x08c20d32,
+0x00000e20, 0x00000000, 0x08398007, 0x02bc4573, 0xffc00ff2, 0xdc09ff08,
+0xc01ff107, 0x80f700bf, 0x3f7007fc, 0xff007fc0, 0x3003fc00, 0x120dc00f,
+0x057c00f7, 0x1fc00fc0, 0x00000600, 0x00000000, 0x00350806, 0x437c021f,
+0xb5d505f0, 0x7c02db00, 0xc22d3083, 0x00d340b4, 0x2df21b7c, 0xdf00b7e8,
+0xf00b7c02, 0x0035828d, 0x094c00d3, 0x0bc08d30, 0x00000420, 0x00000000,
+0x013ca013, 0x8374005d, 0x35490d10, 0x4c0add01, 0x41ad100f, 0x0fd122f5,
+0x0dd00b74, 0xd1103740, 0xd0037400, 0x012c44ad, 0x0d6c00fb, 0x4f420f10,
+0x00000200, 0x00000000, 0x0072a003, 0x8e24010d, 0x835c3410, 0x74000d09,
+0x50001440, 0x00010004, 0x00d82034, 0x05000340, 0xd0002480, 0x04954011,
+0x41040089, 0x1f410d14, 0x00000a00, 0x00000000, 0x20788000, 0xb6b411ad,
+0x7b409a14, 0x8401ed00, 0x421e1107, 0x05a00c7a, 0x1ed087b4, 0xe9007b40,
+0x9027b421, 0x213c401e, 0x04a400b9, 0x13401e10, 0x00000200, 0x00000000,
+0x18301016, 0x527c000f, 0xb3ca8c74, 0x3c00cf20, 0xc82d3043, 0x008320b4,
+0x0cd3933e, 0xcf023744, 0xf0032c22, 0x1a31c00c, 0x510c088b, 0x4bc20c3a,
+0x00000040, 0x00000000, 0x04bdb802, 0x92fc00bd, 0x3dc08e70, 0xdc08ff00,
+0xc08f7003, 0x049f0035, 0x0ff803fc, 0xf7383fc0, 0xf003fc00, 0x003fc01f,
+0x00fc08bf, 0x0bc10ff8, 0x00000660, 0x00000000, 0x00b7a015, 0x827c2113,
+0x04c81130, 0x7c001700, 0xc001b000, 0x40532007, 0x01300440, 0x1f0007c0,
+0x30047c00, 0x2a57c001, 0x074c088b, 0x57c16d30, 0x00000e00, 0x00000000,
+0x00318812, 0x02bc402b, 0x38400eb0, 0xb400ed00, 0x400e1403, 0x00f1403f,
+0x0e9003c4, 0xed103b40, 0x1003b400, 0x011b400e, 0x02ec01e1, 0x4b484e11,
+0x00000620, 0x00000000, 0x80790003, 0x0f340061, 0x78411e10, 0xb411ed04,
+0x401e1007, 0x21e1007b, 0x1e908786, 0xed007b41, 0x1107b6d1, 0x003b401e,
+0x079407f9, 0x0f401e90, 0x00000400, 0x00000000, 0xa0332812, 0x035481c9,
+0x78401e98, 0xf403ed00, 0x442e1007, 0x12e1007b, 0x0e900386, 0xed80bb40,
+0x1407b402, 0x04b3600e, 0x023413d1, 0x4b400c90, 0x00000c20, 0x00000000,
+0x0015a817, 0x05740473, 0x94d00530, 0x74005700, 0xc9051045, 0x115316d7,
+0x8534094d, 0x5d22d7c8, 0x30417c81, 0x001fc057, 0x21dc017b, 0x5fc005b4,
+0x00000620, 0x00000000, 0x00030012, 0x087c101f, 0x0fc403f0, 0xfc003f00,
+0xc1037280, 0x003f000f, 0x037260ec, 0x3f020fc0, 0xf010fc02, 0x0007e003,
+0x806c801f, 0x4bc02172, 0x00000c00, 0x00000000, 0x01270810, 0x224c0083,
+0x23e00932, 0x6c109b04, 0xc4093042, 0x00930024, 0x09f0026c, 0x9f0067c0,
+0xf0024c12, 0x1022c009, 0x024d809b, 0x43c009f0, 0x00000c20, 0x00000000,
+0x20262001, 0x42442091, 0x27680910, 0x45009340, 0x50091102, 0x00914024,
+0x09d0024d, 0x8d226740, 0xd00a4c01, 0x10245009, 0x02440091, 0x074129d0,
+0x00000800, 0x00000000, 0x00248018, 0x82442191, 0x2f4e0d10, 0xc400a100,
+0x400a1c03, 0x20a10028, 0x0fd802c4, 0xb5802f42, 0xd042c400, 0x0024602a,
+0x02640091, 0x634009d8, 0x00000200, 0x00000000, 0x02202010, 0x22040081,
+0x2b400a10, 0x8408a100, 0x508a1022, 0x08a10228, 0x0ad82284, 0xed0a2b40,
+0xd00a8400, 0x10a0402a, 0x0a240081, 0x434008d8, 0x00000080, 0x00000000,
+0x0586b01d, 0x584e1413, 0x17400134, 0x0c021300, 0x48213008, 0x02130084,
+0x01f0084c, 0x170087c0, 0xf0000d00, 0x0500c003, 0x006c1e13, 0x77c3e1f0,
+0x00000ac0, 0x00000000, 0x4127b819, 0x12fe00ff, 0xa7c228f0, 0x5c069f20,
+0xc069b21a, 0x269f11a7, 0x29f01b5c, 0xdf01b7c0, 0xf00b5c02, 0x002fc029,
+0x0adc01b7, 0x67c019f0, 0x00000e60, 0x00000000, 0x022fa018, 0x1acc049f,
+0x24404a32, 0x4c309300, 0xc0693002, 0x009309a6, 0x4b30124c, 0xa3022c80,
+0x30124c04, 0x1927c089, 0x12cc0291, 0x60c16bf8, 0x00000e00, 0x00000000,
+0x0087081c, 0x90440a1d, 0x04500112, 0x05050140, 0x5071143c, 0x030140c0,
+0x01101cc5, 0x11428450, 0x14c44502, 0x054f40b1, 0x50440445, 0x72c001d0,
+0x00000c20, 0x00000000, 0x01a3a010, 0x9a24008d, 0xa0488810, 0x84108108,
+0x40ca5042, 0x16a50229, 0x28146284, 0x81012040, 0x110a0408, 0x01ab400a,
+0x32240681, 0x406008d8, 0x00000e80, 0x00000000, 0x0025a818, 0x8264809d,
+0x24410914, 0xc4109104, 0x406b5002, 0x82b501ad, 0x291022c6, 0x91002440,
+0x10224400, 0x042f426b, 0x02640095, 0x624009d2, 0x00000620, 0x00000000,
+0x0027a805, 0x266c029f, 0xe4cc3930, 0x4c029300, 0xc029706e, 0x619780e5,
+0x0930864c, 0x930024c0, 0x30024c00, 0x40e7c239, 0x026d0293, 0x14d009d0,
+0x00000e20, 0x00000000, 0x00258014, 0x025c49df, 0x77c049f0, 0x7c099f02,
+0xc019b006, 0x059b2066, 0x29f0067c, 0x9f00a7c0, 0xe0067c02, 0x00a7c009,
+0x425c089b, 0x53c109f2, 0x00000600, 0x00000000, 0x2a050814, 0x207c800f,
+0x80c03080, 0x8c020f02, 0xc0223008, 0x4023008b, 0x00f0008c, 0x0f0000c0,
+0xf0080c00, 0x000cc443, 0x005c8013, 0x50c000b4, 0x00000420, 0x00000000,
+0x0014a014, 0x2df4205d, 0xd4412750, 0x44005d90, 0x00053001, 0x20550017,
+0x05700155, 0x7d001540, 0xd0014400, 0x001c5005, 0x09c48051, 0x52c01711,
+0x00000200, 0x00000000, 0x0072a014, 0x0374004d, 0x324c1890, 0x0500cd04,
+0x400c8403, 0x40c02033, 0x1cd00324, 0x4d027040, 0xd0030400, 0x0014422c,
+0x2e1400d1, 0x52403c10, 0x00000a00, 0x00000000, 0x20288005, 0x0334032d,
+0x3a400e10, 0x84006d10, 0x44021000, 0x0025100b, 0x2e5000a4, 0x6d003942,
+0xd0038400, 0x302a4010, 0x050404e1, 0x1641ce10, 0x00000200, 0x00000000,
+0x00681015, 0x26bc002d, 0x7ad21ab0, 0x8c41ed10, 0xc01eb107, 0x81e3407b,
+0x1ef007ac, 0x6f0078c0, 0xf0058501, 0x405cc81e, 0x069c05e3, 0x56c01630,
+0x00000040, 0x00000000, 0x0025b810, 0x037c061f, 0x95c00df0, 0x7c405f00,
+0xc401f000, 0x001b1007, 0x0cf0005c, 0x5f0037c0, 0xf2017020, 0x0025c001,
+0x017c42df, 0x43c00470, 0x00000660, 0x00000000, 0x007fa000, 0x07fc2372,
+0xfcc0df34, 0xc801f322, 0xc09f3007, 0x41f3207c, 0x1b3007d8, 0x73027cc0,
+0x3027cc01, 0x0058c01f, 0x85cc93f3, 0x00c01f34, 0x00000e00, 0x00000000,
+0x02398815, 0x23f4002b, 0x284186b0, 0x94846b00, 0x41821010, 0x04210108,
+0x8a100084, 0x61003840, 0xb0238490, 0x202ac042, 0x11c410fb, 0x56c00210,
+0x00000620, 0x00000000, 0x00210000, 0x00b40221, 0x3a0a4e50, 0xb410e124,
+0x480e9803, 0x40e1243a, 0x0a900386, 0x610c2840, 0x11018400, 0x005c610c,
+0x819402e1, 0x00400650, 0x00000400, 0x00000000, 0x00272804, 0x82340909,
+0x02561490, 0x37034900, 0x58119604, 0x03114002, 0x88940447, 0x41642050,
+0x14450513, 0x01a05001, 0x210401c9, 0x12400050, 0x00000c20, 0x00000000,
+0x0035a815, 0x027c0250, 0xb6c01d70, 0x6401d100, 0xc03db06b, 0x84d102b6,
+0x29a06b5c, 0x4300e4c0, 0x101f4c80, 0x04d4401d, 0x061d01f3, 0x54c00b70,
+0x00000620, 0x00000000, 0x00270001, 0x0278001f, 0x35c00df2, 0x4c045f04,
+0xc0417080, 0x001f0005, 0x4970006c, 0x5f0827c0, 0xf0037c20, 0x0027c101,
+0x017c00df, 0x07c009a0, 0x00000c00, 0x00000000, 0x806f0880, 0x02fc0833,
+0x3ce15db0, 0x4500df10, 0xc00df003, 0x10df0036, 0x5930034d, 0x9f0037c0,
+0xf0014c00, 0x001cc00f, 0x02cc00e3, 0x00c00230, 0x00000c22, 0x00000000,
+0x80662081, 0x46740015, 0x146a0c10, 0xc4007d01, 0x40037100, 0x003d000c,
+0x19f000c8, 0x9d027744, 0xd001c403, 0x502d5043, 0x015400d1, 0x05409114,
+0x00000802, 0x00000000, 0x2124a001, 0x06340011, 0x14480d90, 0x5680cd00,
+0x600dd103, 0x00dd0034, 0x09900340, 0x5d002740, 0x90034006, 0x0010400d,
+0x014400d1, 0x04400910, 0x00000200, 0x00000000, 0x08202010, 0x82348005,
+0x00600410, 0x14004d30, 0x50005900, 0x40090000, 0x08980004, 0x4d002340,
+0xd0030520, 0x40204000, 0x015440c1, 0x41400010, 0x00000080, 0x00000000,
+0x0026b000, 0x02fc0011, 0x14500db2, 0x5e00dd20, 0xc00df203, 0x00df0034,
+0x09b0034c, 0x9f0027c0, 0xb0014c00, 0x0014c005, 0x014c20f3, 0x00c40130,
+0x00000ac0, 0x00000000, 0x002fb805, 0x02fc003f, 0x0bc007f0, 0xec007f80,
+0xc0034200, 0x003f000f, 0x0bf000dc, 0xbf102fc0, 0xf001fc00, 0x002fc40b,
+0x01fc40ff, 0x17c002f2, 0x00000e60, 0x00000000, 0x010f8003, 0x70ec08ff,
+0x3dc18330, 0x5c043f00, 0xc0cfb04b, 0x84d7a006, 0x0f3011dc, 0x270236c0,
+0xb000dc00, 0x003fc009, 0x034c301f, 0x0cc00ff0, 0x00000e00, 0x00000000,
+0x1aa30801, 0x080c06fd, 0xbf426190, 0xc40e5f02, 0x04eea003, 0x10f12597,
+0x4fd02155, 0x15103440, 0x1201140a, 0x0034400b, 0x8bd4021d, 0x04402fb0,
+0x00000c20, 0x00000000, 0x8503a011, 0x902608cd, 0x31484094, 0x16108d05,
+0x120c9893, 0x02c50080, 0x0c500104, 0x01013261, 0x90221400, 0x00334004,
+0x232420cd, 0x444028d8, 0x00000e80, 0x00000000, 0x28258803, 0x126400cd,
+0x37418198, 0x4400d500, 0x440d9003, 0x00d10014, 0x0d500154, 0x01487440,
+0x10025002, 0x0034511d, 0x037400dc, 0x0c4009c0, 0x00000620, 0x00000000,
+0x02478802, 0x006c00df, 0x35c23110, 0x541b1d00, 0xd00db103, 0x00d526c6,
+0x0d74444c, 0x57007280, 0xb2085421, 0x8877c83d, 0x036c009f, 0x08c41de0,
+0x00000e20, 0x00000000, 0x042d8007, 0x85dc00df, 0x3fc01772, 0x7c005f00,
+0xc00e3043, 0x00f7005b, 0x0fe017bc, 0x3f003fc0, 0xf001bc85, 0x027dc00c,
+0x03dc09af, 0x1fc09e30, 0x00000600, 0x00000000, 0x00950802, 0x106c00d7,
+0x34d02930, 0x4c088301, 0xd00db003, 0x84d70885, 0x0d72007c, 0x534077c0,
+0x70034c02, 0x4036c0ad, 0x037c00d3, 0x08c00920, 0x00000420, 0x00000000,
+0x01f4a013, 0x0b443bf1, 0xbcc00d92, 0xdc00df01, 0x800fb103, 0x03e1001e,
+0x5f3203fc, 0x1b0036c4, 0x1003ec03, 0x12f440bd, 0x1bdc0ed1, 0x4c41a9b0,
+0x00000200, 0x00000000, 0x1092a007, 0x034403cd, 0x70400c18, 0x64840100,
+0x400c180b, 0x01c51020, 0x1d500326, 0x0581b141, 0x10001453, 0x0032400c,
+0x1324004d, 0x1c4218c8, 0x00000a00, 0x00000000, 0x80588204, 0x048701e9,
+0x7e401e91, 0x86012502, 0x409e1037, 0x1de5007c, 0x1e5007f6, 0x69407800,
+0x1037b631, 0x057940ce, 0x0794096d, 0x104018d1, 0x00000200, 0x00000000,
+0x00b01012, 0x830408cd, 0x70404d38, 0x05080101, 0x429c1027, 0x45c7a160,
+0x4c70073c, 0x01037148, 0x300c1800, 0x0176c0dc, 0x077c85cf, 0xc8c04cb4,
+0x00000040, 0x00000000, 0x003db002, 0x02de30f7, 0xb9c00f72, 0xfe003c25,
+0xc02fb023, 0x20eb222b, 0x0cb823bc, 0x7f4032c0, 0xf482ec80, 0x0236d08f,
+0x037c80d3, 0x0bc01f30, 0x00000660, 0x00000000, 0x0007a015, 0x837c04df,
+0xb6c00134, 0x7c00d340, 0xc02db813, 0x34db0046, 0x7db0067c, 0x5b0836c0,
+0x30004c00, 0x2034c16d, 0x974c00d3, 0x54c04970, 0x00000e00, 0x00000000,
+0x18098012, 0x01b408ed, 0x3c400610, 0x3400e909, 0x404c524b, 0x02c1101c,
+0x4c100fc4, 0x2d813941, 0x10138480, 0x0038500f, 0x231400c1, 0x48410a50,
+0x00000620, 0x00000000, 0x04790003, 0x479405ed, 0x79441a10, 0xb481e900,
+0x429e1017, 0x85e10208, 0x9e925394, 0xc9027800, 0x10358481, 0x0479411e,
+0xa79401e5, 0x0d401c18, 0x00000400, 0x00000000, 0x00332812, 0x073400cd,
+0x31013c14, 0x3402c900, 0x500d5803, 0x00c90490, 0x0c100304, 0xdd003140,
+0x14070401, 0x0061413c, 0x031400c5, 0x49400c5a, 0x00000c20, 0x00000000,
+0x001da817, 0x01dc005f, 0x1f503730, 0xbc117100, 0xe0053681, 0x005b001c,
+0x05b025dc, 0x79804c80, 0x1045cc03, 0x4815d027, 0x015c0075, 0x5dd00530,
+0x00000620, 0x00000000, 0x00070012, 0x007c020f, 0x00c081f0, 0x7c101700,
+0xc001b000, 0x00170205, 0x2178004c, 0x1f0205c2, 0xf0007d8c, 0x0006c001,
+0x0074101b, 0x4ac001f0, 0x00000c00, 0x00000000, 0x00270810, 0x026c009f,
+0x26c00870, 0x4c029308, 0xc009b202, 0x01870025, 0x5930024d, 0x9f0007c0,
+0xb0020d00, 0x0025c009, 0x024c0093, 0x41c009b0, 0x00000c20, 0x00000000,
+0x00a60001, 0x0a54029d, 0x26c00914, 0x74009500, 0x50091406, 0x09910020,
+0x29120204, 0x99208740, 0x720a4400, 0x40245009, 0x02450091, 0x045009d0,
+0x00000800, 0x00000000, 0x80a4a018, 0x43050095, 0x64400950, 0x54009900,
+0x40090012, 0x00910026, 0x09180254, 0x99006742, 0x10424500, 0x00234808,
+0x02640081, 0x614008d0, 0x00000200, 0x00000000, 0x02202810, 0x7204028d,
+0x2251c890, 0x7414c100, 0x40681023, 0x80810224, 0x8c101a54, 0x8d026348,
+0x50220408, 0x02224c88, 0x32240881, 0x404088d0, 0x00000080, 0x00000000,
+0x3586a01d, 0x180c1457, 0x04cc6070, 0x5c041b05, 0xe041b0d8, 0x7e110187,
+0x2130105c, 0x5f0507c0, 0x30d80c16, 0x00838161, 0x0c6c9613, 0x75c161b1,
+0x00000ac0, 0x00000000, 0x012fa819, 0x12fc009f, 0x24c04b70, 0x7c14bf45,
+0xc069f012, 0x219f032f, 0x69f00aec, 0xfb012fc0, 0xf012fd04, 0x012dc24b,
+0x325c04bf, 0x67c24bf0, 0x00000e60, 0x00000000, 0x812fa818, 0x0aec00b3,
+0x2fc229b0, 0xfc30bf00, 0xc029f00a, 0x06af0126, 0x2af0824c, 0xa301eec2,
+0xf05a1c02, 0x00a6c489, 0x1a44829f, 0x60c029b2, 0x00000e00, 0x00000000,
+0x4507081c, 0xb9442413, 0x07420152, 0x74000f09, 0x44217010, 0x401d1581,
+0xa1f0083c, 0x1b418442, 0xd01c4400, 0x01455075, 0x0444051d, 0x7040f310,
+0x00000c20, 0x00000000, 0x0323a010, 0x1206168d, 0xa3402850, 0x34108d14,
+0x4268d28a, 0x068d0220, 0x08d04a16, 0x8921a240, 0x50022402, 0x012b502a,
+0x1aa406ad, 0x40404a10, 0x00000e80, 0x00000000, 0x0025a018, 0x02460095,
+0x27422954, 0x74029508, 0x54085002, 0x009d1025, 0x09510274, 0x94023440,
+0xd0026400, 0x012d420b, 0x02e400bd, 0x60408b10, 0x00000620, 0x00000000,
+0x01652005, 0x0a440095, 0x27440930, 0x74009d00, 0x4009d102, 0x009d2224,
+0x09d0864d, 0x890826c0, 0xf04a7c03, 0x0027c039, 0x026d1b9e, 0x14d01934,
+0x00000e20, 0x00000000, 0x01258014, 0x025c009b, 0x27c00930, 0x7c009f00,
+0xc0097802, 0x509f0024, 0x09f1267c, 0x9b0067c1, 0xf00e5d03, 0x0067c039,
+0x025c009f, 0x53c019f0, 0x00000600, 0x00000000, 0x00850014, 0x083c0013,
+0x07c00134, 0x4c101101, 0xe801f000, 0x00130004, 0x80b0006d, 0x13004580,
+0x30086c06, 0x200ec002, 0x00cd023f, 0x50d00230, 0x00000420, 0x00000000,
+0x201ca814, 0x05f40771, 0x5f480500, 0xc4007404, 0x64079085, 0x0265201c,
+0x3750017c, 0x71109c48, 0x12017c23, 0x00144205, 0x0144005d, 0x50400554,
+0x00000200, 0x00000000, 0x0236a014, 0x063404d9, 0x73440c10, 0x0402c100,
+0x480cd887, 0x42c12030, 0x2c500334, 0xcc103540, 0x10032402, 0xa832640c,
+0x036420dd, 0x52400c50, 0x00000a00, 0x00000000, 0x00308005, 0xc03401e1,
+0x62440e10, 0x8401e140, 0x408e9043, 0x02250078, 0x4e1027b4, 0x65a90844,
+0x1007f442, 0x00095002, 0x00240029, 0x16400258, 0x00000200, 0x00000000,
+0x40581015, 0x06bc006b, 0x7b407e32, 0x8d01e300, 0x501cf005, 0x01e32578,
+0x1e7017ad, 0xeb416dc6, 0x3005ad01, 0x007ac01c, 0x07ac01ff, 0x56c01c30,
+0x00000040, 0x00000000, 0x9015b010, 0x027c0057, 0x27e56df0, 0x7c201f08,
+0xc02db101, 0x895b01b7, 0x9d77137c, 0xd90277c8, 0xf1817c06, 0x0004c201,
+0x005c001f, 0x41c201f0, 0x00000660, 0x00000000, 0x007f8000, 0x37e4293f,
+0x7d801f70, 0x4d295f00, 0xc03fb007, 0x01db0674, 0x9fb02fec, 0x73087ac0,
+0x30a73503, 0x007ed01f, 0x07fc09f3, 0x00c21f32, 0x00000e00, 0x00000000,
+0x01298835, 0x21fc00e7, 0x13c00eb1, 0x84017d01, 0xc04cf017, 0x8531047a,
+0xca1a9710, 0x29034948, 0x11472c08, 0x02054042, 0x34b40121, 0x545003b0,
+0x00000620, 0x00000000, 0x20190000, 0x13b4402d, 0x29410c11, 0xa414ed80,
+0x420ed010, 0x08a10038, 0x069053a4, 0x61090e40, 0x1201f400, 0x0438400c,
+0x033404e1, 0x00400e90, 0x00000400, 0x00000000, 0x01832804, 0x435680c5,
+0x01401c10, 0x24010c00, 0x440dd100, 0x00011070, 0x00900345, 0x05001300,
+0x10052401, 0x00010060, 0x00340001, 0x10400190, 0x00000c20, 0x00000000,
+0x00a58815, 0x0f74009d, 0x15401f14, 0x6c009f00, 0x440f9202, 0x00e3807c,
+0x0fb003ee, 0xc3005ed2, 0x310f7c31, 0x4034e22d, 0x037c00d1, 0x54c20d92,
+0x00000620, 0x00000000, 0x98810001, 0x217c009f, 0x26c00df8, 0x5c009f00,
+0xc80d7088, 0x009f0037, 0x0470035c, 0x5b0204c4, 0xfc037d00, 0x0005c001,
+0x007c001f, 0x07c001f1, 0x00000c00, 0x00000000, 0x002f0880, 0x03fc293b,
+0x1fc80ff0, 0xfc89f320, 0xd20ff023, 0x00ff003c, 0x19b0c3ec, 0xf3000fc0,
+0xf041cc00, 0x003ec00e, 0x03cc00f0, 0x01c00f35, 0x00000c22, 0x00000000,
+0x12442081, 0x07740113, 0xa7400df0, 0x74801100, 0xc40d1199, 0x22dd0036,
+0x31100344, 0xd1001041, 0xd001ec80, 0x08084803, 0x80c42031, 0x044003b0,
+0x00000802, 0x00000000, 0x8434a001, 0x13740011, 0x91680d50, 0x34001500,
+0x400d1002, 0xd0550034, 0x4d150356, 0x55081440, 0xd0034400, 0x0035400d,
+0x030400c5, 0x05480d10, 0x00000200, 0x00000000, 0x00002010, 0x012400c9,
+0x12400c90, 0x34000142, 0x462c5600, 0xa4090430, 0x00101304, 0x11100448,
+0xd0432720, 0x40057020, 0x40051005, 0x40400098, 0x00000080, 0x00000000,
+0x4036b000, 0x0374201b, 0x05c00f70, 0x7c01d700, 0x482f301e, 0x091e21fc,
+0x01300fbd, 0x616345d0, 0xf02d4c00, 0x22b5c22d, 0x0f4c0bd7, 0x01800d39,
+0x00000ac0, 0x00000000, 0x800fb005, 0x03fc00f7, 0x4fc00f70, 0xfc083f01,
+0xc05e9074, 0x8d3e257b, 0x0ff0774c, 0x3d00d5c0, 0xf015dc00, 0x014ec013,
+0x547c851b, 0x97c003f0, 0x00000e60, 0x00000000, 0x050f8003, 0x02dc0033,
+0x1b800bf0, 0xac007300, 0xc0029100, 0x0073400c, 0x0e3023fc, 0xe3030fc0,
+0x3002ec08, 0x000cc007, 0x02fc006b, 0x0ed00a37, 0x00000680, 0x00000000,
+0x20070801, 0x036c6013, 0x17420b34, 0x54004101, 0x400d1003, 0x00d50084,
+0x0db083e4, 0xd9030740, 0x5002ec00, 0x04346105, 0x43741091, 0x04400d30,
+0x00000c20, 0x00000000, 0x0003a011, 0x021600c9, 0x13440855, 0x04004104,
+0x40009000, 0x00412203, 0x0c511334, 0xc9010342, 0x18020484, 0x11054044,
+0x12140401, 0x44400950, 0x00000c80, 0x00000000, 0x0031a803, 0x0b6448d9,
+0x164019d1, 0x50004410, 0x200d1003, 0x24d10405, 0x0d920374, 0xd9006740,
+0x520e6403, 0x08354004, 0x027430d1, 0x0c408d51, 0x00000620, 0x00000000,
+0x0a07a802, 0x015d031b, 0x07c01975, 0xcc047240, 0xc003b000, 0x001102b1,
+0x0d70837c, 0xd34067c0, 0x300f4c00, 0x00054005, 0x061c005b, 0x0ac13170,
+0x00000e20, 0x00000000, 0x002d8007, 0x83bd0067, 0x5fc40b30, 0xfc407b02,
+0xf00f7203, 0x01bf045e, 0x2ff003ac, 0xe3102bc4, 0xf003bc00, 0x483ef807,
+0x267c00bf, 0x1fc81730, 0x00000600, 0x00000000, 0x00550802, 0x196c009f,
+0x17040934, 0x5c305301, 0xc1007014, 0x001b40a4, 0x8d30235c, 0xdf2224c9,
+0xf00a6c00, 0x4004d005, 0x024c0213, 0x08c02130, 0x00000420, 0x00000000,
+0x0034a013, 0x0b4413dd, 0xd7442900, 0x6c025100, 0x405d1083, 0x139b04ce,
+0x0d5107f4, 0xfc02a440, 0xd0024400, 0x02704005, 0x224512d1, 0x4c401450,
+0x00000200, 0x00000000, 0x0002a007, 0x0a24138d, 0x97430000, 0x5400c508,
+0x40301008, 0x07c52001, 0x08100714, 0x0d004040, 0xd04a3400, 0x8083000c,
+0x020411c5, 0x1c409cd0, 0x00000a00, 0x00000000, 0x18588004, 0x27a4098d,
+0x5b401a19, 0xa401e501, 0x401e1087, 0x81ec0069, 0x1e502734, 0xfd024840,
+0xd0068401, 0x0479401f, 0x2784ad31, 0x10400fd2, 0x00000200, 0x00000000,
+0x00001012, 0x226c08cf, 0x13c08816, 0x1c00c70c, 0xc0007000, 0x00c74015,
+0x4c31031c, 0x0f0210c0, 0xd0033c04, 0x0307e04c, 0x230c0c83, 0x48c084a0,
+0x00000040, 0x00000000, 0x00bdb802, 0x23dc88fe, 0x1fc00bb0, 0xec08fb41,
+0xc08ff003, 0x40dba636, 0x0ff003fc, 0xff023fd4, 0xf003fc00, 0x023ec00e,
+0x23fc2d7f, 0x0bc04730, 0x00000660, 0x00000000, 0x0097a815, 0x034c009f,
+0x17481970, 0x6c00d605, 0xc811f004, 0x00d71034, 0x6d701b48, 0xd70025c0,
+0xb0130c01, 0x0004d00d, 0x034c00df, 0x57c40530, 0x00000e00, 0x00000000,
+0x00399812, 0x032c00ad, 0x1f488e10, 0x8400e100, 0x840fd003, 0x00bb417e,
+0x8eb04b2c, 0xf6002b40, 0x1143ac04, 0x0038400e, 0x0385002d, 0x4b480612,
+0x00000620, 0x00000000, 0x00d90003, 0x078401ed, 0xda400ed8, 0x8601e510,
+0x4012d000, 0x41e5107a, 0x1e121784, 0xec00e949, 0x9007d408, 0x0048401e,
+0x070641ad, 0x0f401610, 0x00000400, 0x00000000, 0x00f32012, 0x032400dd,
+0x5344cc14, 0x0400c500, 0x480cd003, 0x81890336, 0x0c900364, 0xc1007340,
+0x10452400, 0x0030400c, 0x0705004d, 0x4b400410, 0x00000c20, 0x00000000,
+0x0015a017, 0x61cc007d, 0x52c027f4, 0x6d005700, 0xc005f001, 0x0177005e,
+0x15720144, 0x6f009dc8, 0xb041dc00, 0x0014c005, 0x014d005f, 0x5fc02734,
+0x00000620, 0x00000000, 0x20070012, 0x087c0a1f, 0x07c001f4, 0xfc001a00,
+0xc023f800, 0x081f0007, 0x01f0007c, 0x140407c0, 0x70087801, 0x000fc001,
+0x287c003f, 0x4bc011b0, 0x00000c00, 0x00000000, 0x04370010, 0x260c4197,
+0x74c00830, 0x14049361, 0xc8096002, 0x059b00e7, 0x4d30026c, 0x93202348,
+0x30020000, 0x5024d409, 0x020c0093, 0x43c00930, 0x00000c20, 0x00000000,
+0x00a62001, 0x4644029d, 0xe4400915, 0x54809180, 0x412910a6, 0x008141e7,
+0x79b00244, 0x95002760, 0x100a4400, 0x20204009, 0x0a6c0081, 0x07408910,
+0x00000800, 0x00000000, 0x00a4a018, 0x02450add, 0x24410d14, 0xd400810c,
+0x480b1002, 0x40d91027, 0x09120264, 0x91822760, 0x10024400, 0x002d400c,
+0xa24400b1, 0x63400910, 0x00000200, 0x00000000, 0x02202010, 0x2204088d,
+0x24400810, 0x94088102, 0x402a1022, 0x02901523, 0x08902204, 0x95192340,
+0x10821400, 0x00ad4028, 0x0a2402b1, 0x43480810, 0x00000080, 0x00000000,
+0x0586b01d, 0x584c160f, 0x84c94130, 0x5c164100, 0xc1433258, 0x001a0107,
+0x0130086c, 0x130ac340, 0x34514c0a, 0x0005c000, 0x014c8023, 0x77c00134,
+0x00000ac0, 0x00000000, 0x2137b819, 0x12fc44bf, 0x27c80bf4, 0x7c049f21,
+0xc009b012, 0x00bf052f, 0x09d01a58, 0xbf027fc2, 0xf102ec23, 0x20268809,
+0x0add209f, 0x67c00bf0, 0x00000e60, 0x00000000, 0x012fa818, 0x32cc0cb3,
+0x2f404930, 0xcc03bf00, 0xc019300e, 0x00bb222f, 0x0b30dac4, 0xdf01a4c0,
+0x7012c806, 0x4026c029, 0x52cd0093, 0x60c00b70, 0x00000e00, 0x00000000,
+0x4507081c, 0x38040e1b, 0x0742a114, 0x440a0d05, 0x48015038, 0x14110287,
+0x01b0086c, 0x13008444, 0x11086806, 0x01474011, 0x18440121, 0x71000170,
+0x00000c20, 0x00000000, 0x0323a010, 0x02240081, 0x23480811, 0x20048d00,
+0x01289002, 0x00890123, 0x08109204, 0x8d01a144, 0x500e1082, 0x042f4048,
+0xc20494a1, 0x404009d0, 0x00000e80, 0x00000000, 0x0225a818, 0x02655091,
+0x67600914, 0x64009d00, 0x40091202, 0x00910027, 0x09900264, 0x91012450,
+0x10026400, 0x802f4009, 0x024400b1, 0x61400950, 0x00000620, 0x00000000,
+0x00e78005, 0x02640191, 0x674b0930, 0x6d009f08, 0xc0093002, 0x009b4067,
+0x0830024c, 0x9f0065c0, 0x720a1c00, 0x0023c009, 0x264c4193, 0x14c04878,
+0x00000e20, 0x00000000, 0x04258014, 0x025c149f, 0x27c14df0, 0x1c409f00,
+0xc50df602, 0x109f0163, 0x89f0022c, 0x852077c2, 0xf00e7c00, 0x0027c009,
+0x067c049f, 0x53c00970, 0x00000600, 0x00000000, 0x00010014, 0x404c2217,
+0x07c021f4, 0x4c0c0f02, 0xc401f040, 0x001f0004, 0x4171004c, 0x1b0084c0,
+0x70807c00, 0x480fc001, 0x804c8033, 0x53c02130, 0x00000420, 0x00000000,
+0x089ca014, 0x01c4037d, 0x5dc00510, 0xd4007d10, 0x4005d019, 0xa171041d,
+0x1711056c, 0x51005400, 0x1005f400, 0x10174205, 0x05d40051, 0x53400510,
+0x00000200, 0x00000000, 0x02f2a014, 0x0744099d, 0x63022cd4, 0x0400cd00,
+0x502cd003, 0x83d51060, 0x38508204, 0xc8007000, 0x50253440, 0x0031400c,
+0x4f1400d9, 0x53400c54, 0x00000a00, 0x00000000, 0x18388005, 0x0984006d,
+0x39400e10, 0x94816d02, 0x409cd801, 0x0a711039, 0x2b100ba4, 0xe100d060,
+0x1001b40c, 0x100b480e, 0x47940029, 0x17400a10, 0x00000200, 0x00000000,
+0x00781015, 0x878c018f, 0x7b4016f0, 0x8c206f10, 0xc71ef007, 0x05ef007c,
+0x1a7006cc, 0xeb0078c0, 0x70053c15, 0x007dc01e, 0x04dd01eb, 0x57c01a70,
+0x00000040, 0x00000000, 0x0035b010, 0x1b7d127f, 0x574145f5, 0x7c105f00,
+0xc045d001, 0x004f0016, 0x0cd0837c, 0xdf0197d4, 0xf0036c06, 0x100fc00d,
+0x006c0037, 0x43c009f0, 0x00000660, 0x00000000, 0x004fa800, 0x2fde01b3,
+0x7ec4cfb1, 0xdc017f00, 0xc01f3007, 0x0163006d, 0x1af006e8, 0xff00fcc0,
+0x3005dc01, 0x427f401f, 0x07cc8df3, 0x00c01f30, 0x00000e00, 0x00000000,
+0x028d8015, 0x3384006b, 0x38400eb0, 0x94826900, 0xd10eb043, 0x006b0028,
+0x8af00394, 0xeb191844, 0xb0018400, 0x470b600e, 0x03c55c31, 0x56c00a30,
+0x00000620, 0x00000000, 0x00090000, 0x43340021, 0x38400412, 0x34082d00,
+0x408e9023, 0x0821002e, 0x0ad00284, 0xe50c3b41, 0x10019400, 0x2039400e,
+0x41840ce9, 0x00400b90, 0x00000400, 0x00000000, 0x00c30804, 0x0f240001,
+0x10404494, 0x34001980, 0x4234980b, 0x05090080, 0x1c428314, 0xc000d240,
+0x900b0403, 0x2483400c, 0x05041219, 0x12401818, 0x00000c20, 0x00000000,
+0x44358015, 0x0f580091, 0x38803110, 0x7c001f04, 0xc4bfb007, 0x45f302a3,
+0x09d00344, 0xf502f7c8, 0x34091c06, 0x00f5c005, 0x034c03db, 0x54c04cb4,
+0x00000620, 0x00000000, 0x04270001, 0x035c280f, 0x15c019f0, 0x1c021b00,
+0xc828f0c2, 0x001f0037, 0x09f0031c, 0xdf1005d0, 0xf0037c10, 0x080fc007,
+0x037c0037, 0x07c009f0, 0x00000c00, 0x00000000, 0x001f0080, 0x42ec00bf,
+0x7ed01330, 0xcc003300, 0xc81d3103, 0x03f2103c, 0x1b318bec, 0xe3006fc0,
+0x344d4e80, 0x003fc207, 0x058c00f3, 0x00c00b30, 0x00000c22, 0x00000000,
+0x00c62081, 0x460c111d, 0x1444003b, 0x6c031b04, 0x4001b00f, 0x010f0014,
+0x45b00744, 0xdb400700, 0xb40b5480, 0x000e4027, 0x85440031, 0x07c009b0,
+0x00000802, 0x00000000, 0x12348001, 0x0744219d, 0x34404910, 0x44411521,
+0x40651047, 0x00550024, 0x49500364, 0xd1023300, 0x50086480, 0x08314425,
+0x1b4400d5, 0x04400d10, 0x00000200, 0x00000000, 0x00202010, 0x0306000d,
+0x12401892, 0x24000d00, 0x40001c03, 0x00051024, 0x08910204, 0xc1000340,
+0xd0023400, 0x60024004, 0x01050001, 0x43400890, 0x00000080, 0x00000000,
+0x0016a000, 0x03cc00ad, 0x34c00114, 0x4c002540, 0xd0051003, 0x00151024,
+0x0970036c, 0xe10033c0, 0x74006400, 0x0033c205, 0x014c00d7, 0x00c00930,
+0x00000ac0, 0x00000000, 0x000f9805, 0x03e0003f, 0x1dd20350, 0xfc003b00,
+0xc003e103, 0x003f000b, 0x0bf802fc, 0xff101fc0, 0xb102dc00, 0x000fc007,
+0x81fc803f, 0x15c00af0, 0x00000e60, 0x00000000, 0x048fa803, 0x30ec00b2,
+0x3dc08370, 0x7c601300, 0xc00ef053, 0x04df083c, 0x43600bfc, 0x2c301fc0,
+0x74135e44, 0x013cc02f, 0x00cc14f3, 0x0e820f30, 0x00000e00, 0x00000000,
+0x00971005, 0x084c029b, 0x36484118, 0xf4001100, 0x400dd00b, 0x02f12c34,
+0x6d110bc5, 0x1d141749, 0x1023dc02, 0x20bd406f, 0x200102f3, 0x0c410ff0,
+0x00000c20, 0x00000000, 0x9103a011, 0x08240215, 0x22480510, 0x14544500,
+0x481d9003, 0x08c52075, 0x20501b04, 0x01311340, 0x10032002, 0x0232402c,
+0x503400c5, 0x4f400c50, 0x00000e80, 0x00000000, 0x81958007, 0x04540015,
+0x36400554, 0x74001500, 0x401dd003, 0x00d12075, 0x0d110344, 0x99005740,
+0x50835404, 0x0035400d, 0x107040d1, 0x0c400d50, 0x00000620, 0x00000000,
+0x4027a800, 0x406cc095, 0xb4d00911, 0x58a41444, 0xc00d8003, 0x00df0035,
+0x09710368, 0x9a0917c4, 0x71034c40, 0x4034800d, 0x187d00d7, 0x0ac00d50,
+0x00000e22, 0x00000000, 0x103d8087, 0x01cc09bb, 0x3dc40bb0, 0xf8141b01,
+0xd00fd803, 0x10ff003e, 0x4ff0037c, 0xef003f84, 0xb003bc21, 0x0037c80f,
+0x808c00f7, 0x3fc00ff0, 0x00000600, 0x00000000, 0x00210802, 0x085c401b,
+0x37c089f1, 0x7c021300, 0xc90d3043, 0x00db4036, 0x09f1033c, 0x1f0097c0,
+0x32137c40, 0x0036c80c, 0x495c20d3, 0x0bc80d34, 0x00000420, 0x00000000,
+0x0134a013, 0x03c411a1, 0x64400ed0, 0xc4027320, 0x420c1017, 0x03ef2030,
+0x0d1003d4, 0xfd003740, 0x104bc40a, 0x00ba420f, 0x014400f1, 0x6f408f90,
+0x00000200, 0x00000000, 0x0002a007, 0x01562088, 0x77405090, 0x14030502,
+0x40bcd50f, 0x20c10032, 0x04900314, 0x4921b340, 0x92072700, 0x24f3420c,
+0x2d0000d1, 0x1f600d90, 0x00000a00, 0x00000000, 0x02488804, 0x058441a1,
+0x7a4012d1, 0x940d2d42, 0x401e1087, 0x19e9287a, 0x1e900794, 0x6d005b40,
+0x9017c541, 0x057b429e, 0x058429e9, 0x37441e91, 0x00000200, 0x00000000,
+0x00240012, 0x011c000b, 0x27c005d0, 0x1c1d4700, 0xc00cf017, 0x2dd32036,
+0x14f0233c, 0x4f0373e0, 0xb4172c00, 0x0073c00c, 0x050d05d2, 0x4bc00c20,
+0x00000040, 0x00000000, 0x002da802, 0x01fc0027, 0xadd007f0, 0x0c307308,
+0xc90f3863, 0xc8f7023d, 0x0f300bcc, 0xfe0017c0, 0x70638c08, 0x063cc00c,
+0x016c28d7, 0x0bc10f70, 0x00000660, 0x00000000, 0x1017a011, 0x017c009b,
+0xb64081f0, 0x5c920f00, 0xec5c0103, 0x93df01b5, 0x1df00b60, 0xbf2035c0,
+0x34cb1000, 0x2136c0ad, 0x006c04d9, 0x57402df2, 0x00000e00, 0x00000000,
+0x801d8812, 0x05bc02a0, 0x30404a10, 0xa8a42b00, 0x0cce3033, 0x42ec9538,
+0x0e701384, 0xed813942, 0x50139601, 0x0238408f, 0x00840ec1, 0xcf414ed0,
+0x00000624, 0x00000000, 0x00790083, 0x25240121, 0x6b501250, 0x04256120,
+0x421e1017, 0xa5c90379, 0x1c90a784, 0x3d077a40, 0x1407c403, 0x4979405e,
+0x069481e1, 0x07481ed0, 0x00000400, 0x00000000, 0xd2372812, 0x055440c1,
+0x85413c10, 0x0406c90c, 0x41ac9203, 0x00c904f0, 0x2c500314, 0xdd04b340,
+0x50031410, 0x0031400c, 0x173400c1, 0x4b400cd0, 0x00000c20, 0x00000000,
+0x00dda817, 0x0de05373, 0xd7c07770, 0xc5075101, 0x44231001, 0x005900cd,
+0x0790014c, 0x7f00ce42, 0x31019403, 0x2015c806, 0x11dc005b, 0x5fc004f0,
+0x00000620, 0x00000000, 0x01070012, 0x247c0117, 0x04d00174, 0x3e001f00,
+0xe0213080, 0x001f0207, 0x01f1804c, 0x1f8005c1, 0xb0007c80, 0x20845021,
+0x00488017, 0x4bc001f0, 0x00000c00, 0x00000000, 0x00270810, 0x027c059b,
+0x34c00930, 0x5000d100, 0x4011b002, 0x209d0007, 0x09f0027e, 0x9d300744,
+0x90225405, 0x1025c099, 0x224c0091, 0x40c009f0, 0x00000c20, 0x00000000,
+0x00260005, 0x82740091, 0x24c0a910, 0x7c009100, 0x44015102, 0x00910002,
+0x09d20274, 0x9d080744, 0x100a4f00, 0x01a6c009, 0x46440091, 0x07c02970,
+0x00000800, 0x00000000, 0x4024a01c, 0x02540091, 0x24400c14, 0x44008540,
+0x4061901a, 0x00990007, 0x09d00274, 0x99002740, 0x50025440, 0x00224009,
+0x02448085, 0x604009d1, 0x00000200, 0x00000000, 0x00202010, 0x1a240081,
+0x20600810, 0x34148502, 0x428810a2, 0x02c110a7, 0x88d12234, 0x8d022340,
+0x54227408, 0x02224008, 0x22060285, 0x43508c50, 0x00000080, 0x00000000,
+0x0706b019, 0x105e1413, 0x04c0a430, 0x4c041724, 0x4961b058, 0x541f1507,
+0x61f05874, 0x1d0d87e1, 0xf0595456, 0x0503c1c5, 0x584d1417, 0x74d161f0,
+0x00000ac0, 0x00000000, 0x013f9019, 0x1afc20bf, 0x66106bf0, 0x5c909b00,
+0xc84b7012, 0x209b112e, 0x4bf0127c, 0xaf012fc0, 0xb0124c04, 0x4927c049,
+0x12fc449b, 0x67c049f0, 0x00000e64, 0x00000000, 0x29afa818, 0x627654b3,
+0x2cc14af0, 0xbc02b300, 0xc01bf012, 0x06bf0067, 0x29f01a4c, 0xa7116fc0,
+0x30128c07, 0x052cc02a, 0x12ec0c93, 0x60c04af0, 0x00000e00, 0x00000000,
+0x01870898, 0x10740011, 0x00c32110, 0x74045144, 0x4051d014, 0x041d0503,
+0x81d0103c, 0x110d8740, 0x10744482, 0x04844071, 0x5054020b, 0x72c001f0,
+0x00000c20, 0x00000000, 0x0323a010, 0x123400c1, 0x20644851, 0x34048102,
+0x4328d04a, 0x068d00a3, 0x48d21a14, 0x95232500, 0x10020446, 0x68234029,
+0x1a052881, 0x486028d0, 0x00000e80, 0x00000000, 0x0025a018, 0x02748091,
+0xa0420d10, 0x70019100, 0x4001d000, 0x009d1027, 0x09d00274, 0x91002740,
+0x12004402, 0x00234009, 0x02540091, 0x62400950, 0x00000620, 0x00000000,
+0x40a70005, 0x4a741193, 0x645019f0, 0x74039320, 0x45b1d000, 0x009f06a7,
+0x09f0024c, 0x850063c0, 0x34004500, 0x0025b009, 0x326c0091, 0x14f009d0,
+0x00000e20, 0x00000000, 0x00250010, 0x027c039f, 0xa5c049f0, 0x7c009f00,
+0xc411f000, 0x009f0027, 0x09f0026c, 0x9f026740, 0xf0407810, 0x0024e009,
+0x066c008f, 0x59e009f0, 0x00000600, 0x00000000, 0x00850014, 0x085c0213,
+0x06e04170, 0x4c001300, 0x40613010, 0x20130085, 0x01f0004c, 0x130004c0,
+0x30002408, 0x0006c401, 0x084d0017, 0x50c01070, 0x00000420, 0x00000000,
+0x40540814, 0x01748051, 0x16e037b0, 0xc4027108, 0x40333100, 0x82610017,
+0x0510014c, 0x7d405c40, 0x1004d480, 0x001c45b6, 0x01c40055, 0x50403750,
+0x00000200, 0x00000000, 0x0236a014, 0x03540081, 0x30461910, 0x1606c1a0,
+0x603c1403, 0x04c90031, 0x0c980304, 0xc1027040, 0x112f2602, 0x0031600c,
+0x030600c1, 0x52401c18, 0x00000a00, 0x00000000, 0x80288004, 0x03f400a1,
+0x28410791, 0x94013900, 0x40ae988f, 0x00a9007b, 0xde100784, 0x6d083c40,
+0x90139540, 0x2229400e, 0x07c404e1, 0x16414658, 0x00000200, 0x00000000,
+0x007c1034, 0x179c01a1, 0x78501670, 0x9e41e342, 0xc89e3017, 0x254b4079,
+0x1ff0178c, 0xe30078c0, 0x340fac81, 0x0173c00e, 0x878c8be7, 0x56d01670,
+0x00000040, 0x00000000, 0x0025b010, 0x073c209f, 0xa7c009f1, 0x6f000701,
+0xc26d706b, 0x081700b7, 0x2df0437c, 0x570033e0, 0x70c35e86, 0x0006c01f,
+0x803c04df, 0x41c085f0, 0x00000660, 0x00000000, 0x007fa002, 0x47f801bf,
+0x77d01f38, 0xfc01ff00, 0xc29df007, 0x0df784ff, 0xbdf0477c, 0xf7017dc0,
+0x71076c03, 0x1276c01f, 0x07cc01f6, 0x00c21b30, 0x00000e00, 0x00000000,
+0x00298815, 0x039c00af, 0x68444f18, 0x9c14a900, 0x001e7023, 0x01a1023f,
+0x1cd007b4, 0x6100f040, 0x1017ac82, 0x0067489e, 0x474405c3, 0x56c00210,
+0x00000620, 0x00000000, 0x02390000, 0x23b400ad, 0x38400e10, 0xa440ed20,
+0x41ce9003, 0x2069043b, 0x0e9083a4, 0xa10b3841, 0x12132408, 0x0038400e,
+0x338404ed, 0x00400210, 0x00000400, 0x00000000, 0x00632806, 0x07541285,
+0xe0458c10, 0x14038900, 0x400c5103, 0x00090032, 0x0cd00364, 0x01007440,
+0x14033400, 0x8003400c, 0x000400c1, 0x12000010, 0x00000c20, 0x00000000,
+0x0075a815, 0x1bfc009d, 0xa4501930, 0x2c001f82, 0xc02d9a83, 0x803840bf,
+0x3f9203ec, 0x4126b448, 0x32032c98, 0x002ec00e, 0x074d00ff, 0xd4500b30,
+0x00000620, 0x00000000, 0x02270001, 0x135c019f, 0x34c00df4, 0x5c021b22,
+0xc44df083, 0x02172137, 0x0cf0037c, 0x5f0097d0, 0xf0034c00, 0x00b5c02d,
+0x037c00df, 0x04e020f0, 0x00000c00, 0x00000000, 0x007b0880, 0x036c40ab,
+0x2cc00eb0, 0xfe103302, 0xc00f7007, 0x013d003e, 0x0f3103d4, 0x72207c41,
+0x1113f420, 0x00cc4215, 0x03d400f7, 0x000089f0, 0x00000c22, 0x00000000,
+0x00262081, 0x83440095, 0x35402910, 0x74721110, 0x400cb0a7, 0x120d0035,
+0x0d10036c, 0x5b08d6c0, 0x100f5400, 0x21b44185, 0x004440d7, 0x044201d1,
+0x00000800, 0x00000000, 0x0224a001, 0x03640191, 0x20400d90, 0x76081140,
+0x401d1043, 0x28192034, 0x0d108364, 0xdd022540, 0x508b6600, 0x00214c05,
+0x8344e0c1, 0x054025d0, 0x00000200, 0x00000000, 0x00300010, 0x03040085,
+0x31400410, 0x76000141, 0x405d16a3, 0x000d2031, 0x4c141324, 0x5d130340,
+0x500b1620, 0x11316105, 0x0b1410c1, 0x415004d0, 0x00000080, 0x00000000,
+0x00263000, 0x036c0091, 0x6c4805b0, 0x740a1301, 0xc41d180b, 0x471f003e,
+0x1e1087ec, 0xaf0861e2, 0x741f6c80, 0x0345d051, 0x0f5c0fe7, 0x01e005f2,
+0x00000ac0, 0x00000000, 0x203fb805, 0x03f000f7, 0x3fc00ff0, 0xfc05380a,
+0xc08ff007, 0x9d9f003f, 0x9fc1a3ec, 0x3b01c6c1, 0xb10ffc00, 0x4b7ec001,
+0x346c05d6, 0x16c407f0, 0x00000e60, 0x00000000, 0x020fa003, 0x03bc003b,
+0x2cc083f0, 0xfc003700, 0xc647f803, 0x00fb003f, 0xcf300bcd, 0xb7000ed2,
+0xf0008e00, 0x000fc00b, 0x00ccc033, 0x0fc06f30, 0x00000e00, 0x00000000,
+0x80071801, 0x53740811, 0x90404570, 0x74801300, 0x0025d083, 0x62d103b3,
+0xed900b44, 0x81002c40, 0xd0285400, 0x30344009, 0x81c420d1, 0x0f402d30,
+0x00000c20, 0x00000000, 0x2023a011, 0x83140001, 0x224800d0, 0x34000902,
+0x40245082, 0x22090433, 0x4c921804, 0x85202660, 0x50810600, 0x20354008,
+0x02248005, 0x4f40cc90, 0x00000e80, 0x00000000, 0x08b5a003, 0x03740211,
+0x16402450, 0x74061900, 0x4025d003, 0x00191437, 0x8d900144, 0xd1082460,
+0xd0015481, 0x0034400d, 0x476500d5, 0x1f421d10, 0x00000620, 0x00000000,
+0x40c7a886, 0x037c0011, 0xe6d029f0, 0x7c021b02, 0xc021f001, 0x10db8887,
+0x0d300b4d, 0x970246c8, 0xf0094401, 0x0435801d, 0x056c00d7, 0x23e009a4,
+0x00000e22, 0x00000000, 0x81498007, 0x03fc0077, 0x1dc00bf0, 0xfc003340,
+0x8007f003, 0x00e7400f, 0x0f6003bc, 0xef002fc0, 0xf001fc00, 0x083dc02f,
+0x01d800eb, 0x0fc20bf0, 0x00000602, 0x00000000, 0x01250802, 0x027c0a5f,
+0x23c08d30, 0x7c001700, 0xc025f003, 0x42570091, 0x0c34085c, 0x9f0425c0,
+0x308b6c02, 0x0136c009, 0x0b7c80df, 0x2bc00934, 0x00000420, 0x00000000,
+0x0034a013, 0x02764057, 0x17400d12, 0x74001502, 0xc727d007, 0x00510456,
+0x0d104144, 0xdf0020d0, 0x1483cc0b, 0x0130405c, 0x2f7402dd, 0x4f000914,
+0x00000200, 0x00000000, 0x00922003, 0x2724000d, 0xa3420092, 0x34100408,
+0x4054d003, 0xa0c1c031, 0x00101717, 0x8d028241, 0x10002408, 0x08c34018,
+0x27740e0c, 0x1f420858, 0x00000a00, 0x00000000, 0x004a0800, 0x07f40125,
+0x6b401690, 0xb4012504, 0x4016d007, 0x21c18178, 0x94100704, 0xad006842,
+0x1000e481, 0x1059441a, 0x27b4a9e9, 0x3f403a50, 0x00000200, 0x00000000,
+0x02121016, 0x0334080f, 0xa3c00834, 0x34880700, 0x6404d0c2, 0x00871031,
+0x20300a1c, 0xcf0021d0, 0x34292c02, 0x0013c00c, 0x017c080f, 0x4bc00870,
+0x00000040, 0x00000000, 0x101d8802, 0x23fc2837, 0x3fc80f70, 0xfc203f00,
+0xc006f003, 0x00bf013f, 0x35f0237c, 0xf7022fc0, 0xf011dc40, 0x001ec00e,
+0x01fc08ff, 0x1bc00bb0, 0x00000660, 0x00000000, 0x0037a010, 0x075c021f,
+0x27c00130, 0x7c809720, 0xc001b885, 0x00d30027, 0x2935036c, 0xd70110c0,
+0x3405cc00, 0x0017c01d, 0xcb4c00df, 0x47c40d34, 0x00000e00, 0x00000000,
+0x00299912, 0x039c10ed, 0x0f480210, 0xf400a100, 0x40461003, 0x00e11023,
+0x0c100384, 0xf1043850, 0x1019ec00, 0x001b400e, 0x038400ed, 0x4f400ef0,
+0x00000624, 0x00000000, 0x00790004, 0x06b483ed, 0x6b403e58, 0xb401ad00,
+0x40969007, 0x01c1007b, 0x1a900624, 0x64007c50, 0x12078601, 0x005b400e,
+0x070400ed, 0x07401e90, 0x00000402, 0x00000000, 0x00330012, 0x021450cd,
+0x33400c50, 0x3400c901, 0x448c1007, 0x08d100f3, 0x2c820304, 0x41003040,
+0x10812407, 0x0053400c, 0x03041acd, 0x4b400cd4, 0x00000c20, 0x00000000,
+0x009f8817, 0x155c015f, 0x1fc03756, 0xfc077f00, 0xc036b16d, 0x01514617,
+0x04b0016c, 0x77011cc0, 0x3049cc05, 0x00dfc115, 0xc98c037f, 0x5fc005b8,
+0x00000620, 0x00000000, 0x24058012, 0x005c020f, 0x87c901b0, 0x7c831700,
+0xc011f000, 0x001f2007, 0x0170003d, 0x1f0007c9, 0xf2847c00, 0x0247c001,
+0x407c000f, 0x4bc021f0, 0x00000c00, 0x00000000, 0x00e50810, 0x065c89d3,
+0x20c018f0, 0x7c019300, 0xe049f002, 0x00930260, 0x5935024c, 0x8b0021d0,
+0xf0024c04, 0x00e44008, 0x0a4c429f, 0x40c018b8, 0x00000c20, 0x00000000,
+0x00262001, 0x266c1391, 0x24400970, 0x74329501, 0xc009d006, 0x00910026,
+0x19500a54, 0x91002540, 0xd0027c72, 0x00246009, 0x0244009d, 0x06c42912,
+0x00000800, 0x00000000, 0x0020a01c, 0x02440099, 0x244089c0, 0x74089180,
+0x4009d006, 0x00b10025, 0x0b1006c4, 0x99002748, 0xd0024400, 0x20274009,
+0x0244029d, 0x60446990, 0x00000200, 0x00000000, 0x42302814, 0x22254089,
+0x205088d0, 0x342085c2, 0x4149d022, 0x16a1472b, 0xce105394, 0x89002341,
+0xd00a1408, 0x20a04008, 0x0a45028d, 0x42408804, 0x00000080, 0x00000000,
+0x0586b01d, 0x0814141b, 0x84c161f0, 0x7c001305, 0x4041f108, 0x04130185,
+0x6322104c, 0x1b2817c0, 0xf0d04416, 0x2805c001, 0x004c800f, 0x74c161b5,
+0x00000ac0, 0x00000000, 0x112fa919, 0x12dc0097, 0x2fc04b70, 0xfc00bf09,
+0xc00bf012, 0x809f0126, 0x49f0527c, 0xb700adc4, 0xf002fc24, 0x002ec02b,
+0x0afc22bf, 0x67c04bf4, 0x00000e64, 0x00000000, 0x062fa818, 0x227c00b7,
+0xa7c809f0, 0xfc00b305, 0xc00af00a, 0x18970227, 0x4b3052cc, 0xbb002ce1,
+0x7012e810, 0x0820c34b, 0x12cc00af, 0x64c06f30, 0x00000e00, 0x00000000,
+0x8087081c, 0x00740a11, 0x8741e1d0, 0x74001b01, 0x40a5d010, 0x82050387,
+0x21301854, 0x1b028464, 0x10086c00, 0x10044021, 0x08044017, 0x72c00110,
+0x00000c22, 0x00000000, 0x01210012, 0x1236018d, 0x234008d0, 0x34008981,
+0x4008d002, 0x848d0023, 0x0814c214, 0x81002061, 0x508a0410, 0x0d214008,
+0x0a24148d, 0x48422810, 0x00000e80, 0x00000000, 0x00e52818, 0x02760199,
+0x270229d0, 0x74019901, 0x4009d022, 0x008d4127, 0x09110254, 0xd8002442,
+0x10426402, 0x0d255a09, 0x02240095, 0x62400d10, 0x00000620, 0x00000000,
+0x0027a005, 0x2274039d, 0xa7c019f0, 0x74019b01, 0xc029f01a, 0x1b9d0027,
+0x08326e5c, 0x9304a010, 0x700a4c23, 0x0065c009, 0x1269009f, 0x14c00934,
+0x00000e20, 0x00000000, 0x00258012, 0x037c0097, 0x37c05df1, 0x7c009f00,
+0xc099f002, 0x00970037, 0x0970027c, 0x8f0027c0, 0xf0963c04, 0x0076c039,
+0x025c109f, 0x5bc208f8, 0x00000600, 0x00000000, 0x0e010010, 0x207c0417,
+0x01c001f0, 0x7c001308, 0xc441f008, 0x20130000, 0x1130004c, 0x130006c8,
+0x30a04c00, 0x2004c001, 0x084c0003, 0x50c01130, 0x00000420, 0x00000000,
+0x001ca014, 0x0174127d, 0x154815d0, 0x74117502, 0x60079015, 0x00510414,
+0x271001d4, 0x77001d40, 0x10016c22, 0x04140314, 0x15ec0275, 0x51402710,
+0x00000200, 0x00000000, 0x0032a014, 0x0724018d, 0xb14004d0, 0x3411c900,
+0x482cd203, 0x00c14050, 0x18140746, 0x85207150, 0x10070485, 0x2030401c,
+0x07150241, 0x50480c10, 0x00000a00, 0x00000000, 0x00388001, 0x03b480ad,
+0x184436d0, 0xb440ed04, 0x401e9203, 0x0ce10010, 0x68110994, 0x65041940,
+0x1a03a402, 0x004c140e, 0x83b51065, 0x15400410, 0x00000200, 0x00000000,
+0x00781011, 0x07bc81af, 0x5dc114f2, 0xbc01eb42, 0x401ed207, 0x21e30058,
+0x7e34040c, 0xb7007140, 0x3807cc49, 0x2268801e, 0x079d11e3, 0x54c01234,
+0x00000040, 0x00000000, 0x0035b810, 0x4a7c409f, 0x17c065f0, 0x7800d711,
+0xd009b003, 0x14df0187, 0x0df0007c, 0x9f0035c0, 0xf4037c84, 0x0007c00c,
+0x036d04df, 0x43c001f0, 0x00000660, 0x00000000, 0x027da800, 0x27cc09b3,
+0x6fc01730, 0x8c09e324, 0xc61f3027, 0x01f300dd, 0x1f3007cc, 0xf7007ec0,
+0x30078c01, 0x007dc0de, 0x12cc04ff, 0x08c41f30, 0x00000e00, 0x00000000,
+0x041d1815, 0x03ac08a3, 0x0f4006b0, 0x84406704, 0x41063003, 0x28f1001a,
+0x0f1800ac, 0xfb081941, 0x10139400, 0x001840ce, 0x828404bd, 0x554007b0,
+0x00000620, 0x00000000, 0x10290000, 0x03843029, 0x0b400218, 0xc480f100,
+0x402e1103, 0x00e9421b, 0x0e1400a4, 0xe5003340, 0x1203e410, 0x002960ce,
+0x021442ed, 0x21408a90, 0x00000400, 0x00000000, 0x00412004, 0x03240109,
+0xc3448091, 0x0600c504, 0x4010103b, 0x00c91002, 0x1c022424, 0x89003140,
+0x90032420, 0x2491400c, 0x0214008d, 0x19400010, 0x00000c20, 0x00000000,
+0x00752015, 0x024c0191, 0xbfc0053a, 0x4d01d300, 0xc41d300f, 0x00f90015,
+0x17120364, 0x550032c0, 0x34a36c01, 0x0035c00d, 0x025c035f, 0x75c00190,
+0x00000620, 0x00000000, 0x00b70001, 0x027c0697, 0x87c001f0, 0x7c01d700,
+0xc00d7083, 0x00c70011, 0x05f0837c, 0x5f0107c0, 0x70035c02, 0x10564219,
+0x856c81dd, 0x074029f0, 0x00000c00, 0x00000000, 0x801d0084, 0x23fc03bf,
+0xdfc05730, 0xfc00ff08, 0xc00df803, 0x20f34017, 0x5e40000c, 0x63009dd0,
+0xe00bcc00, 0x082dc01f, 0x078c00a3, 0x04d00380, 0x00000c20, 0x00000000,
+0x04960085, 0x8264859d, 0x85c01140, 0x5e08dd00, 0x44097002, 0x00d90006,
+0x0df00444, 0x1b0447c0, 0xd0074401, 0x1a164419, 0x0444419b, 0x24402054,
+0x00000800, 0x00000000, 0x0034a001, 0x0224009d, 0x87400500, 0x6400dd28,
+0x400dd007, 0x00d90107, 0x05500e45, 0xd1002741, 0xd0024401, 0x0033484d,
+0x1a6403d1, 0x04408158, 0x00000200, 0x00000000, 0x88102810, 0x0224408d,
+0x00420014, 0x14804900, 0x40045003, 0x00c90003, 0x04140204, 0xc9000250,
+0xd0020400, 0x2002400c, 0x01258089, 0x40400854, 0x00000080, 0x00000000,
+0x0006b000, 0x032c00dd, 0x07c00131, 0x74009d00, 0xc00dd003, 0x00f31007,
+0x0552004c, 0xf38005c8, 0xf0024c00, 0x2025c00d, 0x036c80f3, 0x04c00174,
+0x00000ac0, 0x00000000, 0x000f8805, 0x03ec00af, 0x0dc403f0, 0xfc00bf10,
+0xc0037003, 0x00f3100e, 0x0ff880fe, 0xbf000dc0, 0xf002fc00, 0x000fc00f,
+0x00dc00bf, 0x17c80b70, 0x00000e60, 0x00000000, 0x023f8003, 0x03ac00ff,
+0x34c40fb0, 0xfc08f300, 0xc00c300b, 0x42eb003c, 0x0f700b7c, 0xf3003ed0,
+0xf0237000, 0x00bfc02f, 0x73cc00fb, 0x0cd003b0, 0x00000e00, 0x00000000,
+0x00071801, 0x004c201d, 0x06c80112, 0x34001b01, 0x44415000, 0x00150105,
+0x01700074, 0x1520044c, 0xd0007484, 0x01074201, 0x0bc40011, 0x04420110,
+0x00000c60, 0x00000000, 0x1133a011, 0x030414cd, 0x30420410, 0x3404c504,
+0x430c1013, 0x04410411, 0x04509334, 0x41083040, 0xd0012410, 0x00334044,
+0x13241441, 0x444005d0, 0x00000e80, 0x00000000, 0x00858007, 0x8064201d,
+0x04428910, 0x74241541, 0x42215000, 0x00958025, 0x09d01874, 0x95080442,
+0xd0027400, 0x00034049, 0x03250498, 0x0c428154, 0x00000600, 0x00000000,
+0x00afa882, 0x21cc287f, 0x5c501f34, 0xfcd1f500, 0xc02b3021, 0x88f3402d,
+0x0a720ffc, 0xb30a1cc0, 0xf002ec00, 0x24bf401f, 0x834c01fb, 0x08e001f0,
+0x00000e22, 0x00000000, 0x001d8007, 0x869d01ae, 0x27c802f0, 0xb8003b00,
+0xc006c006, 0x0137081f, 0x077284fc, 0x7f106fc0, 0xf001fc00, 0x420f4803,
+0x03dc2037, 0x1fc001a0, 0x00000600, 0x00000000, 0x00a50802, 0x314c0053,
+0x154005f0, 0x4c0ad300, 0xc0093001, 0x00530004, 0x41f0034c, 0x1f0016c0,
+0x30805c00, 0x01b6c005, 0x035c185f, 0x09c481f1, 0x00000420, 0x00000000,
+0x0014a013, 0x0e440191, 0x20600911, 0x6c001b00, 0x40051582, 0x609b0175,
+0x2dc0806d, 0xdd202440, 0xf00b7405, 0x00044209, 0x07c5018d, 0x4c42b620,
+0x00000200, 0x00000000, 0x40122003, 0x8e140085, 0x21440851, 0x24810900,
+0x40045802, 0x80890036, 0x1cd00024, 0xcd002640, 0x104b1401, 0x00006208,
+0x67040389, 0x0d403050, 0x00000800, 0x00000000, 0x0a620804, 0x05840141,
+0x58445412, 0xa609c902, 0x405a1105, 0x2169104a, 0x12d007a4, 0x2d825841,
+0x9014b401, 0x00784016, 0x0784896d, 0x10401214, 0x00000820, 0x00000000,
+0x00121012, 0x021c1087, 0x61500050, 0x2c080301, 0xc4143006, 0x08094016,
+0x45f2140c, 0x4d0062c0, 0x32955c00, 0x0700d051, 0x175c091f, 0x49c00470,
+0x00000840, 0x00000000, 0x002da002, 0x01fc007f, 0x1fc04f70, 0x7428df20,
+0xc00bf011, 0x00df122d, 0x0bf023cc, 0xbf021dc0, 0xf0027c00, 0x023de08f,
+0x23fc01ff, 0x0bc007f0, 0x00000620, 0x00000000, 0x0047a014, 0x004d8117,
+0x06c01934, 0x4c001340, 0xd001b000, 0x209f0024, 0x0932007c, 0x9f0007c0,
+0xd2026d80, 0x00044a19, 0x4b49019f, 0x43404130, 0x00000e00, 0x00000000,
+0x20399932, 0x030400f1, 0x30400610, 0x8400f108, 0x400c1003, 0xc061001c,
+0x061003f0, 0x41003f40, 0xd0018400, 0x00384606, 0x1b84006f, 0x4b40e218,
+0x00000664, 0x00000000, 0x40090000, 0x04a40125, 0x48401010, 0xa4812900,
+0x40121c04, 0x0125004a, 0x12d00496, 0x25104b40, 0xd2848401, 0x20484012,
+0x1704410d, 0x13481650, 0x00000400, 0x00000000, 0x08732036, 0x0b2490c1,
+0xb0420c12, 0x2400d924, 0x401d9203, 0x40c50072, 0x1cd88334, 0xd1003340,
+0xd0070401, 0x0030400c, 0x030420c5, 0x5b400c50, 0x00000c00, 0x00000000,
+0x0017a817, 0x01648057, 0x14d00530, 0x65005b00, 0x4005b009, 0x00570016,
+0x05f0017c, 0x550217c0, 0xf1014ca0, 0x0014c005, 0x0146007d, 0x5fc10570,
+0x00000e20, 0x00000000, 0x220d8012, 0x40dc823f, 0x8dc003f2, 0xdc403700,
+0xc0837a10, 0x0033120d, 0xa31200fc, 0x37000fc4, 0xf020dc08, 0x200ee003,
+0x087c803f, 0x4bc021a0, 0x00000600, 0x00000000, 0x00210810, 0x023c0093,
+0x27e00930, 0x6c019300, 0xc0093202, 0x00830a24, 0x0830020c, 0x930022c0,
+0x30025c00, 0x0867c009, 0x827c009f, 0xc3c10d31, 0x00000420, 0x00000000,
+0x00262001, 0x82748291, 0xe7000910, 0x140f9303, 0xc4091702, 0x009b9025,
+0x2950025c, 0x9d082540, 0xa0024400, 0x00674009, 0x0a740097, 0x05c08900,
+0x00000800, 0x00000000, 0x4024801c, 0x02f402b1, 0x2b400b10, 0xe600b100,
+0x400b1882, 0x20b10028, 0xab1002c4, 0xb9102d40, 0x11029400, 0x022f400b,
+0x421400bd, 0x73440d14, 0x00000200, 0x00000000, 0x00282814, 0x02b408a9,
+0x2b402a10, 0x9408a100, 0x400a1802, 0x88a92229, 0x2a522294, 0xad002940,
+0x80228480, 0x023b408a, 0x0a3409a1, 0x51414c14, 0x000000a0, 0x00000000,
+0x0802b01d, 0x00740213, 0x07400114, 0x2c001342, 0xc2813080, 0x82114004,
+0x0110084e, 0x131007c0, 0x3008540a, 0x0087c020, 0xd07c803f, 0x77c0e120,
+0x00000ac0, 0x00000000, 0x04a7a119, 0x0a7c0697, 0xa7c069f0, 0x7c069f11,
+0xc469f04a, 0x069f00a7, 0x29f01a5c, 0x9784e7c0, 0xf01a7c06, 0x11a7c069,
+0x127c069f, 0x67c049f0, 0x00000e24, 0x00000000, 0x41efa018, 0x16ec05b3,
+0x6dc63930, 0x4c01b301, 0xc0d9301e, 0x0393056c, 0x5900064c, 0xb30167c0,
+0x3016cc05, 0x036cc079, 0x5aec03b3, 0x63c029f1, 0x00000e00, 0x00000000,
+0x0087101c, 0x80440401, 0x05c0e1b0, 0x54821f00, 0x40005008, 0x001b0584,
+0xa110503e, 0x15078740, 0x10004c14, 0x00044001, 0x184c0011, 0x734041f8,
+0x00000c60, 0x00000000, 0x02210812, 0x0a051681, 0xa0400814, 0x05168105,
+0x40681022, 0x86850020, 0x081e0a05, 0x81102340, 0x144a1702, 0x01a07068,
+0x02050681, 0x4b4008d0, 0x00000400, 0x00000000, 0x2025a018, 0x02440091,
+0x264a0990, 0x54009500, 0x40091002, 0x20990024, 0x09100254, 0x95002740,
+0x10025400, 0x00244009, 0x02660091, 0x63401950, 0x00000400, 0x00000000,
+0x00278805, 0x02440093, 0x24c30930, 0x4c009100, 0xc0093002, 0x129504a4,
+0x29300244, 0x930027c1, 0x104a5c12, 0x00244129, 0x024c1293, 0x17c449d2,
+0x00000e20, 0x00000000, 0x40258032, 0x021c008f, 0x25d00970, 0x3c108f00,
+0xd008f402, 0x209f4023, 0x0df2023c, 0x8f0027c1, 0xf0020c00, 0x4023c008,
+0x425c409b, 0x4bc00db0, 0x00000600, 0x00000000, 0x02010810, 0x004c2013,
+0x00c00030, 0x4c001324, 0xc0017000, 0x02030084, 0xa138004e, 0x130000c4,
+0x30084d02, 0x0007c421, 0x007c0603, 0x43c06134, 0x00000420, 0x00000000,
+0x00548014, 0x05c50271, 0xdcc00530, 0xc40071a0, 0x60075001, 0x007f0014,
+0x353801ec, 0x51301c40, 0xb16dec01, 0x201dc005, 0x05f41073, 0x53410530,
+0x00000200, 0x00000000, 0x4032a014, 0x1d0486c9, 0x32500c90, 0x0409414a,
+0x500cde03, 0xc0c14030, 0x3c900304, 0xc1c03050, 0x50032600, 0x0033680c,
+0x0a3400c9, 0x53403090, 0x00000a00, 0x00000000, 0x40308001, 0x408420e9,
+0x30400c12, 0x84006100, 0x408ed033, 0x04e51028, 0x54102380, 0xe1093048,
+0xd2032630, 0x0039408e, 0x47b404e1, 0x07400a12, 0x00000620, 0x00000000,
+0x00780011, 0x058c01eb, 0x4a405e94, 0x0d017100, 0x405ef117, 0x07f10060,
+0x56901784, 0xf10178c4, 0x7207ac81, 0x007fc0de, 0x04fc03eb, 0x47c09e32,
+0x00000040, 0x00000000, 0x08b5a810, 0x003800d3, 0x06c12d60, 0x78005f00,
+0xc02d30db, 0x50df00b7, 0xc1f4137c, 0xdf0237c1, 0xb0037480, 0x0007402d,
+0x036c005f, 0x43c42df5, 0x00000620, 0x00000000, 0x00eda000, 0x04fc01f3,
+0x6cc11f30, 0xcc017f00, 0xc03f3007, 0x09f300fe, 0x11b00fec, 0xbb0275c4,
+0x3113cc25, 0x0374c09f, 0x11cc01bf, 0x03c09b31, 0x00000600, 0x00000000,
+0x06291815, 0x009c00e1, 0x28418f30, 0x144b6004, 0x490f1143, 0x01e50629,
+0x52111394, 0xab067141, 0xb0159404, 0x0479420c, 0x2304000d, 0x57400e10,
+0x00000460, 0x00000000, 0x40690000, 0x00340861, 0x28400e10, 0xa4806502,
+0x408e5803, 0x60e50068, 0x405083a4, 0x81013a40, 0x1213264c, 0x103a480e,
+0x230400ad, 0x03420e90, 0x00000408, 0x00000000, 0x00652004, 0x28148a40,
+0x60401c90, 0x640a4119, 0x404c140b, 0x09c500b0, 0x30102b04, 0x8180f348,
+0x1029300c, 0x008340ac, 0x0346008d, 0x93400c94, 0x00000400, 0x00000000,
+0x40e5a815, 0x007c4a53, 0xd4c03f14, 0xed405500, 0xd03f100f, 0x20f340f4,
+0xb77003ec, 0xd1107ec2, 0x10036c02, 0x0076400f, 0x034d45bd, 0x57c029b1,
+0x00000620, 0x00000000, 0x21270001, 0x403c000f, 0x15c24d70, 0x5c104720,
+0xc00cf013, 0x10db2125, 0x0410433c, 0x9f0431c0, 0xf8431c00, 0x0c31c10c,
+0x826c109f, 0x07c13d70, 0x00000c00, 0x00000000, 0x402f0884, 0x00cc02fb,
+0x6ec00fb0, 0xcc007300, 0x400f3003, 0x00eb402c, 0x133003cc, 0xeb003cc0,
+0x3217ec01, 0x003cc00d, 0x03cc01b3, 0x10c00f30, 0x00000c22, 0x00000000,
+0x02662085, 0x08440391, 0x66420d10, 0x54025b00, 0xc00d9403, 0x00db0037,
+0x85b00344, 0x91003440, 0x90076c01, 0x0006c00d, 0x00450013, 0x15404d10,
+0x00000802, 0x00000000, 0x40348001, 0x18640259, 0x30440c10, 0x46085102,
+0x400d9003, 0x00d90031, 0x21900344, 0x91803440, 0xd0024408, 0x0034600d,
+0x07442481, 0x04481894, 0x00000200, 0x00000000, 0x00302810, 0x02340001,
+0x71500c14, 0x05444102, 0x400c9203, 0x04c91021, 0x40950b05, 0xc1413164,
+0x97402620, 0xd132500c, 0x05042249, 0x41400898, 0x000000a0, 0x00000000,
+0x403ab000, 0x0065005b, 0xa2c00f10, 0xcc01d100, 0x42af300b, 0x01eb0028,
+0x11900bc4, 0x9312f4d0, 0x723e4c00, 0x9174c22f, 0x234c0083, 0x00c00db0,
+0x00000ac0, 0x00000000, 0x003fa025, 0x02cc003f, 0x6ec00f38, 0xbc028f80,
+0xc05f70d7, 0x02df003f, 0x23f087ac, 0xff00fac0, 0x60147c00, 0x020de15f,
+0x07fc05f7, 0x17c20f70, 0x00000e20, 0x00000000, 0x020fb003, 0x59cc08af,
+0x0ec04bf0, 0xec00b343, 0xc402b003, 0x00a7023e, 0x0b300acc, 0xff000ec1,
+0x3002fc04, 0x4008c2cf, 0x33cc0cf3, 0x0cc00b30, 0x00000e00, 0x00000000,
+0x00070003, 0x1344009c, 0x84494930, 0x95025302, 0x420df200, 0x2491203d,
+0x25120344, 0x9d010448, 0x10024440, 0x000440cd, 0x331406c3, 0x0c400950,
+0x00000c20, 0x00000000, 0x0033a013, 0x135444cd, 0x00546c5c, 0x4482dd10,
+0x40005803, 0x30950132, 0x08101304, 0xcd040050, 0x50032482, 0x0003400c,
+0x020408c1, 0x4c501110, 0x00000e80, 0x00000000, 0x0805a803, 0x075400dd,
+0x05500c54, 0x4400d912, 0x420c5240, 0x00d10030, 0x04140344, 0x9d021740,
+0x11037440, 0x0637401d, 0x025400d1, 0x0c401959, 0x00000620, 0x00000000,
+0x0107a880, 0x045d019f, 0x04d09d70, 0x48c2cb00, 0x80055003, 0x00971036,
+0x2d31074c, 0x5f0046c9, 0x54036c06, 0x00a6c00c, 0x23480093, 0x00c00830,
+0x00000e22, 0x00000000, 0x001d8087, 0x02ec05bf, 0x5ec00fb0, 0xdc407300,
+0xc00ff04b, 0x50bf0037, 0x0ff013fc, 0xef804c00, 0xe00bcc05, 0x006cc00f,
+0x07fc40e7, 0x1fc009f0, 0x00000602, 0x00000000, 0x2035080a, 0x035d00df,
+0x15c44ff0, 0x5c02d3c0, 0xc025340b, 0xa0930035, 0x0d20035c, 0x570836c0,
+0xb4037c00, 0x0095c409, 0x034c0093, 0x28c80170, 0x00000420, 0x00000000,
+0x0014a013, 0x030440dd, 0x94402d90, 0x0700f182, 0xc8bdb04b, 0x01c5003e,
+0xafb00d04, 0xf10246c2, 0x10814480, 0x0074404d, 0x034400d5, 0x4ec00b10,
+0x00000200, 0x00000000, 0x0002a007, 0x03240099, 0x456008d0, 0x04008102,
+0x4808d403, 0x02810830, 0x08902714, 0xc5004340, 0x10924700, 0x4017410c,
+0x037400c1, 0x1c4008d0, 0x00000a00, 0x00000000, 0x0468801d, 0x07b441bd,
+0x58419e90, 0x8409f10a, 0x419ed027, 0x01a4007a, 0x1f920f80, 0xe1004a4a,
+0x00278401, 0x005a421e, 0x27b400e5, 0x7e401a93, 0x00000200, 0x00000000,
+0x00300012, 0x0b34088d, 0x15c089f0, 0x0402c102, 0xc008f203, 0x90830130,
+0x0834035c, 0xd70406c0, 0x20435408, 0x2d23c00d, 0x023c88c3, 0x48c048f1,
+0x00000040, 0x00000000, 0x302da802, 0x03cc00bf, 0x1e408fb0, 0xec90ef02,
+0xc20fb28b, 0x00ff003e, 0x0ef0037c, 0xfa001ec0, 0x58035c52, 0x003d400f,
+0x02cc04ff, 0x0bc00b70, 0x00000660, 0x00000000, 0x0007a015, 0x025c00df,
+0x04c14904, 0x5d80c300, 0xc00c709f, 0x21832330, 0x0db0034c, 0xdf0484c4,
+0x32067c00, 0x2034c00d, 0x03cc009b, 0x54c08830, 0x00000e00, 0x00000000,
+0x00398913, 0x02b400e7, 0x1c440c30, 0xc405e102, 0x400e1003, 0x20a10538,
+0x2e1003ec, 0xec000840, 0x1003dc04, 0x003ec00f, 0x03d400e5, 0x4c400e50,
+0x00000624, 0x00000000, 0x00790081, 0x069661ed, 0x5a4d1a90, 0xa605e900,
+0x523f5803, 0x01a1007a, 0x6f900785, 0xec207840, 0x9007b405, 0x1078400e,
+0x06841189, 0x04405b10, 0x00000402, 0x00000000, 0x00332812, 0x033688cd,
+0x12401c10, 0x0540c100, 0x400d183b, 0x00c12034, 0x1d508104, 0xcd005047,
+0x9415340c, 0x00b0401c, 0x061401c5, 0x48408c53, 0x00000c20, 0x00000000,
+0x001da817, 0x41dc015f, 0x16c005b0, 0xdc846b41, 0xc007700d, 0x00730014,
+0x27b005c4, 0x4f00d4c0, 0x9001f400, 0x04580105, 0x4544405b, 0x5cd41610,
+0x00000620, 0x00000000, 0x20070012, 0x007c8017, 0x05d00072, 0x1c001740,
+0xe401f000, 0x401f5807, 0x01b0307c, 0x1f2607c0, 0x70205c00, 0x0107c401,
+0x007d001f, 0x4bc001f0, 0x00000c00, 0x00000000, 0x01270810, 0x027c0093,
+0x34c80d70, 0x4c009700, 0xc0193026, 0x00931024, 0x19b0027a, 0xdf0034e0,
+0xf0024c00, 0x1124c009, 0x023c0083, 0x40d00930, 0x00000c20, 0x00000000,
+0x01e62001, 0x02740091, 0x24400918, 0x4d009b40, 0x5019300e, 0x089b0024,
+0x19100236, 0x9d002454, 0xd1064400, 0x40a5c068, 0x027c0091, 0x04400911,
+0x00000800, 0x00000000, 0x00208018, 0x02140091, 0x20600950, 0x64c095c0,
+0x40ad1002, 0xc0952024, 0x49100274, 0x9d862450, 0xd0064400, 0x44244019,
+0x02440091, 0x60440910, 0x00000200, 0x00000000, 0x62202010, 0x22360081,
+0x20608850, 0x04148982, 0x40881023, 0x088d0120, 0x88100664, 0x9d022040,
+0xd0230434, 0x40a34089, 0x02348081, 0x40408910, 0x00000080, 0x00000000,
+0x0587b01d, 0x581c0011, 0x84d16150, 0x4c841705, 0xc0213058, 0x221702c4,
+0x61342874, 0x1f208441, 0xf2584c8e, 0x0004e961, 0xf85c1e13, 0x74c02130,
+0x00000ac0, 0x00000000, 0x012f9919, 0x12fc14bf, 0x27c049b1, 0xfc00bf41,
+0x644b7012, 0x04bb0267, 0x4a7006fc, 0x9f0127d0, 0xd012f901, 0x00ade04b,
+0x06fc01bf, 0x67c06bfe, 0x00000e64, 0x00000000, 0x2037a018, 0x0a7c8893,
+0xa6816950, 0xd490b701, 0xe08b7092, 0x02a3132c, 0x0a300aec, 0x93002cc1,
+0x7042cc00, 0x04ace06b, 0x524c1293, 0x64c06930, 0x00000e00, 0x00000000,
+0x0287089c, 0x3d344010, 0xccc03110, 0x04025500, 0x40017000, 0x44114904,
+0x2130805c, 0x01080540, 0x10814420, 0x00856461, 0x58542411, 0x72900458,
+0x00000c22, 0x00000000, 0x0523a012, 0x02340481, 0x2a400a11, 0x5400850a,
+0x6048905a, 0x00c100a0, 0x49901334, 0x88252041, 0x50422516, 0x00704028,
+0x02340489, 0x48402810, 0x00000e80, 0x00000000, 0x21258818, 0x02340891,
+0x2c400a10, 0x44089500, 0x02095202, 0x84912024, 0x09101270, 0x88042540,
+0x10822400, 0x00654009, 0x82740099, 0x62480850, 0x00000620, 0x00000000,
+0x44a52805, 0x2a7c0093, 0x66c08934, 0x5c039502, 0x5009b202, 0x81924024,
+0x09b41e74, 0x9b00e0c4, 0x702a6420, 0x08e44009, 0x027c409b, 0x14e42911,
+0x00000e20, 0x00000000, 0x20310016, 0x067e619f, 0x25c019f0, 0x7c008f00,
+0xc0097042, 0x019f2023, 0x09f2065c, 0x970667c0, 0xf0065c00, 0x0027c039,
+0x165c0087, 0x59c009f0, 0x00000600, 0x00000000, 0x88850814, 0x087c001f,
+0x0cd00334, 0x5c001320, 0xc88170a0, 0x011f0007, 0x41f20c52, 0x1f208448,
+0xf0406c00, 0x0004c001, 0x005c001f, 0x50c001b0, 0x00000420, 0x00000000,
+0x81942014, 0x017c005d, 0x15400510, 0x84005300, 0xc217b201, 0x027d0015,
+0x06d009cc, 0x5d005d40, 0xd209c400, 0x001fc116, 0x0144005d, 0x50400510,
+0x00000200, 0x00000000, 0x14328014, 0x032440cd, 0x34600c11, 0x1488c180,
+0x401d580f, 0x00c90823, 0x0cd00354, 0xcd008044, 0xd0072400, 0x0836420c,
+0x035020cd, 0x50400c1a, 0x00000a00, 0x00000000, 0x00388004, 0x039604ed,
+0x09600210, 0x8480c9c0, 0x44029080, 0x09ec212b, 0x06d010a4, 0xed80d848,
+0xd0438400, 0x107b040e, 0x031408ed, 0x14404e10, 0x00000200, 0x00000000,
+0x04581014, 0x07a443ed, 0x7c501f32, 0x9c81e300, 0xc0167405, 0x81ea056b,
+0x1ef01594, 0xef0028c1, 0xf026ac01, 0x083a901e, 0x2f9c35ff, 0x54d15e34,
+0x00000040, 0x00000000, 0x0095b810, 0x037c01df, 0x07d401f1, 0x6c00d740,
+0xc921f001, 0x20df0225, 0x45f1205c, 0xde0037da, 0xd0137c0a, 0x0027c00c,
+0x036c06db, 0x43c0ad70, 0x00000660, 0x00000000, 0x007fa002, 0x07cc21ff,
+0x7fc01f30, 0xfc81bb00, 0xc01f300e, 0x01f7226c, 0x167006ec, 0xfb024cc0,
+0x7004cc03, 0x013ec01e, 0x07cc01f3, 0x08c01ff0, 0x00000e00, 0x00000000,
+0x04298815, 0x038840fc, 0x0b484210, 0x9c04a001, 0x4402f020, 0x00710029,
+0x465000fc, 0xfd040940, 0xb002a408, 0x043ad00e, 0x839408f1, 0x54400fd0,
+0x00000620, 0x00000000, 0x00190000, 0x038408ed, 0x33000e10, 0xb410a924,
+0x40061001, 0x00ed9022, 0x27500084, 0xed001a42, 0x90222510, 0x0030400e,
+0x038400e1, 0x60400ed0, 0x00000400, 0x00000000, 0x00c32806, 0x9f0440cd,
+0x43409010, 0x14008100, 0x48a0d429, 0x01490823, 0x04500014, 0xcd00d340,
+0x824a2427, 0x04a0040c, 0x031408c1, 0x1840bcd0, 0x00000c20, 0x00000000,
+0x0075a815, 0x4d4d00ff, 0x77c00d34, 0x34839b10, 0xc03d3407, 0x10fe002e,
+0x05740ac4, 0xff1012c0, 0x30024d01, 0x0024501d, 0x83cc01f2, 0x74c21fd8,
+0x00000620, 0x00000000, 0x00330001, 0x017c00df, 0x07c000f0, 0x7c009f00,
+0xc041f410, 0xc0d70021, 0x15f00c7c, 0xdf0415e0, 0xb0055c40, 0x0027ca3d,
+0x037c00df, 0x07c90df1, 0x00000c00, 0x00000000, 0x044f0880, 0x01bc00fb,
+0x3cc00f30, 0x7c14a300, 0xd097b000, 0x80fb002c, 0x023040dc, 0xfb100cc4,
+0xf002fc00, 0x0008000e, 0x039c00f3, 0x04c00f30, 0x00000c20, 0x00000000,
+0x03062001, 0x09f400d5, 0x0c500351, 0x54019700, 0x40005004, 0x40cb0024,
+0xb1b22415, 0xd1463441, 0xd00f7400, 0x00c6c015, 0x035480db, 0x04440d50,
+0x00000800, 0x00000000, 0x00168001, 0x097400d1, 0x30400d10, 0x64009140,
+0x400d100e, 0x21d9a024, 0x05104044, 0xd1000750, 0xd20c7400, 0x00f5403d,
+0x035400c9, 0x04420c11, 0x00000200, 0x00000000, 0x00000010, 0x013400c5,
+0x00520050, 0x44008140, 0x40015002, 0x00590020, 0x04100104, 0xc1800748,
+0xd0003400, 0x00334008, 0x031440c8, 0x40400c40, 0x00000080, 0x00000000,
+0x00061000, 0x013c00d3, 0x34c80d14, 0xfc009140, 0xc403b000, 0x00db002c,
+0x03100054, 0xfb0017c0, 0xe002fc00, 0x0015c00d, 0x03dc00fb, 0x04c00f38,
+0x00000ac0, 0x00000000, 0x000fb805, 0x81fc40ff, 0x0fc003f0, 0xfc40be08,
+0xc002f000, 0x003e202f, 0x03f001fc, 0xff001cd2, 0xf202fc00, 0x000ec007,
+0x03fc00ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x402f8003, 0x43fc00bb,
+0x3cd08f30, 0xec80f200, 0xc02b9003, 0x20e7213f, 0x0d30038c, 0xff003bc4,
+0xf003dc20, 0x013dc08f, 0x004c081b, 0x0dc80fb0, 0x00000e00, 0x00000000,
+0x04a70001, 0x0bc400db, 0xb4440db0, 0x7420d141, 0x400d0203, 0x00d1023f,
+0x0d900344, 0xfd0d3640, 0xd073ed20, 0x06b4446f, 0x00440411, 0x04410f10,
+0x00000c20, 0x00000000, 0x01b7a011, 0x031400c5, 0xb2505cdc, 0x4400c10c,
+0x4044da07, 0x20d10032, 0x0c508754, 0xcd007140, 0xd0031402, 0x0831482c,
+0x00140089, 0x46404851, 0x00000e80, 0x00000000, 0x0405a803, 0x834401d1,
+0x76401d14, 0x7020d100, 0x491d5007, 0x06d04037, 0xadc00744, 0xd9007742,
+0xd18364a0, 0x0224400d, 0x00550891, 0x0e400910, 0x00000620, 0x00000000,
+0x00a3a802, 0x033c1151, 0x76c001d0, 0x2c02d308, 0xc01db883, 0x82c72033,
+0x1d74031c, 0xdf0037c0, 0xf1035c00, 0x0075ca0d, 0x1154011a, 0x02c009e4,
+0x00000e20, 0x00000000, 0x002d8007, 0x03dc00ef, 0x3dd001f0, 0xfc05ff00,
+0xc00f3003, 0x01ff003f, 0x1f3003cd, 0xff083ec0, 0xf003fc00, 0x0063c00f,
+0x81ac019f, 0x1dd00bf0, 0x00000602, 0x00000000, 0x00f50802, 0x137c04df,
+0x14c008b0, 0x5c12d310, 0xc02df4c3, 0x06d34337, 0x0db0435c, 0xd34037c9,
+0x30035ca8, 0x4034c00d, 0x214d0093, 0x08c00df0, 0x00000420, 0x00000000,
+0x0014a013, 0x43f683d1, 0x75441b14, 0x4c23d100, 0xc20d000f, 0x83d100fe,
+0x0d10034c, 0xe30837c0, 0xb283c400, 0x0826c00f, 0x015c0091, 0x4c420c30,
+0x00000200, 0x00000000, 0x1022a007, 0x0f3400c9, 0x34500098, 0x040bcd10,
+0x420c18af, 0x03cd00b3, 0x8c54a326, 0xc9003360, 0x10033410, 0x0030420d,
+0x16240055, 0x1c404c11, 0x00000a00, 0x00000000, 0x02c88004, 0xa73401e1,
+0xe840b210, 0xc705fd00, 0x401f1117, 0x05e90072, 0x5e502795, 0xe1007900,
+0x8027a429, 0x006a401c, 0x26940965, 0x18409c51, 0x00000200, 0x00000000,
+0x02340012, 0x033410cf, 0x244108b0, 0x0487cf06, 0xc04c5017, 0x11cd0133,
+0x1c70a314, 0xd8013340, 0x30037c00, 0x0030c00c, 0x164c05c7, 0x48c00870,
+0x00000040, 0x00000000, 0x0a2db802, 0x03fc00ff, 0x37c20b70, 0xae10e308,
+0xc00c500b, 0x00f3003d, 0x0d306b6c, 0xff24bfc1, 0xf0435c00, 0x0037c00f,
+0x02fd28fa, 0x0bc02bb0, 0x00000660, 0x00000000, 0x0027a815, 0x137c00d3,
+0x24448d30, 0x3c12dc10, 0xc40db027, 0x03cb41f2, 0x2d301b0c, 0xdb0037c5,
+0x70534c46, 0x2035a41d, 0x4f4c4053, 0x54c069b0, 0x00000e00, 0x00000000,
+0x10018812, 0x53f400e1, 0x38400c90, 0x9e04ef00, 0x400f0213, 0x10e112b8,
+0x4e100384, 0xe5013f40, 0x10138412, 0x1838414e, 0x03c420e1, 0x4ac00a10,
+0x00000620, 0x00000000, 0x00790003, 0x37b401e1, 0x48505e95, 0xb485ed00,
+0x401e5507, 0x79e1017d, 0x7ed40fa5, 0xc508fb62, 0x58070585, 0x0879409e,
+0x07a401e9, 0x0c521cdc, 0x00000402, 0x00000000, 0x20372012, 0x03740fc1,
+0x34400d90, 0x3400c511, 0x40bc5003, 0x00c10031, 0x3cd10f16, 0xc5007340,
+0x10030400, 0x0030400c, 0x232410c9, 0x4a401c50, 0x00000c20, 0x00000000,
+0x445da017, 0x01740271, 0x1cc00711, 0xfc1b3d20, 0x5017706c, 0x0333201d,
+0x03f200ac, 0x5b008fc0, 0x70014c00, 0x0455c005, 0x056c005b, 0x5cc055f0,
+0x00000620, 0x00000000, 0x40070012, 0x087c001f, 0x07c01170, 0x5c001f00,
+0x4441b200, 0x00171004, 0x41209060, 0x1f000740, 0xf0007c00, 0x4007c001,
+0x005c2007, 0x49e020a0, 0x00000c00, 0x00000000, 0x00270010, 0x227c029f,
+0x25c00934, 0x5c021b00, 0xd009b208, 0x14170926, 0x8132206c, 0x960404c0,
+0x30026c00, 0x0022c009, 0x024c0097, 0x41c019d0, 0x00000c20, 0x00000000,
+0x40262801, 0x8e740391, 0xa4400910, 0x5c031102, 0x4009d00c, 0x071701e4,
+0x20100874, 0x89000040, 0x10024401, 0x00274e09, 0x4a540091, 0x144189d0,
+0x00000800, 0x00000000, 0x0064a018, 0x02740091, 0xa4508910, 0x54001900,
+0x4008d008, 0x80150824, 0x01184074, 0x99200441, 0x10022488, 0x00264009,
+0x22e40095, 0x70400992, 0x00000200, 0x00000000, 0x02602010, 0x122410c1,
+0x2040d811, 0x1408c144, 0x6048d022, 0x08850a20, 0x88102274, 0xcd022050,
+0x14220406, 0x85224088, 0x32a50ca1, 0xc05068d2, 0x00000080, 0x00000000,
+0x0c06b01d, 0x317c0017, 0x05d14111, 0x5c161b00, 0xc041b058, 0x96170584,
+0x6134586c, 0x174584c1, 0x10586c04, 0x0102c340, 0x50ec4607, 0x65d051f0,
+0x000008c0, 0x00000000, 0x002f9019, 0x327c00b7, 0x2fc24bf4, 0xfc04bf04,
+0xc12bf012, 0x04bf0127, 0x4ff012fc, 0x93012fc0, 0xf0127c02, 0x042fc009,
+0x125c2c9f, 0x67c46bf0, 0x00000ce0, 0x00000000, 0x00afa818, 0x229c00bb,
+0xbc450fb0, 0xdc0da704, 0xc509d036, 0x13bd00af, 0x1bd046ec, 0xb32c60c1,
+0xf0325c04, 0x00a6c409, 0x129c009f, 0x64e06b30, 0x00000e00, 0x00000000,
+0x4087081c, 0x00440211, 0x94404010, 0x440f5840, 0xc821d13d, 0x871d03c5,
+0x11900444, 0x150d1400, 0xd0004402, 0x02845040, 0x086c0e19, 0x604061b0,
+0x00000c22, 0x00000000, 0x40e3a030, 0x1a340395, 0x23450811, 0x14008d01,
+0x41485a02, 0x409d0022, 0x49c24224, 0x85082045, 0xd01a161c, 0x00204128,
+0x5a04108d, 0x41406894, 0x00000e80, 0x00000000, 0x1025a018, 0x02640099,
+0x264a0910, 0x44a81909, 0x0009d980, 0x461d8005, 0x01900044, 0xd5222070,
+0xd0024440, 0x02244009, 0x02450298, 0x60400990, 0x00000620, 0x00000000,
+0x00278005, 0x0274029b, 0x24c10934, 0x5c030700, 0xc139f004, 0x231e0007,
+0x00c21c6c, 0x9600e4c2, 0xf0025c80, 0x0066c009, 0x0244009f, 0x055099b4,
+0x00000e20, 0x00000000, 0x12658014, 0x021c0397, 0x21d80970, 0x7c011740,
+0xc849f020, 0x411f0005, 0x31b0506c, 0x9b4067c0, 0xf0027c40, 0x0027c009,
+0x027c008f, 0x43c018f0, 0x00000600, 0x00000000, 0x00050014, 0x407e801f,
+0x84c02174, 0x4c421301, 0x4021f898, 0x221f0205, 0x21f0007c, 0x170887c4,
+0x30804c08, 0x0005c001, 0x902c0013, 0x53c10130, 0x00000420, 0x00000000,
+0x029ca814, 0x1df4016d, 0x1cc00651, 0xc6423104, 0xc0056214, 0x1b2d200c,
+0x73700cf4, 0x60201fc0, 0x10014401, 0x00144005, 0x09cc0071, 0x53400710,
+0x00000200, 0x00000000, 0x0016a014, 0x013405c9, 0xe0601c50, 0x0412c900,
+0x440c1003, 0xc0cd04f3, 0x7cd00320, 0xc9203340, 0x90032541, 0x0830480d,
+0x050440c5, 0xd3440c10, 0x00000a00, 0x00000000, 0x04188005, 0x03b402ed,
+0x28414a10, 0x8410f900, 0x009c1213, 0x00ed0239, 0x0ed043b4, 0xed013d40,
+0x9407a484, 0x4178408e, 0x098400e5, 0x17400615, 0x00000200, 0x00000000,
+0x00581011, 0x05b401ed, 0x7cd05e71, 0x8427e940, 0xc81e7107, 0x05ef037b,
+0xfef007bc, 0x4f417b40, 0xb0272c05, 0x41fdc15e, 0x058d8dc7, 0x57801a30,
+0x00000040, 0x00000000, 0x0015b010, 0x017c60df, 0x36d489f4, 0x7d34d300,
+0x410d512b, 0x60db00b6, 0x2d703b74, 0x9322b7c0, 0x700b5c48, 0x05b7f20d,
+0x007c06da, 0x43c009f0, 0x00000660, 0x00000000, 0x005fa800, 0x05f041ff,
+0x6ec0cb41, 0x7c21fb20, 0xc05fb0af, 0x1bf3027c, 0x1ef10ffc, 0xa300f1c0,
+0xf067df01, 0x407cc01f, 0x13cc11f3, 0x08c89734, 0x00000e00, 0x00000000,
+0x10198811, 0x19b400ef, 0x68c24a10, 0x3400c917, 0xc1dfd097, 0x08c1003a,
+0x5e6087b8, 0xeb017840, 0xd0078c04, 0x0079400e, 0x018404e3, 0x56c00614,
+0x00000620, 0x00000000, 0x00990000, 0x01b400ed, 0x99440b50, 0xb408e181,
+0x6c0ed003, 0x58e9303a, 0x4fd003a4, 0x25023d40, 0xd013b600, 0x2038400e,
+0x018420ed, 0x00420290, 0x00000400, 0x00000000, 0x00332800, 0x017613c5,
+0x30400c10, 0x3444c920, 0x503cd1c3, 0x00c90030, 0x3c500714, 0x8d80f102,
+0xd2030420, 0x0031400c, 0x010420c0, 0x1a460090, 0x00000c20, 0x00000000,
+0x0055a031, 0x017401dd, 0xf0c40f50, 0x7c84c308, 0x002f9003, 0x03d96032,
+0x1cd01b74, 0xf74e3dc1, 0xd103f400, 0x003c400f, 0x014c08ff, 0x74a009b1,
+0x00000620, 0x00000000, 0x00530001, 0x087c0a9f, 0x27c001f0, 0x7c02d700,
+0xc04df02b, 0x20d70037, 0x0de08374, 0x51003681, 0xf0037c80, 0x0237c00d,
+0x897c00cf, 0x07e00170, 0x00000c00, 0x00000000, 0x001f0080, 0x254c00f3,
+0x3dc006b4, 0xec00fb40, 0xc80ff003, 0x10f34034, 0x0ff3c3fc, 0x7f003cd0,
+0xe003ec00, 0x003de00d, 0x258c00ff, 0x04d82a32, 0x00000c20, 0x00000000,
+0x00162085, 0x014410c1, 0x76402990, 0x0403d108, 0xc80d904b, 0x00d10034,
+0x0dd10374, 0x0d003448, 0xd0035c20, 0x0037440d, 0x055420dd, 0x84400954,
+0x00000802, 0x00000000, 0x0054a001, 0x014404d9, 0x66522910, 0x74b4d900,
+0x480c9223, 0x21d18874, 0x1d580754, 0x99003640, 0xd1036580, 0x0035400d,
+0x094500dd, 0x04480194, 0x00000200, 0x00000000, 0x00102014, 0x810400c1,
+0x26400010, 0x1408c189, 0x430cd0c3, 0x41c10070, 0x5cd89734, 0x4d013244,
+0xd0031400, 0x0033000c, 0x011402cd, 0x400000d0, 0x00000080, 0x00000000,
+0x0016b000, 0x014500d3, 0x55c001b0, 0x7c02db04, 0x501ff21f, 0x02d31034,
+0xddf0175c, 0x1e207ec0, 0xf117ee00, 0x1179c00f, 0x214c02ff, 0x04c000b0,
+0x00000ac0, 0x00000000, 0x002fb805, 0x01fc007f, 0x31c00ef4, 0xec41ff40,
+0xc00d3057, 0x15ff803d, 0x3df0a37c, 0x3f123dc0, 0xf0235c00, 0x00b7c00f,
+0x85bc45ef, 0x17c00373, 0x00000e60, 0x00000000, 0x000fa003, 0x00fc103b,
+0x1f440330, 0xcd043300, 0xc0c33220, 0x00fb4438, 0x8f3703dc, 0xfb003fc0,
+0x35a3cd00, 0x001cc083, 0x22c804f7, 0x0cc16f30, 0x00000e00, 0x00000000,
+0x00070801, 0x02740013, 0x97400d10, 0x4408d102, 0x40c1541b, 0x00d100bd,
+0x41100144, 0xd5002744, 0x30004400, 0x2b946009, 0x125408d1, 0x04402d52,
+0x00000c20, 0x00000000, 0x4203a011, 0x00301001, 0x11400410, 0x14800108,
+0x40405120, 0x00558000, 0x4c100214, 0x05101340, 0x12030400, 0x44125800,
+0x822400c9, 0x44604c52, 0x00000e80, 0x00000000, 0x28158803, 0x1a7400d9,
+0x17404d10, 0x5400d104, 0x66155003, 0x00558405, 0x05100244, 0x10041640,
+0x10020400, 0x08026000, 0x027600d9, 0x0c410550, 0x00000620, 0x00000000,
+0x0c478802, 0x017c0013, 0x9fc01d34, 0xdc003340, 0xc0017000, 0x454f0264,
+0x2130425c, 0x9b1087c1, 0x301f4c00, 0x00164801, 0x026c40f9, 0x08d0a971,
+0x00000e20, 0x00000000, 0x017d8007, 0x03bc03b7, 0x1fc01ff0, 0xac00ff08,
+0x8003f003, 0x095b006b, 0x03f0203c, 0xa7000bc0, 0x70117c88, 0x101dc003,
+0x0a9c00c3, 0x1fc01bf0, 0x00000600, 0x00000000, 0x01810802, 0x017c005f,
+0x90c00df0, 0x4d000720, 0xc4041020, 0x015f4007, 0xa5302244, 0x970094c4,
+0x70434c02, 0x4114c081, 0x025c00db, 0x0bc020f1, 0x00000420, 0x00000000,
+0x20b48013, 0x037405dd, 0x16c02d70, 0x4000db04, 0x4a05502b, 0x40710027,
+0x05b02a6c, 0x91005442, 0x100344a5, 0x00ec5001, 0x126c40f3, 0x4f4011d0,
+0x00000200, 0x00000000, 0x0002a007, 0x1836120d, 0x70506cd0, 0x340f0500,
+0x4090c500, 0x00800033, 0x1c100904, 0x41007040, 0x10080400, 0x00134130,
+0x023412c0, 0x1f441098, 0x00000a00, 0x00000000, 0x02488004, 0x05b4016d,
+0x78401f50, 0xa409c100, 0x40169027, 0x09e1207b, 0x181005a4, 0x41066850,
+0x10248409, 0x04594052, 0x87a401e1, 0x134012d2, 0x00000200, 0x00000000,
+0x00101012, 0x003c000f, 0x34482cf0, 0x3c000500, 0xc080f020, 0x08830023,
+0x0c13030c, 0x43023040, 0x34220d08, 0x0017c201, 0x023c00c3, 0x4bc108e9,
+0x00000040, 0x00000000, 0x009db802, 0x01fc00ff, 0x3e800ef0, 0x9c00ff02,
+0xc08771a3, 0x08d70047, 0x0ff623fc, 0x7b023bc0, 0xf0a2fc28, 0x040cc063,
+0x03dc10ff, 0x0bc08bf0, 0x00000660, 0x00000000, 0x40f7a015, 0x027c0453,
+0x37c00d30, 0x4d001300, 0xc0453480, 0x099f0137, 0x09f0014c, 0xd30024c8,
+0x30194c01, 0x00169021, 0x02ee01d3, 0x54c05530, 0x00000e00, 0x00000000,
+0x803d8812, 0x03b408e1, 0x33400e10, 0x2c00c180, 0x40861003, 0x00cd043b,
+0x08d00184, 0xe5002050, 0x1021c480, 0x015a4203, 0x02c605e1, 0x48410412,
+0x00000620, 0x00000000, 0x00f90003, 0x06f40169, 0x79411e14, 0x94012100,
+0x44169004, 0x05ad007b, 0x1ed007a6, 0xe900f860, 0x98879411, 0x00104012,
+0x868401e1, 0x0c401e94, 0x00000400, 0x00000000, 0x00732812, 0x07340dc9,
+0x37401c12, 0x2400c100, 0x40849003, 0x04cd00b3, 0x3cd02726, 0xcd007040,
+0x9c275402, 0x01244020, 0x224500c1, 0x4840ac12, 0x00000c20, 0x00000000,
+0x0055a817, 0x4dfc035b, 0x17c02630, 0x5c005348, 0xc405b001, 0x005f045f,
+0x45f00165, 0x5b409442, 0xb0015d00, 0x209ec424, 0x056c0053, 0x5cd01530,
+0x00000620, 0x00000000, 0x20070012, 0x403cc217, 0x87c011f3, 0xf4002f00,
+0xc0017008, 0x001f0183, 0x01f0001e, 0x136007c1, 0x70006490, 0x0007c101,
+0x007c001f, 0x4bc101f0, 0x00000c00, 0x00000000, 0x04370810, 0x027c01df,
+0x25c09934, 0x4c019302, 0xc21db202, 0x00930227, 0x0830927c, 0x9b0420c0,
+0x32867c05, 0x0264c22d, 0x027c0093, 0x43c00d30, 0x00000c20, 0x00000000,
+0x00260001, 0x02740c9d, 0xa7e02910, 0x04099504, 0x4019104a, 0x009110e7,
+0x09120e4c, 0x91002440, 0x10227401, 0x00244009, 0x02740291, 0x07400951,
+0x00000800, 0x00000000, 0x8124a018, 0x0274409d, 0x24510912, 0xc400b120,
+0x40899006, 0x019140a7, 0x0b1442d4, 0xf1022e40, 0x1c0af400, 0x4024400d,
+0x02740391, 0x63400914, 0x00000200, 0x00000000, 0x82202010, 0x0234088d,
+0x20400910, 0x8500e502, 0x40881922, 0x08810523, 0x0a1402a4, 0xa1c02850,
+0x1422b400, 0x02204489, 0x22344081, 0x43408810, 0x00000080, 0x00000000,
+0x0586b01d, 0x503c161f, 0x85440130, 0xcc141335, 0xc161b058, 0x16130107,
+0x4130505c, 0x1b0506e1, 0x3058fc14, 0x0584d021, 0x587c0013, 0x77c16130,
+0x00000ac0, 0x00000000, 0x0127b819, 0x02fc049f, 0x27c00bd0, 0x7c809f01,
+0xc049f012, 0x04bf052f, 0x49f0024e, 0x8f2027c1, 0xf2127c00, 0x012fc049,
+0x12fc028f, 0x67c049f0, 0x00000e60, 0x00000000, 0x022fa018, 0x027c1c9f,
+0x2dc809f0, 0xcc009302, 0xc029315a, 0x0033052f, 0xcb70c2bc, 0x9c202cd0,
+0x11527c14, 0x0124d029, 0x52cc01bb, 0x60c06b30, 0x00000e00, 0x00000000,
+0x0287081c, 0x2874800d, 0x04c003d0, 0x44003101, 0x40605018, 0x01110187,
+0xe110086c, 0x5d028440, 0x11197e82, 0x019cc040, 0x18040211, 0x70400110,
+0x00000c20, 0x00000000, 0x0123a010, 0x02b6448d, 0xa9400bd0, 0x2402a100,
+0x40281012, 0x02c50423, 0x08100214, 0x8d102048, 0x5442b400, 0x462a401a,
+0x420402c1, 0x40422810, 0x00000e80, 0x00000000, 0x2025a818, 0x0374809d,
+0x36400bd0, 0x6400b100, 0x40494802, 0x40950427, 0x49500a44, 0x9c012440,
+0x50021400, 0x2028400a, 0x02040091, 0x60400910, 0x00000620, 0x00000000,
+0x00678805, 0x027c1a9f, 0x25c088d0, 0x6d009320, 0xc4190402, 0x06974067,
+0x09340255, 0x9d0124c0, 0x700a7402, 0x0066c809, 0x024d009b, 0x14d0693c,
+0x00000e20, 0x00000000, 0x22658014, 0x027c00df, 0x25c019f0, 0x5c208f40,
+0xc00df002, 0xe01b0167, 0x08b0123c, 0xdf0027c0, 0xb0027c04, 0x0265c109,
+0x027c008f, 0x53c009f8, 0x00000600, 0x00000000, 0x00050814, 0x004c0a1f,
+0x03c101f1, 0x3c041302, 0xc001b000, 0x02030980, 0x0110007c, 0x170004c0,
+0x34087c02, 0x0484d001, 0x00480113, 0x50840130, 0x00000420, 0x00000000,
+0x11dca014, 0x0146015d, 0x54c125c0, 0xf4115500, 0xc005b009, 0x001b00de,
+0x551035f4, 0x5d015440, 0x10017401, 0x00145025, 0x01440071, 0x50400510,
+0x00000200, 0x00000000, 0x01f2a014, 0x012481cd, 0x536010d0, 0x36000100,
+0x4004543f, 0x00c90230, 0x1c100634, 0xcd007044, 0x10473409, 0x0230600c,
+0x03040041, 0x50401d90, 0x00000a00, 0x00000000, 0x00388005, 0x03a401ed,
+0x08400ad0, 0x3400e500, 0x4036d021, 0x00e9003e, 0x081001a4, 0xed003840,
+0x1041a400, 0x000c600e, 0x0284a061, 0x14402e94, 0x00000200, 0x00000000,
+0x00781015, 0x05a501ed, 0x73c81ed0, 0xbc81e344, 0xc0967417, 0x05eb0058,
+0x1e3106bc, 0xaf0078c0, 0x30073c01, 0x4078c81a, 0x078c0123, 0x54d01fb4,
+0x00000040, 0x00000000, 0x0035b810, 0x035c021f, 0x26440df1, 0x7c009f40,
+0x0821b005, 0x00df1013, 0x09f4837c, 0xdf0837d0, 0xf0037c02, 0x0093c40d,
+0x5a7d000f, 0x43c00d70, 0x00000660, 0x00000000, 0x027fa000, 0xa5fc0bff,
+0x5dc09ef0, 0xdc81f301, 0xc0173107, 0x99e3006f, 0x1b1206cc, 0xff006cc0,
+0x3206cc03, 0x02fcc417, 0x07fc0133, 0x00c01b30, 0x00000e00, 0x00000000,
+0x02198815, 0x63b40ced, 0x18800ed0, 0xac006141, 0x4006b041, 0x30e1412b,
+0x4e1403bc, 0xef003850, 0x10128400, 0x0338404f, 0x22b408a1, 0x54400ab0,
+0x00000620, 0x00000000, 0x22290000, 0x01b600ed, 0x270807d3, 0x0400e103,
+0x40061003, 0x00e1201b, 0x08100224, 0xed003844, 0x91030408, 0x003e6402,
+0x07b400a1, 0x00400810, 0x00000400, 0x00000000, 0x10c22804, 0x0b34060d,
+0x20413cd0, 0x640dc110, 0x40101015, 0x00c10417, 0x2d100b12, 0xc5023040,
+0x906f0400, 0x01f2404d, 0x06740081, 0x10502890, 0x00000c20, 0x00000000,
+0x0345a815, 0x077c025f, 0x37482df0, 0xdc82d320, 0xc455160f, 0x00c30037,
+0x6d300324, 0xdd003440, 0xb4074d00, 0x41f2c02d, 0x167c0053, 0x54c0ad30,
+0x00000620, 0x00000000, 0x00070001, 0x017c084f, 0xa5c085f0, 0x7c00df00,
+0xc005f009, 0x40df00b7, 0x0df0037c, 0xcf0037c0, 0x70017c00, 0x00a5c42d,
+0x037c005f, 0x07c00874, 0x00000c00, 0x00000000, 0x30cf0880, 0x43cc0873,
+0x5fc04ff0, 0xcc804300, 0xc097a003, 0x00f70067, 0x8f3043ec, 0xdf007cc1,
+0x30038d01, 0x003cc05f, 0x22fc0033, 0x00c00f30, 0x00000c22, 0x00000000,
+0x00c62081, 0x01442311, 0xc7411dd0, 0x440fd500, 0x4011b029, 0x01d10027,
+0x1d100e55, 0xdd007452, 0x50034401, 0x41b5424d, 0x03740115, 0x05400910,
+0x00000802, 0x00000000, 0x00b0a001, 0x03441011, 0x334009d0, 0x44009122,
+0x4001d00b, 0x84d52627, 0x0d106344, 0xd5293640, 0x18234428, 0x0034420d,
+0x02740851, 0x04404910, 0x00000200, 0x00000000, 0x00102010, 0x01050001,
+0x33400890, 0x0500c500, 0x4000d001, 0x00c50023, 0x0c100304, 0xcd803000,
+0x19030400, 0x0034400c, 0x032400c1, 0x41400c14, 0x00000080, 0x00000000,
+0x0026b000, 0x034c0011, 0x1fc00df0, 0x4d00d300, 0xc001f001, 0x40d70007,
+0x0d30034c, 0xdf003680, 0x34034c00, 0x0034c00d, 0x02bc0093, 0x00c00930,
+0x00000ac0, 0x00000000, 0x000fb805, 0x01fc003f, 0x1fc007f0, 0xfc003f00,
+0xc203a000, 0x00fb000f, 0x0ff003fc, 0xff003fc0, 0xf003fc00, 0x003bc00f,
+0x03fc00bf, 0x17c00ff0, 0x00000e60, 0x00000000, 0x113ba003, 0xa3ac0023,
+0x3ec08fb0, 0x7c003f00, 0xc04ff080, 0x44f9203e, 0x0f9013ec, 0xbf011fc0,
+0xf012ec00, 0x013ec04f, 0x03cc00ff, 0x0cc00fb0, 0x00000e00, 0x00000000,
+0x03370801, 0x1bf40411, 0x30c0ef10, 0x44004d00, 0x402e1080, 0x0af1203c,
+0x2f500bcc, 0x41021040, 0x10090402, 0x25bc40af, 0x035400dd, 0x04400c10,
+0x00000c20, 0x00000000, 0x0433a031, 0x0b341001, 0x32400cd0, 0x24400500,
+0x408c9001, 0x00c92032, 0x2cd10b24, 0x09103240, 0x920a2488, 0x08b2480c,
+0x034401cd, 0x44414d90, 0x00000e80, 0x00000000, 0x0075a803, 0x03760011,
+0x74400d10, 0x44905d10, 0x400d12c1, 0x00d18835, 0x0d500344, 0xd1003442,
+0x10014400, 0x8036400d, 0x035401dd, 0x0c401d11, 0x00000620, 0x00000000,
+0x0147a802, 0x037c0111, 0x36c00df0, 0x68021700, 0xc40db008, 0x80db0036,
+0x0db1036c, 0x3b101ec8, 0xb002ec02, 0x1036c20d, 0x070c00dd, 0x08d01db0,
+0x00000e20, 0x00000000, 0x00098007, 0x03fc05bf, 0x2fc00db0, 0x4c00ff00,
+0xe00fb080, 0x40ff043e, 0x0fb043fc, 0xfb001ec4, 0xb001fc00, 0x083dc00f,
+0x4bfc70ff, 0x1fc00ff0, 0x00000600, 0x00000000, 0x00250802, 0x137d001f,
+0x24c00d70, 0x5c821703, 0xc90d3049, 0x00d30235, 0x0d30036c, 0x1d0036c0,
+0x70127c00, 0x1334c00d, 0x035c00db, 0x09c20d72, 0x00000420, 0x00000000,
+0xc0b4a013, 0x83d409d1, 0xe5400e12, 0x4401d120, 0x682fb009, 0x85f120bc,
+0x1f101be4, 0xd500b442, 0x10494c03, 0x00fc50bf, 0x1f4403c8, 0x4c400c92,
+0x00000200, 0x00000000, 0x2232a007, 0xa7742305, 0xb0400c50, 0x54109580,
+0x443d110a, 0x93d10035, 0x2d100b44, 0x15015445, 0x400a5410, 0x00b0400d,
+0x031403c1, 0x1d400cd0, 0x00000a00, 0x00000000, 0x2af88004, 0x07a40131,
+0x79401e12, 0x942de111, 0x405e91c6, 0x01f1007c, 0x5f1027c4, 0xe1105862,
+0x10058421, 0x0038421c, 0x27c43df1, 0x10401e90, 0x00000200, 0x00000000,
+0x02301012, 0x033d1005, 0x30c20c70, 0x1c1c8700, 0x435c3017, 0x00c32831,
+0x1c30a72e, 0x070630c1, 0x70021c10, 0x0374c1cc, 0x0b1c0ccb, 0x49c00c70,
+0x00000040, 0x00000000, 0x4a3db802, 0x03dc0037, 0x3fc10ff0, 0xec0cfd21,
+0xc00ff013, 0x18e7063b, 0x0ef203bc, 0xf70035c0, 0xe025fc80, 0x13b7c18f,
+0x033c2ecf, 0x0bc80f70, 0x00000660, 0x00000000, 0x10272015, 0x135c0013,
+0x31426d70, 0x4c009300, 0x80cd1212, 0xc4db0132, 0xed70436c, 0x1b2016c0,
+0x33024d01, 0x00f7c44d, 0x2f0c08d3, 0x57040d32, 0x00000e00, 0x00000000,
+0x00290812, 0x4bb400a0, 0x2ac14c10, 0x1420c100, 0x410ce042, 0x14c51438,
+0x0e100b8d, 0xc9001849, 0xb0010c20, 0x1933414e, 0x538504eb, 0x4a402e50,
+0x00000620, 0x00000000, 0x28610003, 0x07343120, 0x7f401ed0, 0xa441a908,
+0x445e9087, 0x85e1217e, 0x5ed10704, 0x2d007b44, 0xd806a401, 0x0279405e,
+0x578491e9, 0x0f401e12, 0x00000400, 0x00000000, 0x10632812, 0x03340181,
+0x20400c90, 0x3412c900, 0x400c1003, 0x00c50030, 0x0c910304, 0xcd003240,
+0xd0010400, 0x0033400c, 0x030400c9, 0x4a401d50, 0x00000c20, 0x00000000,
+0x415d8817, 0x017c0361, 0x5f4005f0, 0x6d025b84, 0xc0058401, 0x4073001e,
+0x06f201c8, 0x5f0017c0, 0xf001ec02, 0x801dc007, 0x00cc0039, 0x5fc50330,
+0x00000620, 0x00000000, 0x00470012, 0x083c011f, 0x87c80170, 0x5c000740,
+0xc820f000, 0x40170885, 0x2172085c, 0x3b0085c8, 0xb100fe24, 0x1087c800,
+0x887c4217, 0x4ac801f0, 0x00000c00, 0x00000000, 0x00230810, 0x066c0193,
+0x65c01930, 0x0c009351, 0xc2395002, 0x248710e2, 0x0936020c, 0x9f0064c2,
+0x12023c00, 0x20249809, 0x405c101f, 0x40c001f0, 0x00000c20, 0x00000000,
+0x08262001, 0x46440a91, 0x2040a834, 0x6c1b9300, 0x4019706e, 0x07914024,
+0x0930424c, 0x9d1626d0, 0x30027600, 0x14244809, 0x6c4c1307, 0x06c00170,
+0x00000800, 0x00000000, 0x00648018, 0x12642291, 0x25400919, 0xd4009984,
+0x40099002, 0x00958026, 0x49101254, 0xfd202440, 0xd01af406, 0x01244269,
+0x0054041d, 0x604409d2, 0x00000200, 0x00000000, 0x08202010, 0x42040891,
+0xa444c818, 0xb606a100, 0x406c150a, 0x228000b0, 0x6d100a05, 0xa900a040,
+0x540ab442, 0x02204228, 0x2204089d, 0x42408843, 0x00000080, 0x00000000,
+0x4386b01d, 0x286c0211, 0x05404530, 0xd4241900, 0xc1413010, 0x10150006,
+0x4010404c, 0x1d000440, 0xf000f480, 0x0504c841, 0x585c161e, 0x74c161e0,
+0x00000ac0, 0x00000000, 0x432f9819, 0x127c04bf, 0x2f8889d0, 0x64029f08,
+0xc409f222, 0x009f20a7, 0x89700270, 0x9f00a7c0, 0xb00a7c02, 0x11278289,
+0x12dc04a6, 0x67c04bf0, 0x00000e60, 0x00000000, 0x01afa018, 0x42ec02b3,
+0x27c14b30, 0x4c009f00, 0xc0c97132, 0x169b0424, 0x49709a4c, 0x9c2165c8,
+0x301e5c07, 0x08a4c089, 0x1ebc01b3, 0x62c199e0, 0x00000e00, 0x00000000,
+0x0117081c, 0x08450411, 0x04406111, 0x140c1709, 0x44215000, 0x46010100,
+0xe1301804, 0x19039450, 0xb0287e0a, 0x014c4000, 0x14741515, 0x704021d0,
+0x00000c20, 0x00000000, 0x01a3a010, 0x52040085, 0x29030850, 0x8490ad04,
+0x40ca1832, 0x04a96428, 0x0a503284, 0xad042851, 0x12028400, 0x81af486a,
+0x1a34028d, 0x424049d0, 0x00000e80, 0x00000000, 0x0025a818, 0x03440091,
+0x24400952, 0xd420fd00, 0x400b5012, 0x40b1002c, 0x0b9103d4, 0xb9102c40,
+0x9002f450, 0xc02f400b, 0x0074801d, 0x604009d0, 0x00000620, 0x00000000,
+0x42a7a805, 0x02440093, 0x65400944, 0x4c809d02, 0x50097002, 0x009b0024,
+0x09700245, 0x9d00a4c0, 0x10024402, 0x2027d009, 0x6c7c041b, 0x16c018f0,
+0x00000e20, 0x00000000, 0x00618014, 0x021c059f, 0x25c009b0, 0x7c208700,
+0xc008f002, 0x408f8027, 0x0930826c, 0x9b0826ce, 0xf4022c80, 0x2824c008,
+0x007c4413, 0x53c089f0, 0x00000600, 0x00000000, 0x40840814, 0x04741013,
+0x0ce441b1, 0xbc003300, 0xc0037010, 0x0037290b, 0x427a00b8, 0x23418cc0,
+0x3000fc18, 0x000dc083, 0xc87c0013, 0x52c00130, 0x00000420, 0x00000000,
+0x221ca014, 0x09f41171, 0x16512713, 0x74095110, 0x45855041, 0x095100d7,
+0x0510094c, 0x5100d551, 0x12057402, 0x005008a5, 0x44f40a33, 0x50420510,
+0x00000200, 0x00000000, 0x0072a014, 0x013402d1, 0x3b401dd0, 0xb422e100,
+0x403ed00f, 0x43e500fb, 0x3e504b94, 0xe1007a48, 0x144bb621, 0x0039401e,
+0x0334c1cd, 0x50400c90, 0x00000a00, 0x00000000, 0x00988005, 0x13b400e1,
+0x7f4c8c50, 0xb422e140, 0x400ed203, 0x70e1043b, 0x0c1003b4, 0xe1047a40,
+0x1243b600, 0x00b0400e, 0x17b406e5, 0x14488f90, 0x00000200, 0x00000000,
+0x407c1015, 0x0d3c0163, 0x78405ef0, 0xbe41e300, 0xc01ef107, 0x01e7007b,
+0x1e52079c, 0xe20072c0, 0x34073c01, 0x3079c01e, 0x5fbc13ee, 0x54905eb0,
+0x00000040, 0x00000000, 0x0805b810, 0x057c009f, 0x00000d20, 0x7c001f10,
+0xc0012000, 0x001f0007, 0x01f00140, 0x1f0805c0, 0xf0007c00, 0x004fc001,
+0x837cc6db, 0x41c46c77, 0x00000660, 0x00000000, 0x026ba000, 0x05fc01b3,
+0x7fc01730, 0xcc09fb00, 0xc21f3207, 0x05db007f, 0x1eb007bc, 0xf3007cc0,
+0x3027d401, 0x0278c0de, 0x27fc81f3, 0x00c03ef0, 0x00000e00, 0x00000000,
+0x37298835, 0x01f40020, 0x3f408610, 0x9408e102, 0x400c5023, 0xa5ed013b,
+0x1c109334, 0xeb0938c8, 0xb073ac82, 0x2870408e, 0x0fb405e1, 0x54404ed0,
+0x00000620, 0x00000000, 0x082d0000, 0x01b41060, 0x3a400e10, 0x0600e900,
+0x408e9003, 0x24e9203b, 0x0f1303e4, 0xe1103240, 0x13030400, 0x007c444f,
+0x53b414ed, 0x00680fd3, 0x00000400, 0x00000000, 0x10372804, 0x01340301,
+0x03400c10, 0x14010102, 0x4000d000, 0x800d0003, 0x00100134, 0x09000040,
+0x90082405, 0xa8004000, 0x0f3423cd, 0x10420cd0, 0x00000c20, 0x00000000,
+0x0075a815, 0x01fc22d3, 0x76c00f34, 0x4419db00, 0x420d9203, 0x00db0037,
+0x0d10027c, 0xd10036c0, 0x320f4c13, 0x0038c40d, 0x037c80dd, 0x54d31ff0,
+0x00000620, 0x00000000, 0x10b70001, 0x887c00df, 0x17c02cf0, 0x7c42df00,
+0xc02d700b, 0x00cf08b7, 0x0d720274, 0xdf0037c8, 0xf2137c00, 0x0037c00d,
+0x0b7c00d3, 0x07c00df1, 0x00000c00, 0x00000000, 0x803f0880, 0x04cc1073,
+0x2dc03ff0, 0x8e01c300, 0xc09e7023, 0x09ff203e, 0x0ef202c8, 0xcc08bc18,
+0x3007ac01, 0x093cc00e, 0x57fc31f1, 0x03c00ff0, 0x00000c22, 0x00000000,
+0x04f62081, 0x24440091, 0x30405dd0, 0x44021106, 0x4061b1c0, 0x061d0245,
+0x01d02444, 0x1d000442, 0xb0404401, 0x004450e1, 0x0b7442d1, 0x07400dd0,
+0x00000802, 0x00000000, 0x4074a001, 0x01448089, 0x376409d0, 0x64081108,
+0x40011080, 0x001d0406, 0x61d28054, 0x1d088540, 0x12104404, 0x68264801,
+0x037406d5, 0x07440dd0, 0x00000200, 0x00000000, 0x00302010, 0x80040009,
+0x166008d0, 0x04000140, 0x4000da08, 0x000d0001, 0x00d32015, 0x0d000141,
+0x90000420, 0x80264000, 0x033400c5, 0xc3480cd0, 0x00000080, 0x00000000,
+0x0036b000, 0x004c0059, 0x25c00df0, 0x6d001300, 0xc8817008, 0x011d0006,
+0xf1f80858, 0x1f0005c0, 0x30006d00, 0x02668001, 0x877c01d7, 0x03c00ff0,
+0x00000ac0, 0x00000000, 0x003fb805, 0x00fc0037, 0x3dc00fd0, 0xfc00ff00,
+0xe81fb817, 0x08ff083e, 0x1df006ec, 0xff803ec2, 0xf003fc00, 0x0255c80f,
+0x237c08db, 0x17c20ff0, 0x00000e60, 0x00000000, 0x000f8003, 0x03ec20f3,
+0x3cc00eb0, 0xfc043300, 0xc002f002, 0x0433023e, 0x0f3203cc, 0xff0038c0,
+0xf000ec08, 0x007cc01f, 0x17cc01e3, 0x0cc00f30, 0x00000e00, 0x00000000,
+0x00070001, 0x03c400e1, 0x34400d90, 0x748a1100, 0x4061d003, 0x0011023c,
+0x0f10eb45, 0xfd003441, 0xd0084506, 0x009440a9, 0x21440211, 0x04482f10,
+0x00000c20, 0x00000000, 0x0003a011, 0x031400c9, 0x32400016, 0x34000d00,
+0x4120d103, 0x08052021, 0x4c910314, 0xcd002160, 0xd0080408, 0x02304208,
+0x060408c1, 0x44502c10, 0x00000e80, 0x00000000, 0x0005a803, 0x475500c9,
+0x36400590, 0x74015d00, 0x4009d007, 0x00150025, 0x0d900254, 0xdd00a540,
+0xd0084600, 0x44045105, 0x04440251, 0x0c400d90, 0x00000620, 0x00000000,
+0x04c7a802, 0x0f7c20db, 0x36c12db0, 0x7c201f40, 0xc101f003, 0x0517007d,
+0x0db4035c, 0xdf0255d0, 0xf0006c40, 0x0024d005, 0x034c09d3, 0x08c40d30,
+0x00000e20, 0x00000000, 0x10c58007, 0x024c10f7, 0x7dc85f70, 0xf4007301,
+0xd20bf383, 0x054b9278, 0x0e7027ec, 0xef003ed0, 0xf011fc00, 0x027bc249,
+0x02bd21ef, 0x1f000d76, 0x00000600, 0x00000000, 0x00b10802, 0x0b6d00d3,
+0x24c089b0, 0x4d001f00, 0xc125f003, 0x08d30024, 0x0df0024c, 0xd301e4c0,
+0x300a6c08, 0x0084c040, 0x014c0053, 0x08c00df0, 0x00000420, 0x00000000,
+0x0034a013, 0x2f4402f1, 0xb440ad10, 0x6c2b5d0b, 0x002cd013, 0x01d00424,
+0x1fd02a40, 0xfb006444, 0x1003450a, 0x02844055, 0x28441111, 0x4c400fd0,
+0x00000200, 0x00000000, 0x0032a007, 0x034488c9, 0x34401d91, 0x04000d00,
+0x4800d013, 0x01090060, 0xbcd00744, 0xc100a241, 0x90040401, 0x08b04008,
+0x030401c1, 0x1c400dd2, 0x00000a00, 0x00000000, 0x00788804, 0x078401e9,
+0x78405f18, 0xa4112d00, 0x5012d027, 0x01691060, 0x1cd10784, 0xc9086a40,
+0x92008409, 0x0070501a, 0x068401a1, 0x10400ed1, 0x00000200, 0x00000000,
+0x40000012, 0x410c04cb, 0x30c00cb0, 0x0d005f20, 0xc048d003, 0x00cb0830,
+0x0cf2720d, 0xc30032c0, 0xb0624e20, 0x0000c000, 0x010c0003, 0x48c08cf0,
+0x00000040, 0x00000000, 0x000da802, 0x2bde00f7, 0x3fc04ff0, 0xfe027f00,
+0xc00bf00b, 0x00d70277, 0x8ff022fc, 0xff001dc1, 0x7012dc02, 0x401fc08b,
+0x00fc003f, 0x0bc04ff0, 0x00000660, 0x00000000, 0x0077a015, 0x137c04d7,
+0x34c00c30, 0x3c005f00, 0xc0083003, 0x01130124, 0x0df0034c, 0xdf0024c0,
+0x30004d0a, 0x0034c009, 0x437c0092, 0x57c04df0, 0x00000e00, 0x00000000,
+0x20398812, 0x038412f1, 0x38400e90, 0xb4006720, 0x400ab003, 0x00214428,
+0xced003ac, 0xcd002844, 0xb001ec24, 0x40084002, 0x01b44021, 0x4b410ed0,
+0x00000620, 0x00000000, 0x00790003, 0x059405e5, 0x78401f90, 0xb4016d00,
+0x481e1807, 0x01818070, 0x5cd00684, 0xed007940, 0x900f8461, 0x00684012,
+0x06b401e1, 0x0f409ed0, 0x00000400, 0x00000000, 0x02b32812, 0x071400c1,
+0x30400c90, 0x3401450a, 0x409c9003, 0x0b810030, 0x0dd02766, 0xcd019540,
+0x90072500, 0x01c84002, 0x00b40321, 0x4b400cd0, 0x00000c20, 0x00000000,
+0x001da817, 0x41fd0057, 0x54d02734, 0x7c005f00, 0xd0373001, 0x00734014,
+0x05f0014c, 0x5f009dd0, 0xb00dcc00, 0x0154d025, 0x017e1253, 0x5fc005f0,
+0x00000620, 0x00000000, 0x24070012, 0x006c001f, 0x07c00170, 0x7c081f08,
+0xc011f008, 0x041f0003, 0x21f0087c, 0x1f008680, 0xf2047c00, 0x0007c101,
+0x047c101f, 0x4bc801f0, 0x00000c00, 0x00000000, 0x00270810, 0x024c009f,
+0x244109f0, 0x4c00d100, 0xc0083413, 0x00934024, 0x8932027c, 0x834026c0,
+0x70060c00, 0x0020d009, 0x023c0093, 0x43c00930, 0x00000c20, 0x00000000,
+0x08262001, 0x0244009d, 0x24500915, 0x05009140, 0xc0b91002, 0x08910025,
+0x29120a74, 0x9100e445, 0x10064508, 0x00a44108, 0x0a740091, 0x07400914,
+0x00000800, 0x00000000, 0x0024a018, 0x0204008d, 0x21400812, 0x44208500,
+0x40091002, 0x00910026, 0x09900274, 0x91006640, 0xd0124400, 0x00ac4009,
+0x0af408b1, 0x63400910, 0x00000200, 0x00000000, 0x02202010, 0x2204088d,
+0x21408898, 0x06088502, 0x40881003, 0x00816221, 0x88957234, 0x8100a040,
+0x9022040c, 0x0028400a, 0x02b400a1, 0x43404810, 0x00000080, 0x00000000,
+0x0582301d, 0x5804021f, 0x85c22170, 0x4c161700, 0xc1653000, 0x14130586,
+0x61b0197c, 0x130016c1, 0xf2584c03, 0x4004c401, 0x80fc0013, 0x77c0b130,
+0x00000ac0, 0x00000000, 0x012db819, 0x92fd069f, 0x2ec04b70, 0x7c049b01,
+0xc04bf202, 0x80bf012f, 0x497012fc, 0x9f002fc0, 0x7212fc0c, 0x00a3c028,
+0x0a7c029f, 0x67c099f0, 0x00000e60, 0x00000000, 0x0027a018, 0x527c109f,
+0x20c209b0, 0xfc049b0a, 0xc10bb003, 0x04b300ef, 0x6b7042cc, 0xbf002cc0,
+0xf002fc04, 0x0024c00b, 0x034c0093, 0x60c0c930, 0x00000e00, 0x00000000,
+0x22c7081c, 0x0d64431d, 0x44411012, 0x741f3100, 0x40211000, 0x001100c7,
+0x01100844, 0x070006c0, 0xd0007440, 0x40044001, 0x00448011, 0x70400114,
+0x00000c20, 0x00000000, 0x0423a010, 0x42d650ad, 0x2b420a10, 0x3404a100,
+0x41489002, 0x038101a3, 0x28d05224, 0x8d056048, 0xd04a3402, 0x00204008,
+0x82058081, 0x42406810, 0x00000e80, 0x00000000, 0x08258818, 0x02f600bd,
+0x2f426a14, 0x7600b101, 0x40099202, 0x40910127, 0x09960264, 0x95006640,
+0xd0027400, 0x04244009, 0x02441091, 0x62400810, 0x00000620, 0x00000000,
+0x01e7a805, 0x0e5c209f, 0x27c00930, 0x3c099340, 0xc1a9b006, 0x83934027,
+0x08f4262c, 0x9f0024c0, 0xd0127c00, 0x02e4d139, 0x464c0a93, 0x16500930,
+0x00000e20, 0x00000000, 0x3d650014, 0x0a4c009f, 0x64d00971, 0x7c019f00,
+0xc0097026, 0x059f0027, 0x0970025c, 0x9f0027c0, 0xf00e7c00, 0x0477c088,
+0x137c00cf, 0x51c009f0, 0x00000600, 0x00000000, 0x30850814, 0x08fc002f,
+0x0cc82334, 0x4c003340, 0xc0813000, 0x00030003, 0x1130004d, 0x1f0a44d0,
+0xb0284c10, 0x4000c021, 0x100c0013, 0x50c00130, 0x00000420, 0x00000000,
+0x00942014, 0x0134005d, 0x14100518, 0xc4005300, 0x40075001, 0x01730017,
+0x271001c4, 0x7d009c50, 0x30054600, 0x08944427, 0x09440051, 0x50c00510,
+0x00000200, 0x00000000, 0x00b2a014, 0x031480cd, 0x34400c12, 0x2400c500,
+0x401c1005, 0x00890073, 0x0c104e04, 0xcd003248, 0x90061401, 0x00304938,
+0x00060081, 0x50400c14, 0x00000a00, 0x00000000, 0x00388005, 0x00b4402d,
+0x0c400210, 0xa4012108, 0x40065009, 0x11e100bb, 0x4e100e84, 0xad023a40,
+0x9006c403, 0x00304028, 0x028402e0, 0x16404e10, 0x00000200, 0x00000000,
+0x00781015, 0x07dc41ef, 0x78c01e10, 0xad01c720, 0xc0163006, 0x00c94073,
+0x3c3402cc, 0xef007ad0, 0xb1069501, 0x0078c012, 0x060c01c3, 0x54d05f30,
+0x00000040, 0x00000000, 0x0035b810, 0x807c001f, 0x07c001f0, 0x1ca01700,
+0xc005f000, 0x20df0036, 0x1df0027c, 0xdb1035c0, 0x70023c00, 0x01b7d009,
+0x1a7d06df, 0x41c16df0, 0x00000660, 0x00000000, 0x005fa000, 0x87dc01f3,
+0x7cc01f70, 0x8c81f300, 0xc09f7004, 0x01f3007c, 0x1f3007cc, 0x3f007cc0,
+0xf007cc01, 0x21bcc01b, 0x0ccc03f7, 0x00c11ff0, 0x00000e00, 0x00000000,
+0x02198815, 0x40840021, 0x08400334, 0x84002100, 0x40273011, 0x10a34128,
+0x2fb141c4, 0xed000840, 0xd022ac04, 0x02b8420a, 0x628408ed, 0x56c00ed0,
+0x00000620, 0x00000000, 0x00190000, 0x231400c1, 0x38418e50, 0xb400e906,
+0x48025002, 0x00a18038, 0x06d00184, 0x2d003940, 0xd002a400, 0x04384008,
+0x028400e5, 0x00400cd0, 0x00000400, 0x00000000, 0x88132804, 0x1c140001,
+0x00480110, 0x34410900, 0x41001020, 0x00892024, 0x04d20504, 0x8d008140,
+0xd8262480, 0x00f04208, 0x0a040acd, 0x12400cd0, 0x00000c20, 0x00000000,
+0x4035a815, 0x0b5c80d3, 0x74d00d70, 0x3d10db40, 0xe2247005, 0x00938824,
+0x0ff2024c, 0xcf003dd0, 0xf0070c00, 0x0074c1b0, 0x0c4d00d7, 0x54c00ff0,
+0x00000620, 0x00000000, 0x00370001, 0x006c001f, 0x07c40170, 0x4c001720,
+0xe0057001, 0x20d78027, 0x2ca0037c, 0x1f00b640, 0xf0037c00, 0x24b3d025,
+0x107c30cf, 0x07c00df0, 0x00000c00, 0x00000000, 0x003f0880, 0x038c00e3,
+0x3cc00fb0, 0xf400ff00, 0xc8333306, 0x00f34224, 0x5f30028c, 0xbf040ec0,
+0x300fec00, 0x003cc083, 0x00cc00db, 0x00c00e30, 0x00000c22, 0x00000000,
+0x003e2081, 0x00d40031, 0x0c500310, 0x74003900, 0x500110a0, 0x80c1002c,
+0x29500744, 0x1d000440, 0x50075c00, 0x00b54135, 0x080009d0, 0x06c00d10,
+0x00000802, 0x00000000, 0x4010a001, 0x036400d1, 0x34400d90, 0x7400dd90,
+0x40051001, 0x00d90024, 0x0d120754, 0x1d00f440, 0x10034406, 0x00344005,
+0x084400d1, 0x04400d10, 0x00000200, 0x00000000, 0x00102010, 0x00340001,
+0x00480010, 0x74000980, 0x40051101, 0x00894030, 0x04500104, 0x4d000050,
+0x5a035400, 0x40314004, 0x020500c1, 0x42400c14, 0x00000080, 0x00000000,
+0x0012b000, 0x034c00d3, 0x30c00db0, 0x7c00cf00, 0x40013002, 0x009b0024,
+0x0532015c, 0x5f0004d0, 0x30034400, 0x2034c005, 0x024c00d3, 0x00c00f30,
+0x00000ac0, 0x00000000, 0x001fb805, 0x00dc203f, 0x0fc203f0, 0xfc003f00,
+0xc203f100, 0x00a7203f, 0x0bf001fc, 0x6f000fc0, 0xf003fc00, 0x001fc007,
+0x02fc00f7, 0x17c00ff0, 0x00000e60, 0x00000000, 0x003f8003, 0x5bcc1033,
+0x2cc04f70, 0xdc003701, 0xc203f013, 0x40eb023e, 0x0e7183c4, 0x331038c0,
+0x9023ec08, 0x083ce40f, 0x03dc00ef, 0x0fc00ff1, 0x00000e00, 0x00000000,
+0x00330001, 0x0bc40601, 0xb4416e10, 0xe8001b02, 0x4001d00b, 0x0a510134,
+0x0d100344, 0x1109bd48, 0xd09b9404, 0x2034500d, 0x034422fd, 0x07414c10,
+0x00000c20, 0x00000000, 0x0537a011, 0x120410c5, 0x10408c51, 0x04000500,
+0x4000d223, 0x80490133, 0x1cd20704, 0x8904b042, 0xd00b0400, 0x0871401c,
+0x036408dd, 0x47401c90, 0x00000e80, 0x00000000, 0x0065a803, 0x02041815,
+0x34400d10, 0x45801500, 0x4081d003, 0x08512034, 0x1d980744, 0x99203542,
+0xd0035408, 0x0075401d, 0x036100dd, 0x0f401d12, 0x00000620, 0x00000000,
+0x0033a802, 0x074d0317, 0x44d00d50, 0x44039502, 0xc731f003, 0x115b2037,
+0x0cf0034d, 0x5b403444, 0xf0034442, 0x0035400c, 0x6f2e00df, 0x03c00db2,
+0x00000e20, 0x00000000, 0x402d8027, 0x27fc013b, 0x5bc00ef0, 0xec09bb00,
+0xc406f083, 0x11bf003f, 0x0f7003fc, 0x77203bc8, 0xf003dc01, 0x003ec00f,
+0x03cca0ff, 0x1fc00fb0, 0x00000602, 0x00000000, 0x02350802, 0x024d02c7,
+0xb4d00d34, 0x5c085f00, 0xc1013023, 0x0a5f0034, 0x8d71235c, 0xd3103644,
+0x32035c02, 0x0037c8cd, 0xc34c00d3, 0x08c40d70, 0x00000420, 0x00000000,
+0x0064a013, 0x02440a11, 0x3c400f10, 0xfc0a7108, 0xc05b102b, 0x021d013e,
+0xad102b04, 0xb1003c40, 0x1003ec00, 0x00f7463d, 0x0f4507e1, 0x4ec20d10,
+0x00000200, 0x00000000, 0x0072a007, 0x82240005, 0x22400c90, 0x04015500,
+0x401c1007, 0x039d21f4, 0x1cd00714, 0x11003248, 0x10031460, 0x4433442c,
+0x231404c9, 0x1c400c50, 0x00000a00, 0x00000000, 0x00788004, 0x262401e1,
+0x7e481e12, 0xe6057188, 0x54181027, 0x013d0078, 0x1fd007c4, 0x31027842,
+0x14079401, 0x127f401e, 0x078409e9, 0x1a401e10, 0x00000200, 0x00000000,
+0x02300012, 0x232400c7, 0x92c04cb0, 0x0c028700, 0x400c3203, 0x008e0030,
+0xcce0031c, 0x034032c0, 0x30031002, 0x0573c00c, 0x231c00ca, 0x48c00c71,
+0x00000040, 0x00000000, 0x002db802, 0x27cc08ff, 0xb9c02ff0, 0x3c24a700,
+0xc187f4c3, 0x00bf003e, 0xaf2023bc, 0xaf38b7c0, 0xf003ec08, 0x003bc02d,
+0x433c00d7, 0x0bc0aff0, 0x00000660, 0x00000000, 0x0037a015, 0x126c001f,
+0x75c03d70, 0x481cd300, 0x450db113, 0x00572034, 0x6d70137c, 0x1328b7c4,
+0x32136c00, 0x0977c88d, 0x134c10c3, 0x54c0adf0, 0x00000e00, 0x00000000,
+0x00398812, 0x220400ed, 0x78404f10, 0x0404f101, 0x404e1233, 0x00a100bd,
+0x4e1133bc, 0x23013f40, 0x505ba440, 0x04bb404e, 0x238502e3, 0x48400fd0,
+0x00000600, 0x00000000, 0x00790003, 0x078401cd, 0x79409e50, 0xa505e903,
+0x021e9007, 0x03e51178, 0xbe5077a4, 0xb9427b40, 0x50179418, 0x407e411e,
+0x17a401f1, 0x0e405ed0, 0x00000402, 0x00000000, 0x00632812, 0x030400dd,
+0x31400c10, 0x2482c970, 0x409d9003, 0x01810030, 0x0c900314, 0x81003340,
+0x50031401, 0x0033403c, 0x032440c1, 0x4a401cd0, 0x00000c20, 0x00000000,
+0x0015a817, 0x014dc07f, 0x55c40575, 0xec015b03, 0xd885b001, 0x0275101c,
+0x037000f4, 0x790817c0, 0x70017c03, 0x060fc033, 0x60e00073, 0x5ed183d2,
+0x00000620, 0x00000000, 0x12070012, 0x005c001f, 0x06c001f4, 0x5c0c1780,
+0xc0017200, 0x411f0087, 0x4173007c, 0x170007c8, 0xf2006c01, 0x0087c021,
+0x005c0017, 0x49d001f0, 0x00000400, 0x00000000, 0x40a70810, 0x020c0093,
+0x35c40930, 0x4c00df00, 0xc00db002, 0x05970164, 0x8172607c, 0x93402742,
+0x70020c00, 0x0007c111, 0x084d008e, 0x40d00150, 0x00000c20, 0x00000000,
+0x00a20001, 0x02450091, 0xa5c00914, 0x45009d00, 0xc0090402, 0x029511e0,
+0x31100c34, 0x95002744, 0x30026c00, 0x00c5c231, 0x0004039d, 0x04480011,
+0x00000080, 0x00000000, 0x00a42018, 0x02440191, 0x25400914, 0x14008d04,
+0x40095002, 0x82950026, 0x01504076, 0x8d002341, 0xd0025400, 0x010760a1,
+0x0065069d, 0x62400150, 0x00000200, 0x00000000, 0x0a242010, 0x32040881,
+0x21406894, 0x16048d00, 0x406850a2, 0x088120a0, 0x88102274, 0x81012342,
+0x10a2340c, 0x02214088, 0x2304088c, 0x42480952, 0x00000080, 0x00000000,
+0x0086901d, 0x10441613, 0x01c44130, 0x5c481f04, 0x40407050, 0x30148946,
+0x61705876, 0x1f8307c5, 0x70501c15, 0x0597c161, 0x586c121d, 0x76c3c170,
+0x00000a80, 0x00000000, 0x012fb819, 0x0afc04bf, 0x27c26972, 0x6c2c9d04,
+0xd069b092, 0x80bf0327, 0x4b5112be, 0xafb32740, 0xf0126c04, 0x012bc24b,
+0x92fc049f, 0x65c04bb0, 0x00000e60, 0x00000000, 0x802fa018, 0x227c10bf,
+0x25c08938, 0x7c109702, 0xc8893012, 0x00bf152c, 0x5bf216dc, 0x9301a4c1,
+0xf0a25c86, 0x256cc11b, 0x46cc00bf, 0x64c099b0, 0x00000e00, 0x00000000,
+0x0007081c, 0xa874021d, 0x8440a110, 0x74221108, 0x48a39400, 0x041d0d84,
+0x51d05445, 0x19010140, 0x90285604, 0x01c46031, 0x1d448b1d, 0x70400110,
+0x00000c22, 0x00000000, 0x0423a010, 0x1234148d, 0xa1404810, 0xf034a501,
+0x404a104a, 0x12cc2021, 0x48d03204, 0x8901a241, 0xd1122406, 0x0c225149,
+0x4244149d, 0xc04068d0, 0x00000e80, 0x00000000, 0x0025a818, 0x1234009d,
+0x20600910, 0xf400b124, 0x400b9002, 0x009d0824, 0x25d00044, 0x89082742,
+0x90027400, 0x28064001, 0x0047001c, 0x60418850, 0x00000620, 0x00000000,
+0x0227a805, 0x027c129d, 0xe5420930, 0x7c1b9720, 0x90592002, 0x869f8025,
+0x01d1105c, 0x934026c8, 0xf202740c, 0x11066241, 0x0444001d, 0x14d029f1,
+0x00000e20, 0x00000000, 0x00258014, 0x027c099f, 0x27c00974, 0x7c019f02,
+0xc0997002, 0xc08f2427, 0x41f0107c, 0x970021c8, 0xb1025c01, 0x0145c541,
+0x247c001f, 0x53c019b0, 0x00000600, 0x00000000, 0x01050814, 0x007c0413,
+0x06ca00b0, 0xcc023f08, 0xc002f000, 0x00170205, 0x01f0107c, 0x130007c1,
+0x30005220, 0x2387c801, 0x006c841b, 0x50c001f0, 0x00000420, 0x00000000,
+0x001ca014, 0x01740271, 0x14400510, 0x04005d00, 0x4005d001, 0x0071001c,
+0x52d100f4, 0x51001f42, 0x10014c00, 0x00cf4922, 0x64840121, 0x52c007d0,
+0x00000200, 0x00000000, 0x00b2a014, 0x033401c1, 0x32400c90, 0x0400cd00,
+0x420cd003, 0x00cd2070, 0x1cd80f14, 0xc5003340, 0x10033400, 0x0033403c,
+0x0b0503cd, 0x40600cd0, 0x00000a00, 0x00000000, 0x00688005, 0x23b41061,
+0x38400c10, 0x84000d00, 0x5000d000, 0x40690270, 0x8ed00bb4, 0xc5233a40,
+0x10078404, 0x007b408e, 0x038410e5, 0x06404fd0, 0x00000200, 0x00000000,
+0x407c1035, 0x07fc01a3, 0x5ac85eb4, 0x8c00ef10, 0x401ef087, 0x21ef0178,
+0x5ef00fbc, 0xe7007bc3, 0x30171007, 0x157b815e, 0x1f8c01cf, 0x44c4fef0,
+0x00000040, 0x00000000, 0x0025b810, 0x5b7cc01f, 0x15c0ad70, 0x7c001f00,
+0xc401f000, 0x00d70076, 0x4de0537c, 0xdb4437c0, 0xf02b7c62, 0x11b3c06d,
+0x035d06db, 0x43c00cf0, 0x00000660, 0x00000000, 0x005fa000, 0x17fca1f3,
+0x7cc03f30, 0xfc01f700, 0xc09fb007, 0x01f3007a, 0x9ff207cc, 0xf3007ec0,
+0x322f4c03, 0x2474c21f, 0x2fcc1bef, 0x08c01ff2, 0x00000e20, 0x00000000,
+0x10898815, 0x13bc88e1, 0x3ac00f10, 0xb4002b00, 0x40c21020, 0x086b0198,
+0x8ed00384, 0xf1003f4a, 0xb007c400, 0x0570400e, 0x03840ce1, 0x54400ed0,
+0x00000660, 0x00000000, 0x001d0000, 0x333400a9, 0x18400e50, 0xb400e500,
+0x440c9003, 0x10e1082e, 0x0ed00384, 0xe9003b42, 0x98038408, 0x0138500f,
+0x03a480f5, 0x00400ed0, 0x00000400, 0x00000000, 0x00432804, 0x03141389,
+0xd0400c10, 0x74801102, 0x4280d000, 0x91c10000, 0xacd16b05, 0xc9403340,
+0x10034400, 0x20f0423c, 0x6f2400c1, 0x48400cd0, 0x00000c00, 0x00000000,
+0x0435a815, 0x03f400db, 0x34500f60, 0x7840d510, 0xc00db003, 0x0180003a,
+0x3cf00744, 0xf9003fc0, 0x9603c502, 0x00f4401c, 0x0b6600c7, 0x44c1bfe1,
+0x00000600, 0x00000000, 0x50b70001, 0x037c0857, 0x37c80df4, 0x7c001f01,
+0xc1003000, 0x00df80a7, 0x2df2037c, 0xd70033c0, 0xf0837c0c, 0x1137c0cd,
+0x035d20d7, 0x27c00df0, 0x00000c00, 0x00000000, 0x004f0880, 0x03bc01ff,
+0x1ec00fb0, 0x4c00ff00, 0x800f3003, 0x40bf005c, 0x1fb003e0, 0xe3403ec1,
+0x9003cc00, 0x203ec80f, 0x07cc00ff, 0x94400ff0, 0x00000c00, 0x00000000,
+0x20060081, 0x0374205d, 0x14c00d10, 0x45001d00, 0x40011400, 0x01910245,
+0x9dd00354, 0xd1003540, 0x10036c00, 0x0034400d, 0x4b5500dd, 0x14400cd0,
+0x00000802, 0x00000000, 0x8234a001, 0x0374181d, 0x36400c90, 0x5400dd08,
+0x400d1003, 0x03950035, 0x0dd00754, 0xd1003640, 0xd0036400, 0x0074401d,
+0x134621dd, 0x05400dd0, 0x00000200, 0x00000000, 0x80302010, 0x0334000d,
+0x32400c10, 0x04000908, 0x40001000, 0x00910001, 0x0dd80714, 0xc1003040,
+0x10132420, 0x2570501c, 0x0304a1c9, 0x51400cda, 0x00000080, 0x00000000,
+0x0006b000, 0x03fc001f, 0x12c40fb1, 0x5c00df10, 0x400d3003, 0x40970005,
+0x0db0037e, 0xf3403ec8, 0xf007ec00, 0x0976c80d, 0x034c00df, 0x05c00ff0,
+0x00000ac0, 0x00000000, 0x000bb805, 0x03fc003f, 0x1de00ff0, 0xfc003f00,
+0xc003f000, 0x20a7003f, 0x0ff003dc, 0xff003fc0, 0xf20bfc00, 0x057be00e,
+0x03fc00ff, 0x06c80ef0, 0x00000e40, 0x00000000, 0x000fa003, 0x10fc243f,
+0x1fc00330, 0xcc003301, 0xc46f2070, 0x0033023c, 0x033000cc, 0xb3583cc4,
+0xb010cc40, 0x052fc00b, 0x03cc067f, 0x0cc08f30, 0x00000e00, 0x00000000,
+0x00070803, 0x28742a1d, 0x174005b0, 0x445ad102, 0x4089b01b, 0x40114231,
+0x0c100244, 0x91003040, 0x10281400, 0x04a74029, 0x13d4065d, 0x05404e10,
+0x00000c20, 0x00000000, 0x0003a013, 0x0210000d, 0x11600810, 0x05040148,
+0x404c1100, 0x00c12030, 0x0c100314, 0x85001140, 0x18001400, 0x09314028,
+0x4324024d, 0x44404c50, 0x00000e80, 0x00000000, 0x0115a803, 0x0574301d,
+0x17608d90, 0x4500d100, 0x640d9803, 0x00d100b5, 0x00100154, 0x85003550,
+0x10034404, 0x0037401d, 0x0374635d, 0x0d400c50, 0x00000620, 0x00000000,
+0x28a78882, 0x043c031f, 0x1dc12130, 0xcc003301, 0xe20d3400, 0x00932094,
+0x0534235c, 0x9704b5c0, 0xb04d5e00, 0x0227c009, 0x032c015f, 0x08c00d74,
+0x00000e20, 0x00000000, 0x0025800f, 0x01fc02ff, 0x1fc407d0, 0xbc00ff00,
+0xe00af043, 0x05af003f, 0x0ff0076c, 0xbb38bec0, 0xf421fd01, 0x042fc00b,
+0x03dc00ff, 0x1fc00fb1, 0x00000600, 0x00000000, 0x40850802, 0x005c00d3,
+0x13c009f0, 0x7c000700, 0xc40d7000, 0x02d34030, 0xad34023c, 0x970634c1,
+0xb4017c98, 0x4077c109, 0x035c43d3, 0x09c00d30, 0x00000420, 0x00000000,
+0x2014a01b, 0x097600d0, 0x95c05dd0, 0x7404d112, 0x405db003, 0x00f12036,
+0x05106274, 0x91c02440, 0x30817400, 0x00b74049, 0x6bc401d1, 0x4c400fb0,
+0x00000200, 0x00000000, 0x8212a007, 0x40241001, 0x730010d2, 0x34200980,
+0x401cd220, 0x06c10131, 0x18170d34, 0x81207700, 0x10126402, 0x0022442c,
+0x07140051, 0x1d480c16, 0x00000a00, 0x00000000, 0x0048800d, 0x04b409e1,
+0x714012d0, 0xb409e910, 0x401a9227, 0x21e1087b, 0x1e1007b4, 0xa1127a40,
+0x9006b401, 0x006b401e, 0x878409e1, 0x10401e95, 0x00000200, 0x00000000,
+0x01b01012, 0x011c00c1, 0x33c044f0, 0x3c000f44, 0xc08cf020, 0x02810031,
+0x4c31833c, 0x850233c2, 0x30123c00, 0x0027c00c, 0x031c00d3, 0x49c00c30,
+0x00000040, 0x00000000, 0x203db802, 0x01fc20ff, 0x3fc807f0, 0xbc00f702,
+0xc00ff023, 0x00bf023e, 0x09f0017c, 0xbf123dd0, 0x3002fe00, 0x002ec00f,
+0x03be20ff, 0x0bc10ff4, 0x00000660, 0x00000000, 0x1077a015, 0x016e0013,
+0x37c40970, 0x4c001f00, 0xc00d3000, 0x01532137, 0x6d300358, 0x9b8034c0,
+0x32034c01, 0x0030180d, 0x136c001b, 0x57c10d34, 0x00000e00, 0x00000000,
+0x08218913, 0x01ad00e1, 0x33000a10, 0x2c20c110, 0x400ab003, 0x0261023b,
+0x0e100384, 0xa3403c41, 0x1003c500, 0x5039400e, 0x330420a1, 0x4b424e10,
+0x00000620, 0x00000000, 0x00790001, 0x058481e1, 0x7b401e50, 0xa4012580,
+0x401e1004, 0x0589007b, 0x1c104784, 0xe1007a50, 0x18078401, 0x08fa4a1e,
+0x37b60181, 0x0f401e10, 0x00000400, 0x00000000, 0x00b32812, 0x81260ac1,
+0x37446c50, 0x6400c500, 0x400c9003, 0x028101b3, 0x0c1c0706, 0xc900f240,
+0x101b0501, 0x0077401c, 0x03540589, 0x4b400c14, 0x00000c20, 0x00000000,
+0x401da817, 0x11cc0b73, 0x17c82770, 0x6c005f00, 0xc0053001, 0x0a5b4097,
+0x05300d4c, 0x53005ec8, 0x3419cc21, 0x0016c005, 0x017c077b, 0x5fc00530,
+0x00000620, 0x00000000, 0x00870012, 0x487c021f, 0x07c40180, 0xfc002a00,
+0xc001f008, 0x001f0003, 0xa1f0406d, 0x170205c0, 0xf0087c08, 0x0005c081,
+0x006c0017, 0x4bc001f4, 0x00000c00, 0x00000000, 0x04270810, 0x024c008f,
+0x24c00830, 0x44009311, 0x80093002, 0x00930037, 0x0930027c, 0x924424d8,
+0x30263c00, 0x0024c008, 0x025c0083, 0x40d00830, 0x00000c20, 0x00000000,
+0x89262001, 0x0a04029d, 0xe4441950, 0x44009141, 0x4499b002, 0x109b2427,
+0x29120a76, 0x91a02440, 0xb0027403, 0x40a6c209, 0x02448091, 0x044009b4,
+0x00000800, 0x00000000, 0x2064a018, 0x4344109d, 0x24404910, 0xd608b100,
+0x40091002, 0x00912027, 0x0e1442b4, 0x95202040, 0x10025418, 0x00644009,
+0x02540091, 0x60400910, 0x00000200, 0x00000000, 0x02202010, 0x8204008d,
+0x20408850, 0x9408a102, 0x40889022, 0x08800223, 0x8e1022b4, 0x85223040,
+0x90223408, 0x82224088, 0x0a040281, 0x40404890, 0x00000080, 0x00000000,
+0x0586b01d, 0x504d141d, 0x84d16110, 0xdd161325, 0xc1613059, 0x16114583,
+0x63315834, 0x050084c1, 0x30d95c02, 0x0594c160, 0x005c8013, 0x74c0b134,
+0x00000ac0, 0x00000000, 0x012fb119, 0x03bc20af, 0x27c84bf0, 0x6c849f01,
+0xc44be012, 0x04bf0127, 0x49f2137c, 0xb9012fc0, 0xf012fc86, 0x012fc04b,
+0x0a7c02bf, 0x67c099f0, 0x00000e60, 0x00000000, 0x062fa018, 0x127c049b,
+0x6cc12b30, 0x8c059301, 0xc1493006, 0x209b01a7, 0x893212c8, 0x92002040,
+0x111a4c02, 0x01acc029, 0x02fc10bf, 0x60c00930, 0x00000e00, 0x00000000,
+0x4087081c, 0x08740211, 0x85006111, 0x44161141, 0x41411058, 0x14510183,
+0x01105044, 0x11050440, 0x1030440a, 0x01044063, 0x0074021d, 0x7041e172,
+0x00000c20, 0x00000000, 0x0123a012, 0x22340881, 0xa0604c12, 0x14028104,
+0x4008541a, 0x02950363, 0x3a920a14, 0xa1012c44, 0x90128400, 0x01a040ca,
+0xc234348d, 0x40500810, 0x00000e80, 0x00000000, 0x0860a818, 0x027434d1,
+0x24400910, 0x54809100, 0x44095002, 0xc4950023, 0x1b901245, 0xb1042c48,
+0x900a8404, 0x2064400b, 0x0274e29d, 0x60400950, 0x00000620, 0x00000000,
+0x01a7a805, 0x027c8293, 0x24d12934, 0x5d009340, 0xc0097002, 0x03874027,
+0x09b20e5c, 0x9302a4d0, 0xb4024d00, 0x9064f019, 0x027c829f, 0x14c00932,
+0x00000e20, 0x00000000, 0x04258016, 0x0f3c20d7, 0x27c099f0, 0x6d00df00,
+0xc09db002, 0x21d30037, 0x0870026c, 0x9f4066c1, 0x700e7c00, 0x0027c049,
+0x0274009f, 0x53c00970, 0x00000600, 0x00000000, 0x08850814, 0x007c041f,
+0x03c20034, 0x0c000f04, 0xc0017084, 0x02134407, 0x01b0084d, 0x134184c0,
+0x34484c40, 0x0045c101, 0x041c021f, 0x50c00034, 0x00000420, 0x00000000,
+0x01dca014, 0x0170825d, 0x9e400555, 0xc5005d00, 0x41155049, 0x08500097,
+0x3510615c, 0x5100d040, 0x100d4400, 0x149f4135, 0x0dc4415d, 0x50400530,
+0x00000200, 0x00000000, 0x00f2a014, 0x133402cd, 0xb3400c50, 0x05804d02,
+0x40140006, 0x00c10003, 0x3c900e44, 0xd100f040, 0x100b2401, 0x0031603d,
+0x8314018d, 0x50400c90, 0x00000a00, 0x00000000, 0x00288005, 0x03f400ed,
+0x0b400e50, 0x90104d00, 0x40065013, 0x00e1200b, 0x0a102794, 0xe100ac41,
+0x1041a402, 0x002b400a, 0x600411ad, 0x14404e10, 0x00000200, 0x00000000,
+0x00781015, 0x07bc91ef, 0x7b401e74, 0x8d016f20, 0xc116300e, 0x01c3022b,
+0x14b2108c, 0x710058d0, 0x3007ed01, 0x0059c01e, 0x179c01bf, 0x54d03cb0,
+0x00000040, 0x00000000, 0x0025b810, 0x133c06dc, 0x36c00df0, 0x6c021f00,
+0xc041f003, 0x02de0127, 0x09f1032c, 0xdf0027d0, 0xf0015c40, 0x20374009,
+0x847c009f, 0x43c16df0, 0x00000660, 0x00000000, 0x005fa000, 0x8ffc01f3,
+0x7fc01ff1, 0xcc037302, 0x80173007, 0x03f3004f, 0x1f3006cc, 0xbb037cc0,
+0x3006cc01, 0x007fc03f, 0x04ec01f3, 0x00c01f30, 0x00000e00, 0x00000000,
+0x201d8815, 0x0bb408e3, 0x08400fd0, 0xac106b00, 0x4006100b, 0x00ef000b,
+0x4bd002c4, 0xf1422840, 0x70528400, 0x000bc00e, 0x818444b5, 0x54400e54,
+0x00000600, 0x00000000, 0x00290000, 0x03940061, 0x01400ed0, 0x34086980,
+0x41061023, 0x00c900ab, 0x26900094, 0x21051958, 0x18030400, 0x001b400e,
+0x203422e1, 0x00400e10, 0x00000400, 0x00000000, 0x20232804, 0x0b3446c1,
+0x00441cd0, 0x34010900, 0x40001007, 0x00c91023, 0x01d04814, 0x81000540,
+0x50450400, 0x0013400d, 0x01340085, 0x10400d50, 0x00000c20, 0x00000000,
+0x4075a815, 0x0b5c03d3, 0x35c00df0, 0xfc035b00, 0xc0153047, 0x00dbc817,
+0x0d3102dd, 0xd30075c8, 0x300f4d00, 0x0017c915, 0x03fc00d3, 0x54d00f34,
+0x00000620, 0x00000000, 0x02270001, 0x2b7c03c7, 0x05c08df0, 0x6c045f00,
+0xc405f043, 0x00d70013, 0x1d70036c, 0xd70136e0, 0xf0017c00, 0x0095c401,
+0x004c80df, 0x07c00df0, 0x00000c00, 0x00000000, 0x001f0880, 0x43cc00f3,
+0x3fc00fb0, 0xac405300, 0xe4173203, 0x00f3023c, 0x573000ec, 0x63015dc0,
+0x7003cc00, 0x0154c007, 0x039c01e3, 0x01c00d30, 0x00000c22, 0x00000000,
+0x01862001, 0x030400d5, 0x37400d10, 0x44001100, 0xc091b023, 0x06d500b6,
+0x0d160344, 0x51403454, 0x10016c50, 0x54114021, 0x806c09d1, 0x04400db0,
+0x00000802, 0x00000000, 0x0010a001, 0x034400d1, 0x33401d90, 0x46880180,
+0x40005103, 0x00c10094, 0x0d100224, 0x91003540, 0x90220480, 0x201440ad,
+0x005460d1, 0x05400d10, 0x00000200, 0x00000000, 0x00102010, 0x030520c5,
+0x03600810, 0x04000100, 0x4000d001, 0x00c54032, 0x08508204, 0xc1002040,
+0x15022400, 0x00016000, 0x012400c1, 0x40400c90, 0x00000080, 0x00000000,
+0x0006b000, 0x014400d1, 0x07c00db0, 0x4d001340, 0x40017403, 0x00d34030,
+0x0530006c, 0x11001148, 0x71024c00, 0x0814c80d, 0x005c20d3, 0x01c00f30,
+0x00000a80, 0x00000000, 0x000fb805, 0x03fc00ff, 0x0fc00ff0, 0xf4203f00,
+0x8003b003, 0x007f003f, 0x03b200fc, 0x3f000fc4, 0xf000fc80, 0x181f8203,
+0x01fc40ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x003ba003, 0x02cc08fb,
+0x0ec04fb4, 0xfc003f00, 0xc00eb000, 0x08392039, 0x0fb2539c, 0xe3083fc0,
+0x700bcc00, 0x013cc04f, 0x01e81cf3, 0x0cc08f30, 0x00000e00, 0x00000000,
+0x00370801, 0x6a4502d1, 0x07448d11, 0x44044f10, 0x400d1b00, 0x0e110034,
+0x0d120bd4, 0xf702bf41, 0x1020c500, 0x25bd406f, 0xab4c02f5, 0x04404d52,
+0x00000c20, 0x00000000, 0x0037a011, 0x126486c1, 0x02440810, 0x15100d00,
+0x440c5000, 0x24090073, 0x4800d325, 0xc100324a, 0x50134580, 0x0230418c,
+0x036424c9, 0xc4401c50, 0x00000e80, 0x00000000, 0x4135a803, 0x006401d5,
+0x07400910, 0x4402d500, 0x440d5400, 0x80510076, 0x0d100344, 0xd9003741,
+0x00114400, 0x0035400d, 0x234400dd, 0x0c401c50, 0x00000620, 0x00000000,
+0x0033a802, 0x032407d3, 0x46ca19b0, 0x5c021d20, 0xc53dd422, 0x125b3037,
+0x3d34037c, 0xd30037c0, 0x60044d80, 0x0034c20d, 0x0f2c00db, 0x08d00d50,
+0x00000e20, 0x00000000, 0x003d8007, 0x82dd00d3, 0x4fc19b70, 0x7d107f01,
+0xc08f30c6, 0x00a7043d, 0x3ff083fc, 0xf74037c2, 0xf001dc00, 0x003fc00f,
+0x07fc00e7, 0x1fc00ff0, 0x00000600, 0x00000000, 0x00350802, 0x076c02d3,
+0x07c08930, 0x3d001340, 0xc42d2082, 0x025b0036, 0x8930033c, 0xc74033c0,
+0xf0014c04, 0x0034c00d, 0x0b4c00d3, 0x09c00df0, 0x00000420, 0x00000000,
+0x0034a013, 0x014400d1, 0x84402912, 0x5403d101, 0x441c500e, 0x06f100b4,
+0x391003c4, 0xf5203f40, 0xd0010482, 0x003c400f, 0x07c440f1, 0x4c420d10,
+0x00000200, 0x00000000, 0x0032a007, 0x020405d1, 0xc2603892, 0x14009101,
+0x419c5401, 0x138d1076, 0x0c100314, 0xc1003361, 0xd0030401, 0x0034400d,
+0x030400c1, 0x1d400c50, 0x00000a00, 0x00000000, 0x406c8004, 0x0c0519a9,
+0x4840da10, 0x8401e100, 0x409e50c5, 0x0135207c, 0x9e102784, 0xe1907b00,
+0xd1058511, 0x907c041f, 0xc7d401f1, 0x10401f10, 0x00000200, 0x00000000,
+0x00301032, 0x220d0803, 0x02e04d30, 0x1c908300, 0xc00c7401, 0x008f0432,
+0x0c32033c, 0xc74033c0, 0xf2090c00, 0x0130c00c, 0x1a0c00c3, 0x49c00c70,
+0x00000040, 0x00000000, 0x203db802, 0x82dc08b7, 0x0ac44f74, 0x5c88ff02,
+0xc00fa021, 0x006b143f, 0x0bb043fc, 0xff043fc2, 0xf0215c08, 0x003bc08e,
+0x43ac02ef, 0x0bc02e72, 0x00000660, 0x00000000, 0x0027a015, 0x034c009f,
+0x24c00df0, 0x5d009f00, 0xc99db04b, 0x04db00b7, 0x7c32176c, 0xd78936c8,
+0xf0114c13, 0x0934844d, 0x030808d3, 0x54c0ddb0, 0x00000e00, 0x00000000,
+0x00298812, 0x008400ed, 0x38400ed0, 0x0400ed00, 0x044e1003, 0x11a1053f,
+0x8e1033c4, 0xff023040, 0x10413402, 0x0531414c, 0x179c04f5, 0x48400f50,
+0x00000620, 0x00000000, 0x00690003, 0x47a6016d, 0x69401cd0, 0xb4018d0c,
+0x401f0007, 0x09e90179, 0x3a1407a4, 0xe8497a40, 0xd005b425, 0x037840de,
+0xc78401e1, 0x0f705ed2, 0x00000400, 0x00000000, 0x00632812, 0x076409dd,
+0x61401cd1, 0x2400cd00, 0x410c9003, 0x83c10032, 0x30180304, 0xc9003048,
+0x10397480, 0x4031480c, 0x031400c5, 0x4b400c50, 0x00000c20, 0x00000000,
+0x0115a817, 0x01ed007f, 0x99d905f0, 0x7c805f00, 0xc433b409, 0x124b06c9,
+0x8530016c, 0x570016c0, 0xe005dc00, 0x001c8007, 0x01cc0073, 0x5fc003f0,
+0x00000620, 0x00000000, 0x00070012, 0x805c001f, 0x46c001f0, 0x5c021f00,
+0xc8813048, 0x00170085, 0x21f0005c, 0x17a007c2, 0xf0005400, 0x2007c001,
+0x005c001f, 0x488011f0, 0x00000c00, 0x00000000, 0x00270810, 0x024c019f,
+0x24d05830, 0x6c858300, 0xc021b002, 0x11d90046, 0x1db0025c, 0x930026c0,
+0x30027c20, 0x08248408, 0x42480093, 0x43c00171, 0x00000c20, 0x00000000,
+0x00262001, 0x0254119d, 0xa4401912, 0x04079314, 0x4031150e, 0x05930307,
+0x09d00254, 0x91182740, 0x10027408, 0x0026c009, 0x86040093, 0x07400110,
+0x00000800, 0x00000000, 0x00248018, 0x0745089d, 0x34440914, 0xe6009161,
+0x40015012, 0x44950007, 0x89d28254, 0x95502342, 0x10027400, 0x00234009,
+0x12540081, 0x63400150, 0x00000200, 0x00000000, 0x00a02010, 0x3604048d,
+0x26406814, 0x8508a100, 0x408c1062, 0x00858227, 0x88d00204, 0x81842340,
+0x10323004, 0x202340c8, 0x02140881, 0x43408810, 0x00000080, 0x00000000,
+0x0006b01d, 0x504c8c1f, 0x04c04514, 0xec101300, 0xc9617009, 0x0e171507,
+0x05d1b854, 0x131007c1, 0x34507c2c, 0x4387c061, 0x505d1413, 0x77c16170,
+0x00000ac0, 0x00000000, 0x002fb819, 0x12fc0caf, 0x2dcc6bf0, 0x7c209e00,
+0xc04af012, 0x0c8b412f, 0x09b0327d, 0x9d0467c0, 0xf212fc8c, 0x03260469,
+0x02eca09f, 0x67c04bf0, 0x00000e60, 0x00000000, 0x0027a818, 0x72cc08bf,
+0x2fd14bf0, 0xcc12b700, 0xc07bb882, 0x54aa236d, 0x0bf91a4c, 0xb7032ec2,
+0xb00a6c04, 0x00a5c029, 0x42ec0093, 0x63c05c30, 0x00000e00, 0x00000000,
+0x0407081c, 0x09440a1d, 0x04406110, 0x6c000da0, 0x4015187c, 0x26150017,
+0x61d80046, 0x11800141, 0x103c4404, 0x0886c821, 0x084c0201, 0x734001b1,
+0x00000c20, 0x00000000, 0x0923a210, 0x1224848d, 0x25510840, 0x04049d00,
+0x40681402, 0x508121a1, 0x28d29a14, 0x8141a042, 0x10022412, 0x01a24068,
+0x02261681, 0x43417898, 0x00000e80, 0x00000000, 0x0025a018, 0x0264009d,
+0x34400910, 0x6000dd40, 0x60815100, 0x209d1227, 0x18d00255, 0x85002540,
+0x11224400, 0x00264009, 0x43440091, 0x63401998, 0x00000620, 0x00000000,
+0x0067a005, 0x0e6d119d, 0x23c00870, 0x4c069500, 0xe0311000, 0x01832021,
+0x59d00254, 0x910024c0, 0x34126c00, 0x4026d009, 0x0e6c0093, 0x17c009bc,
+0x00000e20, 0x00000000, 0x00a58034, 0x265c048f, 0x64c03970, 0x7c009702,
+0xc3113000, 0x24970067, 0x09f2026c, 0x9b9027e4, 0xf0023c00, 0x0020c008,
+0x263c009f, 0x53c00978, 0x00000600, 0x00000000, 0x00050014, 0x084c501f,
+0x07c08134, 0x6c8e1f00, 0xc0213410, 0x00130887, 0x01320054, 0x174007c1,
+0x30087400, 0x0007c801, 0x8c7c8004, 0x51c20130, 0x00000420, 0x00000000,
+0x0014a814, 0x11c5137f, 0x1f408710, 0x84007d00, 0x41131048, 0x007b205f,
+0x273081c4, 0x71101744, 0xb2017400, 0x10174005, 0x09c40051, 0x50400750,
+0x00000200, 0x00000000, 0x0032a014, 0x0544028d, 0xf3401c12, 0x34019d01,
+0x401cd10b, 0x00c10453, 0x2c100335, 0xcc0a7540, 0x18033400, 0x0033600c,
+0x221400c5, 0x51400c90, 0x00000a00, 0x00000000, 0x09388005, 0x01a500ad,
+0x3b400e10, 0x96006d04, 0x604e1003, 0x04e9041b, 0x02801714, 0x61003b4c,
+0x9a033420, 0x003340ce, 0x020408e1, 0x14405f90, 0x00000200, 0x00000000,
+0x00f81015, 0x050c81ff, 0x7bc01e10, 0x2c81ed00, 0xc29e7457, 0x4321085f,
+0x1a240798, 0xef247bc0, 0x3007be11, 0x28fbc15e, 0x029c21e7, 0x55c03eb0,
+0x00000040, 0x00000000, 0x01b59010, 0x01504057, 0x27c00df0, 0x6c00df10,
+0xc06d3103, 0x011f0017, 0x0173736c, 0x1f0037c4, 0xf007fc00, 0x2437c86d,
+0x025c02df, 0x43c12d70, 0x00000660, 0x00000000, 0x00ffa200, 0x05fc41b3,
+0x7dc09f30, 0xfc017b00, 0xc19e7047, 0x01fb007d, 0x97b087ec, 0xfb406ec8,
+0xf087d401, 0x037cc01f, 0x05c40bf3, 0x00c01fc0, 0x00000e00, 0x00000000,
+0x02398815, 0x19b600ab, 0x38400e10, 0x8404ed00, 0x488e3003, 0x02fd001c,
+0x021013ed, 0x61012948, 0xd053ac08, 0x023dc00e, 0x50840cf3, 0x54404ef0,
+0x00000620, 0x00000000, 0x00390000, 0x013412e9, 0x3a640e10, 0x10008502,
+0x008f1023, 0x0821021b, 0x081903a4, 0xe5802840, 0xd0838400, 0xa13a408c,
+0x00a400e9, 0x00410ed0, 0x00000400, 0x00000000, 0x20772804, 0x093080c1,
+0x72000c10, 0x0402cc00, 0x644c1183, 0x07042112, 0x30100324, 0x05002545,
+0xd2071440, 0xc031400c, 0x082400c1, 0x90403c50, 0x00000c20, 0x00000000,
+0x417ca815, 0x057003c9, 0x76500d14, 0x5d879701, 0x484d1c03, 0x07eb0117,
+0x5db083ed, 0x5f0024c0, 0xf82bc500, 0x003ec00f, 0x086d00fb, 0x54c03fd0,
+0x00000620, 0x00000000, 0x00370001, 0x4d3c809f, 0xb4c80df0, 0x5c00cf20,
+0xc00db003, 0x021f1085, 0x01f4035c, 0x930025c2, 0xf9036c00, 0x0035c00d,
+0x005c00df, 0x07c00df0, 0x00000c00, 0x00000000, 0x003f0880, 0x15cc00f3,
+0x7cc00c30, 0xad10f300, 0xc80f3a0f, 0x01fa021f, 0x0b7083dd, 0x67206ec0,
+0xf003cc08, 0x083cca0f, 0x44bc00f6, 0x00c30f30, 0x00000c22, 0x00000000,
+0x40360081, 0x0b450151, 0x70d01d10, 0x44025100, 0x400d300f, 0x03110112,
+0x01300364, 0xd3006740, 0xd0034412, 0x0036c40d, 0x047400d1, 0x04420cb0,
+0x00000802, 0x00000000, 0x8034a001, 0x81550191, 0x36483d91, 0x6780d102,
+0x481d5443, 0x28dd0017, 0x05d28335, 0x550a3762, 0x50036500, 0x0030400c,
+0x107600d5, 0x04400d10, 0x00000200, 0x00000000, 0x20302010, 0x01140091,
+0x32400412, 0x0400c040, 0x601c9403, 0x00058012, 0x00500324, 0x89003340,
+0xd0030100, 0x0032400c, 0x003480c5, 0x40400c90, 0x00000080, 0x00000000,
+0x883ab000, 0x015c00d1, 0x36c00db4, 0x6d001100, 0xc00d1003, 0x00df0017,
+0x097003d4, 0x65403ac0, 0xf0036d00, 0x083cc00f, 0x007c00f7, 0x00c00f30,
+0x00000ac0, 0x00000000, 0x803fb805, 0x02ed00ff, 0x1de00b70, 0xf800ff00,
+0xc20f7403, 0x003b001f, 0x033003dd, 0xf5003fc4, 0xf083fc00, 0x003fc00f,
+0x00fc00fb, 0x17c00ef0, 0x00000e60, 0x00000000, 0x023fa003, 0x53cfc0ff,
+0x3b400ff3, 0xecc03300, 0xc483d200, 0x483b233c, 0x8370a0c5, 0x37020cc0,
+0x31008d48, 0x003cc003, 0x00cd8423, 0x0cd40b35, 0x00000e00, 0x00000000,
+0x01370801, 0x934410fd, 0x374005d0, 0x44009100, 0x400d9003, 0x061302bc,
+0x01100044, 0x11002444, 0x10004400, 0x003ec541, 0x01444855, 0x04400910,
+0x00000c20, 0x00000000, 0x2033a011, 0x532404c4, 0x67460cd0, 0x14004500,
+0x4008d202, 0x08c50130, 0x44500344, 0x85613048, 0x50000444, 0x00324008,
+0x01140001, 0x44400c50, 0x00000e80, 0x00000000, 0x8035a803, 0x036400dd,
+0x17400dd0, 0x7520c500, 0x502d9003, 0x00d40034, 0x45100244, 0x11083041,
+0x50504404, 0x88364009, 0x03140045, 0x0c400c10, 0x00000620, 0x00000000,
+0x0037a802, 0x036400cf, 0x77c81df0, 0x6c62d700, 0xc094f069, 0x0217006c,
+0x3d70480c, 0xd70014d0, 0x740f4d01, 0x0034d105, 0x015c0553, 0x08c01d70,
+0x00000e20, 0x00000000, 0x043d8007, 0x83dc00ff, 0x3fc027f0, 0x4500fb42,
+0xc40fb006, 0x2333026b, 0x14f000fc, 0xef080fc0, 0xb007fc21, 0x0031c046,
+0xa3ec027d, 0x1fc09f92, 0x00000600, 0x00000000, 0x00350802, 0x037c00df,
+0x37c00df1, 0x4d029b00, 0xc12d3003, 0x00db4164, 0x2db01f6c, 0xd74134c0,
+0x30293c10, 0x0036d029, 0x014c10d3, 0x08c10d34, 0x00000420, 0x00000000,
+0x0074a013, 0x43f400fd, 0xba404fd0, 0x4400b100, 0xc02d1002, 0x00e100a6,
+0xa5100244, 0xd100f6c0, 0x10857411, 0x003c4019, 0x2f7c00f1, 0x4c404d10,
+0x00000200, 0x00000000, 0x00b2a007, 0x073408cd, 0x13400cd0, 0x04008909,
+0x400c161b, 0x00050020, 0x08900a24, 0x4d000050, 0x14073400, 0x0031400c,
+0x01040249, 0x1c402c10, 0x00000a00, 0x00000000, 0x00788004, 0x07b409ed,
+0x5a4032d0, 0x85012100, 0x60121105, 0x01f50062, 0x1a100404, 0x292c6840,
+0x1806b605, 0x0079411e, 0x45b41979, 0x10401e10, 0x00000200, 0x00000000,
+0x06301012, 0x033488cf, 0x13c088f8, 0x0502db00, 0xc00c3003, 0x02c74120,
+0x48b1032c, 0xcf003440, 0x30033c00, 0x4131c80d, 0x014c004a, 0x48d00d30,
+0x00000040, 0x00000000, 0x003db802, 0x43fc3aff, 0x3ec80bf0, 0xfe007f00,
+0xc00afa03, 0x00e3106f, 0x0bf0027c, 0x37203fc0, 0xf0227484, 0x003c808f,
+0x03fc0077, 0x0bc08ff0, 0x00000660, 0x00000000, 0x0037a015, 0x034c02df,
+0x77c08d30, 0x6c00d700, 0xc92d3403, 0x00130137, 0x0df0024c, 0xdb0014c0,
+0x38036c40, 0x23b4c005, 0x014c01d3, 0x54c01d30, 0x00000e00, 0x00000000,
+0x00398812, 0x138404ef, 0x3b400618, 0x2400f101, 0x40061001, 0x07e1023b,
+0x0cd000ac, 0xe1200840, 0x1a030400, 0x24384104, 0x038402e1, 0x48400e10,
+0x00000620, 0x00000000, 0x00790003, 0x170401cd, 0x7b405e10, 0x8409a503,
+0x481e9007, 0x05f11873, 0x1ed20786, 0xe9007870, 0x1007a441, 0x0078441e,
+0x058605e1, 0x0c401e10, 0x00000400, 0x00000000, 0x10332812, 0x034440c5,
+0x33408c14, 0x24098100, 0x409c9007, 0x00d10273, 0xacd00226, 0xd9007441,
+0x11172408, 0x4830401c, 0x070704c1, 0x48409c14, 0x00000c20, 0x00000000,
+0x0015a817, 0x0145004d, 0x9fc01732, 0x6c025701, 0xc015b215, 0x00734017,
+0x15f0014c, 0x5b0614d0, 0x35156d43, 0x0014d025, 0x1dcc1173, 0x5cd00530,
+0x00000620, 0x00000000, 0x20070012, 0x007c001f, 0xc7c001f0, 0x1d001f00,
+0xc0007000, 0x001f0003, 0x01f0003c, 0x170087c0, 0xf0005c00, 0x0003e0e1,
+0x047d001f, 0x4bc801f0, 0x00000c00, 0x00000000, 0x00670810, 0x024c009f,
+0x24e09930, 0x4c109f00, 0x80493002, 0x05934024, 0x0938026d, 0x970024c0,
+0x30060c10, 0x5024c019, 0x027c0093, 0x43c00930, 0x00000c20, 0x00000000,
+0x0a260001, 0x0244029d, 0xa6e03810, 0x44008d00, 0x4009100a, 0x809b0124,
+0x0910024c, 0x9100a450, 0x11064100, 0x00a55098, 0x0274009b, 0x07400914,
+0x00000800, 0x00000000, 0x8024a018, 0x0245029d, 0xa4440910, 0xc7009d08,
+0x400b180a, 0x00910065, 0x0a100244, 0xb520ac40, 0x1012c400, 0x0424400b,
+0x02340091, 0x63400910, 0x00000200, 0x00000000, 0x82302010, 0x2204088d,
+0x20401810, 0x84089d00, 0x508a1c22, 0x00890221, 0x2a142204, 0xa190a840,
+0x10028722, 0x00a1408a, 0x0a340289, 0x43402810, 0x00000080, 0x00000000,
+0x0086b01d, 0x584c961f, 0x04414114, 0x4c561f05, 0xc1633058, 0x14130585,
+0x4112584c, 0x070500c1, 0x34504c14, 0x4500c967, 0x003c0003, 0x77c00030,
+0x00000ac0, 0x00000000, 0x0127b819, 0x127e049f, 0x2bd00bf0, 0x7c24bf00,
+0xc049f092, 0x14a7012e, 0x09f012dc, 0x9f0827c0, 0xf0027c00, 0x0026c049,
+0x02fc02ff, 0x67c00bf0, 0x00000e60, 0x00000000, 0x022fa818, 0x52cc10bf,
+0x25c14bf0, 0x4c1c9345, 0xd00b3022, 0x04bb4368, 0x295022dc, 0x9314a6c0,
+0xb0426c30, 0x0024c02b, 0x0a4c0697, 0x60c02930, 0x00000e00, 0x00000000,
+0x0107081c, 0x186d021f, 0x05c021d0, 0x44061100, 0x40211428, 0x06110004,
+0x50100044, 0x3100c440, 0xd0014437, 0x05c040a5, 0x04440911, 0x70401211,
+0x00000c20, 0x00000000, 0x0023a010, 0x4204148d, 0x214008d0, 0x04048100,
+0x41689212, 0x199101a0, 0x28501a14, 0xa9012a40, 0xd0022400, 0x00a04048,
+0x12a404b5, 0x40424a14, 0x00000e80, 0x00000000, 0x1825a018, 0x82440095,
+0x254289d8, 0x45009106, 0x402d920a, 0x01911024, 0x88100a44, 0xb8812c42,
+0xd0026400, 0x80204009, 0x52e000b1, 0x60000b11, 0x00000620, 0x00000000,
+0x0027a005, 0x0245009d, 0xa1c049f0, 0x4c019300, 0xc009b002, 0x008b0024,
+0x0970065c, 0x9b0126c0, 0xb1026830, 0x0024d0b9, 0x026c0297, 0x14d01938,
+0x00000e20, 0x00000000, 0x00258014, 0x027c109f, 0x75c219f0, 0x3c049f00,
+0xc1087003, 0x309e0027, 0x19d0227c, 0x975467c2, 0xf0035c00, 0x0027c018,
+0x065c009f, 0x53c059f8, 0x00000600, 0x00000000, 0x03050014, 0x004c000f,
+0x87c031f0, 0x4c001304, 0xc001f040, 0x00130040, 0x0130000c, 0x332889c0,
+0xf0086c00, 0x0004d021, 0x08cc0233, 0x50d003f0, 0x00000420, 0x00000000,
+0x005ca014, 0x0144027d, 0x974027d2, 0x45005100, 0x41177009, 0x0271009c,
+0x05b001c4, 0x71001540, 0xd0114500, 0x00144197, 0x01440043, 0x504005d0,
+0x00000200, 0x00000000, 0x0072a814, 0x030403cd, 0xb3400cd0, 0x0400d100,
+0x400cd00b, 0x00c10030, 0x0c100624, 0x5540b140, 0xd0071400, 0x00304228,
+0x035400c9, 0x51400dd0, 0x00000a00, 0x00000000, 0x00388005, 0x038402ad,
+0x33420ad0, 0x8404e100, 0x60065003, 0x04e10028, 0x061009a4, 0xa9000940,
+0xd0039400, 0x0038400e, 0x00940121, 0x154002d0, 0x00000200, 0x00000000,
+0x00781015, 0x078d014d, 0x7bc01ef0, 0x8c23c124, 0xd01cf007, 0x05b34068,
+0x1e1406ed, 0x474071c2, 0xf0079c01, 0x4058c01c, 0x079d00fb, 0x55c01ef8,
+0x00000040, 0x00000000, 0x0015b810, 0x037c801f, 0x37c80df0, 0x7d86df40,
+0xc005f01b, 0x099f0027, 0x05f001dc, 0x970006c0, 0xb00b4d00, 0x0017c009,
+0x006d001f, 0x42c001f0, 0x00000660, 0x00000000, 0x407fb000, 0x27cc0133,
+0x7cc09ef0, 0xdc03f700, 0xc017f02f, 0x0177007c, 0x1f3207dc, 0x73007c80,
+0x300fec01, 0x407cc017, 0x07cd01f3, 0x03c01f30, 0x00000e00, 0x00000000,
+0x00ad8015, 0x0380006b, 0x3840aaf0, 0x8408e101, 0x4087d043, 0x0061022d,
+0x06a040fc, 0xab208850, 0x10038400, 0x00384003, 0x00c40025, 0x57400210,
+0x00000620, 0x00000000, 0x00390000, 0x038400a1, 0x38700fd2, 0x9400e500,
+0x4102d103, 0x0025000a, 0x8c1003a4, 0x61423840, 0x1003a401, 0x0010400e,
+0x0b8418e1, 0x03400e10, 0x00000400, 0x00000000, 0x00032804, 0x030420d1,
+0xb0403c52, 0x0402c104, 0x4030d00f, 0x00050003, 0x24904c34, 0x8900c043,
+0x10072403, 0x50104408, 0x2004000d, 0x13400010, 0x00000c20, 0x00000000,
+0x0035a815, 0x02450051, 0xf4c12dd0, 0x5c00f704, 0xc015f20b, 0x0c370036,
+0x2d300e6c, 0x536274c0, 0x34466d2b, 0x0834c009, 0x070d00d3, 0x57c00d34,
+0x00000620, 0x00000000, 0x00b70001, 0x037c801f, 0xb7c00df0, 0x7c10df00,
+0xc045f203, 0x001b0005, 0x05f00a5c, 0x970287c0, 0xf1035c08, 0x0037c409,
+0x007c0017, 0x07c001f0, 0x00000c00, 0x00000000, 0x006f0880, 0x0acc0053,
+0x3ec13ef0, 0xcd20db00, 0x8032b043, 0x00234028, 0x0e3c02cc, 0x714030c0,
+0xf0076c00, 0x001bc00b, 0x03cc40c3, 0x00c00f30, 0x00000c22, 0x00000000,
+0x20062081, 0x03541011, 0x90401dd0, 0x4400d100, 0x4031100b, 0x0e110404,
+0x07540614, 0xb1208c40, 0xd0074400, 0x001f4419, 0x00c5003b, 0x04400214,
+0x00000802, 0x00000000, 0x0210a001, 0x02440011, 0xb6400dd0, 0x0500c900,
+0x6005900b, 0x00150035, 0x0d104644, 0x45103550, 0xd0136400, 0x00374811,
+0x034400d1, 0x04400d50, 0x00000200, 0x00000000, 0x00002010, 0x03140041,
+0x31400cd0, 0x0500c100, 0x40041203, 0x00050001, 0x04500214, 0x81000140,
+0xd0030600, 0x40334400, 0x00440009, 0x40400110, 0x00000080, 0x00000000,
+0x0006a000, 0x024c8013, 0x36c005f8, 0x4c20fb00, 0xd001b003, 0x00170005,
+0x0d10024c, 0x470015c0, 0xf0036c80, 0x4017c009, 0x034c00d3, 0x00d00d30,
+0x00000ac0, 0x00000000, 0x800fa805, 0x03fe207f, 0x3ac00ff0, 0xfc00ff00,
+0xc003f001, 0x002b000e, 0x07f002fc, 0xbf002ec0, 0xf003f820, 0x001fc00b,
+0x00fc003f, 0x17c003f0, 0x00000e60, 0x00000000, 0x003fa003, 0x03dc4073,
+0x0dc8c370, 0xcc183d03, 0xc982b040, 0x0033030c, 0x0f3003ec, 0xfd002ec9,
+0x3083ec98, 0x023cd003, 0x23cc00f3, 0x0cc00ff9, 0x00000e00, 0x00000000,
+0x803f0801, 0x03c400d1, 0x2440c910, 0x64069d03, 0x4061101b, 0x46911384,
+0x2f0103c4, 0xf1002440, 0x100bf406, 0x01b44041, 0x030410f1, 0x04404dd0,
+0x00000c20, 0x00000000, 0x4033a011, 0x032480c5, 0x10404050, 0x24000d01,
+0x40409040, 0x12492101, 0x0c105326, 0xc9002240, 0x548a3404, 0x30b24100,
+0x130404c1, 0x44415cd2, 0x00000e80, 0x00000000, 0x7035a807, 0x036400c1,
+0x345a0910, 0x64009d04, 0x41040000, 0x10910000, 0x0d008306, 0xd1042440,
+0x50227400, 0x02164108, 0x934480d5, 0x0c401dd2, 0x00000620, 0x00000000,
+0x0037a800, 0x036106d5, 0xc4803570, 0x4d0a5e00, 0xd029b000, 0x801340b5,
+0x0c30036c, 0xdb00a6c8, 0x70033400, 0x40768835, 0x034d00d1, 0x00c00cd0,
+0x00000e20, 0x00000000, 0x083c8083, 0x039c00ff, 0x8fc092f0, 0x9c00ef20,
+0xc24bf013, 0x00ff10bf, 0x0ff703fc, 0xff012bc4, 0xb003fe00, 0x4055e83f,
+0x07fc20fb, 0x1fc00ff2, 0x00000602, 0x00000000, 0x40310802, 0x036c02d3,
+0x94d025f0, 0x5c421f20, 0xc0217000, 0x024f80a6, 0x0d70035c, 0xd70025c0,
+0x70227c20, 0x4130c801, 0x074c04c7, 0x08c40d39, 0x00000420, 0x00000000,
+0x03bca013, 0x3bc404d1, 0x9440b110, 0x44009d03, 0x42051000, 0x00dd0024,
+0x4f1003dc, 0xf1402440, 0xb0027400, 0x01b44009, 0x074411f1, 0x4ec00db1,
+0x00000200, 0x00000000, 0x0032a007, 0x0b3400c1, 0xc34010d0, 0x14400d00,
+0x4004d080, 0x000d0000, 0x7c500316, 0xc5811140, 0x40023400, 0x00b14000,
+0x030402c5, 0x1c400c90, 0x00000a00, 0x00000000, 0x02788004, 0x071401c1,
+0x7b421e10, 0x94010d01, 0x00165807, 0x012d0048, 0x1c100714, 0xe1215044,
+0x92063401, 0x0269501b, 0x878509f5, 0x1a081f90, 0x00000200, 0x00000000,
+0x00341012, 0x033c00c3, 0x034161f2, 0x5c004f00, 0xe0087013, 0xa0cd0832,
+0x0c71031c, 0xc50011c0, 0x72033400, 0x2231c000, 0x030c08c7, 0x48c00cb0,
+0x00000040, 0x00000000, 0x003db002, 0x43ce80ff, 0x34e80ff8, 0xec007f01,
+0xc08db003, 0x00bf003f, 0x8fb82bfc, 0xff011fc0, 0xf007fc00, 0x020ec00a,
+0x43fd08eb, 0x0bc18ef0, 0x00000660, 0x00000000, 0x0137a015, 0x1b7c12db,
+0x24c01d34, 0x7c00d300, 0xc00da800, 0x00130016, 0xccf0037c, 0xd40024c3,
+0x301a4d05, 0x20340805, 0x1b6c06db, 0x54c12df0, 0x00000e00, 0x00000000,
+0x02398812, 0x23b400e1, 0x3c600c10, 0xb420eb08, 0x400e1003, 0x00601010,
+0x0ed003b0, 0xe1402840, 0x5022840e, 0x0001400e, 0x338412f1, 0x48404ed0,
+0x00000620, 0x00000000, 0x02710083, 0x17b401e1, 0x68401e12, 0xb401e900,
+0x40181007, 0x81e81078, 0x1fd227b6, 0xed807a42, 0x9007a481, 0x287a4014,
+0x07a425e9, 0x0c405ed0, 0x00000402, 0x00000000, 0x40332832, 0x0370e0d9,
+0xb0406c11, 0x3001d100, 0x080c1003, 0x01d10074, 0x0cd00336, 0xc1003650,
+0x50030600, 0x802340bd, 0x0f0400c1, 0x48400dd0, 0x00000c20, 0x00000000,
+0x0015a817, 0x0170025b, 0x1cd04730, 0xf4877940, 0x90271401, 0x057b01de,
+0x06d0017c, 0x5f019ec0, 0x30016c00, 0x009ee6a7, 0x04ec606b, 0x5cd403f0,
+0x00000620, 0x00000000, 0x40070012, 0x087c1217, 0x07c401f3, 0x7c101f01,
+0xc9007000, 0x001f4407, 0x01f0007c, 0x132485c0, 0xf0007c00, 0x0405e001,
+0x287c021f, 0x4bc011f0, 0x00000c00, 0x00000000, 0x00270810, 0x164c05db,
+0x23e03930, 0x4c009301, 0xc0093402, 0x00930024, 0x59f2026c, 0x9f0024c8,
+0x70023c00, 0x30e25009, 0x404c4193, 0x40d001f0, 0x00000c20, 0x00000000,
+0x40a60001, 0x1e440791, 0x27e03910, 0x04009100, 0x40091002, 0x00918024,
+0x39d0024c, 0x9b202440, 0xb0127400, 0x00e44009, 0x00440091, 0x044001d0,
+0x00000800, 0x00000000, 0xc420a018, 0x02640091, 0xa74a0990, 0x4400d1c0,
+0x50091003, 0x00910834, 0x09d00244, 0x91802441, 0x50127400, 0x00a46009,
+0x41450891, 0x604001d8, 0x00000200, 0x00000000, 0x02202010, 0x22050881,
+0x21488c15, 0x061c8182, 0x41c81822, 0x1c810720, 0x89d02207, 0x89852040,
+0x90523488, 0x052143c8, 0x22040891, 0x404888d8, 0x00000080, 0x00000000,
+0x0586b01d, 0x082c9613, 0x87436130, 0x0d061305, 0xc0611058, 0x06114184,
+0x61f0084c, 0x030114d1, 0x70107c16, 0x4106c861, 0x584c1653, 0x74d161f0,
+0x00000ac0, 0x00000000, 0x0127b819, 0x1a7e0497, 0x2fc04bf0, 0xfe84bf01,
+0xc04bf812, 0x04bf012f, 0x49f01a58, 0x9c052bc4, 0xf002bc04, 0x052ec44f,
+0x13fd049f, 0x67c04af0, 0x00000e60, 0x00000000, 0x022fa018, 0x324c0293,
+0x2f8d0bb0, 0x7c189f21, 0xc049721a, 0x0c9f2324, 0x2bf05a7e, 0x93022f88,
+0x3012ac00, 0x012cc069, 0x36ac04b3, 0x67c65df8, 0x00000e00, 0x00000000,
+0x0285089c, 0x08c40211, 0x07654110, 0x74001d05, 0x40e59018, 0x025d0394,
+0x71d00874, 0x190a8740, 0x51204404, 0x438442e1, 0x08444401, 0x736040d0,
+0x00000c22, 0x00000000, 0x21232010, 0x328486a5, 0xa3480818, 0x14008d08,
+0x4148101a, 0x2c8c1020, 0x6cd01236, 0x89012040, 0x14022416, 0x04204048,
+0x32241281, 0x434138d0, 0x00000e80, 0x00000000, 0x0025a818, 0x02c402b5,
+0x27480912, 0x74009d02, 0x40099082, 0x049d0224, 0x01d80274, 0x99202740,
+0x50026440, 0x00344009, 0x12644091, 0x634019d0, 0x00000620, 0x00000000,
+0x40252805, 0x024d0097, 0x674009b4, 0x5c409f20, 0xd0193412, 0x029f00a4,
+0x01f00274, 0x930026c8, 0x20226c20, 0x0124f009, 0x0a6c0091, 0x174009d0,
+0x00000e20, 0x00000000, 0x00210014, 0x027c009b, 0x27c809f0, 0x7c489f00,
+0xcc393016, 0x209f0027, 0x01f1027c, 0x970527c0, 0xf0065c00, 0x0027c038,
+0x025c009f, 0x53c009f2, 0x00000600, 0x00000000, 0x00050814, 0x007c0413,
+0x07c801f0, 0x3c001f01, 0xc001f008, 0x0213c087, 0x1172004d, 0x038205c2,
+0xb4047800, 0x0885c021, 0x005c0007, 0x50c00172, 0x00000420, 0x00000000,
+0x00142014, 0x01740251, 0xdf402710, 0xf4005d00, 0x4007d001, 0x005b8017,
+0x0310014c, 0x51c09d40, 0xb44d8400, 0x029c4005, 0x01c40071, 0x50500730,
+0x00000200, 0x00000000, 0x0022a014, 0x037400d1, 0x73412c58, 0x3600cd00,
+0x4c0dc803, 0x40c11033, 0x0cd40304, 0xc1803560, 0xd0001400, 0x0035400c,
+0x031600c5, 0xd0440c50, 0x00000a00, 0x00000000, 0x01188004, 0x02b400a1,
+0x1b400e10, 0xb440ed14, 0x400ed213, 0x01c10173, 0x1e900704, 0xc1005140,
+0xd0018404, 0x00304c4f, 0x07c400e1, 0x14405e10, 0x00000200, 0x00000000,
+0x00e81014, 0x073c01e3, 0x7b401e50, 0xbc89ef00, 0xc81ef037, 0x17e1017b,
+0x5ef0478c, 0xe10839c0, 0xf0079c53, 0x4049c75e, 0x079c41e7, 0x54d05e70,
+0x00000040, 0x00000000, 0x4031b010, 0x1b7c00df, 0x07c00170, 0x7c04df00,
+0xc02df003, 0x00df05b7, 0xac70137c, 0xdf001641, 0xb0035c04, 0x1017c02c,
+0x037c001f, 0x43c18d70, 0x00000660, 0x00000000, 0x006fa002, 0x0fce8173,
+0x6fc01730, 0xec91f300, 0x813fb047, 0x01f7147c, 0x1f3047fc, 0xff206cc8,
+0x3005cda1, 0x911ec11f, 0x07cc01e3, 0x08c01f30, 0x00000e00, 0x00000000,
+0x00198011, 0x92860021, 0x39c20600, 0xb400e102, 0x500ed003, 0x00ec0838,
+0x0e1007f4, 0xfd000852, 0x50018400, 0x003c400e, 0xcbc404e3, 0x54400e51,
+0x00000620, 0x00000000, 0x00210000, 0x83a400e1, 0x0b410e90, 0xa400e100,
+0x400e9063, 0x08ed0038, 0x0e1033b4, 0xed022a40, 0x10019400, 0x042e408e,
+0x23a400f9, 0x40410f10, 0x00000400, 0x00000000, 0x00332806, 0x032500c1,
+0xc1403010, 0x3402c002, 0x401cd203, 0x0bc90030, 0x0d100334, 0xc9200240,
+0x54010400, 0x1034400c, 0x0f240005, 0x18403c50, 0x00000c20, 0x00000000,
+0x103da815, 0x016402d1, 0xb7c019b4, 0xe40af242, 0xc00f9023, 0x01ff003c,
+0x0d3003fc, 0xff0036c0, 0x38815400, 0x0836c00f, 0x0f6c00d9, 0x74500f30,
+0x00000620, 0x00000000, 0x40230201, 0x035c00df, 0x11c00d70, 0x7c00df00,
+0xc08df103, 0x10df0037, 0x0df0033e, 0xdf1095c0, 0xf0017c00, 0x00a7e00d,
+0x1a5d00db, 0x07c00df0, 0x00000c00, 0x00000000, 0x023f0a80, 0x23fc15f3,
+0x3cc10b70, 0xcc00f300, 0xc80fb103, 0x00fb003f, 0x0d3203ec, 0xff201cc8,
+0xb021dc00, 0x142fc70d, 0x05dc00ec, 0x04c10ff0, 0x00000c20, 0x00000000,
+0x0c862081, 0x08741291, 0x044491d0, 0x6c80d308, 0x400dd083, 0x80dd0037,
+0x0d100344, 0xdd0456c0, 0x101d3440, 0x2067480d, 0x2c442011, 0x04480cd0,
+0x00000802, 0x00000000, 0x40368001, 0x097480d1, 0x264000d0, 0x4440c900,
+0x400dd003, 0x00c50037, 0x1d100344, 0xdd207440, 0x10017400, 0x0077480d,
+0x035400d5, 0x04400dd0, 0x00000200, 0x00000000, 0x40200030, 0x033600c1,
+0x304004d0, 0x0600c160, 0x400cd003, 0x00cd0033, 0x1d121315, 0xcd001240,
+0x10013440, 0x4023400c, 0x020600c5, 0x40500cd0, 0x00000080, 0x00000000,
+0x40360000, 0x033c0043, 0x00d00979, 0xc500fb00, 0xc00ff803, 0x00fb003f,
+0x0d3417ec, 0xff203480, 0xb4017e00, 0x2027c00f, 0x015c00d7, 0x04c00ff1,
+0x00000ac0, 0x00000000, 0xc00f9825, 0x00fe003f, 0x0fc203f0, 0xf480ff00,
+0xc40ef003, 0x00ff003f, 0x0ff0a36c, 0xff001f80, 0xf001b400, 0x002fc00f,
+0x00fc0033, 0x17c00ef0, 0x00000e60, 0x00000000, 0x003f8003, 0x13de003f,
+0x3ec20f30, 0xcc00fb40, 0xc08bf002, 0x08f3033c, 0x0bf102cc, 0x7f202fc0,
+0x7000ec08, 0x401cc003, 0x038c2073, 0x0cd00330, 0x00000e00, 0x00000000,
+0x88371801, 0x03442a9f, 0x344c0510, 0x040e9122, 0x408ad003, 0x84d50230,
+0x0dd82244, 0x5d003740, 0x10034c44, 0x1214400d, 0x83440041, 0x04502110,
+0x00000c20, 0x00000000, 0x0033a211, 0xa234408d, 0x30548880, 0x0450c140,
+0x4008d003, 0x04c90136, 0x0cd00304, 0x4d003140, 0x510004c0, 0x08044400,
+0x83040909, 0x44402010, 0x00000e80, 0x00000000, 0x2035a003, 0x03660195,
+0x34480d94, 0x44c1d902, 0x4408d100, 0x00dd0036, 0x4dd00344, 0x5d003740,
+0x10036620, 0x0a145a0d, 0x03200049, 0x0c400110, 0x00000620, 0x00000000,
+0x0037a882, 0x0174118d, 0xf4c00db0, 0x4c05da00, 0xc01df002, 0x00db02b6,
+0x09d0024d, 0xdf0137c0, 0x70004d00, 0x0054c201, 0x074c805b, 0x08c0b531,
+0x00000e20, 0x00000000, 0x043d8007, 0x01d410ff, 0x31c00671, 0xfc802510,
+0xc23ff00a, 0x00f7107d, 0x0ff0027c, 0xff003e84, 0xf203dc00, 0x007fc80e,
+0x17dd0077, 0x1fc017f0, 0x00000600, 0x00000000, 0x00350802, 0x82ad229f,
+0x3cf04b30, 0x4c10d341, 0xc60d3003, 0x00d740b4, 0x0d30024c, 0xcf04b7c0,
+0xb0004c04, 0x0004c101, 0x234c1013, 0x08c00530, 0x00000420, 0x00000000,
+0x04f4a013, 0x434400dd, 0xb4403d10, 0x6c12d100, 0x440d1001, 0x00f140b4,
+0x2d10026c, 0xdda83740, 0x100b0403, 0x02b0431d, 0x07440055, 0x4ec1a732,
+0x00000200, 0x00000000, 0x00f22003, 0x4b0400cd, 0x00400c94, 0x0403c502,
+0x42081003, 0x00d144a4, 0x4c100204, 0x4d20e240, 0x90c82449, 0x00004020,
+0x83140241, 0x1c422990, 0x00000a00, 0x00000000, 0x007a0a04, 0x070401fd,
+0x58419490, 0xa409a500, 0x401e1437, 0x41f12248, 0x1e1006a4, 0x6d017b40,
+0x1027a509, 0x0448489c, 0x07d60165, 0x12401b10, 0x00000200, 0x00000000,
+0x08321012, 0x820e18cf, 0xa04408b0, 0x0c08c701, 0xc08c3013, 0x00d38280,
+0x8c34030c, 0x4d0c33c0, 0xb8806400, 0x0004c080, 0x031c0003, 0x48c028b0,
+0x00000040, 0x00000000, 0x003da802, 0x03dc60ef, 0x3fc00f70, 0xfc08eb10,
+0xc08bf011, 0x00df0207, 0x0ff023fc, 0x6f011fc2, 0xf003dc00, 0x401fc08f,
+0x03ed08fb, 0x0bc00af0, 0x00000660, 0x00000000, 0x0077a010, 0x81fe00db,
+0x0dc00d70, 0x4c01d340, 0xc04d3003, 0x00d34407, 0x0d7082fc, 0xd30037c0,
+0x30004c00, 0x0014d001, 0x034c20d7, 0x54c001f0, 0x00000e00, 0x00000000,
+0x00399912, 0x01b400e1, 0x104004b2, 0x8400e140, 0x410a1003, 0x06eb0003,
+0x0e1002f4, 0xf1003b40, 0x14038000, 0x0038500e, 0x028400e1, 0x494032d0,
+0x00000620, 0x00000000, 0x00790004, 0x063401e9, 0x69401a50, 0xc401e100,
+0x401a1007, 0x05e1004b, 0x1e5006b4, 0xe1047b40, 0x54040400, 0x04484010,
+0x0784010d, 0x0c4018d0, 0x00000400, 0x00000000, 0x20332016, 0x0b3409c1,
+0x30400c51, 0x4412c100, 0x480c1005, 0x00c90083, 0x0c102674, 0xc1007346,
+0x50030400, 0x0c70400d, 0x074400c9, 0x494088d0, 0x00000c20, 0x00000000,
+0x0017a817, 0x09f4037b, 0x1dc00750, 0xcd847348, 0xc2053401, 0x00530017,
+0x0571017c, 0x53409fc0, 0x70014c02, 0x005cc605, 0x054d227f, 0x5cc037f0,
+0x00000620, 0x00000000, 0x00058012, 0x407c001f, 0x03c001b0, 0x7ca01f00,
+0xc401f220, 0x001f2003, 0x01f0007c, 0x0f0047c0, 0xb000bc10, 0x0007d003,
+0x287c0317, 0x4bc101f0, 0x00000c00, 0x00000000, 0x00250810, 0x023c109f,
+0x24c00830, 0x70029340, 0xc8090402, 0x05830434, 0x5930824c, 0x930027c0,
+0x34067c05, 0x0026c229, 0x064c0093, 0x40800934, 0x00000c20, 0x00000000,
+0x38262001, 0x0270209d, 0x24440911, 0x74009100, 0x42091002, 0xa1911024,
+0x29500254, 0x910a2340, 0x10064400, 0x50245009, 0x6a440391, 0x04408910,
+0x00000800, 0x00000000, 0x0464a01c, 0x0274009d, 0x24540910, 0x74009160,
+0x40085202, 0x00910024, 0x09100244, 0x91002740, 0x1022e400, 0x8022400b,
+0x02441881, 0x61400818, 0x00000200, 0x00000000, 0x00202814, 0x5234008d,
+0x20414810, 0x34148105, 0x51485002, 0x28814230, 0x18500a14, 0x81203740,
+0x10228408, 0x0220408e, 0x22050881, 0x41508810, 0x00000080, 0x00000000,
+0x0006b01d, 0x107e141f, 0x04c24130, 0x7c040301, 0xc0417028, 0x02130584,
+0x0130504c, 0x134007c0, 0x30586c16, 0x0d82c163, 0x084c1613, 0x75c16130,
+0x00000ac0, 0x00000000, 0x0023a919, 0x82fc00ff, 0x2fd40bf4, 0xbc14ff30,
+0xc54bb007, 0x869f0127, 0x0bf002fc, 0x9f002bc0, 0xf1126c04, 0x012fc249,
+0x12fc04bb, 0x66c04bf0, 0x00000e60, 0x00000000, 0x802fa018, 0x027c049f,
+0x25c14930, 0x4c00b300, 0xcb2d3022, 0x00b31024, 0x0af0027c, 0xa3002cc2,
+0x3002cc00, 0x0526c089, 0x024c409f, 0x60c00970, 0x00000e00, 0x00000000,
+0x0007181c, 0x087c021f, 0x0c482110, 0x5d161108, 0x44411000, 0x1f130280,
+0x01d00074, 0x111016d0, 0x10000404, 0x01844000, 0x0045001d, 0x7140a2d0,
+0x00000c20, 0x00000000, 0x00210012, 0x0eb402ad, 0xeb401a94, 0x04428900,
+0x40089212, 0x04890462, 0x08d05a34, 0x81002442, 0x10420430, 0x0428404a,
+0x52a416ad, 0x40414a50, 0x00000e80, 0x00000000, 0x00252018, 0x02d40095,
+0x2e408b90, 0x14048948, 0x44499082, 0x80910026, 0x49d01274, 0x91002440,
+0x18034400, 0x083c400b, 0x12e400bd, 0x61400bd0, 0x00000620, 0x00000000,
+0x0027a805, 0x0a74029d, 0xa7c029b0, 0x4c029b00, 0xd009a002, 0x009b4026,
+0x18f0067c, 0x9340a440, 0x30024c20, 0x0064c009, 0x066c0d9f, 0x14c12970,
+0x00000e20, 0x00000000, 0x00258012, 0x0e78009f, 0x25c01872, 0x5c209748,
+0xc0087412, 0x009f0035, 0x09f1067c, 0x9f1227c0, 0xf4023d00, 0x00a5d009,
+0x065c108f, 0x53c008f0, 0x00000600, 0x00000000, 0x00450810, 0x00bc423f,
+0x08c00338, 0x4c001300, 0xc0013000, 0x00134040, 0x11f0004c, 0x034044c0,
+0xb0004c00, 0x0306c000, 0x804c8013, 0x50c061f2, 0x00000420, 0x00000000,
+0x009ca014, 0x0174005d, 0x15500510, 0x44847100, 0x40051001, 0x005b0014,
+0x67d10144, 0x71109846, 0x142d4604, 0x00944205, 0x2d449051, 0x52c005d2,
+0x00000200, 0x00000000, 0x0032a014, 0x033400cd, 0x30500c10, 0x0484c950,
+0x400c5403, 0x21c10830, 0x1cd00304, 0xc1083042, 0x942f0580, 0x40f2420c,
+0x070403c1, 0x52402cd8, 0x00000a00, 0x00000000, 0x04388801, 0x00b4002d,
+0x41500210, 0x84002940, 0x404ed003, 0x03e91038, 0x0ed10384, 0xe1103840,
+0x90038408, 0x0058480a, 0xc38600f1, 0x16400ed0, 0x00000200, 0x00000000,
+0x00781011, 0x073c01ef, 0x38c01c10, 0xcd01eb00, 0xd03f741f, 0x01f30878,
+0x1ef0178d, 0xa30078d0, 0xb00f8405, 0x007ec01e, 0x078d01e3, 0x56d01af0,
+0x00000040, 0x00000000, 0x0015a810, 0x007c001f, 0x07d001c4, 0x7c000700,
+0xc16d305b, 0x00df00b7, 0x05f0237c, 0xdf0033c0, 0x70037c20, 0x0017c20d,
+0x037c00cd, 0x43c029f0, 0x00000660, 0x00000000, 0x005d2000, 0x87cc01ef,
+0x7cc21f30, 0x8d21f328, 0xc01fb007, 0x01b300fc, 0x1f3007cc, 0xff005fc0,
+0x7507fc01, 0x007ec01f, 0x86cc8177, 0x00c03730, 0x00000e00, 0x00000000,
+0x00191815, 0x0084082f, 0x08408208, 0x8400a100, 0x400e9003, 0x00af0238,
+0x06b103ac, 0xef003b44, 0x1063840a, 0x021e508a, 0x02d510e1, 0x544006b0,
+0x00000620, 0x00000000, 0x00090000, 0x030510ed, 0x3a400c10, 0xc400a102,
+0x410c1063, 0x00a10030, 0x0a1003a4, 0xcd043b40, 0x50031400, 0x0038500c,
+0x63a4087d, 0x00400310, 0x00000400, 0x00000000, 0x00112004, 0x00040205,
+0x02422014, 0x04018100, 0x401c140f, 0x009d0130, 0x10100324, 0xc501f340,
+0x10030400, 0x0112400c, 0x06340259, 0x10400090, 0x00000c20, 0x00000000,
+0x0025a815, 0x074402dd, 0x76c09d30, 0xcd32c330, 0xd01fb083, 0x00d340b4,
+0x551003ec, 0x7d0077c0, 0x700ddc00, 0x00a4c075, 0x856c099f, 0x54d00d34,
+0x00000620, 0x00000000, 0x00370001, 0x047c101f, 0x45c011f0, 0x7c101f00,
+0xc80df043, 0x00df0037, 0x25f1037c, 0xcf2037c4, 0xf0415c82, 0x02b5d041,
+0x015c0097, 0x07c02d70, 0x00000c00, 0x00000000, 0x022f0884, 0x038c00eb,
+0x32c00e30, 0xcc00f300, 0xc00fb403, 0x0193003f, 0x4338030c, 0x7f003fc0,
+0xb0008e01, 0x00a8c02f, 0x01c908b2, 0x00801e30, 0x00000c22, 0x00000000,
+0x20122085, 0x00440011, 0x05480154, 0x41001500, 0x420d1003, 0x01b10037,
+0x31500344, 0xdd08e640, 0x10004401, 0x00b44131, 0x0144009b, 0x06c01910,
+0x00000802, 0x00000000, 0x0014a201, 0x034000d9, 0x36580d11, 0x04a0d110,
+0x400d1883, 0x04910833, 0x25100344, 0x550d3748, 0x90934444, 0x00244204,
+0x42170055, 0x05406d10, 0x00000200, 0x00000000, 0x00102810, 0x00044001,
+0x01400050, 0x04208500, 0x400c1803, 0x00810053, 0x04500305, 0xcd003340,
+0x10010400, 0x00004000, 0x021500cd, 0x43400416, 0x00000080, 0x00000000,
+0x0006b000, 0x034d00db, 0x36c00d30, 0xcd008320, 0xc00fb003, 0x00d30037,
+0x0110034c, 0x5f8037c8, 0xb0034400, 0x0824d00d, 0x015c0017, 0x01c00d30,
+0x00000ac0, 0x00000000, 0x001fa805, 0x00fc003f, 0x0fc003f4, 0xfc00bf60,
+0xc00ff003, 0x00ff003f, 0x03f003fc, 0xff002ec0, 0xf401fd00, 0x000fc203,
+0x00ec002b, 0x16c002f0, 0x00000e60, 0x00000000, 0x003fa003, 0x33dc0cf7,
+0x0ce80330, 0xf450f301, 0xc02ff040, 0xb4ef010f, 0x4f3010dc, 0xf3060cc0,
+0x3000fc10, 0x013ac003, 0x03844cfb, 0x0cc00f30, 0x00000e00, 0x00000000,
+0x203f0801, 0x3a4c0e41, 0x8440a110, 0x7416e180, 0x4a2fd149, 0x82fd2182,
+0xef100844, 0xf1098441, 0x10387412, 0x02bc40e1, 0x03440ee1, 0x04402f50,
+0x00000c20, 0x00000000, 0x0033a011, 0x030500c5, 0x20414014, 0x3400c107,
+0x406cd010, 0x00cd0603, 0x0d100814, 0xc1002040, 0x10c03404, 0x00304104,
+0x036400c9, 0x44402d10, 0x00000e80, 0x00000000, 0x08358803, 0x4244a051,
+0x25410010, 0x7600d105, 0x400dd000, 0x00dd0017, 0x0d130044, 0xd0000542,
+0x10013400, 0x18344904, 0xa36400d1, 0x0c400d50, 0x00000620, 0x00000000,
+0x0037a802, 0x2c44a017, 0x14500d30, 0x7c00d040, 0xc00df20a, 0x00df1137,
+0x0d10015c, 0xd34094e2, 0x340b7c00, 0x0034d009, 0x036d00db, 0x08d00d30,
+0x00000e20, 0x00000000, 0x00358007, 0x42fe082f, 0x5ac09ff1, 0x7c00ff00,
+0xc80ff017, 0x00ff303e, 0x0ff4657c, 0xff0096c0, 0xf1007c00, 0x143fe00f,
+0x03d800ff, 0x1fc00df2, 0x00000600, 0x00000000, 0x00350802, 0x080c1097,
+0xa4c02df1, 0x5c04db10, 0x840d3408, 0x08d30007, 0x4d30036c, 0xd740a4c0,
+0x340b7c00, 0x0037c029, 0x035c20c7, 0x08c00df1, 0x00000420, 0x00000000,
+0x003ca013, 0x0a4c0091, 0x24400dd2, 0x4423f300, 0x400f1014, 0x02e10817,
+0x2e108304, 0xf1000441, 0x1281740a, 0x04bb480d, 0x630400f1, 0x4c507e30,
+0x00000200, 0x00000000, 0x00368007, 0x01060285, 0x014000d1, 0x1400c500,
+0x440c501c, 0x10c10003, 0x1c100224, 0xc1000440, 0x10003400, 0x00724000,
+0x0f1400c5, 0x9c404c50, 0x00000a00, 0x00000000, 0x00788004, 0x45a51161,
+0x49541cd0, 0xa409e500, 0x461e1105, 0x21e1004b, 0x1f100684, 0xe1106840,
+0x1006b401, 0x017b4012, 0x07842de1, 0x10405e12, 0x00000200, 0x00000000,
+0x00301012, 0x010e0487, 0x15c000f0, 0x1c10c740, 0xc00c300b, 0x00c34023,
+0x0c34612c, 0xc100b0c0, 0x30083c00, 0x0032c08c, 0x031c04c7, 0x48c00c70,
+0x00000040, 0x00000000, 0x043db802, 0x21dc007d, 0x1ec00ff0, 0xdc00fa02,
+0xc48ff003, 0x00fd103f, 0x0ef001fc, 0xfb003fc1, 0xf003fc00, 0x013fc40f,
+0x23fe24df, 0x0bc14f70, 0x00000660, 0x00000000, 0x0d37a015, 0x004c0117,
+0x37c00134, 0x4d13df08, 0xc18d7002, 0x10de0036, 0x4df0024c, 0xd10814c8,
+0xf0037c14, 0x0d33c001, 0x434c12d3, 0x54c10d72, 0x00000e00, 0x00000000,
+0x01398812, 0x03c40071, 0x3b400e10, 0x8406fd00, 0x400ed003, 0x80e9003b,
+0x4fd00284, 0xe1003041, 0xd002b482, 0x003b4006, 0x939402f1, 0x48404ed0,
+0x00000620, 0x00000000, 0x00710003, 0x048401a5, 0x7b401210, 0x8401ed00,
+0x405ed007, 0x09cd206b, 0x5ed00786, 0xe1007840, 0xd007b445, 0xc27f403a,
+0x278405e1, 0x0e401ed0, 0x00000400, 0x00000000, 0x10332812, 0x070521c1,
+0x73401d10, 0x0420cd02, 0x400dd00b, 0x00c900f7, 0x0cd00f04, 0xd1023050,
+0xd0077400, 0x0033401d, 0x171400c0, 0x4a420cd0, 0x00000c20, 0x00000000,
+0x0015a837, 0x1dcc0777, 0x9fc07730, 0xcc005f00, 0xc4057001, 0x005f015f,
+0x07f015cc, 0x53005cc0, 0xf01dfc00, 0x001fc037, 0x488c0061, 0x5ed006f8,
+0x00000620, 0x00000000, 0x00070012, 0x407c101f, 0x07c101f0, 0x7c801f04,
+0xc001f000, 0x000b0407, 0x01f0405d, 0x1f4007c0, 0xf0407c00, 0x0007c101,
+0x007c001f, 0x49c001f0, 0x00000c00, 0x00000000, 0x00270810, 0x8e3c409b,
+0x24c00930, 0x7e009f10, 0xc2093042, 0x00930024, 0x39d0024c, 0x9b0024c0,
+0x70024c05, 0x2020c009, 0x004c0093, 0x40c009f2, 0x00000c20, 0x00000000,
+0x00262001, 0x0e740091, 0x24480910, 0x74829d00, 0x4009100a, 0x00910024,
+0x39d28264, 0x910026c0, 0x10024503, 0x10a44009, 0x046c8091, 0x04400910,
+0x00000800, 0x00000000, 0x0020a018, 0x42740099, 0x24440910, 0x34029d00,
+0x4009100a, 0x00910024, 0x08d00365, 0x91002051, 0x108244c2, 0x41244009,
+0x19450099, 0x60601950, 0x00000200, 0x00000000, 0x00a02010, 0x0a340281,
+0x2141c810, 0x34808d17, 0x50881052, 0x00818720, 0x08d05224, 0x81672040,
+0x18720400, 0x022051c8, 0x22240891, 0x40489810, 0x00000080, 0x00000000,
+0x0006b01d, 0x007cc01b, 0x84d06130, 0x74141f11, 0xc1613410, 0x14134184,
+0x41f0104c, 0x13018441, 0x34184c14, 0x9594c061, 0x584c5613, 0x74d16172,
+0x00000ac0, 0x00000000, 0x00a7b819, 0x8afc62bf, 0x2ec84bf4, 0xf4149f01,
+0xc0497152, 0x009f012f, 0x49f002dc, 0x9f092fc3, 0xf012fc14, 0x2127c84b,
+0x12dd849f, 0x67c04870, 0x00000e60, 0x00000000, 0x01a7a018, 0x4afc06b3,
+0x27c029f0, 0xdc10bf85, 0xc1293042, 0x04932127, 0x2bf0123c, 0xbf08270e,
+0x30424c86, 0x01afc009, 0x168c109b, 0x60c12bf0, 0x00000e00, 0x00000000,
+0x0107081c, 0x10342659, 0x8344a1d8, 0x55001d11, 0x40605408, 0x42110597,
+0x019100e6, 0x19038640, 0x12004504, 0x004740a5, 0x544c0217, 0x704071d0,
+0x00000c20, 0x00000000, 0x0322a010, 0x02340889, 0x230048d0, 0x04108d04,
+0x40485052, 0x08a90223, 0x28c00ab4, 0x8d042340, 0x90420402, 0x91b74108,
+0x0a243481, 0x40404cd0, 0x00000e80, 0x00000000, 0x0025a818, 0x02748099,
+0x274009d0, 0x44209900, 0x4409102a, 0xa0990227, 0x09d046f4, 0x9d01a740,
+0x94064400, 0x20074049, 0x50440095, 0x604801d0, 0x00000620, 0x00000000,
+0x40278805, 0x027c0293, 0x274809d2, 0x5c209d01, 0xc0097002, 0x00994027,
+0x09f88274, 0x9f0827e0, 0xb0024400, 0x0007c029, 0x00640093, 0x14d001d0,
+0x00000e20, 0x00000000, 0x00258014, 0x027c0097, 0x67c209f0, 0x7c009f02,
+0xc009f042, 0x00971023, 0x09b0026c, 0x9b1066c0, 0x70027c00, 0x8007c009,
+0x007d009f, 0x53c001f0, 0x00000600, 0x00000000, 0x20010814, 0x907c0212,
+0x87a00130, 0x7c400300, 0xc001f288, 0x00330004, 0x813108fc, 0x0f1007c0,
+0xf0003c00, 0x0044d021, 0x88440013, 0x50c01072, 0x00000420, 0x00000000,
+0x0014a014, 0x89f43071, 0x17e2051d, 0xf6007100, 0x4005d00d, 0x40530014,
+0x1710015c, 0x7d0017c0, 0xd0817401, 0x000c4005, 0x08ec0051, 0x50400330,
+0x00000208, 0x00000000, 0x8032a014, 0x833412c1, 0x33420c50, 0x7409c908,
+0x400cc80f, 0x00c50030, 0x0c140334, 0xcd003340, 0xd8033401, 0x0034620c,
+0x170400d9, 0x50400c51, 0x00000a00, 0x00000000, 0x00308005, 0x04b40021,
+0x79444e52, 0xb480e111, 0x481ed043, 0x802d2338, 0x0e9004b4, 0x6d003908,
+0xd003b410, 0x013040dc, 0x77e580c9, 0x14404e90, 0x00000200, 0x00000000,
+0x01781015, 0x07bc01e3, 0x7b409e50, 0xb441eb45, 0xd11ef005, 0x81e74570,
+0x163007bc, 0xad127b40, 0xf027bc01, 0x4378c05e, 0x278d01eb, 0x54d03c70,
+0x00000040, 0x00000000, 0x1135b810, 0x0274001f, 0x37808da1, 0x7c005f00,
+0xc0adf001, 0x00130837, 0x0d70005c, 0x1f02b7c0, 0xf0837c00, 0x13b7c10d,
+0x1b5c5ed7, 0x43c16d70, 0x00000660, 0x00000000, 0x04bfa000, 0x85fe09bf,
+0x7fc2cff0, 0xe981ff24, 0xc81ff007, 0x01ff107d, 0x1f7007fc, 0xfb087cc8,
+0xe067cc21, 0x007cc01f, 0x07c409f9, 0x00c01ff0, 0x00000e00, 0x00000000,
+0x02398815, 0x109c00ad, 0x3b440ec0, 0x8400ad10, 0x400ec000, 0x00292038,
+0x0e1000b4, 0x65003c10, 0xd0238482, 0x0038424e, 0x5b868ce1, 0x54408ed2,
+0x00000620, 0x00000000, 0x02390000, 0x01b600ad, 0x3b608ed1, 0x8400e900,
+0x400ed043, 0x00ed0438, 0x06500324, 0xa1003c40, 0xda0b8400, 0x4232450c,
+0x038400e1, 0x02400ed0, 0x00000400, 0x00000000, 0x00332804, 0x1a10018d,
+0x33402cc0, 0x00000d80, 0x480cd000, 0x400d9830, 0x08100034, 0x05043042,
+0xd1030400, 0x0032401c, 0x0f4500c1, 0x12440cd0, 0x00000c20, 0x00000000,
+0x003da815, 0x0a74005f, 0x3fc0afd0, 0x4c001b00, 0xd00ff006, 0x00df007c,
+0x0d70036c, 0xd1003c80, 0xc003cd00, 0x4032e01f, 0x8f4c00f3, 0x56900cf0,
+0x00000620, 0x00000000, 0x20370001, 0x205c180f, 0x33c41df0, 0x1c00df00,
+0xc00cf002, 0x001b0037, 0x04f0007c, 0xd70836c0, 0xf2077c00, 0x0035c00d,
+0x1b6c00cf, 0x05c00df0, 0x00000c00, 0x00000000, 0x803f0880, 0x03ec097f,
+0x3ec00ef0, 0xfc251330, 0xc00d3020, 0x40ff003c, 0x45f003fc, 0x5f003cc0,
+0xf003cc02, 0x203fc00f, 0x07cc00f3, 0x00c00d30, 0x00000c22, 0x00000000,
+0x00362081, 0x2744531d, 0x34600dd0, 0x74025108, 0x440db000, 0x20170034,
+0x15d00074, 0x5f003440, 0xd0034403, 0x0035c00d, 0x034400d1, 0x04400db0,
+0x00000802, 0x00000000, 0x0034a001, 0x0064005d, 0x34400dd2, 0x74021150,
+0x400d5803, 0x00dd0035, 0x0dd00374, 0x8d003441, 0xd0035480, 0x0077400d,
+0x234500d9, 0x04601d10, 0x00000200, 0x00000000, 0x00302010, 0x800480cd,
+0x32400cd1, 0x36008180, 0x500c1400, 0x00050031, 0x04c00034, 0x85003050,
+0xd0031000, 0x0075000c, 0x034400c0, 0x40501d90, 0x00000080, 0x00000000,
+0x003eb000, 0x016e005d, 0x3cd00fd0, 0x7c601300, 0xc00f1003, 0x40df203d,
+0x05f00374, 0x1d003cc4, 0xf003dc00, 0x0037c00f, 0x034c00eb, 0x00d00d30,
+0x00000ac0, 0x00000000, 0x003fb805, 0x03fc00ff, 0x3dc00ff8, 0xfc403f00,
+0xc00ff000, 0x0036003e, 0x07f000fc, 0x3f803fc4, 0xf003ec00, 0x503fc00f,
+0x03fc00ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x102fa203, 0x83bc0873,
+0x1fc14f30, 0xce003328, 0xc06b3088, 0x02f70a3f, 0x0ff003cc, 0xf7080fc6,
+0x7080ee04, 0x081fc02f, 0x03cc003f, 0x0cc043f0, 0x00000e00, 0x00000000,
+0x06b70801, 0x03f42081, 0xaf482d14, 0x44520100, 0x406bb000, 0x24f1003f,
+0x01d003c5, 0xd9422300, 0xb2007000, 0x0837424d, 0xc344401d, 0x0440a5d0,
+0x00000c20, 0x00000000, 0x2123a011, 0x03344481, 0x93400c10, 0x040c0100,
+0x4028d013, 0x04c51133, 0x1cd00304, 0xcd604340, 0x18d20402, 0x2013404c,
+0x8334005d, 0x455014d0, 0x00000e80, 0x00000000, 0x0135a803, 0x03761091,
+0x67601d11, 0x44205508, 0x4009d083, 0x00d10037, 0x11d18344, 0xdd206744,
+0x90023400, 0x0017624d, 0x0160625c, 0x0c4005d0, 0x00000620, 0x00000000,
+0x0027a802, 0x037c40d3, 0x53c01d30, 0xc5011301, 0xc089f0c3, 0x00d72037,
+0x05f0034c, 0xd70847c0, 0x7006ec00, 0x2017812d, 0x0f7c005f, 0x09c48cf0,
+0x00000e20, 0x00000000, 0x40398007, 0x83f403ff, 0x2fc805f0, 0x3c453b00,
+0xc009b00f, 0x00ff0037, 0x0bf003f4, 0xf1002fc2, 0xf00f7800, 0x801e821f,
+0x8bdd007f, 0x1fc20fe0, 0x00000600, 0x00000000, 0x00250802, 0x034c81df,
+0x14d00d34, 0x4c014b00, 0xd0093083, 0x00d3c030, 0x0db0037c, 0xdb4007c0,
+0xb0834c00, 0x0094c01d, 0x0f4c0a53, 0x08c10df0, 0x00000420, 0x00000000,
+0x0034a013, 0x1b80019d, 0x24400d10, 0xc4005000, 0x01094003, 0x00f1003c,
+0x1b5003fc, 0xf1002704, 0xb10fe88a, 0x0044881d, 0x876c6041, 0x4e803fd0,
+0x00000200, 0x00000000, 0x0022a007, 0x932500cd, 0x72498810, 0x04200900,
+0x033c1003, 0x00d10031, 0x1c180334, 0xc8101702, 0x9044048a, 0x01d3612c,
+0x02140185, 0x1c4294d2, 0x00000a00, 0x00000000, 0x00788004, 0x27a409ad,
+0x62401e10, 0x84016120, 0x401e5807, 0x21e10279, 0x1a402794, 0xe1c05b41,
+0x91458401, 0x4459401f, 0x0fb50925, 0x124016d1, 0x00000200, 0x00000000,
+0x00301012, 0x032c00cf, 0x12402832, 0x0c000b04, 0x42083083, 0x00c12031,
+0x8cb00374, 0xcb400340, 0xb0010424, 0x0093c00c, 0x0b1c4057, 0x48c08cf0,
+0x00000040, 0x00000000, 0x003db802, 0x0bdc00bf, 0x2dc08ff0, 0xfd407f80,
+0xc80bf003, 0x00df0c36, 0x0bf04bfc, 0xee023fc0, 0xe003fd00, 0x221ad80e,
+0x03ec007b, 0x0bc20ef0, 0x00000660, 0x00000000, 0x0827a015, 0x072d80cf,
+0xb4c20b32, 0x4c035384, 0xc0593203, 0x38d32134, 0x05300b4d, 0xd7000fc0,
+0xb0007c00, 0x2014c05d, 0x066c005f, 0x57c00d30, 0x00000e00, 0x00000000,
+0x00398812, 0x1b8400ed, 0x39080e15, 0xc6306110, 0x408b1003, 0x04f10338,
+0x4e1013fc, 0xe9003f08, 0xb503dc04, 0x801ac54f, 0x03ac007d, 0x4b406e32,
+0x00000620, 0x00000000, 0x00790003, 0x97e401fd, 0x78001812, 0xa4416188,
+0x401e14c3, 0x05e14870, 0xbe100384, 0xed084b0a, 0x10059409, 0x805840de,
+0x0796016d, 0x0f401e94, 0x00000400, 0x00000000, 0x08332812, 0x030608cd,
+0x30400c12, 0x24414148, 0x581c110f, 0x00d18030, 0x2c100374, 0xc9003744,
+0x94071400, 0x2882433c, 0x0324014d, 0x4b401c10, 0x00000c20, 0x00000000,
+0x0015a817, 0x01ec007f, 0xdcc02630, 0xac455324, 0xc055300d, 0x00530014,
+0x3730014c, 0x57411fc0, 0x300ddc80, 0x805ce635, 0x09dc097f, 0x5fc437b0,
+0x00000620, 0x00000000, 0x10070012, 0x007c921f, 0x87d001f1, 0x5d001f04,
+0xc201f000, 0x801f1007, 0x01f0007c, 0x170047c4, 0xf02c7c00, 0x1207e081,
+0x407d081f, 0x4bc091f1, 0x00000c00, 0x00000000, 0x00270810, 0x024d009f,
+0x64c109f8, 0x7c01d300, 0xc0093042, 0x00930027, 0x49b0026c, 0x930027c1,
+0x34227c00, 0x14274005, 0x024c019f, 0x43c059f0, 0x00000c20, 0x00000000,
+0x00262001, 0x0264228d, 0xe05009d9, 0x74219111, 0x40291082, 0x809b0027,
+0x29100255, 0x91502740, 0x100e7402, 0x00274001, 0x064c018d, 0x074019d0,
+0x00000800, 0x00000000, 0x0024a018, 0x0264809d, 0x244009d0, 0x76049112,
+0x41891002, 0x00912023, 0x09900264, 0x91c02740, 0x18033490, 0x022540a1,
+0x06402895, 0x634009d8, 0x00000200, 0x00000000, 0x02202010, 0x0224089d,
+0x205149d0, 0x76158105, 0x41481782, 0x08890123, 0x18102215, 0x81c22340,
+0x10233400, 0x00234088, 0x2624288d, 0x436008d9, 0x00000080, 0x00000000,
+0x0586b01d, 0x004e025f, 0x04d441d0, 0x7c040301, 0xc0413278, 0x021302c7,
+0x41b0586c, 0x13058741, 0x30587e34, 0x2017c169, 0x084d165f, 0x77c141f2,
+0x00000ac0, 0x00000000, 0x012fb819, 0x0a5e04be, 0x2bd00bf2, 0xfc149f40,
+0xc34be006, 0x269f0267, 0x0bf0127c, 0x9f512fc4, 0xd012fc00, 0x003ec449,
+0x129c04bf, 0x67c20ff0, 0x00000e60, 0x00000000, 0x0127a018, 0x424d22bf,
+0x2cc109b0, 0x0c909304, 0xc90b3036, 0x149301a7, 0x4b300adc, 0xb30326c0,
+0x3056ce04, 0x002ec01a, 0x02cc00bf, 0x63c04b30, 0x00000e00, 0x00000000,
+0x0107081c, 0x0044841d, 0x04520310, 0x44001b20, 0xc0011100, 0x02111107,
+0x21109078, 0x11008440, 0x10014c42, 0x2007c001, 0x8054951d, 0x734021b2,
+0x00000c20, 0x00000000, 0x04a3a010, 0x0284048d, 0x20400a12, 0x3510c100,
+0x4908d032, 0x208120a3, 0x28101a11, 0x8901a040, 0x10422442, 0x00204418,
+0x0614018d, 0x43408810, 0x00000e80, 0x00000000, 0x0825a818, 0x0244409d,
+0x24450b10, 0x24848900, 0x4819d002, 0x20910027, 0x29120274, 0xd940a450,
+0x14020580, 0x00274019, 0x0654019d, 0x63404990, 0x00000620, 0x00000000,
+0x0227a805, 0x824c059f, 0x24c00930, 0x6c009301, 0xc809f016, 0x00930027,
+0x0834025c, 0x8b02e4c2, 0x32026400, 0x00a4c009, 0x025c239f, 0x17c20930,
+0x00000e20, 0x00000000, 0x00658014, 0x027c049f, 0x27c40870, 0x5c00df34,
+0xc0093526, 0x009f4025, 0x09f00265, 0x970065c0, 0xf0527c40, 0x0227c009,
+0x0274009f, 0x53c009f0, 0x00000600, 0x00000000, 0x00050814, 0x00bc0813,
+0x00d023f2, 0x7c001300, 0xc0113400, 0x00131003, 0x31f0000c, 0x134004d0,
+0x30007c00, 0x0484c011, 0x244c0113, 0x50c021f0, 0x00000420, 0x00000000,
+0x0014a014, 0x01744071, 0x9c4405d0, 0x74005100, 0xc0171201, 0x00513815,
+0x27d0056c, 0x75001440, 0x5001dc02, 0x081ec427, 0x8dc5037b, 0x504007d0,
+0x00000200, 0x00000000, 0x0032a014, 0x033410d1, 0x10480cd0, 0x3400c120,
+0x400c0003, 0x00d54833, 0x0cd00704, 0x45003440, 0x100c3484, 0x02304281,
+0x034000d1, 0x50400cd0, 0x00000a00, 0x00000000, 0x01788005, 0x04b400e1,
+0x104002d0, 0xf400a100, 0x402a1023, 0x08e50031, 0x2fd84394, 0xa5033104,
+0x5043f400, 0x004e04c2, 0x938442c9, 0x144014d0, 0x00000200, 0x00000000,
+0x417c1015, 0x03b401e3, 0x78401ef0, 0xbc016300, 0x40123037, 0x01f7007b,
+0x16d00785, 0x670338c0, 0x3007bc81, 0x0048c056, 0x8d8c4123, 0x54c41af0,
+0x00000040, 0x00000000, 0x0275b810, 0x007c00df, 0x37c000f0, 0x7c661f40,
+0xc005d20b, 0x01db10b5, 0x04f0036c, 0x9f0136c0, 0xb5011e00, 0x2003c411,
+0x877c001f, 0x43c005f2, 0x00000660, 0x00000000, 0x007fa000, 0x87fc01ff,
+0x7cc01f70, 0xcc03f700, 0xc897f027, 0x0df70cfc, 0x13b006cc, 0xf7607fc0,
+0x3004dc29, 0x024cc8d3, 0x07cc0d73, 0x00c48e30, 0x00000e00, 0x00000000,
+0x02398815, 0x00b600ad, 0x380c4212, 0xac00a146, 0x500ad033, 0x08e1023d,
+0x021002bc, 0xa1103b40, 0x1002d400, 0x0b09c4c3, 0x0ac48c71, 0x5440c6b0,
+0x00000620, 0x00000000, 0x00390000, 0x03b4086d, 0x38050e50, 0x84006500,
+0x000cd003, 0x04cd0038, 0x86100280, 0xed443b40, 0x5043b020, 0x008e40e2,
+0x21960ca1, 0x01448b10, 0x00000400, 0x00000000, 0x00772804, 0x0036800d,
+0xf0407010, 0x24200100, 0x4000d003, 0x00c92030, 0x40100224, 0x8940b340,
+0x5a0d0480, 0x00014001, 0x06544281, 0x10401490, 0x00000c20, 0x00000000,
+0x013da815, 0x037c11df, 0xb0d01d70, 0xcc015700, 0xc001f003, 0x00ff003c,
+0x3134024c, 0x9f00bfe1, 0x70045e40, 0x01c6c003, 0x8bdc28a3, 0x55d04534,
+0x00000620, 0x00000000, 0x20370001, 0x007c44df, 0xa7c001f2, 0x7c885f40,
+0xc00df203, 0x00d70033, 0x2170023c, 0xd7083740, 0xa4017e00, 0x4087c011,
+0x6b6900df, 0x078205f2, 0x00000c00, 0x00000000, 0x003f0880, 0x037c01f3,
+0x3cc00ef2, 0xce003306, 0xc00f3003, 0x00e3003d, 0x5630024c, 0x83143cc0,
+0x32c18c02, 0x080c4803, 0x00cc003f, 0x03c00330, 0x00000c22, 0x00000000,
+0x08362081, 0x007403d1, 0x344001d0, 0x44181100, 0x40015083, 0x00d50034,
+0x31102650, 0xd1603781, 0x50015483, 0x0007c029, 0x8a402939, 0x074125b0,
+0x00000802, 0x00000000, 0x0034a001, 0x83740a11, 0x34500dd0, 0x10000104,
+0x411c1203, 0x20d10036, 0x01138344, 0x91503142, 0x10084480, 0x21854031,
+0x0544005d, 0x07400510, 0x00000200, 0x00000000, 0x00302010, 0x00340001,
+0x204000d2, 0x04200100, 0x40085003, 0x00c50032, 0x001a0314, 0x41803340,
+0x50021420, 0x08034000, 0x80054049, 0x43400492, 0x00000088, 0x00000000,
+0x0036b000, 0x037c0013, 0x34c00df0, 0xd4800340, 0xc0053083, 0x00d3003c,
+0x05340344, 0x910039c0, 0x30034e80, 0x0005c401, 0x004c009f, 0x03c00132,
+0x00000ac0, 0x00000000, 0x003fb805, 0x00fc003f, 0x3bd002f0, 0xfd203b00,
+0xc403c003, 0x00ff003d, 0x03e203fc, 0xff003dc0, 0xf001fc00, 0x000bc003,
+0x00fc00bf, 0x17c007f0, 0x00000e60, 0x00000000, 0x003fa003, 0x23fc4cff,
+0x3ec043b8, 0xf884f301, 0xc44ff003, 0x2c730b0f, 0x0f3011fc, 0xf3260fc9,
+0x3102fc00, 0x023cc48b, 0x038c0c33, 0x0cc08fb0, 0x00000e00, 0x00000000,
+0x003b0801, 0x20740ed1, 0xbc41c9b0, 0x84bcf124, 0x49cf1203, 0x06450183,
+0x6f104930, 0xf1088741, 0x10387408, 0x423d48ad, 0x0bc40201, 0x1c406f10,
+0x00000c20, 0x00000000, 0x0032a011, 0x13140005, 0x30440414, 0x0400c983,
+0x420c5203, 0x0c410303, 0x0c901934, 0xc1000140, 0x10c23414, 0x41344848,
+0x23040801, 0x4c402d90, 0x00000e80, 0x00000000, 0x08358803, 0x2074b811,
+0x3040ad10, 0x0400c900, 0x420d1003, 0x02552087, 0x0d908174, 0xd1201340,
+0x10067480, 0x0035404c, 0x03460011, 0x1c4a0d90, 0x00000620, 0x00000000,
+0x0037a800, 0x855c2095, 0x34c00110, 0x4d00db40, 0xc40d7203, 0x01d30237,
+0x0db0097c, 0xd340b5c2, 0x30077440, 0x0834c009, 0x034d0253, 0x00c00db1,
+0x00000e22, 0x00000000, 0x083d8087, 0x84fc0097, 0x3dd80bf0, 0xfc20f720,
+0xc10f7003, 0x08ff007f, 0x0d7089fc, 0xff1007c0, 0xf101bc20, 0x0c3fc70b,
+0x03fc093f, 0x1fc00f70, 0x00000602, 0x00000000, 0x00310802, 0x030c0017,
+0x34c821f8, 0x7c40d322, 0xd00d3103, 0x22d380b0, 0x0d340b0c, 0xd340b4d0,
+0xb4037c40, 0x0037c019, 0x034d02d3, 0x28c00d70, 0x00000420, 0x00000000,
+0x003ca013, 0x22444011, 0x7c4409d2, 0xf441f340, 0x403f1003, 0x00db8034,
+0x1f108344, 0xf3081440, 0xf2037412, 0x00fb4029, 0x33840091, 0x4c400e10,
+0x00000200, 0x00000000, 0x0032a003, 0x0a042f45, 0x724001d0, 0x3648c900,
+0x481c5003, 0x00052800, 0x0c100204, 0xc9080064, 0x94023411, 0x00f34828,
+0x0b260091, 0x1c400c50, 0x00000a00, 0x00000000, 0x08788000, 0x048481e1,
+0x7f4010d2, 0xb601e100, 0x411c1303, 0x21650058, 0x1e100784, 0xe1306861,
+0xd407f401, 0x047f421e, 0x07a629e1, 0x74401f10, 0x00000200, 0x00000000,
+0x00301016, 0x030c0007, 0x32c08cd0, 0x3800cb02, 0xc00c1023, 0x00c54020,
+0x0c302b0d, 0xcb008080, 0xb4223c80, 0x0133c008, 0x032c0a83, 0x48c00c70,
+0x00000040, 0x00000000, 0x0435b800, 0x017d009f, 0x30c08df0, 0x7810d704,
+0xc18df073, 0x00db0037, 0x0df0836c, 0xdf0037c0, 0xf4033c18, 0x00b3c00d,
+0x035c28df, 0x0bc0acf0, 0x00000660, 0x00000000, 0x0037a015, 0x00644057,
+0xb6c4053a, 0x4d13cf04, 0xc95d304b, 0x005f0006, 0xedf0017c, 0xd71037c0,
+0xf0024c91, 0x2034d21c, 0x734c0053, 0x44c00d30, 0x00000e00, 0x00000000,
+0x133d8810, 0x80ac00c1, 0x3b400630, 0xc400ed01, 0x4a4e3093, 0x006d0018,
+0x4ed001b4, 0xcd002bc3, 0x70038404, 0x00b0400e, 0x83840061, 0x4c404c10,
+0x00000624, 0x00000000, 0x017900a3, 0x07040165, 0x7b401e91, 0x8401fd00,
+0x445e9303, 0x01ed0068, 0x1e1007b4, 0xed007b40, 0xd006a401, 0x4178401f,
+0x070401e1, 0x0440de14, 0x00000402, 0x00000000, 0x20332812, 0x436028c1,
+0x33400c94, 0x0400cd08, 0x420c9003, 0x0bcd00f4, 0x0cd00734, 0xcd207740,
+0x50072480, 0x0032401c, 0x03040ac1, 0xc84c0d10, 0x00000c20, 0x00000000,
+0x0015a816, 0x01cc4177, 0x1fc44730, 0x44207d00, 0xd0053001, 0x017f095c,
+0x063045fc, 0x7701dfc0, 0xf015ec80, 0x001cc017, 0x01cc0973, 0x5c500730,
+0x00000620, 0x00000000, 0x00070012, 0x007c001f, 0x87c00170, 0x7c821f00,
+0xc8217000, 0x101f0407, 0x21f0407c, 0x1f0405c0, 0xf0005d00, 0xa005c081,
+0x083d001f, 0x4bd001f0, 0x00000c00, 0x00000000, 0x00270810, 0x024c089f,
+0x66c20830, 0x7c009f02, 0xc049a102, 0x00830027, 0x0930020c, 0x930024c0,
+0xf0026c20, 0x1027c009, 0x264c0093, 0x41c00934, 0x00000c20, 0x00000000,
+0x18262000, 0x0e440091, 0xe4400915, 0x74129d00, 0x42399082, 0x00910827,
+0x29120244, 0x911826d1, 0xd0027400, 0x10a74209, 0x1a4c0081, 0x04400931,
+0x00000800, 0x00000000, 0x0020a018, 0x2244008d, 0x24400910, 0x34009d04,
+0x4109d802, 0x00910027, 0x09900244, 0x94002440, 0xd0036401, 0x00234089,
+0x02440099, 0x614009d0, 0x00000200, 0x00000000, 0x10a02010, 0x8a040281,
+0x215bc818, 0x34408d00, 0x4208d00a, 0x3c812723, 0x09147205, 0x81072040,
+0xd0723400, 0x00234148, 0x22041c89, 0x40408810, 0x00000080, 0x00000000,
+0x0004301c, 0x014d001f, 0x04c26130, 0x74141f95, 0xc140b000, 0x06134187,
+0x4130184c, 0x11418441, 0xf0186c14, 0x4517c041, 0x584c061b, 0x75c161b0,
+0x00000ac0, 0x00000000, 0x08a7b039, 0x0bfc22bf, 0x26c04bf0, 0x7c949f05,
+0xc149320a, 0x04bf012f, 0x497092fc, 0x9f112fc1, 0xf012fc34, 0x2527c54b,
+0x125d04a7, 0x67c049f0, 0x00000e64, 0x00000000, 0x01a7a218, 0x42cc06bf,
+0xafc029f2, 0x7412bf01, 0xc06bf01a, 0x049f0127, 0x2bf0127c, 0xbf0424c1,
+0xf01a4c02, 0x04afc04b, 0x5acc269f, 0x63c02914, 0x00000e00, 0x00000000,
+0x0186089c, 0x00440651, 0x874421d0, 0x1c461d21, 0x44411098, 0x021d0517,
+0x00700074, 0x1d018444, 0xd0014504, 0x01874161, 0x1c44005d, 0x73400010,
+0x00000c22, 0x00000000, 0x00a1a010, 0xc205228d, 0xa34068d0, 0x36008920,
+0x4468d00a, 0x188d00a3, 0x09905a34, 0x99042054, 0xd01a0406, 0x01214088,
+0x1244028d, 0x4b402810, 0x00000e80, 0x00000000, 0x00252818, 0x226468d1,
+0x274429d0, 0x74209d00, 0x40091102, 0x429d0027, 0x09500a74, 0xdd082540,
+0xd0024440, 0x00276409, 0x0045009d, 0x63400918, 0x00000620, 0x00000000,
+0x0027a801, 0x0a4c009f, 0x27c019f0, 0x7c009f00, 0x4009f002, 0x019f10a7,
+0x09f0067c, 0x9f2024c0, 0xf0024800, 0x8825e409, 0x0044028f, 0x17c00912,
+0x00000c20, 0x00000000, 0x00218014, 0x065c4197, 0x27c049f0, 0x5c109f14,
+0xc0097802, 0x099f0027, 0x09f2227c, 0x9f0266c9, 0xf0027c10, 0x1027c109,
+0x407c409f, 0x5bc009f4, 0x00000400, 0x00000000, 0x00050814, 0x207c0a17,
+0x04c001e0, 0x4c801308, 0xc4015100, 0x00134084, 0x0170006d, 0x1b0804c0,
+0x30884d00, 0x0006d001, 0x006d0213, 0x50d201b0, 0x00000420, 0x00000000,
+0x1014a014, 0x05f48075, 0x9f4405d0, 0x44027100, 0x40071801, 0x00510014,
+0x36d20144, 0x6b0016e0, 0x10014412, 0x081c4027, 0x048c0071, 0x50400510,
+0x00000000, 0x00000000, 0x1032a014, 0x033413dd, 0xf0420cd0, 0x6403c100,
+0x401c5003, 0x00c19031, 0xbcd00304, 0xc5103040, 0x50033400, 0x0070402c,
+0x0f0400c1, 0x50400c10, 0x00000a00, 0x00000000, 0x02788205, 0x01b64025,
+0xe3404ed2, 0xa4038000, 0x443c1803, 0x05e10071, 0x0ec01394, 0xe9027e42,
+0x5417b400, 0x00f14818, 0x430404c1, 0x10405e10, 0x00000200, 0x00000000,
+0x033c1015, 0x84bc41a7, 0x78c37ef0, 0xa501e340, 0xd01a502f, 0x87c30179,
+0x1e709fac, 0xb3007c40, 0x710ffc01, 0x4078c01e, 0x178897e3, 0x50c43e30,
+0x00000040, 0x00000000, 0x0035b010, 0x007c001f, 0x37c40df2, 0x5c009f00,
+0xc005f11b, 0x02df20b6, 0x0df00b6c, 0x9f05b7c0, 0xb0034c00, 0x0014c40d,
+0x337c86df, 0x43c06d74, 0x00000660, 0x00000000, 0x007fa002, 0x06fc01f7,
+0x7fc09f36, 0xec01f703, 0x021ff007, 0x87ff24ff, 0xdbf23bfe, 0x7f007cc2,
+0xf08fcc81, 0x013cc017, 0x3f8c81ff, 0x08c03f30, 0x00000e00, 0x00000000,
+0x00388815, 0x209c006b, 0x29e08e30, 0xa448a122, 0x404a9003, 0x40ed013b,
+0x8a7103be, 0x2d013848, 0xd0038400, 0x0328400b, 0x238480ed, 0x44400e10,
+0x00000620, 0x00000000, 0x00390008, 0x40b400a5, 0x03448e90, 0x04004111,
+0x440a5023, 0x04ed083b, 0x409223b4, 0x6d0c3848, 0xd0238408, 0x823a4006,
+0x13c400cd, 0x00400e15, 0x00000400, 0x00000000, 0x80332816, 0x0c141241,
+0x05402c10, 0x04201100, 0x40011003, 0x09dd1073, 0x01502754, 0x0d203060,
+0xd0070600, 0x8006401c, 0x034400dd, 0x18400c18, 0x00000c20, 0x00000000,
+0x003da815, 0x0f7c0255, 0x1740afb0, 0xed805740, 0x4005f083, 0x20ffa17f,
+0x05d103f4, 0xdd003cd2, 0xf01fc400, 0x0006d11d, 0x034d01fd, 0x54500f34,
+0x00000620, 0x00000000, 0x28370009, 0x097c001f, 0x07c80df0, 0x7c005f00,
+0xc005f083, 0x00df0037, 0x0171037c, 0x5f0033c0, 0xf0937d02, 0x0035cc21,
+0x0b7c08df, 0x07c00df0, 0x00000c00, 0x00000000, 0x10370801, 0x47fc0037,
+0x3cc00f70, 0x8c08f300, 0x880b3803, 0x80ff003c, 0x8f3003cc, 0x930c3cc0,
+0x3003ccc0, 0x004fc00b, 0x0fcc00f3, 0x00c00e30, 0x00000c22, 0x00000000,
+0x08362081, 0x0374021d, 0xb4600dd0, 0x7c73d30c, 0x41255003, 0x80dd2034,
+0x3990036c, 0x1b0836c1, 0x10834400, 0x0cd5c241, 0x076c20d9, 0x04400db2,
+0x00000802, 0x00000000, 0x00348000, 0x9a7400dd, 0x14440cd0, 0x44801900,
+0x40055103, 0x00dd0035, 0x05900354, 0xcd003442, 0x14031400, 0x22074445,
+0x0b4400d9, 0x04400d10, 0x00000a00, 0x00000000, 0x00302010, 0x003480cd,
+0x01400cd0, 0x14000110, 0x44005003, 0xa0cd0031, 0x00960315, 0x01003040,
+0x10031400, 0x00214000, 0x036400d9, 0x40400c90, 0x00000080, 0x00000000,
+0x003eb000, 0x033c009f, 0x04500f70, 0xc5001b40, 0xd0091083, 0x80ff003d,
+0x053803d4, 0xd1403c50, 0x3203dd00, 0x4007c001, 0x034c00f2, 0x00d00e30,
+0x00000044, 0x00000000, 0x083f9004, 0x83fc00ff, 0x0ec00ff0, 0xec003f00,
+0xc003f103, 0x00ff103e, 0x037803ec, 0x3f003fc4, 0xf083ec00, 0x000dc203,
+0x03fc00f7, 0x17e80ff0, 0x00000e60, 0x00000000, 0x003fa003, 0x00fc1433,
+0x1ac00f30, 0xfc08ff00, 0xc84f7123, 0x04f100bd, 0x4b70d0ec, 0x3b053d80,
+0xf241dc80, 0x040ad40b, 0x03cc00f3, 0x0fc5c734, 0x00000e00, 0x00000000,
+0x20330801, 0x10748651, 0x25480f11, 0x7400dd00, 0x44edd013, 0x1af103bc,
+0xc8100855, 0x1100b450, 0xd0594424, 0x0094c00b, 0x030402eb, 0x07402511,
+0x00000c20, 0x00000000, 0xa033a011, 0x60341001, 0x20040c12, 0x3604cd00,
+0x410cd003, 0x00c19031, 0x04500004, 0x81003441, 0xd0010410, 0x05306888,
+0x830402c1, 0x47404414, 0x00000e80, 0x00000000, 0x20358803, 0x80740851,
+0x34580d10, 0x7400dd10, 0x400dd003, 0x00d18034, 0x09108514, 0x9540b440,
+0xd1074400, 0x00364009, 0x034400d9, 0x0f408512, 0x00000620, 0x00000000,
+0x4077a800, 0x03340093, 0x34c80c34, 0x7cb0df00, 0xc009f047, 0x00d34035,
+0x19700c4c, 0x1b2030c0, 0xf0075d09, 0x9034c808, 0x034d00d3, 0x0bc23530,
+0x00000e20, 0x00000000, 0x027d8087, 0x007c80ff, 0xadc80ff0, 0xf8a0fd20,
+0xc00ed08b, 0x40ee003b, 0x2bf082dc, 0x3b027fc4, 0xd0037c01, 0x003dc00b,
+0x83f800ff, 0x1fc015e0, 0x00000600, 0x00000000, 0x00350802, 0x236d0893,
+0x27c00d34, 0x7e01d320, 0xc0093003, 0x00d31034, 0x45b0024c, 0x930cb4c0,
+0x30127c01, 0x0033c009, 0x034d00d3, 0x08c06130, 0x00000420, 0x00000000,
+0x21f4a013, 0x8dc401d1, 0xa6480f10, 0x7401db03, 0x420d1082, 0x00fb003c,
+0x29108355, 0x910836c0, 0xb087742b, 0x0037424b, 0x03ee00f1, 0x4c502151,
+0x00000200, 0x00000000, 0x01e6a007, 0x84040109, 0x13400c10, 0x3400c100,
+0x500c1049, 0x00c90030, 0x09d00004, 0x11001060, 0x500d3482, 0x42234008,
+0x036400d5, 0x1c422c10, 0x00000a00, 0x00000000, 0x02688006, 0x1c844149,
+0x7b409e10, 0xf6016912, 0x491f1005, 0x4dc92278, 0x1a520694, 0x61427040,
+0xd055b401, 0x027b409a, 0x07a001e5, 0x10009e40, 0x00000200, 0x00000000,
+0x42201012, 0x800c060b, 0x23e80c10, 0x3400c320, 0xc88c3403, 0x04c98034,
+0x2cf0034c, 0xc3023040, 0x70013c00, 0x0233c008, 0x030c04c6, 0x48c00430,
+0x00000040, 0x00000000, 0x0a2db802, 0x90dc00b6, 0x3ec10ff0, 0xbc407f20,
+0xc00eb003, 0x05ff003f, 0x89b0237c, 0xff023fd8, 0xb013fc08, 0x023fc20b,
+0x63dc00fb, 0x0bc00ff4, 0x00000660, 0x00000000, 0x0037a015, 0x077c0093,
+0x34ed2d30, 0x7c84d300, 0xc009f001, 0x18db00b7, 0x0d30804c, 0x532005c4,
+0x30037c12, 0x2034c019, 0x034c04d3, 0x54c0093c, 0x00000e00, 0x00000000,
+0x00398812, 0x14b400e1, 0x38400f12, 0xb490e100, 0x400ed003, 0x01c1053b,
+0x0c1002ec, 0x61003bc4, 0x1003b400, 0x2038512a, 0x83d48af1, 0x48400e14,
+0x00000620, 0x00000000, 0x00790083, 0x27f40361, 0x68404e10, 0xb401e120,
+0x401ad007, 0x00e1427b, 0x1e100784, 0xe58c6d40, 0x90473401, 0x00f8404a,
+0x178405e1, 0x0c451210, 0x00000400, 0x00000000, 0x0a372812, 0x893440c1,
+0x74400c00, 0x34424140, 0x421cd187, 0x00c10033, 0x9c114324, 0xc5007240,
+0x90073401, 0x00704008, 0x031400c9, 0x48506010, 0x00000c20, 0x00000000,
+0x4055a817, 0x4dfc8173, 0x9cc00536, 0xfc485321, 0xc047f00d, 0x00530017,
+0x073409cc, 0x570859f0, 0xa52dfc05, 0x40dcc805, 0x014c0053, 0x5cc03734,
+0x00000620, 0x00000000, 0x00070012, 0x407c901f, 0x47c801f2, 0x7c001f08,
+0xc001f22c, 0x00170807, 0x01f0807d, 0x1a4007c0, 0x70007c02, 0x0007c000,
+0x007c0017, 0x4bc001f2, 0x00000c00, 0x00000000, 0x02270810, 0x067c4993,
+0x24c009f0, 0x7c01db00, 0xc059f012, 0x80830023, 0x0938024d, 0xd30064c8,
+0x20023c80, 0x0520d009, 0x020c8093, 0x40c00930, 0x00000c20, 0x00000000,
+0x00a62001, 0x22742091, 0xa50009d8, 0x76019140, 0x4809d012, 0x009b0027,
+0x2850026d, 0x93002474, 0x10027400, 0x00644019, 0x026c009b, 0x04402950,
+0x00000800, 0x00000000, 0x00a4a018, 0x02748091, 0x244008d0, 0x56089904,
+0x4009d802, 0x80910027, 0xa9120304, 0x91412440, 0x5482540a, 0x00344049,
+0x02440081, 0x6040ac10, 0x00000200, 0x00000000, 0x4a202010, 0x22340881,
+0x214828d0, 0x34008102, 0x61ccd002, 0x00890123, 0x89500224, 0x81003042,
+0x50233408, 0x022040c8, 0xa2240489, 0x40508850, 0x00000080, 0x00000000,
+0x0082b01d, 0x597c1613, 0x804001d0, 0x5c801b00, 0xc061d100, 0x1e1312c7,
+0x6110784d, 0x13450441, 0x70585c02, 0x0580c031, 0x084c0b13, 0x74d16030,
+0x00000ac0, 0x00000000, 0x212fb819, 0x92bc04ff, 0x2fc029f0, 0xfc149f01,
+0xc04bf052, 0x019d0263, 0x4bf006fc, 0x97003bc0, 0xb012fc04, 0x112fc0ca,
+0x1a7c099f, 0x67c04bf0, 0x00000e60, 0x00000000, 0x002fa019, 0x22bc6cb3,
+0xacc10870, 0x7c029700, 0xc14bf002, 0x029301a4, 0x8bb00a4d, 0xb3012cc0,
+0xf032fc00, 0x002cc183, 0x324c0c93, 0x60c14b30, 0x00000e00, 0x00000000,
+0x4107089c, 0x18740e11, 0x06400130, 0x74001511, 0x40217250, 0x80111180,
+0x8550006c, 0x13000450, 0xd0301c04, 0x14045071, 0x08144a11, 0x70506514,
+0x00000c20, 0x00000000, 0x0423a010, 0x0a340081, 0x62610850, 0x34208501,
+0x4149d012, 0x008180a0, 0x08100a44, 0x89022440, 0xd0123414, 0x02224008,
+0x1a240089, 0x40410814, 0x00000e80, 0x00000000, 0x0021a818, 0x82760091,
+0x22480991, 0x74009100, 0x08095062, 0x00810024, 0x89501264, 0x91002540,
+0xd00b5614, 0x04264009, 0x02342099, 0x60404814, 0x00000620, 0x00000000,
+0x0027a805, 0x227c0393, 0x64c00872, 0x7c049740, 0xc009f002, 0x80934024,
+0x0930164c, 0x9b40a0c8, 0xe0a27c01, 0x0062d008, 0x026c809b, 0x14c02934,
+0x00000e20, 0x00000000, 0x00258014, 0x823c029f, 0x65d00970, 0x7c00df11,
+0xd0097003, 0x009f1027, 0x09f0027c, 0x970026c0, 0xf0065c80, 0xc165c001,
+0x025c0097, 0x53c009f0, 0x00000600, 0x00000000, 0x00050814, 0x104c001f,
+0x04c20132, 0x7c001308, 0xc8113000, 0x00131003, 0x01b0086c, 0x1b0244c0,
+0x30004c10, 0x1006c401, 0x004c4003, 0x50d06130, 0x00000420, 0x00000000,
+0x801ca014, 0x05c4805d, 0x1c400712, 0x74055100, 0x6076b00d, 0x0051401f,
+0x375001fc, 0x7100dcc2, 0xb001dc83, 0x115c4013, 0x017c0051, 0x51501714,
+0x00000200, 0x00000000, 0x0062a014, 0x072501cd, 0x12520c10, 0x34004100,
+0x401c1048, 0x00c90033, 0xad900364, 0xc9807269, 0x50072601, 0x0870601c,
+0x030400c1, 0x50403012, 0x00000a00, 0x00000000, 0x0c288005, 0x43e403ed,
+0x2e404e12, 0xb4006100, 0x400a900e, 0x00e9023b, 0x0e542334, 0xa1001840,
+0xdb0e9603, 0x5020554c, 0x13b001c1, 0x15490210, 0x00000200, 0x00000000,
+0x00481015, 0x06ac81bd, 0x7a413e34, 0xf4016300, 0x48163017, 0x01c8417b,
+0x1cb417ac, 0xfb207250, 0x7407ad01, 0x007ac00e, 0x178c04e3, 0x54d01f34,
+0x00000040, 0x00000000, 0x202db810, 0x005800df, 0x21c00df0, 0x7c065f44,
+0xc007f0af, 0x00d70137, 0x0df00b6c, 0x9f0017d0, 0xa0026c00, 0x00a7c81d,
+0x2b6c02df, 0x42c00df4, 0x00000660, 0x00000000, 0x027fa002, 0x06fc41f3,
+0x5dc01fb0, 0xcc037300, 0xc097300d, 0x13f320fd, 0x1fb00fec, 0xf3206dc0,
+0xf006fc01, 0x03fec11f, 0x0fcc13f3, 0x00c01f30, 0x00000e00, 0x00000000,
+0x02398815, 0x01f404e1, 0x28c48e11, 0xc4806110, 0x41873089, 0x00f1013c,
+0x4e1013ed, 0xab002ac0, 0xd002b480, 0x022a400e, 0x03c440f1, 0x54400f52,
+0x00000620, 0x00000000, 0x200d0208, 0x42b400e1, 0x79400c90, 0xa4006900,
+0x4a86902b, 0x08e10839, 0x06128384, 0xa1003d44, 0xd002a400, 0x8120400f,
+0x038400e1, 0x004006d0, 0x00000400, 0x00000000, 0x00372806, 0x0c3421c1,
+0x24400c10, 0x04124940, 0x40041003, 0x00c10030, 0x7c102324, 0x8900f242,
+0xd00e3408, 0x0224420c, 0x030400c1, 0x1040a4d4, 0x00000c20, 0x00000000,
+0x0005a81d, 0x8f7c0fd3, 0x05c00fb0, 0xec005b00, 0xc009b01d, 0x00f3403d,
+0x4d3403cc, 0xd304f5c0, 0xf00a3c01, 0x6076f00c, 0x03cd40f3, 0x54d010f8,
+0x00000620, 0x00000000, 0x60070001, 0x037c809f, 0x35c00df2, 0x5c401702,
+0xc00df409, 0x00df0033, 0x0c70137c, 0x9f0417cc, 0xf22a7c00, 0x2027c80d,
+0x037c00df, 0x07c02364, 0x00000c00, 0x00000000, 0x002f0801, 0x428c03a3,
+0x2ec20e30, 0xcc007306, 0xc857f003, 0x00e3003c, 0x2f3c03ec, 0xf3001cc0,
+0x304efc00, 0x017ec00f, 0x03cc00e3, 0x00c10330, 0x00000c22, 0x00000000,
+0x18262089, 0x1e446091, 0x34400d50, 0x44005110, 0xd004d02f, 0x00da0036,
+0x1d100315, 0x9b025144, 0x50005c43, 0x0065401d, 0x035440df, 0x04509914,
+0x00000802, 0x00000000, 0x0414a001, 0x07450091, 0x06400d10, 0x44040180,
+0x4005d081, 0x00d10034, 0x0d580366, 0x1920b440, 0x50027423, 0x0034401d,
+0x030400d5, 0x0440251b, 0x00000200, 0x00000000, 0x40102010, 0x03048081,
+0x30400c50, 0x06000140, 0x4004d101, 0x00c90030, 0x0c520315, 0x89003140,
+0x52021400, 0x28214a0c, 0x031420cd, 0x40480d1a, 0x00000080, 0x00000000,
+0x0026b001, 0x02440093, 0x2ac20f12, 0x4c804300, 0x4005d002, 0x00f3003c,
+0x005003ec, 0x930014c0, 0x71027c00, 0x003ec00d, 0x03cc00f7, 0x00c00534,
+0x00000ac0, 0x00000000, 0x003bb805, 0x80fc80bf, 0x3fc00ff8, 0xfc607f08,
+0xc007f002, 0x00ff083f, 0x0bb003fc, 0xb7001bc0, 0xf080dc00, 0x082f800e,
+0x03fc40ff, 0x17c007f0, 0x00000e60, 0x00000000, 0xc080a300, 0x0833020e,
+0x839820e8, 0x3b038ec0, 0xb020ec08, 0x820ec083, 0x20ec0838, 0x0ec083b0,
+0xa8083b02, 0xc083b228, 0x083b020e, 0x03b020ec, 0x0000008c, 0x00000000,
+0xa022a200, 0x0232808e, 0x23a808ea, 0x3a808ea0, 0xa808ea02, 0x008ea023,
+0x08ea023a, 0x8ea023a8, 0xea023a80, 0xa023a808, 0x023a808e, 0x03a808ea,
+0x00000a88, 0x00000000, 0x80420100, 0x04120104, 0x41201048, 0x12010480,
+0x20104804, 0x01048041, 0x10480412, 0x04804120, 0x48051201, 0x80412018,
+0x04120104, 0x01201048, 0x00000004, 0x00000000, 0x80002100, 0x401a0006,
+0x01a2006a, 0x18108600, 0xa0006800, 0x80068001, 0x0068001a, 0x068001a0,
+0x6a401a00, 0x8001a110, 0x001a0006, 0x01a00068, 0x00000004, 0x00000000,
+0xa0128200, 0x013a884e, 0x138004e2, 0x3a884e20, 0xa804ea01, 0x004ea013,
+0x04ea013a, 0x4e2013a8, 0xea203a80, 0xa013a804, 0x0138804e, 0x03a804ea,
+0x00000a8c, 0x00000000, 0x0000a300, 0x00180006, 0x01800060, 0x18080602,
+0x80006080, 0x00060001, 0x00600018, 0x06000180, 0x60001800, 0x00018080,
+0x00180806, 0x01800060, 0x0000008c, 0x00000000, 0x2012a300, 0x00108044,
+0x11000442, 0x10804420, 0x08044201, 0x00442011, 0x04420110, 0x44201108,
+0x42001080, 0x20110804, 0x01108044, 0x01080442, 0x0000008c, 0x00000000,
+0xa052a200, 0x04088142, 0x50881420, 0x0a8342a0, 0x88142a05, 0x0142a050,
+0x1422050a, 0x42a050a8, 0x28070a81, 0xa050a814, 0x050a8142, 0x00a8142a,
+0x00000a8c, 0x00000000, 0x80300100, 0x032800ca, 0x3aa00ca8, 0x2200ea80,
+0xa00ca803, 0x00ca8032, 0x0ca8032a, 0xca8032a0, 0xa8032a00, 0x8032a00e,
+0x030200ea, 0x02a00ca8, 0x00000004, 0x00000000, 0x00000100, 0x01080002,
+0x00800020, 0x20000200, 0x80002080, 0x00020000, 0x00200008, 0x02080080,
+0x20070800, 0x00008000, 0x00080002, 0x80800020, 0x00000004, 0x00000000,
+0x4006a200, 0x40410010, 0x04100104, 0x61101040, 0x10010400, 0x00104004,
+0x01040040, 0x10400410, 0x04404100, 0x40041101, 0x00410010, 0x80100104,
+0x00000a8c, 0x00000000, 0xa002a300, 0x001a8006, 0x09a00066, 0x1a8026a0,
+0xa8006a00, 0x8006a001, 0x006a001b, 0x06a001a8, 0x6e801a80, 0xa001a802,
+0x001a8026, 0x01a8006a, 0x0000008c, 0x00000000, 0xc002a300, 0x01190006,
+0x01b80060, 0x1b0006c0, 0xb0006000, 0x0006c001, 0x006c001b, 0x06c00190,
+0x60001b00, 0xc001b000, 0x001b0006, 0x01b0006c, 0x0000008c, 0x00000000,
+0x2842a300, 0x0430910c, 0x431810c2, 0x30910c20, 0x0810c004, 0xa10c2043,
+0x10c20430, 0x0c004308, 0xc2443081, 0x20430a10, 0x0430810c, 0x030810c2,
+0x00000a88, 0x00000000, 0x00000100, 0x0030000c, 0x030000c0, 0x30080c02,
+0x00008000, 0x000c0003, 0x00c00030, 0x0c000300, 0xc0003000, 0x00030080,
+0x0030080c, 0x030000c0, 0x00000208, 0x00000000, 0x80400100, 0x0c32010c,
+0x432010ca, 0x32010c80, 0x2010c804, 0x010c8043, 0x10c80432, 0x0c804320,
+0xca0c3201, 0x80432010, 0x0432010c, 0x032010c8, 0x00000004, 0x00000000,
+0x2042a300, 0x0c1a8106, 0x4180106a, 0x1a810620, 0x88106204, 0x8106a041,
+0x106a041a, 0x06a041a8, 0x6a0c1a81, 0xa041a810, 0x041a8106, 0x01a8106a,
+0x00000a8c, 0x00000000, 0x0042a300, 0x04100104, 0x410010c0, 0x10010400,
+0x00104084, 0x01040041, 0x10400410, 0x04004100, 0xc0041001, 0x00410210,
+0x04100104, 0x01001040, 0x0000008c, 0x00000000, 0x2042a200, 0x04188126,
+0x418010c2, 0x18812620, 0x88106204, 0x81062041, 0x10620418, 0x06204188,
+0xc2049881, 0x20418810, 0x04188106, 0x01881062, 0x00000088, 0x00000000,
+0xa006a200, 0x006a801a, 0x06800180, 0x6a801aa0, 0xa801a200, 0x801aa006,
+0x01aa006a, 0x1a2006a8, 0x88006a80, 0xa006a801, 0x0068801a, 0x02a801aa,
+0x00000a8c, 0x00000000, 0x80600000, 0x060a0182, 0x60a01828, 0x0a018280,
+0xa0182806, 0x01828060, 0x18280608, 0x820060a0, 0x28060a01, 0x0060a018,
+0x060a0182, 0x00a01828, 0x00000004, 0x00000000, 0x80400000, 0x04020120,
+0x40201008, 0x02012080, 0x20100804, 0x01008040, 0x10080402, 0x00804020,
+0x08048201, 0x80402010, 0x04020100, 0x00201008, 0x00000004, 0x00000000,
+0xc062a300, 0x262b018a, 0x62b018ac, 0x2b098ac0, 0xb018a806, 0x018ac062,
+0x18ac062b, 0x888062b0, 0xac262b01, 0xc062b098, 0x062b018a, 0x02b018ac,
+0x00000a88, 0x00000000, 0xa062a300, 0x063a918e, 0x638818ee, 0x3a918ea0,
+0xa818e706, 0x818ea063, 0x18ea0638, 0x8ca063a8, 0xe6463881, 0x2063a818,
+0x063a818e, 0x03a818ea, 0x0000008c, 0x00000000, 0xc062a200, 0x063b018a,
+0x63b018e8, 0x33818e40, 0xb018ec06, 0x018ec063, 0x18e40632, 0x8ee063b8,
+0xe2863901, 0xc063b018, 0x063b018e, 0x03b018ec, 0x00000088, 0x00000000,
+0xa062a200, 0x063a818e, 0x63a818e2, 0x32898ea2, 0xa818ea06, 0x018ea863,
+0x18e20632, 0x8ea863a8, 0xca063a81, 0x2063a098, 0x863a898e, 0x03a818ea,
+0x00000a88, 0x00000000, 0x80400000, 0x04120104, 0x412010c8, 0x12010480,
+0x20104804, 0x01048041, 0x10480412, 0x04804120, 0x68041201, 0x80412010,
+0x04120104, 0x01201048, 0x00000800, 0x00000000, 0x80622000, 0x061a0186,
+0x61a0186a, 0x1a818680, 0xa0186886, 0x01868861, 0x1848061a, 0x86a061a8,
+0x6a061a01, 0x8061a018, 0x061a0184, 0x01a01868, 0x00000008, 0x00000000,
+0xa002a200, 0x003a800e, 0x038800ea, 0x38800ea0, 0xa800ea00, 0x800ea003,
+0x00ea003a, 0x0e8003a0, 0xe8001280, 0xa0038800, 0x0038800e, 0x03a800e2,
+0x00000a80, 0x00000000, 0x0042a200, 0x04180106, 0x41801060, 0x18010600,
+0x80102004, 0x01060041, 0x10600418, 0x06004180, 0x60041801, 0x00418010,
+0x04180106, 0x01801060, 0x00000280, 0x00000000, 0x2040a000, 0x04108104,
+0x41081042, 0x10810420, 0x08100204, 0x81042041, 0x10420410, 0x04004100,
+0x40041081, 0x20410810, 0x04108104, 0x01081042, 0x00000088, 0x00000000,
+0xa042a200, 0x040a8102, 0x40a81020, 0x0a0102a0, 0xa8102a04, 0x8102a040,
+0x102a040a, 0x02804080, 0x28040a81, 0xa040aa10, 0x040a8102, 0x00a8102a,
+0x00000a88, 0x00000000, 0x80c28000, 0x0c2a030a, 0xc2a030a8, 0x2a010a80,
+0xa030a80c, 0x030a80c2, 0x30a80c2a, 0x0a80c2a0, 0xa80c2a03, 0x00c2a030,
+0x0c28030a, 0x02a030a8, 0x00000000, 0x00000000, 0x0012a200, 0x01080042,
+0x10800420, 0x08004200, 0x80042001, 0x00420010, 0x04200108, 0x42081080,
+0x20010800, 0x00108004, 0x01080042, 0x00800420, 0x00000000, 0x00000000,
+0x4042a200, 0x04010100, 0x40101004, 0x01010040, 0x10100404, 0x01004040,
+0x10040400, 0x00404010, 0x04040101, 0x40400010, 0x04010100, 0x00101004,
+0x00000a88, 0x00000000, 0xa0022200, 0x001a8006, 0x01a8006e, 0x180006a0,
+0xa8006800, 0xc0068001, 0x0062001b, 0x06a001a8, 0x6e001a80, 0xa001ac00,
+0x001aa006, 0x01a8006a, 0x00000088, 0x00000000, 0x4002a300, 0x00190006,
+0x019000e2, 0x0b000680, 0xb0002c00, 0xa006c001, 0x00640019, 0x068001b0,
+0xe8001b00, 0xc001b000, 0x001b0006, 0x01b0006c, 0x00000000, 0x00000000,
+0x20000000, 0x0030800c, 0x03080062, 0x30800c00, 0x0800c280, 0x800c2003,
+0x00c20030, 0x0c000308, 0x62003080, 0x20030a00, 0x0010800c, 0x030800c2,
+0x00000000, 0x00000000, 0x00000000, 0x00b0000c, 0x23000040, 0x30002c00,
+0x0000c000, 0x000c0003, 0x00c00030, 0x0c000300, 0x4000b000, 0x0003001a,
+0x0030000c, 0x030000c0, 0x00000000, 0x00000000, 0x80a00000, 0x0a30028c,
+0xa32028c8, 0x32008c80, 0x2028c80a, 0x828c80a3, 0x28c80a32, 0x8c80a320,
+0xca0a3202, 0x80a32028, 0x8a12028c, 0x032028c8, 0x00000000, 0x00000000,
+0xa0c40000, 0x0c588316, 0xe5883168, 0x5a8316a0, 0xa8316a0c, 0x0316a0c5,
+0x316a0c5a, 0x16a0c5a8, 0x6a0c5a83, 0x20c5a839, 0x0c5a8316, 0x01a8316a,
+0x00000000, 0x00000000, 0x00000000, 0x00900004, 0x81000040, 0x10002400,
+0x00004000, 0x00040001, 0x00400010, 0x04000100, 0x40009000, 0x00010002,
+0x00100004, 0x01000040, 0x00000000, 0x00000000, 0x22100000, 0x21188846,
+0x11888460, 0x18804626, 0x88846221, 0x08462211, 0x84622118, 0x46221188,
+0x62211888, 0x22118804, 0x21188046, 0x01888462, 0x00000000, 0x00000000,
+0x22000000, 0xa028800a, 0x02a880a8, 0x2a880aa2, 0xa880a220, 0x080aa202,
+0x80a22028, 0x0a220288, 0xa8002888, 0x22028880, 0x202a880a, 0x02a880a2,
+0x00000000, 0x00000000, 0x84100000, 0x41081042, 0x1081042a, 0x0a104204,
+0xa1042841, 0x10420410, 0x0428410a, 0x428410a1, 0x20410a10, 0x8410a004,
+0x410a1042, 0x00a10428, 0x00000000, 0x00000000, 0x80500000, 0x05020140,
+0x50201408, 0x021940a0, 0x20140885, 0x01408050, 0x14080502, 0x40805020,
+0x08050201, 0x80502014, 0x05020140, 0x00201408, 0x00000000, 0x00000000,
+0xc0300000, 0x032b00ca, 0x32b00cac, 0x2b08ca80, 0xb00cac03, 0x00cac032,
+0x0cac032b, 0xca8032b0, 0xac032b00, 0xc032b00c, 0x032b00ca, 0x02b00cac,
+0x00000000, 0x00000000, 0xa0100000, 0x013a804e, 0x13a004ee, 0x3a804ea8,
+0xaa04ea01, 0x804ea013, 0x04ea013a, 0x4e601388, 0xe6013880, 0xa013a804,
+0x013a804e, 0x03a804e8, 0x00000000, 0x00000000, 0x18c40000, 0x8c484312,
+0xc0863120, 0x48030218, 0x8631218c, 0x631218c4, 0x31218c48, 0x1218c486,
+0x200c4863, 0x18c48230, 0x8c486302, 0x00863121, 0x00000000, 0x00000000,
+0xfffc0000, 0xffcbfff2, 0xfcbfff2f, 0xcbfff2ff, 0xbfff2fff, 0xfff2fffc,
+0xff2fffcb, 0xf2fffcbf, 0x2fffcbff, 0xfffcbfff, 0xffcbfff2, 0x00bfff2f,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xdb340000, 0xb3437ed0,
+0x7c36cd0d, 0x4bedf0db, 0x36cd0db3, 0x6cd0db34, 0xcd0db343, 0xd0db3436,
+0x0dfb436c, 0xdb34bedf, 0xb3436df0, 0x0036cd0d, 0x00000000, 0x00000000,
+0x3ccc0000, 0xccc8ff32, 0xfc8f3323, 0xcbf3f23c, 0x8f3323cc, 0xf3323ccc,
+0x3323ccc8, 0x323ccc8f, 0x23fcc8f3, 0x3cccbf3f, 0xccc8f3f2, 0x008f3323,
+0x00000000, 0x00000000, 0x7edc0000, 0xedc9fb72, 0xdc9fb721, 0xc9e3727e,
+0x9fb727ed, 0xfb727edc, 0xb727edc9, 0x727edc9f, 0x21edc9fb, 0x7edc9fb7,
+0xedc9fb72, 0x009fb727, 0x00000000, 0x00000000, 0x40800000, 0x0839020e,
+0x839020e4, 0x39020e40, 0x9020e608, 0x020e4083, 0x20e40839, 0x0e608390,
+0xe0083902, 0x40839028, 0x0839020e, 0x038020e6, 0x00000000, 0x00000000,
+0xa0200000, 0x023a808e, 0x23a808ea, 0x3a808ea0, 0xa808ea02, 0x808ea023,
+0x08ea023a, 0x8ea023a8, 0xee023a80, 0xa023a808, 0x023a808e, 0x03a808ee,
+0x00000000, 0x00000000, 0x80400000, 0x04120104, 0x41201048, 0x12010480,
+0x20104804, 0x01048041, 0x00480412, 0x04804120, 0x48051201, 0x80412018,
+0x04120104, 0x01201048, 0x00000000, 0x00000000, 0x08000000, 0x00180006,
+0x01800060, 0x18118600, 0x80006000, 0x00060001, 0x10600018, 0x06000181,
+0x60401800, 0x00018100, 0x00180006, 0x01890060, 0x00000000, 0x00000000,
+0x22100000, 0x0138884e, 0x138804e2, 0x38884e20, 0x8804e001, 0x804e2013,
+0x04e20138, 0x4e001388, 0xe2203880, 0x20138814, 0x2138804e, 0x038884e0,
+0x00000000, 0x00000000, 0x00000000, 0x00180006, 0x01800060, 0x18080602,
+0x80006000, 0x00060201, 0x80608018, 0x06000180, 0x60281800, 0x00018000,
+0x00180006, 0x01800060, 0x00000000, 0x00000000, 0x20100000, 0x01108044,
+0x11080442, 0x10806420, 0x08044001, 0x80442011, 0x06420110, 0x44001108,
+0x42009080, 0x20110806, 0x03108044, 0x01080240, 0x00000000, 0x00000000,
+0x20140000, 0x05488152, 0x54881522, 0x48815220, 0x88152205, 0x81522054,
+0x15220548, 0x52205488, 0x20054881, 0x20548815, 0x05488152, 0x00801920,
+0x00000000, 0x00000000, 0x00700310, 0x032800ca, 0x32800ca0, 0x0200ca00,
+0x800ca003, 0x00ca0032, 0x0ca00328, 0xca003280, 0x80032800, 0x0032800c,
+0x072800ca, 0x02801ca0, 0x00000000, 0x00000000, 0x00200310, 0x00000002,
+0x00800020, 0x08002200, 0x80002000, 0x00020000, 0x02200008, 0x02000080,
+0x82008800, 0x00008002, 0x02080002, 0x00800620, 0x0000000c, 0x00000000,
+0x40020310, 0x00010000, 0x00100004, 0x01100040, 0x10000400, 0x00004000,
+0x00040001, 0x00400011, 0x84400100, 0x40001100, 0x00010000, 0x00110004,
+0x0000000c, 0x00000000, 0x00020310, 0x00128006, 0x01880062, 0x18800620,
+0x88006000, 0x80062001, 0x00620018, 0x06000188, 0x62801880, 0x20018800,
+0x00188006, 0x01980062, 0x0000000c, 0x00000000, 0x40028008, 0x00180006,
+0x019a0064, 0x19000640, 0x90006400, 0x80064001, 0x00640019, 0x06400190,
+0x60001900, 0x40019800, 0x00190006, 0x41800464, 0x00000000, 0x00000000,
+0x2442a202, 0x0430110c, 0x430810c2, 0x30910c20, 0x0810c204, 0x810c2043,
+0x10c20430, 0x0c204308, 0xc6443081, 0x20431810, 0x4430810c, 0x030910c2,
+0x00000a88, 0x00000000, 0x00008002, 0x0030000c, 0x030000c0, 0x30080c02,
+0x0000c000, 0x000c0203, 0x80c00030, 0x0c000300, 0xc0203000, 0x00030000,
+0x0030000c, 0x030000c0, 0x00000000, 0x00000000, 0x00402002, 0x0430010c,
+0x430010c0, 0x30010c00, 0x0010c004, 0x010c0043, 0x10c00430, 0x0c004300,
+0xc00d3001, 0x00430010, 0x0430010c, 0x030830c0, 0x00000000, 0x00000000,
+0x2042a202, 0x04188106, 0x41801062, 0x18810620, 0x88106204, 0x01062041,
+0x10620418, 0x06204188, 0xe20c1881, 0x20418010, 0x04188106, 0x01883062,
+0x00000a88, 0x00000000, 0x00408002, 0x04100104, 0x41001040, 0x10010400,
+0x00104004, 0x01040041, 0x10400410, 0x04004100, 0x60041001, 0x00410010,
+0x04100104, 0x03001040, 0x00000000, 0x00000000, 0x2042800a, 0x04188106,
+0x41801062, 0x18810620, 0x88106204, 0x01062041, 0x10620418, 0x06204188,
+0x42041881, 0x20418010, 0x04188106, 0x03081062, 0x00000000, 0x00000000,
+0x2002a202, 0x8028800a, 0x028800a2, 0x28800a20, 0x8800a200, 0x800a2002,
+0x00a20028, 0x0a200288, 0x80002880, 0x20028000, 0x0028800a, 0x420000a2,
+0x00000a88, 0x00000000, 0x00600012, 0x06080182, 0x60801820, 0x08018200,
+0x80182006, 0x01820060, 0x18200608, 0x82006080, 0x20060801, 0x00608018,
+0x06080182, 0x00801820, 0x00000000, 0x00000000, 0x80408212, 0x04028100,
+0x40201008, 0x02010088, 0x20100804, 0x01008040, 0x10080402, 0x00804020,
+0x0a040201, 0x80402010, 0x04020100, 0x00201008, 0x00000000, 0x00000000,
+0xc062a202, 0x062a018a, 0x62b018ac, 0x2b098ac0, 0xb018ac06, 0x018ac062,
+0x98ac062b, 0x8ac062b0, 0xac262b01, 0xc062b098, 0x062b018a, 0x02b098ac,
+0x00000a88, 0x00000000, 0x24628200, 0x0638918e, 0x638018e2, 0x38918e20,
+0x8818e206, 0x018e2063, 0x18e20638, 0x8e206388, 0xe2463881, 0x20638818,
+0x4638818e, 0x039918e2, 0x00000000, 0x00000000, 0x40628002, 0x0639018e,
+0x639018e4, 0x39018e60, 0x9018e406, 0x018e4063, 0x18e40639, 0x8e406390,
+0xe8063901, 0x40639018, 0x0638018e, 0x03a018e4, 0x00000000, 0x00000000,
+0xa062a20a, 0x063a818e, 0x63a818ea, 0x3a898ee2, 0xa818ea06, 0x818ea263,
+0x98ea063a, 0x8ea063a8, 0xe6263a81, 0xa063a818, 0x063a018e, 0x438818ea,
+0x00000a88, 0x00000000, 0x80480002, 0x04120124, 0x41201048, 0x12012480,
+0x20104804, 0x01048041, 0x10480412, 0x04804120, 0x48049201, 0x80412010,
+0x04920104, 0x03201248, 0x00000000, 0x00000000, 0x00608002, 0x06180186,
+0x61801860, 0x18018600, 0x80186006, 0x01860061, 0x18600618, 0x86006180,
+0x40061801, 0x00618018, 0x06180186, 0x01881860, 0x00000000, 0x00000000,
+0x2006a000, 0x0078801e, 0x078801e2, 0x78801e00, 0x8801e200, 0x801e2007,
+0x01e20078, 0x1e200788, 0xe2007880, 0x20078801, 0x0078801e, 0x038801e2,
+0x00000a88, 0x00000000, 0x004a8002, 0x04180126, 0x41801060, 0x18012600,
+0x80106004, 0x21060841, 0x10600418, 0x06004180, 0x60049801, 0x00418010,
+0x04980106, 0x01801260, 0x00000000, 0x00000000, 0x20428002, 0x04108104,
+0x41081042, 0x10810400, 0x08104204, 0x81042041, 0x10420410, 0x04204108,
+0x42041081, 0x20410810, 0x04108104, 0x01081042, 0x00000000, 0x00000000,
+0x2042a202, 0x04088102, 0x40881022, 0x08810200, 0x88102204, 0x81022040,
+0x10220408, 0x02204088, 0x20040881, 0x20408810, 0x04088102, 0x00801022,
+0x00000a88, 0x00000000, 0x00c00002, 0x0c28030a, 0xc28030a0, 0x28030a00,
+0x8030a00c, 0x030a00c2, 0x30a00c28, 0x0a00c280, 0xa0040203, 0x00c28030,
+0x0c28030a, 0x028030a0, 0x00000000, 0x00000000, 0x00100002, 0x01082042,
+0x10800420, 0x08004200, 0x80042001, 0x00420010, 0x04200108, 0x42001080,
+0x22010800, 0x00108004, 0x01088042, 0x00800420, 0x00000000, 0x00000000,
+0x4042a202, 0x04010100, 0x40101004, 0x01010040, 0x10100404, 0x01004040,
+0x10040401, 0x00404010, 0x04040101, 0x40401010, 0x04000100, 0x00101004,
+0x00000a88, 0x00000000, 0x20028002, 0x00188006, 0x01880062, 0x18800620,
+0x88006200, 0x80062001, 0x00620018, 0x06200188, 0x62001880, 0x20018800,
+0x0018c006, 0x01980062, 0x00000000, 0x00000000, 0x40008002, 0x80198006,
+0x09900066, 0x19002640, 0x90006400, 0x00064009, 0x02640019, 0x06400190,
+0x40009900, 0x40019000, 0x00190006, 0x03800064, 0x00000000, 0x00000000,
+0x2006a202, 0x0070801c, 0x070801c2, 0x70801c20, 0x0801c200, 0x801c2007,
+0x01c20070, 0x1c200708, 0x46007080, 0x20070801, 0x0070801c, 0x018801c2,
+0x00000a88, 0x00000000, 0x0080200a, 0x0830020c, 0x830020c0, 0x30028c00,
+0x0020c008, 0x020c00e3, 0x28c00830, 0x0c008300, 0x400a3002, 0x00830020,
+0x0830020c, 0x010020c0, 0x00000000, 0x00000000, 0x00a00002, 0x0a30828c,
+0xab0028c2, 0x3003ac00, 0x0028c00a, 0x028c00ab, 0x2ac00a30, 0x8c00a300,
+0x4006b002, 0x00a30028, 0x0a30028c, 0x430828c0, 0x00000200, 0x00000000,
+0x20c2a002, 0x0c120306, 0xc1883060, 0x18838620, 0x8830620c, 0x830620c1,
+0x38620c18, 0x0620c188, 0x620e1883, 0x20c18830, 0x0c188306, 0x01883062,
+0x00000a88, 0x00000000, 0x00020002, 0x00100004, 0x01000040, 0x10000400,
+0x00004000, 0x00040021, 0x00400010, 0x04000100, 0x40001000, 0x00010000,
+0x00100004, 0x01000040, 0x00000000, 0x00000000, 0x22128002, 0x21100846,
+0x11888460, 0x18804620, 0x88846221, 0x88462011, 0x04622118, 0x46221188,
+0x62011888, 0x22118884, 0x21188846, 0x01888462, 0x00000000, 0x00000000,
+0x2002a202, 0x2028200a, 0x028880a0, 0x28800a22, 0x8880a220, 0x880a2202,
+0xa0a22028, 0x0a220288, 0xa0202888, 0x22028880, 0x0028880a, 0x028000a2,
+0x00000a88, 0x00000000, 0x04100002, 0x41081042, 0x10810420, 0x08004204,
+0x81042041, 0x10420410, 0x04204108, 0x42041080, 0x20410810, 0x04108004,
+0x41081042, 0x00810420, 0x00000008, 0x00000000, 0x80508000, 0x05020140,
+0x50201408, 0x02014080, 0x20140805, 0x01408050, 0x14080502, 0x40805020,
+0x0a050201, 0x80502014, 0x05020140, 0x00201408, 0x00000000, 0x00000000,
+0xc0b2a002, 0x0b2b02ca, 0xb2b02cac, 0x2b02cac0, 0xb02cac0b, 0x02cac0b2,
+0x2cac0b2b, 0xcac0b2b0, 0xac0b2b02, 0xc0b2b02c, 0x0b2b02ca, 0x02b02cac,
+0x00000a88, 0x00000000, 0x20120002, 0x0138804e, 0x138804e2, 0x38804e20,
+0x8804e201, 0x804e2013, 0x04e20038, 0x4e20138a, 0xe2003880, 0x20138804,
+0x0138804e, 0x039804e2, 0x00000000, 0x00000000, 0x10c40000, 0x8c484312,
+0xc0863121, 0x48030218, 0x8631218c, 0x631218c0, 0x30218c48, 0x1218c482,
+0x200c0863, 0x18c48231, 0x0c486312, 0x00803121, 0x00000000, 0x00000000,
+0xfffc0000, 0xffcbfff2, 0xfcbfff2f, 0xcbfff2ff, 0xbfff2fff, 0xfff2fffc,
+0xff2fffcb, 0xf2fffcbf, 0x2fffcbff, 0xfffcbfff, 0xffcbfff2, 0x00bfff2f,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xdfb40000, 0xb3437ed0,
+0x7c36cd0d, 0x4bfff0db, 0x36cd0db3, 0x6cd0db7c, 0xdf0db343, 0xd0db34be,
+0x0db7c36c, 0xdb34becd, 0xfb436cd0, 0x0037ed0d, 0x00000000, 0x00000000,
+0x3fcc0000, 0xccc8ff32, 0xfc8f3323, 0xcbfff23c, 0x8f3323cc, 0xf3323cfc,
+0x3f23ccc8, 0x323cccbf, 0x23cfc8f3, 0x3cccbf33, 0xfcc8f332, 0x008ff323,
+0x00000000, 0x00000000, 0x7edc0000, 0xedc9fb72, 0xdc9fb727, 0xc9fb727e,
+0x9fb727ed, 0xfb727edc, 0xb727edc9, 0x727edc9f, 0x218dc9fb, 0x7edc9fb7,
+0xedc9fb72, 0x0087b727, 0x00000000, 0x00000000, 0x21c00000, 0x24d18020,
+0x42100002, 0x02850061, 0x0a004034, 0x85002140, 0x51060433, 0x08c34208,
+0x82143395, 0xc14008d0, 0x14218508, 0x00085002, 0x00000000, 0x00000000,
+0xa0004000, 0x00528820, 0x0828900a, 0x410060a0, 0x08004804, 0x802c2001,
+0x000a0040, 0x20208118, 0x44005080, 0x20000002, 0x00128020, 0x00080202,
+0x00000120, 0x00000000, 0x61000000, 0x40109504, 0x1138940e, 0x128c5061,
+0x08c6ce31, 0x845c2312, 0xc4061180, 0x54231828, 0x46118084, 0x23180044,
+0x10b08454, 0x00284002, 0x00000000, 0x00000000, 0x20900800, 0x01308144,
+0x1038340e, 0xd0006060, 0x08960e01, 0x8068201e, 0x04060133, 0x64201828,
+0x0201b380, 0x20100006, 0x01318064, 0x00280602, 0x00000000, 0x00000000,
+0x01124000, 0x25131454, 0x13004048, 0x10044401, 0x00e44031, 0x04400110,
+0x84003133, 0x40031000, 0x00110004, 0x410020c4, 0x10800400, 0x00004000,
+0x00000900, 0x00000000, 0x04400010, 0x20300100, 0x4020000c, 0x20010c00,
+0x00108400, 0x01000042, 0x10000400, 0x00004000, 0x80040201, 0x80402010,
+0x04000108, 0x00001000, 0x00000000, 0x00000000, 0x81110010, 0x11900474,
+0x1832044c, 0x102c7c01, 0x00c44831, 0x04600319, 0xc4001100, 0x50031002,
+0x40118104, 0x43103044, 0x11800454, 0x40004540, 0x00000800, 0x00000000,
+0x80100000, 0x05130244, 0x1030844c, 0x80004000, 0x00a60801, 0x00400018,
+0x040001b3, 0x40001000, 0x00018000, 0x00103004, 0x01800054, 0x40000540,
+0x00000000, 0x00000000, 0x2a102010, 0x11e2844c, 0x53088486, 0x00855821,
+0x08048281, 0x85702b53, 0xd7ceb533, 0x4823580a, 0x02153185, 0x615a08d7,
+0x15008540, 0x40085402, 0x00000080, 0x00000000, 0xa2100010, 0x01028064,
+0x5538844a, 0x90806c20, 0x18064201, 0x80602053, 0x04020190, 0x6420d818,
+0x42019280, 0xa05b0804, 0x01808064, 0x00080642, 0x00000000, 0x00000000,
+0xc1000010, 0x2411841c, 0x0620804c, 0xa08c0c21, 0x28d28a20, 0x84002305,
+0xc04210a0, 0x28230828, 0x0210708c, 0x630b0840, 0x10408408, 0x40084002,
+0x00000000, 0x00000000, 0xa0080800, 0x20a3801c, 0x021883c2, 0x13801c22,
+0x08018a04, 0x80102803, 0x01ce0033, 0x14e00b38, 0x82002380, 0xa0020800,
+0x0033801c, 0x43380082, 0x00000020, 0x00000000, 0x61000010, 0x14d08000,
+0x0028408e, 0x63840ca1, 0x08c00610, 0x8400234b, 0xc00e3053, 0x0c234108,
+0x8e1063a4, 0x210028c2, 0x10608400, 0x40084282, 0x00000000, 0x00000000,
+0x80480000, 0x00200908, 0x0030118a, 0xb2831ca0, 0x00808800, 0x81040003,
+0x10460410, 0x0c000100, 0x02040081, 0x00011010, 0x04120100, 0x00001040,
+0x00000000, 0x00000000, 0x41480000, 0x14122004, 0x0d304042, 0x838c0421,
+0x20c24410, 0x8408030b, 0x02c40040, 0x0c000f00, 0x4210508c, 0x030c2042,
+0x10410400, 0x00004280, 0x00000000, 0x00000000, 0x40070800, 0x00120824,
+0x093000cc, 0x13800806, 0x20110004, 0x00280809, 0x01402020, 0x28000500,
+0x8c002300, 0x000a2001, 0x00200020, 0x00000100, 0x00000420, 0x00000000,
+0x0808000c, 0x00000001, 0x0b000000, 0x02000008, 0x00000004, 0x0000080b,
+0x00000000, 0x000c0b00, 0x00000000, 0x080b0000, 0x00000000, 0x33000000,
+0x00000000, 0x00000000, 0x0308040c, 0x00000501, 0x09090c0a, 0x00010107,
+0x08000800, 0x01010709, 0x00080402, 0x010b0908, 0x08040201, 0x03090800,
+0x04020103, 0x31080008, 0x00000010, 0x00000000, 0x385be000, 0xc4030910,
+0xffe52fe7, 0x01019a03, 0x980c0264, 0x00020001, 0x90019003, 0x01000001,
+0x00000300, 0x00000004, 0x0c030001, 0x00019c00, 0x00000f80, 0x00000000,
+0x70c80000, 0x6401322e, 0x00774532, 0x00000000, 0x00000208, 0x00000000,
+0x00000001, 0x01000002, 0x00080000, 0x00000008, 0x00010000, 0x00000800,
+0x00000000, 0x00000000, 0x42280000, 0x29138111, 0x02802a14, 0x44000000,
+0x01000000, 0x00000000, 0x00010044, 0x00000000, 0x01004400, 0x00000100,
+0x00440000, 0x00010001, 0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff,
+0xfc000000, 0x03ff7eff, 0x00000000, 0xf76cff7c, 0x00000002, 0xeefffc00,
+0x000003fd, 0x7cfc0000, 0x00037ff6, 0x00000000, 0x00000000, 0x00000000,
+0xfffc0000, 0x0003ffff, 0x7c000000, 0x03e77beb, 0x00000000, 0xfef7fffc,
+0x00000003, 0xf7fef400, 0x000003ff, 0x7efc0000, 0x0003fffe, 0x00000000,
+0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff, 0xf8000000, 0x03f3fbf3,
+0x00000000, 0xedf2fdf8, 0x00000003, 0xf6f9f400, 0x000002ff, 0xfcfc0000,
+0x0002fef7, 0x00000000, 0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff,
+0x3c000000, 0x03df7fcf, 0x00000000, 0xfffddefc, 0x00000003, 0xfffefc00,
+0x000003ff, 0xfffc0000, 0x0003ffff, 0x00000000, 0x00000000, 0x00000000,
+0xfffc0000, 0x0003ffff, 0xfc000000, 0x03dfdeff, 0x00000000, 0xffff7ffc,
+0x00000003, 0xfe7f3c00, 0x000003ff, 0xfffc0000, 0x0003ffff, 0x00000000,
+0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff, 0xdc000000, 0x03ffffff,
+0x00000000, 0xffffffbc, 0x00000003, 0x7ffebc00, 0x000003ff, 0xbf7c0000,
+0x0003feff, 0x00000000, 0x00000000, 0x00000000, 0xa3400000, 0x14528804,
+0x41085006, 0xc0840421, 0x08514214, 0x85002140, 0x514234a2, 0x00210108,
+0x06148085, 0xe14328d0, 0x14e08528, 0x00085002, 0x00000000, 0x00000000,
+0xe2400000, 0x84028000, 0x4228000e, 0x40800820, 0x00004201, 0x80402011,
+0x00828102, 0x60200208, 0x8a004080, 0x20091804, 0x00708060, 0x00080402,
+0x00000000, 0x00000000, 0xa0000000, 0x5953a824, 0x1918440e, 0x00854423,
+0x00444211, 0x8440211a, 0x44420191, 0x00234908, 0x42101084, 0x23032840,
+0x10108404, 0x00084002, 0x00000000, 0x00000000, 0x62100000, 0x41838164,
+0x1808040a, 0x80807420, 0x0004c201, 0x80702018, 0x040221a2, 0x40205908,
+0x06015080, 0xe01b0807, 0x01208048, 0x00080702, 0x00000000, 0x00000000,
+0x42400000, 0x55102060, 0x41004400, 0x10042801, 0x00408810, 0x04640102,
+0x44083180, 0x68c11000, 0x00100004, 0x011020c4, 0x11100450, 0x01004440,
+0x00000000, 0x00000000, 0x80000010, 0x00132108, 0x02301088, 0x20010400,
+0x10100804, 0x01080041, 0x10000410, 0x00004000, 0x00040001, 0x80401010,
+0x04200100, 0x40001080, 0x00000000, 0x00000000, 0xc0100010, 0x19d20164,
+0x11306440, 0x90046c03, 0x20464411, 0x04640112, 0x864811b0, 0x64031100,
+0x40115004, 0x43192046, 0x11100464, 0x41004540, 0x00000000, 0x00000000,
+0x80100010, 0x01130060, 0x18000444, 0x00005c00, 0x00048801, 0x0050001a,
+0x84480190, 0x68c01900, 0x40011000, 0x001d2004, 0x01800044, 0x41000400,
+0x00000000, 0x00000000, 0xe0100010, 0x55418944, 0x50284442, 0x10856021,
+0x08548615, 0x85606153, 0x54821500, 0x5c215108, 0x42152385, 0x615008d4,
+0x15208560, 0x40085442, 0x00000000, 0x00000000, 0xe0100010, 0x01a28248,
+0x111804ca, 0x50804420, 0x08054a01, 0x8040a013, 0x05422100, 0x6c201308,
+0xca019080, 0x60100805, 0x01b08064, 0x400806c2, 0x00000000, 0x00000000,
+0xa3000010, 0x08108014, 0x0628e0ce, 0x508c0021, 0x08428610, 0x84046107,
+0x41821040, 0x0c230b28, 0x46107084, 0x83000841, 0x18708424, 0x400842c2,
+0x00000000, 0x00000000, 0xe0480810, 0x0001a008, 0x0b1810ca, 0xa0801820,
+0x38024e00, 0x8014600a, 0x020280b3, 0x04e00d28, 0x86000380, 0xa00b3800,
+0x00138038, 0x4338000e, 0x00000020, 0x00000000, 0x20000010, 0x08928814,
+0x0528414a, 0xb0840c21, 0x28400210, 0x84002108, 0x420e1081, 0x24210108,
+0x02100084, 0x410128c0, 0x10b08404, 0x40084042, 0x00000000, 0x00000000,
+0x08400000, 0x04030928, 0x4a303004, 0x70011400, 0x3010c004, 0x01000044,
+0x104a2443, 0x0c004600, 0x8004a001, 0xa04d1013, 0x04100114, 0x00001000,
+0x00000000, 0x00000000, 0x02040000, 0x10930404, 0x0130d348, 0x100c2c01,
+0x30434010, 0x04200100, 0x42c62002, 0x04000100, 0x40109004, 0x43092040,
+0x10300404, 0x01004140, 0x00000000, 0x00000000, 0x02090800, 0x00402000,
+0x01002048, 0x30000000, 0x00028000, 0x00100000, 0x01002001, 0x28000100,
+0x40004000, 0x20032000, 0x00b0000c, 0x01000140, 0x00000420, 0x00000000,
+0x08080000, 0x04000401, 0x0b000801, 0x00040008, 0x00000004, 0x0802000b,
+0x00010801, 0x02000b00, 0x01080108, 0x000b0000, 0x08010802, 0x03000001,
+0x00000000, 0x00000000, 0x03083c3c, 0x00000901, 0x09090809, 0x00010107,
+0x08000800, 0x01010309, 0x00080000, 0x01030908, 0x08000001, 0x03090800,
+0x00000101, 0xf1080008, 0x000000f0, 0x00000000, 0xa1240000, 0x1402b696,
+0x02482655, 0x02019a98, 0x00000000, 0x00030000, 0x08019c03, 0x02000000,
+0x00000200, 0x00000190, 0x0c000000, 0x00000c00, 0x00000000, 0x00000000,
+0x1a980000, 0x00017333, 0x0229620b, 0x00000100, 0x00880008, 0x00000000,
+0x08000001, 0x00000002, 0x00080000, 0x00000000, 0x08010001, 0x00000800,
+0x00000000, 0x00000000, 0x84100000, 0x41132183, 0x00218040, 0x44000000,
+0x00000100, 0x00000000, 0x00020044, 0x00000000, 0x01004400, 0x00000100,
+0x00440000, 0x00010003, 0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff,
+0xfc000000, 0x03ffffff, 0x00000000, 0x7fff7ffc, 0x00000003, 0xf7fefc00,
+0x000003ff, 0xdefc0000, 0x0001fff7, 0x00000000, 0x00000000, 0x00000000,
+0xfffc0000, 0x0003ffff, 0xfc000000, 0x03ffffff, 0x00000000, 0x7fff7ffc,
+0x00000001, 0xfffffc00, 0x0000007f, 0xfffc0000, 0x0002fffe, 0x00000000,
+0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff, 0xfc000000, 0x03ffffff,
+0x00000000, 0xfffdfefc, 0x00000003, 0xfdfffc00, 0x000003ff, 0xfffc0000,
+0x0003ffff, 0x00000000, 0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff,
+0xfc000000, 0x03ef7f7f, 0x00000000, 0x9ffffffc, 0x00000003, 0xfffffc00,
+0x000003fc, 0xfffc0000, 0x0003ffff, 0x00000000, 0x00000000, 0x00000000,
+0xfffc0000, 0x0003ffff, 0xfc000000, 0x03ffffff, 0x00000000, 0xfdddfdfc,
+0x00000003, 0xffff7c00, 0x000003fd, 0xfffc0000, 0x0003ffff, 0x00000000,
+0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff, 0xfc000000, 0x03ffbfff,
+0x00000000, 0xfffefffc, 0x00000003, 0x7ffffc00, 0x000003ff, 0xff7c0000,
+0x0003feff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x8004000c, 0x00000040, 0x71c2000c, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x8004000c, 0x00004040, 0x01c2000c, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x8000000c, 0xefcf0000, 0x8001000c, 0xc0000000, 0x7002000c, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x8001000c, 0xa0000000, 0x8005000c, 0x00000000, 0x8000000c,
+0xe9d60000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+};
diff -Nru a/sound/pci/rme9652/hammerfall_mem.c b/sound/pci/rme9652/hammerfall_mem.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/sound/pci/rme9652/hammerfall_mem.c	Thu Jun 20 15:54:00 2002
@@ -0,0 +1,279 @@
+/* 
+    ALSA memory allocation module for the RME Digi9652
+  
+ 	Copyright(c) 1999 IEM - Winfried Ritsch
+        Copyright (C) 1999 Paul Barton-Davis 
+
+    This module is only needed if you compiled the hammerfall driver with
+    the PREALLOCATE_MEMORY option. It allocates the memory need to
+    run the board and holds it until the module is unloaded. Because
+    we need 2 contiguous 1.6MB regions for the board, it can be
+    a problem getting them once the system memory has become fairly
+    fragmented. 
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+    $Id$
+
+
+    Tue Oct 17 2000  Jaroslav Kysela <perex@suse.cz>
+    	* space is allocated only for physical devices
+        * added support for 2.4 kernels (pci_alloc_consistent)
+    
+*/
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <sound/initval.h>
+
+#define HAMMERFALL_CARDS			8
+#define HAMMERFALL_CHANNEL_BUFFER_SAMPLES  (16*1024)
+#define HAMMERFALL_CHANNEL_BUFFER_BYTES    (4*HAMMERFALL_CHANNEL_BUFFER_SAMPLES)
+
+/* export */
+
+static int snd_enable[8] = {1,1,1,1,1,1,1,1};
+MODULE_PARM(snd_enable, "1-" __MODULE_STRING(HAMMERFALL_CARDS) "i");
+MODULE_PARM_DESC(snd_enable, "Enable cards to allocate buffers for.");
+
+MODULE_AUTHOR("Winfried Ritsch, Paul Barton-Davis <pbd@op.net>");
+MODULE_DESCRIPTION("Memory allocator for RME Hammerfall");
+MODULE_CLASSES("{sound}");
+MODULE_LICENSE("GPL");
+
+/* Since we don't know at this point if we're allocating memory for a
+   Hammerfall or a Hammerfall/Light, assume the worst and allocate
+   space for the maximum number of channels.
+
+   The extra channel is allocated because we need a 64kB-aligned
+   buffer in the actual interface driver code (see rme9652.c or hdsp.c
+   for details)
+*/
+
+#define TOTAL_SIZE (26+1)*(HAMMERFALL_CHANNEL_BUFFER_BYTES)
+#define NBUFS   2*HAMMERFALL_CARDS
+
+#define HAMMERFALL_BUF_ALLOCATED 0x1
+#define HAMMERFALL_BUF_USED      0x2
+
+typedef struct hammerfall_buf_stru hammerfall_buf_t;
+
+struct hammerfall_buf_stru {
+	struct pci_dev *pci;
+	void *buf;
+	dma_addr_t addr;
+	char flags;
+};
+
+static hammerfall_buf_t hammerfall_buffers[NBUFS];
+
+/* These are here so that we have absolutely no dependencies
+   on any other modules. Dependencies can (1) cause us to
+   lose in the rush for 2x1.6MB chunks of contiguous memory
+   and (2) make driver debugging difficult because unloading
+   and reloading the snd module causes us to have to do the
+   same for this one. Since we can rarely if ever allocate
+   memory after starting things running, that would be very
+   undesirable.  
+*/
+
+/* remove hack for pci_alloc_consistent to avoid dependecy on snd module */
+#ifdef HACK_PCI_ALLOC_CONSISTENT
+#undef pci_alloc_consistent
+#endif
+
+static void *hammerfall_malloc_pages(struct pci_dev *pci,
+				  unsigned long size,
+				  dma_addr_t *dmaaddr)
+{
+	void *res;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 3, 0)
+	res = (void *) pci_alloc_consistent(pci, size, dmaaddr);
+#else
+	int pg;
+	for (pg = 0; PAGE_SIZE * (1 << pg) < size; pg++);
+	res = (void *)__get_free_pages(GFP_KERNEL, pg);
+	if (res != NULL)
+		*dmaaddr = virt_to_bus(res);
+#endif
+	if (res != NULL) {
+		struct page *page = virt_to_page(res);
+		struct page *last_page = page + (size + PAGE_SIZE - 1) / PAGE_SIZE;
+		while (page < last_page)
+			set_bit(PG_reserved, &(page++)->flags);
+	}
+	return res;
+}
+
+static void hammerfall_free_pages(struct pci_dev *pci, unsigned long size,
+			       void *ptr, dma_addr_t dmaaddr)
+{
+	struct page *page, *last_page;
+
+	if (ptr == NULL)
+		return;
+	page = virt_to_page(ptr);
+	last_page = virt_to_page(ptr) + (size + PAGE_SIZE - 1) / PAGE_SIZE;
+	while (page < last_page)
+		clear_bit(PG_reserved, &(page++)->flags);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 3, 0)
+	pci_free_consistent(pci, size, ptr, dmaaddr);
+#else
+	{
+		int pg;
+		for (pg = 0; PAGE_SIZE * (1 << pg) < size; pg++);
+		if (bus_to_virt(dmaaddr) != ptr) {
+			printk(KERN_ERR "hammerfall_free_pages: dmaaddr != ptr\n");
+			return;
+		}
+		free_pages((unsigned long)ptr, pg);
+	}
+#endif
+}
+
+void *snd_hammerfall_get_buffer (struct pci_dev *pcidev, dma_addr_t *dmaaddr)
+{
+	int i;
+	hammerfall_buf_t *rbuf;
+
+	for (i = 0; i < NBUFS; i++) {
+		rbuf = &hammerfall_buffers[i];
+		if (rbuf->flags == HAMMERFALL_BUF_ALLOCATED) {
+			rbuf->flags |= HAMMERFALL_BUF_USED;
+			rbuf->pci = pcidev;
+			MOD_INC_USE_COUNT;
+			*dmaaddr = rbuf->addr;
+			return rbuf->buf;
+		}
+	}
+
+	return NULL;
+}
+
+void snd_hammerfall_free_buffer (struct pci_dev *pcidev, void *addr)
+{
+	int i;
+	hammerfall_buf_t *rbuf;
+
+	for (i = 0; i < NBUFS; i++) {
+		rbuf = &hammerfall_buffers[i];
+		if (rbuf->buf == addr && rbuf->pci == pcidev) {
+			MOD_DEC_USE_COUNT;
+			rbuf->flags &= ~HAMMERFALL_BUF_USED;
+			return;
+		}
+	}
+
+	printk ("Hammerfall memory allocator: unknown buffer address or PCI device ID");
+}
+
+static void __exit hammerfall_free_buffers (void)
+
+{
+	int i;
+	hammerfall_buf_t *rbuf;
+
+	for (i = 0; i < NBUFS; i++) {
+
+		/* We rely on general module code to prevent
+		   us from being unloaded with buffers in use.
+
+		   However, not quite. Do not release memory
+		   if it is still marked as in use. This might
+		   be unnecessary.
+		*/
+
+		rbuf = &hammerfall_buffers[i];
+
+		if (rbuf->flags == HAMMERFALL_BUF_ALLOCATED) {
+			hammerfall_free_pages (rbuf->pci, TOTAL_SIZE, rbuf->buf, rbuf->addr);
+			rbuf->buf = NULL;
+			rbuf->flags = 0;
+		}
+	}
+}				 
+
+static int __init alsa_hammerfall_mem_init(void)
+{
+	int i;
+	struct pci_dev *pci;
+	hammerfall_buf_t *rbuf;
+
+	/* make sure our buffer records are clean */
+
+	for (i = 0; i < NBUFS; i++) {
+		rbuf = &hammerfall_buffers[i];
+		rbuf->pci = NULL;
+		rbuf->buf = NULL;
+		rbuf->flags = 0;
+	}
+
+	/* ensure sane values for the number of buffers */
+
+	/* Remember: 2 buffers per card, one for capture, one for
+	   playback.
+	*/
+	
+	i = 0;	/* card number */
+	rbuf = hammerfall_buffers;
+	pci_for_each_dev(pci) {
+		int k;
+		
+		/* check for Hammerfall and Hammerfall DSP cards */
+
+		if (pci->vendor != 0x10ee || (pci->device != 0x3fc4 && pci->device != 0x3fc5)) 
+			continue;
+
+		if (!snd_enable[i])
+			continue;
+
+		for (k = 0; k < 2; ++k) {
+			rbuf->buf = hammerfall_malloc_pages(pci, TOTAL_SIZE, &rbuf->addr);
+			if (rbuf->buf == NULL) {
+				hammerfall_free_buffers();
+				printk(KERN_ERR "Hammerfall memory allocator: no memory available for card %d buffer %d\n", i, k + 1);
+				return -ENOMEM;
+			}
+			rbuf->flags = HAMMERFALL_BUF_ALLOCATED;
+			rbuf++;
+		}
+		i++;
+	}
+
+	if (i == 0)
+		printk(KERN_ERR "Hammerfall memory allocator: "
+		       "no Hammerfall cards found...\n");
+	else
+		printk(KERN_ERR "Hammerfall memory allocator: "
+		       "buffers allocated for %d cards\n", i);
+
+	return 0;
+}
+
+static void __exit alsa_hammerfall_mem_exit(void)
+{
+	hammerfall_free_buffers();
+}
+
+module_init(alsa_hammerfall_mem_init)
+module_exit(alsa_hammerfall_mem_exit)
+
+EXPORT_SYMBOL(snd_hammerfall_get_buffer);
+EXPORT_SYMBOL(snd_hammerfall_free_buffer);
diff -Nru a/sound/pci/rme9652/hdsp.c b/sound/pci/rme9652/hdsp.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/sound/pci/rme9652/hdsp.c	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,3141 @@
+/*
+ *   ALSA driver for RME Hammerfall DSP audio interface(s)
+ *
+ *      Copyright (c) 2002  Paul Davis
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/asoundef.h>
+#include <sound/rawmidi.h>
+#define SNDRV_GET_ID
+#include <sound/initval.h>
+
+#include "multiface_firmware.dat"
+#include "digiface_firmware.dat"
+
+static int snd_index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *snd_id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int snd_enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int snd_precise_ptr[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 }; /* Enable precise pointer */
+
+MODULE_PARM(snd_index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+MODULE_PARM_DESC(snd_index, "Index value for RME Hammerfall DSP interface.");
+MODULE_PARM_SYNTAX(snd_index, SNDRV_INDEX_DESC);
+MODULE_PARM(snd_id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+MODULE_PARM_DESC(snd_id, "ID string for RME Hammerfall DSP interface.");
+MODULE_PARM_SYNTAX(snd_id, SNDRV_ID_DESC);
+MODULE_PARM(snd_enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+MODULE_PARM_DESC(snd_enable, "Enable/disable specific Hammerfall DSP soundcards.");
+MODULE_PARM_SYNTAX(snd_enable, SNDRV_ENABLE_DESC);
+MODULE_PARM(snd_precise_ptr, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+MODULE_PARM_DESC(snd_precise_ptr, "Enable precise pointer (doesn't work reliably).");
+MODULE_PARM_SYNTAX(snd_precise_ptr, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
+MODULE_AUTHOR("Paul Davis <pbd@op.net>");
+MODULE_DESCRIPTION("RME Hammerfall DDSP");
+MODULE_LICENSE("GPL");
+MODULE_CLASSES("{sound}");
+MODULE_DEVICES("{{RME,Hammerfall-DSP},");
+
+typedef enum {
+	Digiface,
+	Multiface
+} HDSP_Type;
+
+#define HDSP_MAX_CHANNELS        26
+#define DIGIFACE_SS_CHANNELS     26
+#define DIGIFACE_DS_CHANNELS     14
+#define MULTIFACE_SS_CHANNELS    18
+#define MULTIFACE_DS_CHANNELS    10
+
+/* Write registers. These are defined as byte-offsets from the iobase value.
+ */
+#define HDSP_resetPointer               0
+#define HDSP_outputBufferAddress	32
+#define HDSP_inputBufferAddress		36
+#define HDSP_controlRegister		64
+#define HDSP_interruptConfirmation	96
+#define HDSP_outputEnable	  	128
+#define HDSP_jtagReg  			256
+#define HDSP_midiDataOut0  		352
+#define HDSP_midiDataOut1  		356
+#define HDSP_fifoData  			368
+#define HDSP_inputEnable	 	384
+
+/* Read registers. These are defined as byte-offsets from the iobase value
+ */
+
+#define HDSP_statusRegister    0
+#define HDSP_timecode        128
+#define HDSP_status2Register 192
+#define HDSP_midiDataOut0    352
+#define HDSP_midiDataOut1    356
+#define HDSP_midiDataIn0     360
+#define HDSP_midiDataIn1     364
+#define HDSP_midiStatusOut0  384
+#define HDSP_midiStatusOut1  388
+#define HDSP_midiStatusIn0   392
+#define HDSP_midiStatusIn1   396
+#define HDSP_fifoStatus      400
+
+/* the meters are regular i/o-mapped registers, but offset
+   considerably from the rest. the peak registers are reset
+   when read; the least-significant 4 bits are full-scale counters; 
+   the actual peak value is in the most-significant 24 bits.
+*/
+
+#define HDSP_playbackPeakLevel  4096  /* 26 * 32 bit values */
+#define HDSP_inputPeakLevel     4224  /* 26 * 32 bit values */
+#define HDSP_outputPeakLevel    4100  /* 26 * 32 bit values */
+#define HDSP_playbackRmsLevel   4612  /* 26 * 64 bit values */
+#define HDSP_inputRmsLevel      4884  /* 26 * 64 bit values */
+
+#define HDSP_IO_EXTENT     5192
+
+/* jtag register bits */
+
+#define HDSP_TMS                0x01
+#define HDSP_TCK                0x02
+#define HDSP_TDI                0x04
+#define HDSP_JTAG               0x08
+#define HDSP_PWDN               0x10
+#define HDSP_PROGRAM	        0x020
+#define HDSP_CONFIG_MODE_0	0x040
+#define HDSP_CONFIG_MODE_1	0x080
+#define HDSP_VERSION_BIT	0x100
+#define HDSP_BIGENDIAN_MODE     0x200
+#define HDSP_RD_MULTIPLE        0x400
+
+#define HDSP_S_PROGRAM     	(HDSP_PROGRAM|HDSP_CONFIG_MODE_0)
+#define HDSP_S_LOAD		(HDSP_PROGRAM|HDSP_CONFIG_MODE_1)
+
+/* Control Register bits */
+
+#define HDSP_Start                (1<<0)  // start engine
+#define HDSP_Latency0             (1<<1)  // buffer size = 2^n where n is defined by Latency{2,1,0}
+#define HDSP_Latency1             (1<<2)  // [ see above ]
+#define HDSP_Latency2             (1<<3)  // ] see above ]
+#define HDSP_ClockModeMaster      (1<<4)  // 1=Master, 0=Slave/Autosync
+#define HDSP_AudioInterruptEnable (1<<5)  // what do you think ?
+#define HDSP_Frequency0           (1<<6)  // 0=44.1kHz/88.2kHz 1=48kHz/96kHz
+#define HDSP_Frequency1           (1<<7)  // 0=32kHz/64kHz
+#define HDSP_DoubleSpeed          (1<<8)  // 0=normal speed, 1=double speed
+#define HDSP_SPDIFProfessional    (1<<9)  // 0=consumer, 1=professional
+#define HDSP_SPDIFEmphasis        (1<<10) // 0=none, 1=on
+#define HDSP_SPDIFNonAudio        (1<<11) // 0=off, 1=on
+#define HDSP_SPDIFOpticalOut      (1<<12) // 1=use 1st ADAT connector for SPDIF, 0=do not
+#define HDSP_SyncRef2             (1<<13) 
+#define HDSP_SPDIFInputSelect0    (1<<14) 
+#define HDSP_SPDIFInputSelect1    (1<<15) 
+#define HDSP_SyncRef0             (1<<16) 
+#define HDSP_SyncRef1             (1<<17) 
+#define HDSP_Midi0InterruptEnable (1<<22)
+#define HDSP_Midi1InterruptEnable (1<<23)
+#define HDSP_LineOut              (1<<24)
+
+#define HDSP_LatencyMask    (HDSP_Latency0|HDSP_Latency1|HDSP_Latency2)
+#define HDSP_FrequencyMask  (HDSP_Frequency0|HDSP_Frequency1|HDSP_DoubleSpeed)
+
+#define HDSP_SPDIFInputMask    (HDSP_SPDIFInputSelect0|HDSP_SPDIFInputSelect1)
+#define HDSP_SPDIFInputADAT1    0
+#define HDSP_SPDIFInputCoaxial (HDSP_SPDIFInputSelect1)
+#define HDSP_SPDIFInputCDROM   (HDSP_SPDIFInputSelect0|HDSP_SPDIFInputSelect1)
+
+#define HDSP_SyncRefMask        (HDSP_SyncRef0|HDSP_SyncRef1|HDSP_SyncRef2)
+#define HDSP_SyncRef_ADAT1      0
+#define HDSP_SyncRef_ADAT2      (HDSP_SyncRef0)
+#define HDSP_SyncRef_ADAT3      (HDSP_SyncRef1)
+#define HDSP_SyncRef_SPDIF      (HDSP_SyncRef0|HDSP_SyncRef1)
+#define HDSP_SyncRef_WORD       (HDSP_SyncRef2)
+#define HDSP_SyncRef_ADAT_SYNC  (HDSP_SyncRef0|HDSP_SyncRef2)
+
+/* Preferred sync source choices - used by "sync_pref" control switch */
+
+#define HDSP_SYNC_FROM_SELF      0
+#define HDSP_SYNC_FROM_WORD      1
+#define HDSP_SYNC_FROM_ADAT_SYNC 2
+#define HDSP_SYNC_FROM_SPDIF     3
+#define HDSP_SYNC_FROM_ADAT1     4
+#define HDSP_SYNC_FROM_ADAT2     5
+#define HDSP_SYNC_FROM_ADAT3     6
+
+/* Possible sources of S/PDIF input */
+
+#define HDSP_SPDIFIN_OPTICAL 0	/* optical  (ADAT1) */
+#define HDSP_SPDIFIN_COAXIAL 1	/* coaxial  (RCA) */
+#define HDSP_SPDIFIN_INTERN  2	/* internal (CDROM) */
+
+#define HDSP_Frequency32KHz    HDSP_Frequency0
+#define HDSP_Frequency44_1KHz  HDSP_Frequency1
+#define HDSP_Frequency48KHz   (HDSP_Frequency1|HDSP_Frequency0)
+#define HDSP_Frequency64KHz   (HDSP_DoubleSpeed|HDSP_Frequency0)
+#define HDSP_Frequency88_2KHz (HDSP_DoubleSpeed|HDSP_Frequency1)
+#define HDSP_Frequency96KHz   (HDSP_DoubleSpeed|HDSP_Frequency1|HDSP_Frequency0)
+
+#define hdsp_encode_latency(x)       (((x)<<1) & HDSP_LatencyMask)
+#define hdsp_decode_latency(x)       (((x) & HDSP_LatencyMask)>>1)
+
+#define hdsp_encode_spdif_in(x) (((x)&0x3)<<14)
+#define hdsp_decode_spdif_in(x) (((x)>>14)&0x3)
+
+/* Status Register bits */
+
+#define HDSP_audioIRQPending    (1<<0)
+#define HDSP_Lock2              (1<<1)
+#define HDSP_Lock1              (1<<2)
+#define HDSP_Lock0              (1<<3)
+#define HDSP_SPDIFSync          (1<<4)
+#define HDSP_TimecodeLock       (1<<5)
+#define HDSP_BufferPositionMask 0x000FFC0 /* Bit 6..15 : h/w buffer pointer */
+#define HDSP_Sync2              (1<<16)
+#define HDSP_Sync1              (1<<17)
+#define HDSP_Sync0              (1<<18)
+#define HDSP_DoubleSpeedStatus  (1<<19)
+#define HDSP_ConfigError        (1<<20)
+#define HDSP_DllError           (1<<21)
+#define HDSP_spdifFrequency0    (1<<22)
+#define HDSP_spdifFrequency1    (1<<23)
+#define HDSP_spdifFrequency2    (1<<24)
+#define HDSP_SPDIFErrorFlag     (1<<25)
+#define HDSP_BufferID           (1<<26)
+#define HDSP_TimecodeSync       (1<<27)
+#define HDSP_CIN                (1<<28)
+#define HDSP_midi0IRQPending    (1<<30) /* notice the gap at bit 29 */
+#define HDSP_midi1IRQPending    (1<<31)
+
+#define HDSP_spdifFrequencyMask    (HDSP_spdifFrequency0|HDSP_spdifFrequency1|HDSP_spdifFrequency2)
+
+#define HDSP_spdifFrequency32KHz   (HDSP_spdifFrequency0|HDSP_spdifFrequency1|HDSP_spdifFrequency2)
+#define HDSP_spdifFrequency44_1KHz (HDSP_spdifFrequency2|HDSP_spdifFrequency1)
+#define HDSP_spdifFrequency48KHz   (HDSP_spdifFrequency0|HDSP_spdifFrequency2)
+
+#define HDSP_spdifFrequency64KHz    0
+#define HDSP_spdifFrequency88_2KHz (HDSP_spdifFrequency2)
+#define HDSP_spdifFrequency96KHz   (HDSP_spdifFrequency0|HDSP_spdifFrequency1)
+
+/* Status2 Register bits */
+
+#define HDSP_version0     (1<<0)
+#define HDSP_version1     (1<<1)
+#define HDSP_version2     (1<<2)
+#define HDSP_wc_lock      (1<<3)
+#define HDSP_wc_sync      (1<<4)
+#define HDSP_inp_freq0    (1<<5)
+#define HDSP_inp_freq1    (1<<6)
+#define HDSP_inp_freq2    (1<<7)
+#define HDSP_SelSyncRef0  (1<<8)
+#define HDSP_SelSyncRef1  (1<<9)
+#define HDSP_SelSyncRef2  (1<<10)
+
+#define HDSP_wc_valid (HDSP_wc_lock|HDSP_wc_sync)
+
+#define HDSP_systemFrequencyMask (HDSP_inp_freq0|HDSP_inp_freq1|HDSP_inp_freq2)
+#define HDSP_systemFrequency32   (HDSP_inp_freq0)
+#define HDSP_systemFrequency44_1 (HDSP_inp_freq1)
+#define HDSP_systemFrequency48   (HDSP_inp_freq0|HDSP_inp_freq1)
+#define HDSP_systemFrequency64   (HDSP_inp_freq2)
+#define HDSP_systemFrequency88_2 (HDSP_inp_freq0|HDSP_inp_freq2)
+#define HDSP_systemFrequency96   (HDSP_inp_freq1|HDSP_inp_freq2)
+
+#define HDSP_SelSyncRefMask        (HDSP_SelSyncRef0|HDSP_SelSyncRef1|HDSP_SelSyncRef2)
+#define HDSP_SelSyncRef_ADAT1      0
+#define HDSP_SelSyncRef_ADAT2      (HDSP_SelSyncRef0)
+#define HDSP_SelSyncRef_ADAT3      (HDSP_SelSyncRef1)
+#define HDSP_SelSyncRef_SPDIF      (HDSP_SelSyncRef0|HDSP_SelSyncRef1)
+#define HDSP_SelSyncRef_WORD       (HDSP_SelSyncRef2)
+#define HDSP_SelSyncRef_ADAT_SYNC  (HDSP_SelSyncRef0|HDSP_SelSyncRef2)
+
+/* FIFO wait times, defined in terms of loops on readl() */
+
+#define HDSP_LONG_WAIT	 40000
+#define HDSP_SHORT_WAIT  100
+
+/* Computing addresses for adjusting gains */
+
+#define INPUT_TO_OUTPUT_KEY(in,out)     ((64 * (out)) + (in))
+#define PLAYBACK_TO_OUTPUT_KEY(chn,out) ((64 * (out)) + 32 + (chn))
+#define UNITY_GAIN                       32768
+#define MINUS_INFINITY_GAIN              0
+
+#ifndef PCI_VENDOR_ID_XILINX
+#define PCI_VENDOR_ID_XILINX		0x10ee
+#endif
+#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP
+#define PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP 0x3fc5
+#endif
+
+/* the size of a substream (1 mono data stream) */
+
+#define HDSP_CHANNEL_BUFFER_SAMPLES  (16*1024)
+#define HDSP_CHANNEL_BUFFER_BYTES    (4*HDSP_CHANNEL_BUFFER_SAMPLES)
+
+/* the size of the area we need to allocate for DMA transfers. the
+   size is the same regardless of the number of channels - the 
+   Multiface still uses the same memory area.
+
+   Note that we allocate 1 more channel than is apparently needed
+   because the h/w seems to write 1 byte beyond the end of the last
+   page. Sigh.
+*/
+
+#define HDSP_DMA_AREA_BYTES ((HDSP_MAX_CHANNELS+1) * HDSP_CHANNEL_BUFFER_BYTES)
+#define HDSP_DMA_AREA_KILOBYTES (HDSP_DMA_AREA_BYTES/1024)
+
+#define HDSP_MATRIX_MIXER_SIZE 2048
+
+typedef struct _hdsp      hdsp_t;
+typedef struct _hdsp_midi hdsp_midi_t;
+
+struct _hdsp_midi {
+    hdsp_t                  *hdsp;
+    int                      id;
+    snd_rawmidi_t           *rmidi;
+    snd_rawmidi_substream_t *input;
+    snd_rawmidi_substream_t *output;
+    char                     istimer; /* timer in use */
+    struct timer_list	     timer;
+    spinlock_t               lock;
+};
+
+struct _hdsp {
+	spinlock_t lock;
+	snd_pcm_substream_t *capture_substream;
+	snd_pcm_substream_t *playback_substream;
+        hdsp_midi_t midi[2];
+	int precise_ptr;
+	u32 control_register;	         /* cached value */
+	u32 creg_spdif;
+	u32 creg_spdif_stream;
+	char *card_name;		 /* digiface/multiface */
+        HDSP_Type type;                  /* ditto, but for code use */
+	size_t period_bytes;		 /* guess what this is */
+	unsigned char ds_channels;
+	unsigned char ss_channels;	 /* different for multiface/digiface */
+	void *capture_buffer_unaligned;	 /* original buffer addresses */
+	void *playback_buffer_unaligned; /* original buffer addresses */
+	unsigned char *capture_buffer;	 /* suitably aligned address */
+	unsigned char *playback_buffer;	 /* suitably aligned address */
+	dma_addr_t capture_buffer_addr;
+	dma_addr_t playback_buffer_addr;
+	pid_t capture_pid;
+	pid_t playback_pid;
+	int running;
+        int passthru;                   /* non-zero if doing pass-thru */
+	int last_spdif_sample_rate;	/* so that we can catch externally ... */
+	int last_adat_sample_rate;	/* ... induced rate changes            */
+        char *channel_map;
+	int dev;
+	int irq;
+	unsigned long port;
+	struct resource *res_port;
+        unsigned long iobase;
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	struct pci_dev *pci;
+	snd_info_entry_t *proc_entry;
+	snd_kcontrol_t *spdif_ctl;
+        unsigned short mixer_matrix[HDSP_MATRIX_MIXER_SIZE];
+};
+
+/* These tables map the ALSA channels 1..N to the channels that we
+   need to use in order to find the relevant channel buffer. RME
+   refer to this kind of mapping as between "the ADAT channel and
+   the DMA channel." We index it using the logical audio channel,
+   and the value is the DMA channel (i.e. channel buffer number)
+   where the data for that channel can be read/written from/to.
+*/
+
+static char channel_map_df_ss[HDSP_MAX_CHANNELS] = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
+	18, 19, 20, 21, 22, 23, 24, 25
+};
+
+static char channel_map_mf_ss[HDSP_MAX_CHANNELS] = { /* Multiface */
+	/* ADAT 0 */
+	0, 1, 2, 3, 4, 5, 6, 7, 
+	/* ADAT 2 */
+	16, 17, 18, 19, 20, 21, 22, 23, 
+	/* SPDIF */
+	24, 25,
+	-1, -1, -1, -1, -1, -1, -1, -1, 
+};
+
+static char channel_map_ds[HDSP_MAX_CHANNELS] = {
+	/* ADAT channels are remapped */
+	1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23,
+	/* channels 12 and 13 are S/PDIF */
+	24, 25,
+	/* others don't exist */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
+};
+
+#define HDSP_PREALLOCATE_MEMORY	/* via module snd-hdsp_mem */
+
+#ifdef HDSP_PREALLOCATE_MEMORY
+extern void *snd_hammerfall_get_buffer(struct pci_dev *, dma_addr_t *dmaaddr);
+extern void snd_hammerfall_free_buffer(struct pci_dev *, void *ptr);
+#endif
+
+static struct pci_device_id snd_hdsp_ids[] __devinitdata = {
+	{PCI_VENDOR_ID_XILINX,
+	 PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP, 
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,}, /* RME Hammerfall-DSP */
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, snd_hdsp_ids);
+
+static inline void hdsp_write(hdsp_t *hdsp, int reg, int val)
+{
+	writel(val, hdsp->iobase + reg);
+}
+
+static inline unsigned int hdsp_read(hdsp_t *hdsp, int reg)
+{
+	return readl (hdsp->iobase + reg);
+}
+
+static inline unsigned long long hdsp_read64 (hdsp_t *hdsp, int reg)
+{
+	unsigned long long val;
+	val = hdsp_read(hdsp, reg);
+	val = (val<<32)|hdsp_read(hdsp, reg + 4);
+
+	return val;
+}
+
+static inline int hdsp_check_for_iobox (hdsp_t *hdsp)
+{
+	if (hdsp_read (hdsp, HDSP_statusRegister) & HDSP_ConfigError) {
+		snd_printk ("Hammerfall-DSP: no Digiface or Multiface connected!\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static inline int hdsp_fifo_wait(hdsp_t *hdsp, int count, int timeout)
+{    
+	int i;
+
+	/* the fifoStatus registers reports on how many words
+	   are available in the command FIFO.
+	*/
+	
+	for (i = 0; i < timeout; i++)
+		if ((hdsp_read (hdsp, HDSP_fifoStatus) & 0xff) <= count)
+			return 0;
+
+	snd_printk ("wait for FIFO status <= %d failed after %d iterations\n",
+		    count, timeout);
+	return -1;
+}
+
+static inline int hdsp_read_gain (hdsp_t *hdsp, unsigned int addr)
+{
+	if (addr >= HDSP_MATRIX_MIXER_SIZE) {
+		return 0;
+	}
+	return hdsp->mixer_matrix[addr];
+}
+
+static inline int hdsp_write_gain(hdsp_t *hdsp, unsigned int addr, unsigned short data)
+{
+	unsigned int ad;
+
+	if (addr >= HDSP_MATRIX_MIXER_SIZE)
+		return -1;
+
+	ad = data + addr * 65536;
+
+	if (hdsp_fifo_wait(hdsp, 127, HDSP_LONG_WAIT)) {
+		return -1;
+	}
+	
+	hdsp_write (hdsp, HDSP_fifoData, ad);
+	hdsp->mixer_matrix[addr] = data;
+
+	return 0;
+}
+
+static inline int snd_hdsp_use_is_exclusive(hdsp_t *hdsp)
+{
+	unsigned long flags;
+	int ret = 1;
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+	if ((hdsp->playback_pid != hdsp->capture_pid) &&
+	    (hdsp->playback_pid >= 0) && (hdsp->capture_pid >= 0)) {
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return ret;
+}
+
+static inline int hdsp_system_sample_rate (hdsp_t *hdsp)
+{
+	unsigned int status2 = hdsp_read(hdsp, HDSP_status2Register);
+	unsigned int rate_bits = status2 & HDSP_systemFrequencyMask;
+
+	switch (rate_bits) {
+	case HDSP_systemFrequency32:   return 32000;
+	case HDSP_systemFrequency44_1: return 44100;
+	case HDSP_systemFrequency48:   return 48000;
+	case HDSP_systemFrequency64:   return 64000;
+	case HDSP_systemFrequency88_2: return 88200;
+	case HDSP_systemFrequency96:   return 96000;
+	default:                       return 0;
+	}
+}
+
+static inline int hdsp_spdif_sample_rate(hdsp_t *hdsp)
+{
+	unsigned int status = hdsp_read(hdsp, HDSP_statusRegister);
+	unsigned int rate_bits = (status & HDSP_spdifFrequencyMask);
+
+	if (status & HDSP_SPDIFErrorFlag) {
+		return 0;
+	}
+
+	switch (rate_bits) {
+	case HDSP_spdifFrequency32KHz: return 32000;
+	case HDSP_spdifFrequency44_1KHz: return 44100;
+	case HDSP_spdifFrequency48KHz: return 48000;
+	case HDSP_spdifFrequency64KHz: return 64000;
+	case HDSP_spdifFrequency88_2KHz: return 88200;
+	case HDSP_spdifFrequency96KHz: return 96000;
+	default:
+		snd_printk ("unknown frequency status; bits = 0x%x, status = 0x%x", rate_bits, status);
+		return 0;
+	}
+}
+
+static inline void hdsp_compute_period_size(hdsp_t *hdsp)
+{
+	hdsp->period_bytes = 1 << ((hdsp_decode_latency(hdsp->control_register) + 8));
+}
+
+static snd_pcm_uframes_t hdsp_hw_pointer(hdsp_t *hdsp)
+{
+	int position;
+
+	position = hdsp_read(hdsp, HDSP_statusRegister);
+
+	if (!hdsp->precise_ptr) {
+		return (position & HDSP_BufferID) ? (hdsp->period_bytes / 4) : 0;
+	}
+
+	position &= HDSP_BufferPositionMask;
+	position /= 4;
+	position -= 32;
+	position &= (HDSP_CHANNEL_BUFFER_SAMPLES-1);
+	return position;
+}
+
+static inline void hdsp_reset_hw_pointer(hdsp_t *hdsp)
+{
+#if 0
+	/* reset the hw pointer to zero. We do this by writing to 8
+	   registers, each of which is a 32bit wide register, and set
+	   them all to zero. 
+	*/
+
+	for (i = 0; i < 8; ++i) {
+		hdsp_write(hdsp, i, 0);
+		udelay(10);
+	}
+#endif
+}
+
+static inline void hdsp_start_audio(hdsp_t *s)
+{
+	s->control_register |= (HDSP_AudioInterruptEnable | HDSP_Start);
+	hdsp_write(s, HDSP_controlRegister, s->control_register);
+}
+
+static inline void hdsp_stop_audio(hdsp_t *s)
+{
+	s->control_register &= ~(HDSP_Start | HDSP_AudioInterruptEnable);
+	hdsp_write(s, HDSP_controlRegister, s->control_register);
+}
+
+static inline void hdsp_silence_playback(hdsp_t *hdsp)
+{
+	memset(hdsp->playback_buffer, 0, HDSP_DMA_AREA_BYTES);
+}
+
+static int hdsp_set_interrupt_interval(hdsp_t *s, unsigned int frames)
+{
+	int n;
+
+	spin_lock_irq(&s->lock);
+
+	frames >>= 7;
+	n = 0;
+	while (frames) {
+		n++;
+		frames >>= 1;
+	}
+
+	s->control_register &= ~HDSP_LatencyMask;
+	s->control_register |= hdsp_encode_latency(n);
+
+	hdsp_write(s, HDSP_controlRegister, s->control_register);
+
+	hdsp_compute_period_size(s);
+
+	spin_unlock_irq(&s->lock);
+
+	return 0;
+}
+
+static int hdsp_set_rate(hdsp_t *hdsp, int rate)
+{
+	int reject_if_open = 0;
+	int current_rate;
+
+	if (!(hdsp->control_register & HDSP_ClockModeMaster)) {
+		snd_printk ("device is not running as a clock master: cannot set sample rate.\n");
+		return -1;
+	}
+
+	/* Changing from a "single speed" to a "double speed" rate is
+	   not allowed if any substreams are open. This is because
+	   such a change causes a shift in the location of 
+	   the DMA buffers and a reduction in the number of available
+	   buffers. 
+
+	   Note that a similar but essentially insoluble problem
+	   exists for externally-driven rate changes. All we can do
+	   is to flag rate changes in the read/write routines.
+	 */
+
+	spin_lock_irq(&hdsp->lock);
+	current_rate = hdsp_system_sample_rate(hdsp);
+
+	switch (rate) {
+	case 32000:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate = HDSP_Frequency32KHz;
+		break;
+	case 44100:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate = HDSP_Frequency44_1KHz;
+		break;
+	case 48000:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate = HDSP_Frequency48KHz;
+		break;
+	case 64000:
+		if (current_rate < 48000) {
+			reject_if_open = 1;
+		}
+		rate = HDSP_Frequency64KHz;
+		break;
+	case 88200:
+		if (current_rate < 48000) {
+			reject_if_open = 1;
+		}
+		rate = HDSP_Frequency88_2KHz;
+		break;
+	case 96000:
+		if (current_rate < 48000) {
+			reject_if_open = 1;
+		}
+		rate = HDSP_Frequency96KHz;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (reject_if_open && (hdsp->capture_pid >= 0 || hdsp->playback_pid >= 0)) {
+		snd_printk ("cannot change between single- and double-speed mode (capture PID = %d, playback PID = %d)\n",
+			    hdsp->capture_pid,
+			    hdsp->playback_pid);
+		spin_unlock_irq(&hdsp->lock);
+		return -EBUSY;
+	}
+
+	hdsp->control_register &= ~HDSP_FrequencyMask;
+	hdsp->control_register |= rate;
+	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
+
+	if (rate > 48000) {
+		hdsp->channel_map = channel_map_ds;
+	} else {
+		switch (hdsp->type) {
+		case Multiface:
+			hdsp->channel_map = channel_map_mf_ss;
+			break;
+		case Digiface:
+			hdsp->channel_map = channel_map_df_ss;
+			break;
+		}
+	}
+
+	spin_unlock_irq(&hdsp->lock);
+	return 0;
+}
+
+static void hdsp_set_thru(hdsp_t *hdsp, int channel, int enable)
+{
+
+	hdsp->passthru = 0;
+
+	if (channel < 0) {
+
+		int i;
+
+		/* set thru for all channels */
+
+		if (enable) {
+			for (i = 0; i < 26; i++) {
+				hdsp_write_gain (hdsp, INPUT_TO_OUTPUT_KEY(i,i), UNITY_GAIN);
+			}
+		} else {
+			for (i = 0; i < 26; i++) {
+				hdsp_write_gain (hdsp, INPUT_TO_OUTPUT_KEY(i,i), MINUS_INFINITY_GAIN);
+			}
+		}
+
+	} else {
+		int mapped_channel;
+
+		snd_assert(channel < HDSP_MAX_CHANNELS, return);
+
+		mapped_channel = hdsp->channel_map[channel];
+
+		if (enable) {
+			hdsp_write_gain (hdsp, INPUT_TO_OUTPUT_KEY(channel,channel), UNITY_GAIN);
+		} else {
+			hdsp_write_gain (hdsp, INPUT_TO_OUTPUT_KEY(channel,channel), MINUS_INFINITY_GAIN);
+		}
+	}
+}
+
+static int hdsp_set_passthru(hdsp_t *hdsp, int onoff)
+{
+	if (onoff) {
+		hdsp_set_thru(hdsp, -1, 1);
+		hdsp_reset_hw_pointer(hdsp);
+		hdsp_silence_playback(hdsp);
+
+		/* we don't want interrupts, so do a
+		   custom version of hdsp_start_audio().
+		*/
+
+		hdsp->control_register |= (HDSP_Start|HDSP_AudioInterruptEnable|hdsp_encode_latency(7));
+
+		hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
+		hdsp->passthru = 1;
+	} else {
+		hdsp_set_thru(hdsp, -1, 0);
+		hdsp_stop_audio(hdsp);		
+		hdsp->passthru = 0;
+	}
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------
+   MIDI
+  ----------------------------------------------------------------------------*/
+
+static inline unsigned char snd_hdsp_midi_read_byte (hdsp_t *hdsp, int id)
+{
+	/* the hardware already does the relevant bit-mask with 0xff */
+	if (id) {
+		return hdsp_read(hdsp, HDSP_midiDataIn1);
+	} else {
+		return hdsp_read(hdsp, HDSP_midiDataIn0);
+	}
+}
+
+static inline void snd_hdsp_midi_write_byte (hdsp_t *hdsp, int id, int val)
+{
+	/* the hardware already does the relevant bit-mask with 0xff */
+	if (id) {
+		return hdsp_write(hdsp, HDSP_midiDataOut1, val);
+	} else {
+		return hdsp_write(hdsp, HDSP_midiDataOut0, val);
+	}
+}
+
+static inline int snd_hdsp_midi_input_available (hdsp_t *hdsp, int id)
+{
+	if (id) {
+		return (hdsp_read(hdsp, HDSP_midiStatusIn1) & 0xff);
+	} else {
+		return (hdsp_read(hdsp, HDSP_midiStatusIn0) & 0xff);
+	}
+}
+
+static inline int snd_hdsp_midi_output_possible (hdsp_t *hdsp, int id)
+{
+	if (id) {
+		return (hdsp_read(hdsp, HDSP_midiStatusOut1) & 0xff) < 128;
+	} else {
+		return (hdsp_read(hdsp, HDSP_midiStatusOut0) & 0xff)< 128;
+	}
+}
+
+static inline void snd_hdsp_flush_midi_input (hdsp_t *hdsp, int id)
+{
+	while (snd_hdsp_midi_input_available (hdsp, id)) {
+		snd_hdsp_midi_read_byte (hdsp, id);
+	}
+}
+
+static int snd_hdsp_midi_output_write (hdsp_midi_t *hmidi)
+{
+	unsigned long flags;
+	int n_pending;
+	int clear_timer = 0;
+	int to_write;
+	int i;
+	unsigned char buf[128];
+
+	/* Output is not interrupt driven */
+		
+	spin_lock_irqsave (&hmidi->lock, flags);
+
+	if (hmidi->output) {
+		if (!snd_rawmidi_transmit_empty (hmidi->output)) {
+			if ((n_pending = snd_hdsp_midi_output_possible (hmidi->hdsp, hmidi->id)) > 0) {
+				if (n_pending > sizeof (buf))
+					n_pending = sizeof (buf);
+				
+				if ((to_write = snd_rawmidi_transmit (hmidi->output, buf, n_pending)) > 0) {
+					for (i = 0; i < to_write; ++i) 
+						snd_hdsp_midi_write_byte (hmidi->hdsp, hmidi->id, buf[i]);
+				} else {
+					clear_timer = 1;
+				}
+			}
+		} else {
+			clear_timer = 1;
+		}
+
+		if (clear_timer && hmidi->istimer && --hmidi->istimer <= 0) {
+			printk ("removing timer because there is nothing to do\n");
+			if (del_timer(&hmidi->timer)) {
+				printk ("not removed\n");
+			}
+		} 
+	}
+
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+	return 0;
+}
+
+static int snd_hdsp_midi_input_read (hdsp_midi_t *hmidi)
+{
+	unsigned char buf[128]; /* this buffer is designed to match the MIDI input FIFO size */
+	unsigned long flags;
+	int n_pending;
+	int i;
+
+	spin_lock_irqsave (&hmidi->lock, flags);
+
+	if ((n_pending = snd_hdsp_midi_input_available (hmidi->hdsp, hmidi->id)) > 0) {
+		if (hmidi->input) {
+			if (n_pending > sizeof (buf)) {
+				n_pending = sizeof (buf);
+			}
+			for (i = 0; i < n_pending; ++i) {
+				buf[i] = snd_hdsp_midi_read_byte (hmidi->hdsp, hmidi->id);
+			}
+			if (n_pending) {
+				snd_rawmidi_receive (hmidi->input, buf, n_pending);
+			}
+		} else {
+			/* flush the MIDI input FIFO */
+			while (--n_pending) {
+				snd_hdsp_midi_read_byte (hmidi->hdsp, hmidi->id);
+			}
+		}
+	} 
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+	return snd_hdsp_midi_output_write (hmidi);
+}
+
+static void snd_hdsp_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	hdsp_t *hdsp;
+	hdsp_midi_t *hmidi;
+	unsigned long flags;
+
+	hmidi = (hdsp_midi_t *) substream->rmidi->private_data;
+	hdsp = hmidi->hdsp;
+	spin_lock_irqsave (&hdsp->lock, flags);
+	if (up) {
+		snd_hdsp_flush_midi_input (hdsp, hmidi->id);
+		if (hmidi->id) 
+			hdsp->control_register |= HDSP_Midi1InterruptEnable;
+		else 
+			hdsp->control_register |= HDSP_Midi0InterruptEnable;
+	} else {
+		if (hmidi->id) 
+			hdsp->control_register &= ~HDSP_Midi1InterruptEnable;
+		else 
+			hdsp->control_register &= ~HDSP_Midi0InterruptEnable;
+	}
+
+	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
+	spin_unlock_irqrestore (&hdsp->lock, flags);
+}
+
+static void snd_hdsp_midi_output_timer(unsigned long data)
+{
+	hdsp_midi_t *hmidi = (hdsp_midi_t *) data;
+	unsigned long flags;
+	
+	snd_hdsp_midi_output_write(hmidi);
+	spin_lock_irqsave (&hmidi->lock, flags);
+
+	/* this does not bump hmidi->istimer, because the
+	   kernel automatically removed the timer when it
+	   expired, and we are now adding it back, thus
+	   leaving istimer wherever it was set before.  
+	*/
+
+	if (hmidi->istimer) {
+		hmidi->timer.expires = 1 + jiffies;
+		add_timer(&hmidi->timer);
+	}
+
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+}
+
+static void snd_hdsp_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	hdsp_midi_t *hmidi;
+	unsigned long flags;
+
+	hmidi = (hdsp_midi_t *) substream->rmidi->private_data;
+	spin_lock_irqsave (&hmidi->lock, flags);
+	if (up) {
+		if (!hmidi->istimer) {
+			hmidi->timer.function = snd_hdsp_midi_output_timer;
+			hmidi->timer.data = (unsigned long) hmidi;
+			hmidi->timer.expires = 1 + jiffies;
+			printk ("add timer from output trigger\n");
+			add_timer(&hmidi->timer);
+			hmidi->istimer++;
+		}
+	} else {
+		if (hmidi->istimer && --hmidi->istimer <= 0) {
+			printk ("remove timer in trigger off\n");
+			if (del_timer (&hmidi->timer)) {
+				printk ("not removed\n");
+			}
+		}
+	}
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+}
+
+static int snd_hdsp_midi_input_open(snd_rawmidi_substream_t * substream)
+{
+	hdsp_midi_t *hmidi;
+	unsigned long flags;
+
+	hmidi = (hdsp_midi_t *) substream->rmidi->private_data;
+	spin_lock_irqsave (&hmidi->lock, flags);
+	snd_hdsp_flush_midi_input (hmidi->hdsp, hmidi->id);
+	hmidi->input = substream;
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+
+	return 0;
+}
+
+static int snd_hdsp_midi_output_open(snd_rawmidi_substream_t * substream)
+{
+	hdsp_midi_t *hmidi;
+	unsigned long flags;
+
+	hmidi = (hdsp_midi_t *) substream->rmidi->private_data;
+	spin_lock_irqsave (&hmidi->lock, flags);
+	hmidi->output = substream;
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+
+	return 0;
+}
+
+static int snd_hdsp_midi_input_close(snd_rawmidi_substream_t * substream)
+{
+	hdsp_midi_t *hmidi;
+	unsigned long flags;
+
+	snd_hdsp_midi_input_trigger (substream, 0);
+
+	hmidi = (hdsp_midi_t *) substream->rmidi->private_data;
+	spin_lock_irqsave (&hmidi->lock, flags);
+	hmidi->input = NULL;
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+
+	return 0;
+}
+
+static int snd_hdsp_midi_output_close(snd_rawmidi_substream_t * substream)
+{
+	hdsp_midi_t *hmidi;
+	unsigned long flags;
+
+	snd_hdsp_midi_output_trigger (substream, 0);
+
+	hmidi = (hdsp_midi_t *) substream->rmidi->private_data;
+	spin_lock_irqsave (&hmidi->lock, flags);
+	hmidi->output = NULL;
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+
+	return 0;
+}
+
+snd_rawmidi_ops_t snd_hdsp_midi_output =
+{
+	open:		snd_hdsp_midi_output_open,
+	close:		snd_hdsp_midi_output_close,
+	trigger:	snd_hdsp_midi_output_trigger,
+};
+
+snd_rawmidi_ops_t snd_hdsp_midi_input =
+{
+	open:		snd_hdsp_midi_input_open,
+	close:		snd_hdsp_midi_input_close,
+	trigger:	snd_hdsp_midi_input_trigger,
+};
+
+static int __devinit snd_hdsp_create_midi (snd_card_t *card, hdsp_t *hdsp, int id)
+{
+	char buf[32];
+
+	hdsp->midi[id].id = id;
+	hdsp->midi[id].rmidi = NULL;
+	hdsp->midi[id].input = NULL;
+	hdsp->midi[id].output = NULL;
+	hdsp->midi[id].hdsp = hdsp;
+	hdsp->midi[id].istimer = 0;
+	spin_lock_init (&hdsp->midi[id].lock);
+
+	sprintf (buf, "%s MIDI %d", card->shortname, id+1);
+	if (snd_rawmidi_new (card, buf, id, 1, 1, &hdsp->midi[id].rmidi) < 0) {
+		return -1;
+	}
+
+	sprintf (hdsp->midi[id].rmidi->name, "%s MIDI %d", card->id, id+1);
+	hdsp->midi[id].rmidi->private_data = &hdsp->midi[id];
+
+	snd_rawmidi_set_ops (hdsp->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_hdsp_midi_output);
+	snd_rawmidi_set_ops (hdsp->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_hdsp_midi_input);
+
+	hdsp->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
+		SNDRV_RAWMIDI_INFO_INPUT |
+		SNDRV_RAWMIDI_INFO_DUPLEX;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+  Control Interface
+  ----------------------------------------------------------------------------*/
+
+static u32 snd_hdsp_convert_from_aes(snd_aes_iec958_t *aes)
+{
+	u32 val = 0;
+	val |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? HDSP_SPDIFProfessional : 0;
+	val |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? HDSP_SPDIFNonAudio : 0;
+	if (val & HDSP_SPDIFProfessional)
+		val |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? HDSP_SPDIFEmphasis : 0;
+	else
+		val |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? HDSP_SPDIFEmphasis : 0;
+	return val;
+}
+
+static void snd_hdsp_convert_to_aes(snd_aes_iec958_t *aes, u32 val)
+{
+	aes->status[0] = ((val & HDSP_SPDIFProfessional) ? IEC958_AES0_PROFESSIONAL : 0) |
+			 ((val & HDSP_SPDIFNonAudio) ? IEC958_AES0_NONAUDIO : 0);
+	if (val & HDSP_SPDIFProfessional)
+		aes->status[0] |= (val & HDSP_SPDIFEmphasis) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;
+	else
+		aes->status[0] |= (val & HDSP_SPDIFEmphasis) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;
+}
+
+static int snd_hdsp_control_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_hdsp_control_spdif_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	
+	snd_hdsp_convert_to_aes(&ucontrol->value.iec958, hdsp->creg_spdif);
+	return 0;
+}
+
+static int snd_hdsp_control_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change;
+	u32 val;
+	
+	val = snd_hdsp_convert_from_aes(&ucontrol->value.iec958);
+	spin_lock_irqsave(&hdsp->lock, flags);
+	change = val != hdsp->creg_spdif;
+	hdsp->creg_spdif = val;
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return change;
+}
+
+static int snd_hdsp_control_spdif_stream_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_hdsp_control_spdif_stream_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	
+	snd_hdsp_convert_to_aes(&ucontrol->value.iec958, hdsp->creg_spdif_stream);
+	return 0;
+}
+
+static int snd_hdsp_control_spdif_stream_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change;
+	u32 val;
+	
+	val = snd_hdsp_convert_from_aes(&ucontrol->value.iec958);
+	spin_lock_irqsave(&hdsp->lock, flags);
+	change = val != hdsp->creg_spdif_stream;
+	hdsp->creg_spdif_stream = val;
+	hdsp->control_register &= ~(HDSP_SPDIFProfessional | HDSP_SPDIFNonAudio | HDSP_SPDIFEmphasis);
+	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register |= val);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return change;
+}
+
+static int snd_hdsp_control_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_hdsp_control_spdif_mask_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = kcontrol->private_value;
+	return 0;
+}
+
+#define HDSP_SPDIF_IN(xname, xindex) \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, name: xname, index: xindex, \
+  info: snd_hdsp_info_spdif_in, \
+  get: snd_hdsp_get_spdif_in, put: snd_hdsp_put_spdif_in }
+
+static unsigned int hdsp_spdif_in(hdsp_t *hdsp)
+{
+	return hdsp_decode_spdif_in(hdsp->control_register & HDSP_SPDIFInputMask);
+}
+
+static int hdsp_set_spdif_input(hdsp_t *hdsp, int in)
+{
+	hdsp->control_register &= ~HDSP_SPDIFInputMask;
+	hdsp->control_register |= hdsp_encode_spdif_in(in);
+	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
+	return 0;
+}
+
+static int snd_hdsp_info_spdif_in(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[3] = {"ADAT1", "Coaxial", "Internal"};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item > 2)
+		uinfo->value.enumerated.item = 2;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdsp_get_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	
+	spin_lock_irqsave(&hdsp->lock, flags);
+	ucontrol->value.enumerated.item[0] = hdsp_spdif_in(hdsp);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return 0;
+}
+
+static int snd_hdsp_put_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change;
+	unsigned int val;
+	
+	if (!snd_hdsp_use_is_exclusive(hdsp))
+		return -EBUSY;
+	val = ucontrol->value.enumerated.item[0] % 3;
+	spin_lock_irqsave(&hdsp->lock, flags);
+	change = val != hdsp_spdif_in(hdsp);
+	if (change)
+		hdsp_set_spdif_input(hdsp, val);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return change;
+}
+
+#define HDSP_SPDIF_OUT(xname, xindex) \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, name: xname, index: xindex, \
+  info: snd_hdsp_info_spdif_out, \
+  get: snd_hdsp_get_spdif_out, put: snd_hdsp_put_spdif_out }
+
+static int hdsp_spdif_out(hdsp_t *hdsp)
+{
+	return (hdsp->control_register & HDSP_SPDIFOpticalOut) ? 1 : 0;
+}
+
+static int hdsp_set_spdif_output(hdsp_t *hdsp, int out)
+{
+	if (out) {
+		hdsp->control_register |= HDSP_SPDIFOpticalOut;
+	} else {
+		hdsp->control_register &= ~HDSP_SPDIFOpticalOut;
+	}
+	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
+	return 0;
+}
+
+static int snd_hdsp_info_spdif_out(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdsp_get_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	
+	spin_lock_irqsave(&hdsp->lock, flags);
+	ucontrol->value.integer.value[0] = hdsp_spdif_out(hdsp);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return 0;
+}
+
+static int snd_hdsp_put_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change;
+	unsigned int val;
+	
+	if (!snd_hdsp_use_is_exclusive(hdsp))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irqsave(&hdsp->lock, flags);
+	change = val != hdsp_spdif_out(hdsp);
+	hdsp_set_spdif_output(hdsp, val);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return change;
+}
+
+#define HDSP_SYNC_PREF(xname, xindex) \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, name: xname, index: xindex, \
+  info: snd_hdsp_info_sync_pref, \
+  get: snd_hdsp_get_sync_pref, put: snd_hdsp_put_sync_pref }
+
+static int hdsp_sync_pref(hdsp_t *hdsp)
+{
+	/* Notice that this looks at the requested sync source,
+	   not the one actually in use.
+	*/
+	
+	if (hdsp->control_register & HDSP_ClockModeMaster) {
+		return HDSP_SYNC_FROM_SELF;
+	}
+
+	switch (hdsp->control_register & HDSP_SyncRefMask) {
+	case HDSP_SyncRef_ADAT1:
+		return HDSP_SYNC_FROM_ADAT1;
+	case HDSP_SyncRef_ADAT2:
+		return HDSP_SYNC_FROM_ADAT2;
+	case HDSP_SyncRef_ADAT3:
+		return HDSP_SYNC_FROM_ADAT3;
+	case HDSP_SyncRef_SPDIF:
+		return HDSP_SYNC_FROM_SPDIF;
+	case HDSP_SyncRef_WORD:
+		return HDSP_SYNC_FROM_WORD;
+	case HDSP_SyncRef_ADAT_SYNC:
+		return HDSP_SYNC_FROM_ADAT_SYNC;
+	default:
+		return HDSP_SYNC_FROM_SELF;
+	}
+	return 0;
+}
+
+static int hdsp_set_sync_pref(hdsp_t *hdsp, int pref)
+{
+	hdsp->control_register &= ~HDSP_SyncRefMask;
+	switch (pref) {
+	case HDSP_SYNC_FROM_ADAT1:
+		hdsp->control_register &= ~HDSP_ClockModeMaster;
+		hdsp->control_register &= ~HDSP_SyncRefMask; /* clear SyncRef bits */
+		break;
+	case HDSP_SYNC_FROM_ADAT2:
+		hdsp->control_register &= ~HDSP_ClockModeMaster;
+		hdsp->control_register |= HDSP_SyncRef_ADAT2;
+		break;
+	case HDSP_SYNC_FROM_ADAT3:
+		hdsp->control_register &= ~HDSP_ClockModeMaster;
+		hdsp->control_register |= HDSP_SyncRef_ADAT3;
+		break;
+	case HDSP_SYNC_FROM_SPDIF:
+		hdsp->control_register &= ~HDSP_ClockModeMaster;
+		hdsp->control_register |= HDSP_SyncRef_SPDIF;
+		break;
+	case HDSP_SYNC_FROM_WORD:
+		hdsp->control_register &= ~HDSP_ClockModeMaster;
+		hdsp->control_register |= HDSP_SyncRef_WORD;
+		break;
+	case HDSP_SYNC_FROM_ADAT_SYNC:
+		hdsp->control_register &= ~HDSP_ClockModeMaster;
+		hdsp->control_register |= HDSP_SyncRef_ADAT_SYNC;
+		break;
+	case HDSP_SYNC_FROM_SELF:
+		hdsp->control_register |= HDSP_ClockModeMaster;
+		break;
+	default:
+		return -1;
+	}
+	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
+	return 0;
+}
+
+static int snd_hdsp_info_sync_pref(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = {"Internal", "Word", "ADAT Sync", "IEC958", "ADAT1", "ADAT2", "ADAT3" };
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = (hdsp->type == Digiface) ? 7 : 6;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdsp_get_sync_pref(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	
+	spin_lock_irqsave(&hdsp->lock, flags);
+	ucontrol->value.enumerated.item[0] = hdsp_sync_pref(hdsp);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return 0;
+}
+
+static int snd_hdsp_put_sync_pref(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change, max;
+	unsigned int val;
+	
+	if (!snd_hdsp_use_is_exclusive(hdsp))
+		return -EBUSY;
+	max = hdsp->ss_channels == (hdsp->type == Digiface) ? 7 : 6;
+	val = ucontrol->value.enumerated.item[0] % max;
+	spin_lock_irqsave(&hdsp->lock, flags);
+	change = val != hdsp_sync_pref(hdsp);
+	hdsp_set_sync_pref(hdsp, val);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return change;
+}
+
+#define HDSP_PASSTHRU(xname, xindex) \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, name: xname, index: xindex, \
+  info: snd_hdsp_info_passthru, \
+  put: snd_hdsp_put_passthru, \
+  get: snd_hdsp_get_passthru }
+
+static int snd_hdsp_info_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdsp_get_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+	ucontrol->value.integer.value[0] = hdsp->passthru;
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return 0;
+}
+
+static int snd_hdsp_put_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change;
+	unsigned int val;
+	int err = 0;
+
+	if (!snd_hdsp_use_is_exclusive(hdsp))
+		return -EBUSY;
+
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irqsave(&hdsp->lock, flags);
+	change = (ucontrol->value.integer.value[0] != hdsp->passthru);
+	if (change)
+		err = hdsp_set_passthru(hdsp, val);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return err ? err : change;
+}
+
+#define HDSP_LINE_OUT(xname, xindex) \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, name: xname, index: xindex, \
+  info: snd_hdsp_info_line_out, \
+  get: snd_hdsp_get_line_out, put: snd_hdsp_put_line_out }
+
+static int hdsp_line_out(hdsp_t *hdsp)
+{
+	return (hdsp->control_register & HDSP_LineOut) ? 1 : 0;
+}
+
+static int hdsp_set_line_output(hdsp_t *hdsp, int out)
+{
+	if (out) {
+		hdsp->control_register |= HDSP_LineOut;
+	} else {
+		hdsp->control_register &= ~HDSP_LineOut;
+	}
+	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
+	return 0;
+}
+
+static int snd_hdsp_info_line_out(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdsp_get_line_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	
+	spin_lock_irqsave(&hdsp->lock, flags);
+	ucontrol->value.integer.value[0] = hdsp_line_out(hdsp);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return 0;
+}
+
+static int snd_hdsp_put_line_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change;
+	unsigned int val;
+	
+	if (!snd_hdsp_use_is_exclusive(hdsp))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irqsave(&hdsp->lock, flags);
+	change = val != hdsp_line_out(hdsp);
+	hdsp_set_line_output(hdsp, val);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return change;
+}
+
+#define HDSP_MIXER(xname, xindex) \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, name: xname, index: xindex, \
+  info: snd_hdsp_info_mixer, \
+  get: snd_hdsp_get_mixer, put: snd_hdsp_put_mixer }
+
+static int snd_hdsp_info_mixer(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 3;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 65536;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int snd_hdsp_get_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int source;
+	int destination;
+	int addr;
+
+	source = ucontrol->value.integer.value[0];
+	destination = ucontrol->value.integer.value[1];
+
+	if (source > 25) {
+		addr = PLAYBACK_TO_OUTPUT_KEY(source-26,destination);
+	} else {
+		addr = INPUT_TO_OUTPUT_KEY(source, destination);
+	}
+	
+	spin_lock_irqsave(&hdsp->lock, flags);
+	ucontrol->value.integer.value[0] = hdsp_read_gain (hdsp, addr);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return 0;
+}
+
+static int snd_hdsp_put_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change;
+	int source;
+	int destination;
+	int gain;
+	int addr;
+
+	if (!snd_hdsp_use_is_exclusive(hdsp))
+		return -EBUSY;
+
+	source = ucontrol->value.integer.value[0];
+	destination = ucontrol->value.integer.value[1];
+
+	if (source > 25) {
+		addr = PLAYBACK_TO_OUTPUT_KEY(source-26, destination);
+	} else {
+		addr = INPUT_TO_OUTPUT_KEY(source, destination);
+	}
+
+	gain = ucontrol->value.integer.value[2];
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+	if ((change = gain != hdsp_read_gain(hdsp, addr)))
+		hdsp_write_gain(hdsp, addr, gain);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return change;
+}
+
+/* The simple mixer control(s) provide gain control for the
+   basic 1:1 mappings of playback streams to output
+   streams. 
+*/
+
+#define HDSP_PLAYBACK_MIXER \
+{ iface: SNDRV_CTL_ELEM_IFACE_MIXER, \
+  access: SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE | \
+		 SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  info: snd_hdsp_info_playback_mixer, \
+  get: snd_hdsp_get_playback_mixer, put: snd_hdsp_put_playback_mixer }
+
+static int snd_hdsp_info_playback_mixer(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 65536;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int snd_hdsp_get_playback_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int addr;
+	int chn;
+
+	chn = ucontrol->id.index - 1;
+	addr = PLAYBACK_TO_OUTPUT_KEY(chn, chn);
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+	ucontrol->value.integer.value[0] = hdsp_read_gain (hdsp, addr);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return 0;
+}
+
+static int snd_hdsp_put_playback_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change;
+	int addr;
+	int chn;
+	int gain;
+
+	if (!snd_hdsp_use_is_exclusive(hdsp))
+		return -EBUSY;
+	
+	chn = ucontrol->id.index - 1;
+	addr = PLAYBACK_TO_OUTPUT_KEY(chn, chn);
+	gain = ucontrol->value.integer.value[0];
+
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+	if ((change = gain != hdsp_read_gain(hdsp, addr)))
+		hdsp_write_gain(hdsp, addr, gain);
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return change;
+}
+
+#define HDSP_PEAK_PLAYBACK \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, \
+  access: SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  info: snd_hdsp_info_peak_playback, \
+  get: snd_hdsp_get_peak_playback \
+}
+
+static int snd_hdsp_info_peak_playback(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	return 0;
+}
+
+static int snd_hdsp_get_peak_playback(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned int peakval = hdsp_read (hdsp, HDSP_playbackPeakLevel + (4 * (ucontrol->id.index-1)));
+	ucontrol->value.integer.value[0] = peakval & 0xffffff00;  /* peak */
+	ucontrol->value.integer.value[1] = peakval & 0xf;         /* overs */
+	return 0;
+}
+
+#define HDSP_PEAK_INPUT \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, \
+  access: SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  info: snd_hdsp_info_peak_input, \
+  get: snd_hdsp_get_peak_input \
+}
+
+static int snd_hdsp_info_peak_input(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	return 0;
+}
+
+static int snd_hdsp_get_peak_input(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned int peakval = hdsp_read (hdsp, HDSP_inputPeakLevel + (4 * (ucontrol->id.index-1)));
+	ucontrol->value.integer.value[0] = peakval & 0xffffff00;  /* peak */
+	ucontrol->value.integer.value[1] = peakval & 0xf;         /* overs */
+	return 0;
+}
+
+#define HDSP_PEAK_OUTPUT \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, \
+  access: SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  info: snd_hdsp_info_peak_output, \
+  get: snd_hdsp_get_peak_output \
+}
+
+static int snd_hdsp_info_peak_output(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	return 0;
+}
+
+static int snd_hdsp_get_peak_output(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	unsigned int peakval = hdsp_read (hdsp, HDSP_outputPeakLevel + (4 * (ucontrol->id.index-1)));
+	ucontrol->value.integer.value[0] = peakval & 0xffffff00;  /* peak */
+	ucontrol->value.integer.value[1] = peakval & 0xf;         /* overs */
+	return 0;
+}
+
+#define HDSP_RMS_INPUT \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, \
+  access: SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  info: snd_hdsp_info_rms_input, \
+  get: snd_hdsp_get_rms_input \
+}
+
+static int snd_hdsp_info_rms_input(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER64;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_hdsp_get_rms_input(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer64.value[0] = hdsp_read64 (hdsp, HDSP_inputRmsLevel + (8 * (ucontrol->id.index-1)));
+	return 0;
+}
+
+#define HDSP_RMS_PLAYBACK \
+{ iface: SNDRV_CTL_ELEM_IFACE_PCM, \
+  access: SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  info: snd_hdsp_info_rms_playback, \
+  get: snd_hdsp_get_rms_playback \
+}
+
+static int snd_hdsp_info_rms_playback(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER64;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_hdsp_get_rms_playback(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	hdsp_t *hdsp = _snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer64.value[0] = hdsp_read64 (hdsp, HDSP_playbackRmsLevel + (8 * (ucontrol->id.index-1)));
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_hdsp_controls[] = {
+{
+	iface:		SNDRV_CTL_ELEM_IFACE_PCM,
+	name:		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	info:		snd_hdsp_control_spdif_info,
+	get:		snd_hdsp_control_spdif_get,
+	put:		snd_hdsp_control_spdif_put,
+},
+{
+	access:		SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	iface:		SNDRV_CTL_ELEM_IFACE_PCM,
+	name:		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+	info:		snd_hdsp_control_spdif_stream_info,
+	get:		snd_hdsp_control_spdif_stream_get,
+	put:		snd_hdsp_control_spdif_stream_put,
+},
+{
+	access:		SNDRV_CTL_ELEM_ACCESS_READ,
+	iface:		SNDRV_CTL_ELEM_IFACE_MIXER,
+	name:		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
+	info:		snd_hdsp_control_spdif_mask_info,
+	get:		snd_hdsp_control_spdif_mask_get,
+	private_value:	IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_CON_EMPHASIS,	                                                                                      
+},
+{
+	access:		SNDRV_CTL_ELEM_ACCESS_READ,
+	iface:		SNDRV_CTL_ELEM_IFACE_MIXER,
+	name:		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PRO_MASK),
+	info:		snd_hdsp_control_spdif_mask_info,
+	get:		snd_hdsp_control_spdif_mask_get,
+	private_value:	IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_PRO_EMPHASIS,
+},
+HDSP_MIXER("Mixer", 0),
+HDSP_SPDIF_IN("IEC958 Input Connector", 0),
+HDSP_SPDIF_OUT("IEC958 Output also on ADAT1", 0),
+HDSP_SYNC_PREF("Preferred Sync Source", 0),
+HDSP_PASSTHRU("Passthru", 0),
+HDSP_LINE_OUT("Line Out", 0),
+};
+
+#define HDSP_CONTROLS (sizeof(snd_hdsp_controls)/sizeof(snd_kcontrol_new_t))
+
+static snd_kcontrol_new_t snd_hdsp_playback_mixer = HDSP_PLAYBACK_MIXER;
+static snd_kcontrol_new_t snd_hdsp_input_peak = HDSP_PEAK_INPUT;
+static snd_kcontrol_new_t snd_hdsp_output_peak = HDSP_PEAK_OUTPUT;
+static snd_kcontrol_new_t snd_hdsp_playback_peak = HDSP_PEAK_PLAYBACK;
+static snd_kcontrol_new_t snd_hdsp_input_rms = HDSP_RMS_INPUT;
+static snd_kcontrol_new_t snd_hdsp_playback_rms = HDSP_RMS_PLAYBACK;
+
+int snd_hdsp_create_controls(snd_card_t *card, hdsp_t *hdsp)
+{
+	int idx, err, limit;
+	snd_kcontrol_t *kctl;
+
+	for (idx = 0; idx < HDSP_CONTROLS; idx++) {
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_hdsp_controls[idx], hdsp))) < 0)
+			return err;
+		if (idx == 1)	/* IEC958 (S/PDIF) Stream */
+			hdsp->spdif_ctl = kctl;
+	}
+
+	if (hdsp->type == Digiface) {
+		limit = DIGIFACE_SS_CHANNELS;
+	} else {
+		limit = MULTIFACE_SS_CHANNELS;
+	}
+
+	/* The index values are one greater than the channel ID so that alsamixer
+	   will display them correctly. We want to use the index for fast lookup
+	   of the relevant channel, but if we use it at all, most ALSA software
+	   does the wrong thing with it ...
+	*/
+
+	snd_hdsp_playback_mixer.name = "Chn";
+	snd_hdsp_input_peak.name = "Input Peak";
+	snd_hdsp_output_peak.name = "Output Peak";
+	snd_hdsp_playback_peak.name = "Playback Peak";
+	snd_hdsp_playback_rms.name = "Playback RMS";
+	snd_hdsp_input_rms.name = "Input RMS";
+
+	for (idx = 0; idx < limit; ++idx) {
+		snd_hdsp_playback_mixer.index = idx+1;
+		if ((err = snd_ctl_add (card, kctl = snd_ctl_new1(&snd_hdsp_playback_mixer, hdsp)))) {
+			return err;
+		}
+		snd_hdsp_input_peak.index = idx+1;
+		if ((err = snd_ctl_add (card, kctl = snd_ctl_new1(&snd_hdsp_input_peak, hdsp)))) {
+			return err;
+		}
+		snd_hdsp_output_peak.index = idx+1;
+		if ((err = snd_ctl_add (card, kctl = snd_ctl_new1(&snd_hdsp_output_peak, hdsp)))) {
+			return err;
+		}
+		snd_hdsp_playback_peak.index = idx+1;
+		if ((err = snd_ctl_add (card, kctl = snd_ctl_new1(&snd_hdsp_playback_peak, hdsp)))) {
+			return err;
+		}
+		snd_hdsp_playback_rms.index = idx+1;
+		if ((err = snd_ctl_add (card, kctl = snd_ctl_new1(&snd_hdsp_playback_rms, hdsp)))) {
+			return err;
+		}
+		snd_hdsp_input_rms.index = idx+1;
+		if ((err = snd_ctl_add (card, kctl = snd_ctl_new1(&snd_hdsp_input_rms, hdsp)))) {
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+/*------------------------------------------------------------
+   /proc interface 
+ ------------------------------------------------------------*/
+
+static void
+snd_hdsp_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	hdsp_t *hdsp = (hdsp_t *) entry->private_data;
+	unsigned int status;
+	unsigned int status2;
+	char *requested_sync_ref;
+	int x;
+
+	if (hdsp_check_for_iobox (hdsp)) {
+		return;
+	}
+
+	status = hdsp_read(hdsp, HDSP_statusRegister);
+	status2 = hdsp_read(hdsp, HDSP_status2Register);
+
+	snd_iprintf(buffer, "%s (Card #%d)\n", hdsp->card_name, hdsp->card->number + 1);
+	snd_iprintf(buffer, "Buffers: capture %p playback %p\n",
+		    hdsp->capture_buffer, hdsp->playback_buffer);
+	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
+		    hdsp->irq, hdsp->port, hdsp->iobase);
+	snd_iprintf(buffer, "Control register: 0x%x\n", hdsp->control_register);
+	snd_iprintf(buffer, "Status register: 0x%x\n", status);
+	snd_iprintf(buffer, "Status2 register: 0x%x\n", status2);
+	snd_iprintf(buffer, "FIFO status: %d\n", hdsp_read(hdsp, HDSP_fifoStatus) & 0xff);
+
+	snd_iprintf(buffer, "MIDI1 Output status: 0x%x\n", hdsp_read(hdsp, HDSP_midiStatusOut0));
+	snd_iprintf(buffer, "MIDI1 Input status: 0x%x\n", hdsp_read(hdsp, HDSP_midiStatusIn0));
+	snd_iprintf(buffer, "MIDI2 Output status: 0x%x\n", hdsp_read(hdsp, HDSP_midiStatusOut1));
+	snd_iprintf(buffer, "MIDI2 Input status: 0x%x\n", hdsp_read(hdsp, HDSP_midiStatusIn1));
+
+	snd_iprintf(buffer, "\n");
+
+	x = 1 << (6 + hdsp_decode_latency(hdsp->control_register & HDSP_LatencyMask));
+
+	snd_iprintf(buffer, "Latency: %d samples (2 periods of %lu bytes)\n", x, (unsigned long) hdsp->period_bytes);
+	snd_iprintf(buffer, "Hardware pointer (frames): %ld\n", hdsp_hw_pointer(hdsp));
+	snd_iprintf(buffer, "Passthru: %s\n", hdsp->passthru ? "yes" : "no");
+	snd_iprintf(buffer, "Line out: %s\n", (hdsp->control_register & HDSP_LineOut) ? "on" : "off");
+
+	snd_iprintf(buffer, "Firmware version: %d\n", (status2&HDSP_version0)|(status2&HDSP_version1)<<1|(status2&HDSP_version2)<<2);
+
+	switch (hdsp_sync_pref (hdsp)) {
+	case HDSP_SYNC_FROM_WORD:
+		requested_sync_ref = "Word";
+		break;
+	case HDSP_SYNC_FROM_ADAT_SYNC:
+		requested_sync_ref = "ADAT Sync";
+		break;
+	case HDSP_SYNC_FROM_SPDIF:
+		requested_sync_ref = "SPDIF";
+		break;
+	case HDSP_SYNC_FROM_ADAT1:
+		requested_sync_ref = "ADAT1";
+		break;
+	case HDSP_SYNC_FROM_ADAT2:
+		requested_sync_ref = "ADAT2";
+		break;
+	case HDSP_SYNC_FROM_ADAT3:
+		requested_sync_ref = "ADAT3";
+		break;
+	case HDSP_SYNC_FROM_SELF:
+	default:
+		requested_sync_ref = "Master";
+		break;
+	}
+
+	if ((hdsp->control_register & HDSP_ClockModeMaster)) {
+		snd_iprintf (buffer, "Sync reference: %s/Master (chosen)\n", requested_sync_ref);
+	} else if (hdsp_system_sample_rate(hdsp) == 0) {
+		snd_iprintf (buffer, "Sync reference: %s/Master (forced)\n", requested_sync_ref);
+	} else {
+		switch (status2 & HDSP_SelSyncRefMask) {
+		case HDSP_SelSyncRef_ADAT1:
+			snd_iprintf (buffer, "Sync reference: %s/ADAT1\n", requested_sync_ref);
+			break;
+		case HDSP_SelSyncRef_ADAT2:
+			snd_iprintf (buffer, "Sync reference: %s/ADAT2\n", requested_sync_ref);
+			break;
+		case HDSP_SelSyncRef_ADAT3:
+			snd_iprintf (buffer, "Sync reference: %s/ADAT3\n", requested_sync_ref);
+			break;
+		case HDSP_SelSyncRef_SPDIF:
+			snd_iprintf (buffer, "Sync reference: %s/SPDIF\n", requested_sync_ref);
+			break;
+		case HDSP_SelSyncRef_WORD:
+			snd_iprintf (buffer, "Sync reference: %s/WORD\n", requested_sync_ref);
+			break;
+		case HDSP_SelSyncRef_ADAT_SYNC:
+			snd_iprintf (buffer, "Sync reference: %s/ADAT Sync\n", requested_sync_ref);
+			break;
+		default:
+			snd_iprintf (buffer, "Sync reference: %s/Master (fallback)\n", requested_sync_ref);
+			break;
+		}
+	}
+	snd_iprintf (buffer, "Sample rate: %d\n", hdsp_system_sample_rate(hdsp));
+
+	snd_iprintf(buffer, "\n");
+
+	switch ((hdsp->control_register & HDSP_SPDIFInputMask) >> 14) {
+	case HDSP_SPDIFIN_OPTICAL:
+		snd_iprintf(buffer, "IEC958 input: ADAT1\n");
+		break;
+	case HDSP_SPDIFIN_COAXIAL:
+		snd_iprintf(buffer, "IEC958 input: Coaxial\n");
+		break;
+	case HDSP_SPDIFIN_INTERN:
+		snd_iprintf(buffer, "IEC958 input: Internal\n");
+		break;
+	default:
+		snd_iprintf(buffer, "IEC958 input: ???\n");
+		break;
+	}
+	
+	if (hdsp->control_register & HDSP_SPDIFOpticalOut) {
+		snd_iprintf(buffer, "IEC958 output: Coaxial & ADAT1\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 output: Coaxial only\n");
+	}
+
+	if (hdsp->control_register & HDSP_SPDIFProfessional) {
+		snd_iprintf(buffer, "IEC958 quality: Professional\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 quality: Consumer\n");
+	}
+
+	if (hdsp->control_register & HDSP_SPDIFEmphasis) {
+		snd_iprintf(buffer, "IEC958 emphasis: on\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 emphasis: off\n");
+	}
+
+	if (hdsp->control_register & HDSP_SPDIFNonAudio) {
+		snd_iprintf(buffer, "IEC958 NonAudio: on\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 NonAudio: off\n");
+	}
+
+	snd_iprintf(buffer, "\n");
+
+	if ((x = hdsp_spdif_sample_rate (hdsp)) != 0) {
+		snd_iprintf (buffer, "IEC958 sample rate: %d\n", x);
+	} else {
+		snd_iprintf (buffer, "IEC958 sample rate: Error flag set\n");
+	}
+
+	snd_iprintf(buffer, "\n");
+
+	/* Sync Check */
+	x = status & HDSP_Sync0;
+	if (status & HDSP_Lock0) {
+		snd_iprintf(buffer, "ADAT1: %s\n", x ? "Sync" : "Lock");
+	} else {
+		snd_iprintf(buffer, "ADAT1: No Lock\n");
+	}
+
+	x = status & HDSP_Sync1;
+	if (status & HDSP_Lock1) {
+		snd_iprintf(buffer, "ADAT2: %s\n", x ? "Sync" : "Lock");
+	} else {
+		snd_iprintf(buffer, "ADAT2: No Lock\n");
+	}
+
+	if (hdsp->type == Digiface) {
+		x = status & HDSP_Sync2;
+		if (status & HDSP_Lock2) {
+			snd_iprintf(buffer, "ADAT3: %s\n", x ? "Sync" : "Lock");
+		} else {
+			snd_iprintf(buffer, "ADAT3: No Lock\n");
+		}
+	}
+
+	snd_iprintf(buffer, "\n");
+
+#if 0
+	for (x = 0; x < 26; x++) {
+		unsigned int val = hdsp_read (hdsp, HDSP_inputPeakLevel + (4 * x));
+		snd_iprintf (buffer, "%d: input peak = %d overs = %d\n", x, val&0xffffff00, val&0xf);
+	}
+#endif
+}
+
+static void __devinit snd_hdsp_proc_init(hdsp_t *hdsp)
+{
+	snd_info_entry_t *entry;
+
+	if ((entry = snd_info_create_card_entry(hdsp->card, "hdsp", hdsp->card->proc_root)) !=
+	    NULL) {
+		entry->content = SNDRV_INFO_CONTENT_TEXT;
+		entry->private_data = hdsp;
+		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->c.text.read_size = 256;
+		entry->c.text.read = snd_hdsp_proc_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	hdsp->proc_entry = entry;
+}
+
+static void snd_hdsp_proc_done(hdsp_t *hdsp)
+{
+	if (hdsp->proc_entry) {
+		snd_info_unregister(hdsp->proc_entry);
+		hdsp->proc_entry = NULL;
+	}
+}
+
+static void snd_hdsp_free_buffers(hdsp_t *hdsp)
+{
+	if (hdsp->capture_buffer_unaligned) {
+#ifndef HDSP_PREALLOCATE_MEMORY
+		snd_free_pci_pages(hdsp->pci,
+				   HDSP_DMA_AREA_BYTES,
+				   hdsp->capture_buffer_unaligned,
+				   hdsp->capture_buffer_addr);
+#else
+		snd_hammerfall_free_buffer(hdsp->pci, hdsp->capture_buffer_unaligned);
+#endif
+	}
+
+	if (hdsp->playback_buffer_unaligned) {
+#ifndef HDSP_PREALLOCATE_MEMORY
+		snd_free_pci_pages(hdsp->pci,
+				   HDSP_DMA_AREA_BYTES,
+				   hdsp->playback_buffer_unaligned,
+				   hdsp->playback_buffer_addr);
+#else
+		snd_hammerfall_free_buffer(hdsp->pci, hdsp->playback_buffer_unaligned);
+#endif
+	}
+}
+
+static int __devinit snd_hdsp_initialize_memory(hdsp_t *hdsp)
+{
+	void *pb, *cb;
+	dma_addr_t pb_addr, cb_addr;
+	unsigned long pb_bus, cb_bus;
+
+#ifndef HDSP_PREALLOCATE_MEMORY
+	cb = snd_malloc_pci_pages(hdsp->pci, HDSP_DMA_AREA_BYTES, &cb_addr);
+	pb = snd_malloc_pci_pages(hdsp->pci, HDSP_DMA_AREA_BYTES, &pb_addr);
+#else
+	cb = snd_hammerfall_get_buffer(hdsp->pci, &cb_addr);
+	pb = snd_hammerfall_get_buffer(hdsp->pci, &pb_addr);
+#endif
+
+	if (cb == 0 || pb == 0) {
+		if (cb) {
+#ifdef HDSP_PREALLOCATE_MEMORY
+			snd_hammerfall_free_buffer(hdsp->pci, cb);
+#else
+			snd_free_pci_pages(hdsp->pci, HDSP_DMA_AREA_BYTES, cb, cb_addr);
+#endif
+		}
+		if (pb) {
+#ifdef HDSP_PREALLOCATE_MEMORY
+			snd_hammerfall_free_buffer(hdsp->pci, pb);
+#else
+			snd_free_pci_pages(hdsp->pci, HDSP_DMA_AREA_BYTES, pb, pb_addr);
+#endif
+		}
+
+		printk(KERN_ERR "%s: no buffers available\n", hdsp->card_name);
+		return -ENOMEM;
+	}
+
+	/* save raw addresses for use when freeing memory later */
+
+	hdsp->capture_buffer_unaligned = cb;
+	hdsp->playback_buffer_unaligned = pb;
+	hdsp->capture_buffer_addr = cb_addr;
+	hdsp->playback_buffer_addr = pb_addr;
+
+	/* Align to bus-space 64K boundary */
+
+	cb_bus = (cb_addr + 0xFFFF) & ~0xFFFFl;
+	pb_bus = (pb_addr + 0xFFFF) & ~0xFFFFl;
+
+	/* Tell the card where it is */
+
+	hdsp_write(hdsp, HDSP_inputBufferAddress, cb_bus);
+	hdsp_write(hdsp, HDSP_outputBufferAddress, pb_bus);
+
+	hdsp->capture_buffer = cb + (cb_bus - cb_addr);
+	hdsp->playback_buffer = pb + (pb_bus - pb_addr);
+
+	return 0;
+}
+
+static void snd_hdsp_set_defaults(hdsp_t *hdsp)
+{
+	unsigned int i;
+
+	/* ASSUMPTION: hdsp->lock is either held, or
+	   there is no need to hold it (e.g. during module
+	   initalization).
+	 */
+
+	/* set defaults:
+
+	   SPDIF Input via Coax 
+	   Master clock mode
+	   maximum latency (7 => 2^7 = 8192 samples, 64Kbyte buffer,
+	                    which implies 2 4096 sample, 32Kbyte periods).
+           Enable line out.			    
+	 */
+
+	hdsp->control_register = HDSP_ClockModeMaster | 
+		                 HDSP_SPDIFInputCoaxial | 
+		                 hdsp_encode_latency(7) | 
+		                 HDSP_LineOut;
+
+	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
+	hdsp_reset_hw_pointer(hdsp);
+	hdsp_compute_period_size(hdsp);
+
+	/* silence everything */
+	
+	for (i = 0; i < HDSP_MATRIX_MIXER_SIZE; ++i) {
+		hdsp->mixer_matrix[i] = MINUS_INFINITY_GAIN;
+	}
+
+	for (i = 0; i < 2048; i++)
+		hdsp_write_gain (hdsp, i, MINUS_INFINITY_GAIN);
+
+	hdsp->passthru = 0;
+
+	/* set a default rate so that the channel map is set up.
+	 */
+
+	hdsp_set_rate(hdsp, 48000);
+}
+
+void snd_hdsp_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	hdsp_t *hdsp = (hdsp_t *) dev_id;
+	unsigned int status;
+	int audio;
+	int midi0;
+	int midi1;
+	unsigned int midi0status;
+	unsigned int midi1status;
+
+	status = hdsp_read(hdsp, HDSP_statusRegister);
+
+	audio = status & HDSP_audioIRQPending;
+	midi0 = status & HDSP_midi0IRQPending;
+	midi1 = status & HDSP_midi1IRQPending;
+
+	if (!audio && !midi0 && !midi1) {
+		return;
+	}
+
+	hdsp_write(hdsp, HDSP_interruptConfirmation, 0);
+
+	midi0status = hdsp_read (hdsp, HDSP_midiStatusIn0) & 0xff;
+	midi1status = hdsp_read (hdsp, HDSP_midiStatusIn1) & 0xff;
+
+	if (audio) {
+		if (hdsp->capture_substream) {
+			snd_pcm_period_elapsed(hdsp->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);
+		}
+		
+		if (hdsp->playback_substream) {
+			snd_pcm_period_elapsed(hdsp->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream);
+		}
+	}
+
+	/* note: snd_hdsp_midi_input_read() calls output_write() because
+	   output is not interrupt-driven ...
+	*/
+
+	if (midi0status)
+		snd_hdsp_midi_input_read (&hdsp->midi[0]);
+	if (midi1status)
+		snd_hdsp_midi_input_read (&hdsp->midi[1]);
+}
+
+static snd_pcm_uframes_t snd_hdsp_hw_pointer(snd_pcm_substream_t *substream)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	return hdsp_hw_pointer(hdsp);
+}
+
+static char *hdsp_channel_buffer_location(hdsp_t *hdsp,
+					     int stream,
+					     int channel)
+
+{
+	int mapped_channel;
+
+        snd_assert(channel >= 0 || channel < HDSP_MAX_CHANNELS, return NULL);
+        
+	if ((mapped_channel = hdsp->channel_map[channel]) < 0) {
+		return NULL;
+	}
+	
+	if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+		return hdsp->capture_buffer + (mapped_channel * HDSP_CHANNEL_BUFFER_BYTES);
+	} else {
+		return hdsp->playback_buffer + (mapped_channel * HDSP_CHANNEL_BUFFER_BYTES);
+	}
+}
+
+static int snd_hdsp_playback_copy(snd_pcm_substream_t *substream, int channel,
+				  snd_pcm_uframes_t pos, void *src, snd_pcm_uframes_t count)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	snd_assert(pos + count <= HDSP_CHANNEL_BUFFER_BYTES / 4, return -EINVAL);
+
+	channel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	copy_from_user(channel_buf + pos * 4, src, count * 4);
+	return count;
+}
+
+static int snd_hdsp_capture_copy(snd_pcm_substream_t *substream, int channel,
+				 snd_pcm_uframes_t pos, void *dst, snd_pcm_uframes_t count)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	snd_assert(pos + count <= HDSP_CHANNEL_BUFFER_BYTES / 4, return -EINVAL);
+
+	channel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	copy_to_user(dst, channel_buf + pos * 4, count * 4);
+	return count;
+}
+
+static int snd_hdsp_hw_silence(snd_pcm_substream_t *substream, int channel,
+				  snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	channel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	memset(channel_buf + pos * 4, 0, count * 4);
+	return count;
+}
+
+static int snd_hdsp_reset(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	snd_pcm_substream_t *other;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		other = hdsp->capture_substream;
+	else
+		other = hdsp->playback_substream;
+	if (hdsp->running)
+		runtime->status->hw_ptr = hdsp_hw_pointer(hdsp);
+	else
+		runtime->status->hw_ptr = 0;
+	if (other) {
+		snd_pcm_substream_t *s = substream;
+		snd_pcm_runtime_t *oruntime = other->runtime;
+		do {
+			s = s->link_next;
+			if (s == other) {
+				oruntime->status->hw_ptr = runtime->status->hw_ptr;
+				break;
+			}
+		} while (s != substream);
+	}
+	return 0;
+}
+
+static int snd_hdsp_hw_params(snd_pcm_substream_t *substream,
+				 snd_pcm_hw_params_t *params)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	int err;
+	pid_t this_pid;
+	pid_t other_pid;
+
+	if (hdsp_check_for_iobox (hdsp)) {
+		return -EIO;
+	}
+
+	spin_lock_irq(&hdsp->lock);
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		hdsp->control_register &= ~(HDSP_SPDIFProfessional | HDSP_SPDIFNonAudio | HDSP_SPDIFEmphasis);
+		hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register |= hdsp->creg_spdif_stream);
+		this_pid = hdsp->playback_pid;
+		other_pid = hdsp->capture_pid;
+	} else {
+		this_pid = hdsp->capture_pid;
+		other_pid = hdsp->playback_pid;
+	}
+
+	if ((other_pid > 0) && (this_pid != other_pid)) {
+
+		/* The other stream is open, and not by the same
+		   task as this one. Make sure that the parameters
+		   that matter are the same.
+		 */
+
+		if (params_rate(params) != hdsp_system_sample_rate(hdsp)) {
+			spin_unlock_irq(&hdsp->lock);
+			_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);
+			return -EBUSY;
+		}
+
+		if (params_period_size(params) != hdsp->period_bytes / 4) {
+			spin_unlock_irq(&hdsp->lock);
+			_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+			return -EBUSY;
+		}
+
+		/* We're fine. */
+
+		spin_unlock_irq(&hdsp->lock);
+ 		return 0;
+
+	} else {
+		spin_unlock_irq(&hdsp->lock);
+	}
+
+	/* how to make sure that the rate matches an externally-set one ?
+	 */
+
+	if ((err = hdsp_set_rate(hdsp, params_rate(params))) < 0) {
+		_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);
+		return err;
+	}
+
+	if ((err = hdsp_set_interrupt_interval(hdsp, params_period_size(params))) < 0) {
+		_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+		return err;
+	}
+
+	return 0;
+}
+
+static int snd_hdsp_channel_info(snd_pcm_substream_t *substream,
+				    snd_pcm_channel_info_t *info)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	int chn;
+
+	snd_assert(info->channel < HDSP_MAX_CHANNELS, return -EINVAL);
+
+	if ((chn = hdsp->channel_map[info->channel]) < 0) {
+		return -EINVAL;
+	}
+
+	info->offset = chn * HDSP_CHANNEL_BUFFER_BYTES;
+	info->first = 0;
+	info->step = 32;
+	return 0;
+}
+
+static int snd_hdsp_ioctl(snd_pcm_substream_t *substream,
+			     unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case SNDRV_PCM_IOCTL1_RESET:
+	{
+		return snd_hdsp_reset(substream);
+	}
+	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
+	{
+		snd_pcm_channel_info_t *info = arg;
+		return snd_hdsp_channel_info(substream, info);
+	}
+	default:
+		break;
+	}
+
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+static int snd_hdsp_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	snd_pcm_substream_t *other;
+	int running;
+	
+	if (hdsp_check_for_iobox (hdsp)) {
+		return -EIO;
+	}
+
+	spin_lock(&hdsp->lock);
+	running = hdsp->running;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		running |= 1 << substream->stream;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		running &= ~(1 << substream->stream);
+		break;
+	default:
+		snd_BUG();
+		spin_unlock(&hdsp->lock);
+		return -EINVAL;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		other = hdsp->capture_substream;
+	else
+		other = hdsp->playback_substream;
+
+	if (other) {
+		snd_pcm_substream_t *s = substream;
+		do {
+			s = s->link_next;
+			if (s == other) {
+				snd_pcm_trigger_done(s, substream);
+				if (cmd == SNDRV_PCM_TRIGGER_START)
+					running |= 1 << s->stream;
+				else
+					running &= ~(1 << s->stream);
+				goto _ok;
+			}
+		} while (s != substream);
+		if (cmd == SNDRV_PCM_TRIGGER_START) {
+			if (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) &&
+			    substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+				hdsp_silence_playback(hdsp);
+		} else {
+			if (running &&
+			    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				hdsp_silence_playback(hdsp);
+		}
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+				hdsp_silence_playback(hdsp);
+	}
+ _ok:
+	snd_pcm_trigger_done(substream, substream);
+	if (!hdsp->running && running)
+		hdsp_start_audio(hdsp);
+	else if (hdsp->running && !running)
+		hdsp_stop_audio(hdsp);
+	hdsp->running = running;
+	spin_unlock(&hdsp->lock);
+
+	return 0;
+}
+
+static int snd_hdsp_prepare(snd_pcm_substream_t *substream)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	int result = 0;
+
+	if (hdsp_check_for_iobox (hdsp)) {
+		return -EIO;
+	}
+
+	spin_lock_irq(&hdsp->lock);
+	if (!hdsp->running)
+		hdsp_reset_hw_pointer(hdsp);
+	spin_unlock_irq(&hdsp->lock);
+	return result;
+}
+
+static snd_pcm_hardware_t snd_hdsp_playback_subinfo =
+{
+	info:			(SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_NONINTERLEAVED |
+				 SNDRV_PCM_INFO_SYNC_START |
+				 SNDRV_PCM_INFO_DOUBLE),
+	formats:		SNDRV_PCM_FMTBIT_S32_LE,
+	rates:			(SNDRV_PCM_RATE_32000 | 
+				 SNDRV_PCM_RATE_44100 | 
+				 SNDRV_PCM_RATE_48000 | 
+				 SNDRV_PCM_RATE_64000 | 
+				 SNDRV_PCM_RATE_88200 | 
+				 SNDRV_PCM_RATE_96000),
+	rate_min:		32000,
+	rate_max:		96000,
+	channels_min:		10,
+	channels_max:		HDSP_MAX_CHANNELS,
+	buffer_bytes_max:	1024*1024,
+	period_bytes_min:	1,
+	period_bytes_max:	1024*1024,
+	periods_min:		2,
+	periods_max:		2,
+	fifo_size:		0,
+};
+
+static snd_pcm_hardware_t snd_hdsp_capture_subinfo =
+{
+	info:			(SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_NONINTERLEAVED |
+				 SNDRV_PCM_INFO_SYNC_START),
+	formats:		SNDRV_PCM_FMTBIT_S32_LE,
+	rates:			(SNDRV_PCM_RATE_32000 |
+				 SNDRV_PCM_RATE_44100 | 
+				 SNDRV_PCM_RATE_48000 | 
+				 SNDRV_PCM_RATE_64000 | 
+				 SNDRV_PCM_RATE_88200 | 
+				 SNDRV_PCM_RATE_96000),
+	rate_min:		32000,
+	rate_max:		96000,
+	channels_min:		10,
+	channels_max:		HDSP_MAX_CHANNELS,
+	buffer_bytes_max:	1024*1024,
+	period_bytes_min:	1,
+	period_bytes_max:	1024*1024,
+	periods_min:		2,
+	periods_max:		2,
+	fifo_size:		0,
+};
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+#define PERIOD_SIZES sizeof(period_sizes) / sizeof(period_sizes[0])
+
+static snd_pcm_hw_constraint_list_t hw_constraints_period_sizes = {
+	count: PERIOD_SIZES,
+	list: period_sizes,
+	mask: 0
+};
+
+static int snd_hdsp_hw_rule_channels(snd_pcm_hw_params_t *params,
+					snd_pcm_hw_rule_t *rule)
+{
+	hdsp_t *hdsp = rule->private;
+	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	unsigned int list[2] = { hdsp->ds_channels, hdsp->ss_channels };
+	return snd_interval_list(c, 2, list, 0);
+}
+
+static int snd_hdsp_hw_rule_channels_rate(snd_pcm_hw_params_t *params,
+					     snd_pcm_hw_rule_t *rule)
+{
+	hdsp_t *hdsp = rule->private;
+	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	snd_interval_t *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	if (r->min > 48000) {
+		snd_interval_t t = {
+			min: hdsp->ds_channels,
+			max: hdsp->ds_channels,
+			integer: 1,
+		};
+		return snd_interval_refine(c, &t);
+	} else if (r->max < 88200) {
+		snd_interval_t t = {
+			min: hdsp->ss_channels,
+			max: hdsp->ss_channels,
+			integer: 1,
+		};
+		return snd_interval_refine(c, &t);
+	}
+	return 0;
+}
+
+static int snd_hdsp_hw_rule_rate_channels(snd_pcm_hw_params_t *params,
+					     snd_pcm_hw_rule_t *rule)
+{
+	hdsp_t *hdsp = rule->private;
+	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	snd_interval_t *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	if (c->min >= hdsp->ss_channels) {
+		snd_interval_t t = {
+			min: 44100,
+			max: 48000,
+			integer: 1,
+		};
+		return snd_interval_refine(r, &t);
+	} else if (c->max <= hdsp->ds_channels) {
+		snd_interval_t t = {
+			min: 88200,
+			max: 96000,
+			integer: 1,
+		};
+		return snd_interval_refine(r, &t);
+	}
+	return 0;
+}
+
+static int snd_hdsp_playback_open(snd_pcm_substream_t *substream)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	unsigned long flags;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if (hdsp_check_for_iobox (hdsp)) {
+		return -EIO;
+	}
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+
+	snd_pcm_set_sync(substream);
+
+        runtime->hw = snd_hdsp_playback_subinfo;
+	runtime->dma_area = hdsp->playback_buffer;
+	runtime->dma_bytes = HDSP_DMA_AREA_BYTES;
+
+	if (hdsp->capture_substream == NULL) {
+		hdsp_stop_audio(hdsp);
+		hdsp_set_thru(hdsp, -1, 0);
+	}
+
+	hdsp->playback_pid = current->pid;
+	hdsp->playback_substream = substream;
+
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_period_sizes);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			     snd_hdsp_hw_rule_channels, hdsp,
+			     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			     snd_hdsp_hw_rule_channels_rate, hdsp,
+			     SNDRV_PCM_HW_PARAM_RATE, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			     snd_hdsp_hw_rule_rate_channels, hdsp,
+			     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+
+	hdsp->creg_spdif_stream = hdsp->creg_spdif;
+	hdsp->spdif_ctl->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(hdsp->card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO, &hdsp->spdif_ctl->id);
+	return 0;
+}
+
+static int snd_hdsp_playback_release(snd_pcm_substream_t *substream)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	unsigned long flags;
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+
+	hdsp->playback_pid = -1;
+	hdsp->playback_substream = NULL;
+
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+
+	hdsp->spdif_ctl->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(hdsp->card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO, &hdsp->spdif_ctl->id);
+	return 0;
+}
+
+
+static int snd_hdsp_capture_open(snd_pcm_substream_t *substream)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	unsigned long flags;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if (hdsp_check_for_iobox (hdsp)) {
+		return -EIO;
+	}
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+
+	snd_pcm_set_sync(substream);
+
+	runtime->hw = snd_hdsp_capture_subinfo;
+	runtime->dma_area = hdsp->capture_buffer;
+	runtime->dma_bytes = HDSP_DMA_AREA_BYTES;
+
+	if (hdsp->playback_substream == NULL) {
+		hdsp_stop_audio(hdsp);
+		hdsp_set_thru(hdsp, -1, 0);
+	}
+
+	hdsp->capture_pid = current->pid;
+	hdsp->capture_substream = substream;
+
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_period_sizes);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			     snd_hdsp_hw_rule_channels, hdsp,
+			     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			     snd_hdsp_hw_rule_channels_rate, hdsp,
+			     SNDRV_PCM_HW_PARAM_RATE, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			     snd_hdsp_hw_rule_rate_channels, hdsp,
+			     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	return 0;
+}
+
+static int snd_hdsp_capture_release(snd_pcm_substream_t *substream)
+{
+	hdsp_t *hdsp = _snd_pcm_substream_chip(substream);
+	unsigned long flags;
+
+	spin_lock_irqsave(&hdsp->lock, flags);
+
+	hdsp->capture_pid = -1;
+	hdsp->capture_substream = NULL;
+
+	spin_unlock_irqrestore(&hdsp->lock, flags);
+	return 0;
+}
+
+static snd_pcm_ops_t snd_hdsp_playback_ops = {
+	open:		snd_hdsp_playback_open,
+	close:		snd_hdsp_playback_release,
+	ioctl:		snd_hdsp_ioctl,
+	hw_params:	snd_hdsp_hw_params,
+	prepare:	snd_hdsp_prepare,
+	trigger:	snd_hdsp_trigger,
+	pointer:	snd_hdsp_hw_pointer,
+	copy:		snd_hdsp_playback_copy,
+	silence:	snd_hdsp_hw_silence,
+};
+
+static snd_pcm_ops_t snd_hdsp_capture_ops = {
+	open:		snd_hdsp_capture_open,
+	close:		snd_hdsp_capture_release,
+	ioctl:		snd_hdsp_ioctl,
+	hw_params:	snd_hdsp_hw_params,
+	prepare:	snd_hdsp_prepare,
+	trigger:	snd_hdsp_trigger,
+	pointer:	snd_hdsp_hw_pointer,
+	copy:		snd_hdsp_capture_copy,
+};
+
+static int __devinit snd_hdsp_create_pcm(snd_card_t *card,
+					 hdsp_t *hdsp)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(card, hdsp->card_name, 0, 1, 1, &pcm)) < 0)
+		return err;
+
+	hdsp->pcm = pcm;
+	pcm->private_data = hdsp;
+	strcpy(pcm->name, hdsp->card_name);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_hdsp_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_hdsp_capture_ops);
+
+	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+
+	return 0;
+}
+
+static int __devinit snd_hdsp_initialize_firmware (hdsp_t *hdsp)
+{
+	int i;
+	int status_reg;
+	u32 *firmware_ptr;
+
+	if (hdsp_check_for_iobox (hdsp)) {
+		return -EIO;
+	}
+
+	if (hdsp_fifo_wait (hdsp, 0, 100)) {
+		return -EIO;
+	}
+	
+	/* enable all channels */
+
+	for (i = 0; i < HDSP_MAX_CHANNELS; ++i) {
+		hdsp_write (hdsp, HDSP_inputEnable + (4 * i), 1);
+		hdsp_write (hdsp, HDSP_outputEnable + (4 * i), 1);
+	}
+
+	status_reg = hdsp_read (hdsp, HDSP_statusRegister);
+
+	if ((status_reg & HDSP_DllError) == 0) {
+
+		/* i/o box is connected, firmware already loaded */
+
+		if (hdsp_read (hdsp, HDSP_status2Register) & HDSP_version1) {
+			hdsp->type = Multiface;
+			hdsp->card_name = "RME Hammerfall DSP (Multiface)";
+			hdsp->ss_channels = MULTIFACE_SS_CHANNELS;
+			hdsp->ds_channels = MULTIFACE_DS_CHANNELS;
+		} else {
+			hdsp->type = Digiface;
+			hdsp->card_name = "RME Hammerfall DSP (Digiface)";
+			hdsp->ss_channels = DIGIFACE_SS_CHANNELS;
+			hdsp->ds_channels = DIGIFACE_DS_CHANNELS;
+		}
+
+	} else {
+
+		/* firmware not loaded, but i/o box is connected */
+		
+		hdsp_write (hdsp, HDSP_jtagReg, HDSP_PROGRAM);
+		hdsp_write (hdsp, HDSP_fifoData, 0);
+		hdsp_fifo_wait (hdsp, 0, HDSP_SHORT_WAIT);
+
+		hdsp_write (hdsp, HDSP_jtagReg, HDSP_S_LOAD);
+		hdsp_write (hdsp, HDSP_fifoData, 0);
+
+		if (hdsp_fifo_wait (hdsp, 0, HDSP_SHORT_WAIT) < 0) {
+			printk ("looks like a multiface\n");
+			hdsp->type = Multiface;
+			hdsp->card_name = "RME Hammerfall DSP (Multiface)";
+			hdsp_write (hdsp, HDSP_jtagReg, HDSP_VERSION_BIT);
+			hdsp_write (hdsp, HDSP_jtagReg, HDSP_S_LOAD);
+			hdsp_fifo_wait (hdsp, 0, HDSP_SHORT_WAIT);
+		} else {
+			printk ("looks like a digiface\n");
+			hdsp->type = Digiface;
+			hdsp->card_name = "RME Hammerfall DSP (Digiface)";
+		} 
+
+		hdsp_write (hdsp, HDSP_jtagReg, HDSP_S_PROGRAM);
+		hdsp_write (hdsp, HDSP_fifoData, 0);
+		
+		if (hdsp_fifo_wait (hdsp, 0, HDSP_LONG_WAIT) < 0) {
+			snd_printk ("timeout waiting for download preparation\n");
+			return -EIO;
+		}
+		
+		hdsp_write (hdsp, HDSP_jtagReg, HDSP_S_LOAD);
+		
+		if (hdsp->type == Digiface) {
+			firmware_ptr = digiface_firmware;
+		} else {
+			firmware_ptr = multiface_firmware;
+		}
+		
+		for (i = 0; i < 24413; ++i) {
+			hdsp_write(hdsp, HDSP_fifoData, firmware_ptr[i]);
+			if (hdsp_fifo_wait (hdsp, 127, HDSP_LONG_WAIT)) {
+				snd_printk ("timeout during firmware loading\n");
+				return -EIO;
+			}
+		}
+		
+		if (hdsp_fifo_wait (hdsp, 3, HDSP_LONG_WAIT)) {
+			snd_printk ("timeout at end of firmware loading\n");
+			return -EIO;
+		}
+
+	}
+
+	
+	snd_hdsp_flush_midi_input (hdsp, 0);
+	snd_hdsp_flush_midi_input (hdsp, 1);
+
+#ifdef SNDRV_BIG_ENDIAN
+	hdsp_write(hdsp, HDSP_jtagReg, HDSP_BIGENDIAN_MODE);
+#endif
+
+	return 0;
+}
+
+static int __devinit snd_hdsp_create(snd_card_t *card,
+				     hdsp_t *hdsp,
+				     int precise_ptr)
+{
+	struct pci_dev *pci = hdsp->pci;
+	int err;
+	unsigned short rev;
+
+	hdsp->irq = -1;
+	hdsp->midi[0].rmidi = 0;
+	hdsp->midi[1].rmidi = 0;
+	hdsp->midi[0].input = 0;
+	hdsp->midi[1].input = 0;
+	hdsp->midi[0].output = 0;
+	hdsp->midi[1].output = 0;
+	spin_lock_init(&hdsp->midi[0].lock);
+	spin_lock_init(&hdsp->midi[1].lock);
+	hdsp->iobase = 0;
+	hdsp->res_port = 0;
+
+	hdsp->card = card;
+	
+	spin_lock_init(&hdsp->lock);
+
+	pci_read_config_word(hdsp->pci, PCI_CLASS_REVISION, &rev);
+	strcpy(card->driver, "H-DSP");
+	strcpy(card->mixername, "Xilinx FPGA");
+	
+	switch (rev & 0xff) {
+	case 0xa:
+		/* hdsp_initialize_firmware() will reset this */
+		hdsp->card_name = "RME Hammerfall DSP";
+		break;
+
+	default:
+		return -ENODEV;
+	}
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	pci_set_master(hdsp->pci);
+
+	hdsp->port = pci_resource_start(pci, 0);
+
+	if ((hdsp->res_port = request_mem_region(hdsp->port, HDSP_IO_EXTENT, "hdsp")) == NULL) {
+		snd_printk("unable to grab memory region 0x%lx-0x%lx\n", hdsp->port, hdsp->port + HDSP_IO_EXTENT - 1);
+		return -EBUSY;
+	}
+
+	if ((hdsp->iobase = (unsigned long) ioremap_nocache(hdsp->port, HDSP_IO_EXTENT)) == 0) {
+		snd_printk("unable to remap region 0x%lx-0x%lx\n", hdsp->port, hdsp->port + HDSP_IO_EXTENT - 1);
+		return -EBUSY;
+	}
+
+	if (request_irq(pci->irq, snd_hdsp_interrupt, SA_INTERRUPT|SA_SHIRQ, "hdsp", (void *)hdsp)) {
+		snd_printk("unable to use IRQ %d\n", pci->irq);
+		return -EBUSY;
+	}
+
+	hdsp->irq = pci->irq;
+	hdsp->precise_ptr = precise_ptr;
+
+	if ((err = snd_hdsp_initialize_memory(hdsp)) < 0) {
+		return err;
+	}
+
+	if ((err = snd_hdsp_initialize_firmware(hdsp)) < 0) {
+		return err;
+	}
+
+	if ((err = snd_hdsp_create_pcm(card, hdsp)) < 0) {
+		return err;
+	}
+
+	if ((err = snd_hdsp_create_midi(card, hdsp, 0)) < 0) {
+		return err;
+	}
+
+	if ((err = snd_hdsp_create_midi(card, hdsp, 1)) < 0) {
+		return err;
+	}
+
+	if ((err = snd_hdsp_create_controls(card, hdsp)) < 0) {
+		return err;
+	}
+
+	snd_hdsp_proc_init(hdsp);
+
+	hdsp->last_spdif_sample_rate = -1;
+	hdsp->last_adat_sample_rate = -1;
+	hdsp->playback_pid = -1;
+	hdsp->capture_pid = -1;
+	hdsp->capture_substream = NULL;
+	hdsp->playback_substream = NULL;
+
+	snd_hdsp_set_defaults(hdsp);
+
+	return 0;
+}
+
+static int snd_hdsp_free(hdsp_t *hdsp)
+{
+	/* stop the audio, and cancel all interrupts */
+	hdsp->control_register &= ~(HDSP_Start|HDSP_AudioInterruptEnable|HDSP_Midi0InterruptEnable|HDSP_Midi1InterruptEnable);
+	hdsp_write (hdsp, HDSP_controlRegister, hdsp->control_register);
+
+	if (hdsp->irq >= 0)
+		free_irq(hdsp->irq, (void *)hdsp);
+
+	snd_hdsp_proc_done(hdsp);
+	snd_hdsp_free_buffers(hdsp);
+	
+	if (hdsp->iobase)
+		iounmap((void *) hdsp->iobase);
+
+	if (hdsp->res_port) {
+		release_resource(hdsp->res_port);
+		kfree_nocheck(hdsp->res_port);
+	}
+		
+	return 0;
+}
+
+static void snd_hdsp_card_free(snd_card_t *card)
+{
+	hdsp_t *hdsp = (hdsp_t *) card->private_data;
+
+	if (hdsp)
+		snd_hdsp_free(hdsp);
+}
+
+static int __devinit snd_hdsp_probe(struct pci_dev *pci,
+				    const struct pci_device_id *id)
+{
+	static int dev;
+	hdsp_t *hdsp;
+	snd_card_t *card;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!snd_enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	if (!(card = snd_card_new(snd_index[dev], snd_id[dev], THIS_MODULE, sizeof(hdsp_t))))
+		return -ENOMEM;
+
+	hdsp = (hdsp_t *) card->private_data;
+	card->private_free = snd_hdsp_card_free;
+	hdsp->dev = dev;
+	hdsp->pci = pci;
+
+	if ((err = snd_hdsp_create(card, hdsp, snd_precise_ptr[dev])) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->shortname, "Hammerfall DSP");
+	sprintf(card->longname, "%s at 0x%lx, irq %d", hdsp->card_name, 
+		hdsp->port, hdsp->irq);
+	
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_hdsp_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	name:"RME Hammerfall DSP",
+	id_table:snd_hdsp_ids,
+	probe:snd_hdsp_probe,
+	remove:__devexit_p(snd_hdsp_remove),
+};
+
+static int __init alsa_card_hdsp_init(void)
+{
+	if (pci_module_init(&driver) < 0) {
+#ifdef MODULE
+		printk(KERN_ERR "RME Hammerfall-DSP: no cards found\n");
+#endif
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit alsa_card_hdsp_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_hdsp_init)
+module_exit(alsa_card_hdsp_exit)
+
+#ifndef MODULE
+
+/* format is: snd-hdsp=snd_enable,snd_index,snd_id */
+
+static int __init alsa_card_hdsp_setup(char *str)
+{
+	static unsigned __initdata nr_dev = 0;
+
+	if (nr_dev >= SNDRV_CARDS)
+		return 0;
+	(void)(get_option(&str,&snd_enable[nr_dev]) == 2 &&
+	       get_option(&str,&snd_index[nr_dev]) == 2 &&
+	       get_id(&str,&snd_id[nr_dev]) == 2);
+	nr_dev++;
+	return 1;
+}
+
+__setup("snd-hdsp=", alsa_card_hdsp_setup);
+
+#endif /* ifndef MODULE */
diff -Nru a/sound/pci/rme9652/multiface_firmware.dat b/sound/pci/rme9652/multiface_firmware.dat
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/sound/pci/rme9652/multiface_firmware.dat	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,4072 @@
+/* stored in little-endian */
+static u32 multiface_firmware[97652] __devinitdata = {
+0xffffffff, 0x66aa9955, 0x8001000c, 0xe0000000, 0x8006800c, 0xb0000000,
+0x8004800c, 0xb4fc0100, 0x8003000c, 0x00000000, 0x8001000c, 0x90000000,
+0x8004000c, 0x00000000, 0x8001000c, 0x80000000, 0x0002000c, 0x581a000a,
+0x00044800, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00800000,
+0x00000120, 0x00000000, 0x00044800, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x04800000, 0x00000120, 0x00000000, 0x00024001, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000100, 0x00000000,
+0x00004000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000100, 0x00000000, 0x00004004, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000900, 0x00000000, 0x0000c004, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000320, 0x00000000,
+0x00004801, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000120, 0x00000000, 0x038048fa, 0x38000e00, 0x8014e001, 0x012e0053,
+0x15c00538, 0x9e006f80, 0xe0027800, 0x00078001, 0x0070009e, 0x6f0001c0,
+0x70009e00, 0xf811c000, 0x00000123, 0x00000000, 0x023fa003, 0x0bfe08ff,
+0x0fe003b0, 0xfc403723, 0xc00f3008, 0x00ff0034, 0x0f3003fc, 0xbf003e80,
+0xf003cc00, 0x003ec00f, 0x03fc20ff, 0x0fc407b0, 0x00000e00, 0x00000000,
+0x00370801, 0x9b74021d, 0x87440510, 0x2c4099a1, 0x40091400, 0x801d0804,
+0x01108074, 0x1d000448, 0xd0004400, 0x20064001, 0x0074001d, 0x07400910,
+0x00000c20, 0x00000000, 0x0033a011, 0x0834260d, 0x83440091, 0x34004d29,
+0x40041011, 0x000d2000, 0x00108034, 0x05080042, 0xd1002400, 0x00034000,
+0x0014000d, 0x47400800, 0x00000e80, 0x00000000, 0x0035a803, 0x0174001d,
+0x37400591, 0x0420d900, 0x440d1001, 0xc81d0004, 0x80170074, 0x1d310450,
+0xd0006400, 0x08074001, 0x1874001d, 0x0f400900, 0x00000620, 0x00000000,
+0x0037a802, 0x127400df, 0x474011b0, 0x748b1f02, 0xc0013062, 0x011f0484,
+0x1132307c, 0x5f00c6c0, 0xf00c6c22, 0x00c7c031, 0x0c7c031f, 0x0b4011a0,
+0x00000e20, 0x00000000, 0x003d8007, 0x02f8043f, 0x2fc09370, 0xfc80bf00,
+0xc00ff006, 0x11fe013f, 0x0fe003f4, 0xff003fc0, 0xf00f5500, 0x20fec83f,
+0x87fc03ff, 0x1fc02df4, 0x00000600, 0x00000000, 0x00750802, 0x805c021f,
+0x170029f0, 0x4c005f08, 0xc00d300b, 0x00df2037, 0x6df0034c, 0xdf0837c0,
+0x008b7c02, 0x00b7c0ad, 0x0b7c04df, 0x0ac00df1, 0x00000420, 0x00000000,
+0x02b4a013, 0x1144001d, 0x7740a9d0, 0x4500dd00, 0x447db083, 0x13dd0077,
+0x4dd02f44, 0xd9113740, 0x50477405, 0x0137400d, 0x037403dd, 0x4d404d90,
+0x00000200, 0x00000000, 0x0032a007, 0x115490cd, 0x43000890, 0x0400c900,
+0x431d1080, 0x210d1143, 0x20d08c45, 0x1d0c8242, 0x10903413, 0x0cc34320,
+0xc8742b0d, 0x1c4320d0, 0x00000a00, 0x00000000, 0x00788004, 0x2584010d,
+0x5a605ed0, 0x8401ed08, 0x409a9007, 0x09ed057b, 0x9ed01794, 0xa9027a40,
+0x5007b401, 0x007b401e, 0x57b401ed, 0x11401e90, 0x00000200, 0x00000000,
+0x02301012, 0x001c10cd, 0x03e208f0, 0x0c0ecf04, 0xc0043800, 0xe0df8173,
+0x2cf0670c, 0x8f00b3c0, 0x33233c00, 0x0033c00c, 0x033c00cf, 0x48cc0cf0,
+0x00000040, 0x00000000, 0x003db802, 0x01f600ff, 0x3fe84fe0, 0xfc08ef00,
+0xc00ff183, 0x80ff023f, 0x0ff113ec, 0xb80037c2, 0xf083fc00, 0x003fc80f,
+0x93fc00ff, 0x09c01ff0, 0x00000660, 0x00000000, 0x0037a015, 0x827c01df,
+0x14c005b0, 0x5c20df01, 0xc401b000, 0x00130004, 0x0132044c, 0x53280448,
+0xb0807c00, 0x0004c001, 0x004c0013, 0x57c00130, 0x00000e00, 0x00000000,
+0x08398012, 0x02b4002d, 0x38400600, 0xb400ed04, 0xce0e1903, 0x40eb503e,
+0x0eb103ac, 0xeb003ac4, 0xb103b440, 0x103ac40e, 0x03ac40eb, 0x4b000eb1,
+0x00000620, 0x00000000, 0x00790003, 0x02b4a0ed, 0x5a403e11, 0x9601ed00,
+0x401c9004, 0x01c50478, 0x1c910704, 0xe1087040, 0xd0479601, 0x1070401c,
+0x470461c5, 0x0f021e18, 0x00000400, 0x00000000, 0x00372812, 0x833600cd,
+0xb2403d10, 0x7440cd00, 0x484f1003, 0x80e0007a, 0x6f902ba4, 0xe980ba08,
+0x5013b64d, 0x013a400e, 0x13a400ed, 0x4b401e99, 0x00000c20, 0x00000000,
+0x0015a817, 0x15fce07f, 0x96d807b3, 0xdc007f03, 0xc045b029, 0x98542a14,
+0x45b02d4c, 0x5301d480, 0xd20d7c00, 0x0094c455, 0x014c4b57, 0x5fc11730,
+0x00000620, 0x00000000, 0x10070012, 0x407c201f, 0x85c061f0, 0x7c001f00,
+0xc803f280, 0x403f008f, 0x23f008fc, 0x3f248fc0, 0xb008fc02, 0x128fcc03,
+0x08fc8a3b, 0x4bc003f0, 0x00000c00, 0x00000000, 0x00a70810, 0x020c0083,
+0x74c05978, 0x4c819f01, 0xd0093082, 0x01934164, 0x19f08e4d, 0x934065c0,
+0x34164d09, 0x4064d129, 0x26510593, 0x43c01935, 0x00000c20, 0x00000000,
+0x50262001, 0x06440090, 0xa4504918, 0x45028d00, 0xe229b002, 0xa2970926,
+0x09d00e44, 0x91002446, 0x101e6c40, 0x00e44039, 0x1244e091, 0x06403910,
+0x00000800, 0x00000000, 0x0024a018, 0x524480d0, 0xa4600d50, 0x44089d00,
+0x00891002, 0x18e11028, 0x8bd082c4, 0xe10a2844, 0x10838410, 0x0238400e,
+0x028420e1, 0x63418b10, 0x00000200, 0x00000000, 0x02302810, 0x0a040281,
+0x20408810, 0x04008d82, 0x402e9422, 0x42a920a8, 0x2ad00b84, 0xa100a840,
+0x100aa402, 0x00a8402e, 0x0a8402a1, 0x43400a10, 0x00000080, 0x00000000,
+0x0886a01d, 0x00042011, 0x84c16050, 0x0c005f05, 0x40013008, 0x00130004,
+0x05f0004c, 0x130015c0, 0x30004c00, 0x0014c001, 0x005c0053, 0x77c00330,
+0x00000ac0, 0x00000000, 0x0127a819, 0x0afc02ff, 0x27c04bf0, 0xfe00bf01,
+0xc029f092, 0x829700a7, 0x29f00a7c, 0xdf00a790, 0xf08b5c02, 0x00a7c02d,
+0x0a7c829f, 0x66c029f0, 0x00000e60, 0x00000000, 0x00afa018, 0x32fc0cbf,
+0x27c00bb0, 0xfc00bf02, 0xc009b002, 0x049f0024, 0x49341a7c, 0x9f01a7e4,
+0x059a7c0c, 0x41a4d069, 0x0a7c8493, 0x63c009d0, 0x00000e00, 0x00000000,
+0x2007081c, 0x3874ae0d, 0x07490130, 0x74001d02, 0x44011000, 0xa01d2204,
+0x45120074, 0x1d2297e4, 0x10987404, 0x00844821, 0x08748e51, 0x734027d2,
+0x00000c20, 0x00000000, 0x0023a010, 0x0236808d, 0x23408810, 0x34008d00,
+0x41ca9002, 0x1cad0d28, 0x2a180a94, 0xad002b41, 0x111ab682, 0x11a8406a,
+0x0ab430a5, 0x43402ad1, 0x00000e80, 0x00000000, 0x8025a818, 0x0274009d,
+0x27400998, 0x74209d00, 0x4aa81292, 0x90fd242c, 0x0f101bb4, 0xfd0a2d42,
+0x1002f620, 0x01ac400b, 0x82f400b5, 0x63408bd9, 0x00000620, 0x00000000,
+0x0027a805, 0x127c009f, 0x27c24938, 0x74009f11, 0xc029b802, 0x009f2024,
+0x1932067c, 0x9f002740, 0x31027c00, 0x00244409, 0x627c0897, 0x17c039f0,
+0x00000e20, 0x00000000, 0x00258014, 0x0e7c039f, 0x77c00970, 0x7c099f21,
+0xd809f002, 0x089b0267, 0x49f0466c, 0x9f0827c0, 0xf00a7802, 0x0427c039,
+0x027c019b, 0x53c019f2, 0x00000600, 0x00000000, 0x00050814, 0x48140617,
+0x84c02170, 0x7c001f02, 0xc8233000, 0x0432238f, 0x03e028fc, 0x33100fc0,
+0xf000fc10, 0x000fc723, 0x00cc123f, 0x53c023f0, 0x00000420, 0x00000000,
+0x005c8014, 0x09c4077d, 0x14401770, 0xf6207d08, 0xc0051061, 0x025500d5,
+0x15d0015c, 0x530095c5, 0xd0817420, 0x00974005, 0x8144805d, 0x534005d0,
+0x00000200, 0x00000000, 0x0072a014, 0x033401cd, 0xb0689c50, 0x7600cd21,
+0x410e100f, 0x03e1003b, 0x4ed003b4, 0xe94c7a40, 0x9033f400, 0x08ff401f,
+0x638500ed, 0x53421ed0, 0x00000a00, 0x00000000, 0x04088005, 0x04a4012d,
+0x38401450, 0xf400ed80, 0x400e1803, 0x02e51079, 0x0ed003b4, 0xe100f940,
+0x9003b440, 0x00bb402e, 0x838411ed, 0x17402ed0, 0x00000200, 0x00000000,
+0x00781015, 0x01b421e7, 0x78501e70, 0xb401ef02, 0xc81e1007, 0x01e38073,
+0x1ef007bc, 0xeb187fe4, 0xf007bc01, 0x187bc61e, 0x878c01ff, 0x57ce1ef0,
+0x00000040, 0x00000000, 0x0035b810, 0x015c201f, 0xa7c80df1, 0x3400df01,
+0xc201e503, 0x001f0807, 0x01f0805c, 0x5f0807c0, 0xf0007c20, 0x0007c201,
+0x807c001f, 0x43c001f1, 0x00000660, 0x00000000, 0x807fb000, 0x27fc09f3,
+0x5cc05ff1, 0xcc01f308, 0xc41f3804, 0x29f3007c, 0x1f3007cc, 0xf5007cc0,
+0x30a7cc01, 0x027c089f, 0x27c08df3, 0x00c09f30, 0x00000e00, 0x00000000,
+0x02098015, 0x02b40ea1, 0xd840f6d1, 0xac00e120, 0xc0d61004, 0x01eb02ba,
+0x8eb2232c, 0xeb223ac5, 0xb003ac2d, 0x223ac48e, 0x63ac8ceb, 0x56c08eb1,
+0x00000620, 0x00000000, 0x00290000, 0x41b480e1, 0x106008d1, 0xc400f900,
+0x404c1010, 0x0cc9003a, 0x0c104304, 0xc1003240, 0x124304ac, 0x1030408c,
+0x83061cc1, 0x00411c13, 0x00000400, 0x00000000, 0x00232804, 0x07345b91,
+0xc05808d0, 0x2402c903, 0x40d8120c, 0x020d2802, 0x10904c24, 0x49004242,
+0x98082413, 0x12022010, 0x00264209, 0x12400098, 0x00000c20, 0x00000000,
+0x00358815, 0x067c0113, 0x74c019f0, 0x4c00cb40, 0xc83d10a0, 0x01d90876,
+0x1d310f4c, 0x9308b682, 0x300b4c10, 0x00f4c02d, 0x0f4c03d3, 0x54c02d30,
+0x00000620, 0x00000000, 0x00870001, 0x007c001f, 0x37c0a1f0, 0x7c06d700,
+0xc00df228, 0x0cdb03b7, 0x2df0037c, 0x9f1337c1, 0xf0037c02, 0x0137c4ed,
+0x437c80df, 0x07c04df0, 0x00000c00, 0x00000000, 0x081f0880, 0x00dc003f,
+0x5fc057f0, 0xec253300, 0xc05bf004, 0x05ff0135, 0x9ff00bfc, 0xaf017fc0,
+0xf0c7cc01, 0x013f009f, 0x23fc14ff, 0x03c08ff0, 0x00000c22, 0x00000000,
+0x24962081, 0x05440b1d, 0x474025b0, 0x55841100, 0x4405d148, 0x001d0047,
+0x31f10074, 0x1d110748, 0xd1005401, 0x04874821, 0x1874521d, 0x074001d2,
+0x00000802, 0x00000000, 0x0034a001, 0x1274005d, 0x034009d0, 0x4400d182,
+0x400dd023, 0x20150007, 0x01d80074, 0x1d000740, 0xd0184428, 0x20074821,
+0x0074001d, 0x074009d1, 0x00000200, 0x00000000, 0x00002010, 0x820400cd,
+0x034040d0, 0x0420d190, 0x4444d013, 0x240d1003, 0x00d80834, 0x0d000340,
+0xd0001400, 0x00024000, 0x0034000d, 0x434408c0, 0x00000080, 0x00000000,
+0x0002a000, 0x005c005f, 0x47c051f0, 0x4c001140, 0xc359f857, 0x55170805,
+0x01f0007c, 0x1f1007c2, 0xf0004c25, 0x2007c201, 0x807c001f, 0x03c409e0,
+0x00000ac0, 0x00000000, 0x000fa805, 0x03fc00ff, 0x07c08130, 0x3c002f02,
+0xc00df003, 0x40df057f, 0x0f7007fc, 0x9f003fc0, 0xf003fc02, 0x003fc80f,
+0x03fc80ff, 0x17c007f0, 0x00000e60, 0x00000000, 0x820f8003, 0x20fc00ff,
+0x04e00dd0, 0x5c04ff00, 0xc00d3000, 0x00df0034, 0x0f3003cc, 0xd30034c0,
+0x3003dc00, 0x003cc00f, 0x03cc00f3, 0x0cc00f30, 0x00000e00, 0x00000000,
+0x02070801, 0x187400dd, 0x8444add0, 0x4508dd00, 0x40017010, 0x401d0004,
+0x01100044, 0x11000440, 0x10007440, 0x20044001, 0x00440011, 0x04400111,
+0x00000c20, 0x00000000, 0x0023a011, 0x183400cd, 0x834000d0, 0x2400cd00,
+0x50001842, 0x00cd0030, 0x08940315, 0x81401050, 0x57031400, 0x4032500c,
+0x020500c1, 0x44500c14, 0x00000e80, 0x00000000, 0x8525a803, 0x237440dd,
+0x875001d0, 0x2408dd00, 0x600d5202, 0x040d0004, 0x04920034, 0x51002040,
+0x58003400, 0x00024000, 0x01440001, 0x0c400090, 0x00000620, 0x00000000,
+0x10878802, 0x0c7480dd, 0xc74201f0, 0x64611f00, 0xc00d3061, 0x205f3924,
+0x05b1015c, 0x530234c0, 0x70005c00, 0x08064801, 0x01440013, 0x08c00130,
+0x00000e20, 0x00000000, 0x040d8007, 0x45fc80fd, 0x1c4000f0, 0xcc113f31,
+0xc901f205, 0x41bf201f, 0x0b7026cc, 0xbf000fc0, 0xb003fc00, 0x003dc00f,
+0x02fc00fe, 0x1fc00f60, 0x00000600, 0x00000000, 0x00950802, 0x087c20d7,
+0x96c00df0, 0x7c420f20, 0xc481b00b, 0x185f0024, 0x01f0214c, 0x1f0017c3,
+0x70407c00, 0x0205c081, 0x207c081f, 0x0bc081f0, 0x00000420, 0x00000000,
+0x00d4a013, 0x0f7404dc, 0x56c01dd1, 0x5c831d04, 0x402d1403, 0x439d01d4,
+0x1dd00645, 0xdd04a744, 0xd04b7407, 0x0274509d, 0x277409dd, 0x4f409dd0,
+0x00000200, 0x00000000, 0x00d2a007, 0x003446cc, 0x42490cda, 0x30010d20,
+0x422d1000, 0x008d0c12, 0xacd04204, 0xcd046340, 0x40873410, 0x00b0402c,
+0x0b7402cd, 0x1f402cd0, 0x00000a00, 0x00000000, 0x8c588004, 0x44b441ed,
+0x5a609ed1, 0xb4092d00, 0x44121824, 0x414d116a, 0x12d11584, 0x2d115b42,
+0xd114b441, 0x10484410, 0x04b6412d, 0x124012d1, 0x00000200, 0x00000000,
+0x90301012, 0x3b3c08cf, 0x72c150f0, 0x3c170f01, 0xd0103905, 0xa98f2952,
+0xd8f0160c, 0x8f0243c0, 0x70033c01, 0x0031c08c, 0x223c60cf, 0x4bc00cf0,
+0x00000040, 0x00000000, 0x023db802, 0x23fc80ff, 0x3f8083f0, 0x9c003f02,
+0xc00f7021, 0x007f022d, 0x05f121fc, 0x5f2037c0, 0xf1107c40, 0x000fc003,
+0x01fc403f, 0x0bc013f0, 0x00000660, 0x00000000, 0x2027a015, 0x097c80db,
+0x60c011f0, 0x2c20d101, 0xc00d2006, 0x001f0004, 0x05f0007c, 0x5f002700,
+0x30047c00, 0x0007c001, 0x017c001f, 0x57c001f0, 0x00000e00, 0x00000000,
+0x98298812, 0x41bc00e1, 0x38c00270, 0x8500e104, 0x44021202, 0x00ed1038,
+0x0ad003b4, 0xad001b40, 0x10032400, 0x003b400e, 0x02b400ed, 0x4b400ed0,
+0x00000620, 0x00000000, 0x04700003, 0x87b401e5, 0x7b601ed8, 0x8431c900,
+0x40109007, 0x012d004a, 0x12d084b4, 0x2d104b64, 0x1204b601, 0x004b6012,
+0x84b4012d, 0x0f4012d0, 0x00000400, 0x00000000, 0xa0f30812, 0x2714a0c5,
+0xb1407c5a, 0x2440c902, 0x700c9547, 0x92cd0874, 0x6cd04b34, 0xcd003340,
+0x146b3412, 0x0cf3413c, 0x4b3413cd, 0x4b41acd0, 0x00000c20, 0x00000000,
+0x40dda817, 0x0174c057, 0x554017d1, 0xcc007b20, 0xc0059805, 0xc25d0054,
+0x25f1897c, 0x5f0017c0, 0x300d7402, 0x01d7c075, 0x097c075f, 0x5fc035f0,
+0x00000620, 0x00000000, 0x10070012, 0x087e001b, 0x04c08170, 0x5c000701,
+0xc0037020, 0x023f228f, 0x22f008fc, 0x3f100f40, 0xf000ec02, 0x008fc023,
+0x08fc023f, 0x4bc023f0, 0x00000c00, 0x00000000, 0x04e70810, 0x077c009b,
+0x37c08960, 0x4d109f00, 0xc008f002, 0x00930024, 0x0970027c, 0x9f0824c0,
+0xf0027c80, 0x0027c009, 0x027c009f, 0x43c009f0, 0x00000c20, 0x00000000,
+0x00662001, 0x0e5c0891, 0x274439d0, 0x44489d00, 0x5409d002, 0x029140a4,
+0x29d10a74, 0x9d0024d0, 0xd1027402, 0x10a5c429, 0x0a74a29d, 0x074029d0,
+0x00000800, 0x00000000, 0x0020a018, 0x1a548090, 0x256009d0, 0x46009d80,
+0x4019d802, 0x00b8802c, 0x0bd002f4, 0xbd802c60, 0xd002f600, 0x002f400b,
+0x02f400bd, 0x63400bd0, 0x00000200, 0x00000000, 0x42202010, 0x22344881,
+0x23420cd0, 0x06008d80, 0x403ad022, 0x02e180b8, 0x2ed00bb4, 0xed80a860,
+0xd00ab402, 0x00b9402e, 0x0bb402ed, 0x43402ed0, 0x00000080, 0x00000000,
+0x0586b01d, 0x585c8213, 0x05c141f8, 0x44141f05, 0xc001f008, 0x80132004,
+0x01700074, 0x1f0014c0, 0xf0007c00, 0x0007c001, 0x007c001f, 0x77c003f0,
+0x00000ac0, 0x00000000, 0x012fb819, 0x125c849f, 0x37c00af0, 0xfc00bf00,
+0xc029f112, 0x029f10a7, 0x29d00a7c, 0x9f00b5c0, 0xf00a7c82, 0x00a5c029,
+0x0a7c029f, 0x67c009f0, 0x00000e60, 0x00000000, 0x01afa818, 0x826c08bf,
+0x2fc00bf8, 0x8c20af00, 0xc149700a, 0x28930024, 0xc9320a4c, 0x9300a705,
+0x30326c06, 0x00254089, 0x0a4c0093, 0x60c02930, 0x00000e00, 0x00000000,
+0x1187081c, 0x2836800d, 0x044001d0, 0x6c001d00, 0x4461b000, 0x04154104,
+0x61140045, 0x11008640, 0x1028444e, 0x00874021, 0x00451611, 0x70400310,
+0x00000c20, 0x00000000, 0x0323a010, 0x5224048d, 0xa16008d2, 0x66008d20,
+0x411ad202, 0x02ad04a8, 0x0a109a84, 0xa9c1a940, 0x14128500, 0x45a9406a,
+0x0a8422a1, 0x40504a14, 0x00000e80, 0x00000000, 0x0525a818, 0x4274009d,
+0x244109d0, 0x44009c00, 0x42191302, 0x20b1082c, 0x0b1002c4, 0xb1002e04,
+0x5802e480, 0x002f400b, 0x02c400b1, 0x60400b10, 0x00000620, 0x00000000,
+0x00278005, 0x0e64009f, 0xa54009d0, 0x44009e10, 0xd409c012, 0x00938024,
+0x1930024c, 0x9300a780, 0x30824c00, 0x0025c209, 0x024c0093, 0x14c00930,
+0x00000e20, 0x00000000, 0x00258014, 0x277c009f, 0xe5c099f0, 0x7d308f00,
+0xc009f00e, 0x408f1023, 0x39f1027c, 0x8f1026c0, 0xb0c21c04, 0x0027c009,
+0x123c408f, 0x53c009f0, 0x00000600, 0x00000000, 0x00850014, 0x884c101f,
+0x86c46070, 0x6c00131a, 0xc0023000, 0x0033000c, 0x033000cc, 0x33108fc0,
+0x3000cc00, 0x080cc003, 0x00fc003f, 0x53c003f0, 0x00000420, 0x00000000,
+0x021ca014, 0x0140807d, 0x14c01750, 0x04827140, 0x50051001, 0x00514814,
+0x05140145, 0x51e01744, 0x16094500, 0x00145005, 0x0174005d, 0x534007d0,
+0x00000200, 0x00000000, 0x80b2a014, 0x470402cd, 0x30403c90, 0x260ac500,
+0x400cd002, 0x00c10230, 0x0c900354, 0xc1123740, 0x10230420, 0x0034400c,
+0x033608cd, 0x53400dd0, 0x00000a00, 0x00000000, 0x00388005, 0x478401ed,
+0x78410e10, 0xc4006500, 0x40005012, 0x20218008, 0x02108094, 0x21000340,
+0x91008400, 0x00084210, 0x80b4a02d, 0x174002d0, 0x00000200, 0x00000000,
+0x90781015, 0x478c21af, 0x70d01474, 0xac81e700, 0xc012f136, 0x41733050,
+0x1630051e, 0x42005bc0, 0x3007cc01, 0x0058c016, 0x05bc016f, 0x57c016f0,
+0x00000040, 0x00000000, 0x2025b810, 0x007da0df, 0x37e20d70, 0x4c805b20,
+0xc80db01a, 0x009d0027, 0x09f0026c, 0x970027c8, 0x72007c80, 0x2027c009,
+0x027c009f, 0x43c009f0, 0x00000660, 0x00000000, 0x007fa000, 0x05cd0d73,
+0x64c01f71, 0xce01df00, 0xd01f7066, 0x01d24b64, 0x1f3427fc, 0xf3426ed0,
+0xf104dd89, 0x407c909f, 0x07cd09b3, 0x03c01f34, 0x00000e00, 0x00000000,
+0x02198815, 0x11840871, 0x6a805610, 0xc60d4d05, 0x40821006, 0x892b0358,
+0x91102424, 0x31005841, 0x90178409, 0x020840c3, 0x20840861, 0x57408210,
+0x00000620, 0x00000000, 0x00310000, 0x01060421, 0x28404410, 0x8404ed03,
+0x40025582, 0x40610008, 0x061011b4, 0x61010060, 0xd0108404, 0x00104406,
+0x01841001, 0x03401610, 0x00000400, 0x00000000, 0x00072804, 0x00040041,
+0x60400010, 0x04004d80, 0x401c1002, 0x13810070, 0x28100e24, 0x8104f040,
+0x9a4f0402, 0x04e04138, 0x4e0413d1, 0x13413810, 0x00000c20, 0x00000000,
+0x00058815, 0x6344c0d1, 0x34520c1d, 0xc500cf10, 0xc03d7002, 0xb29110f4,
+0x99324a7c, 0x9104b6c2, 0xf04b4411, 0x04a4c129, 0x4a4c43d3, 0x57c12930,
+0x00000620, 0x00000000, 0x00370001, 0x037c001f, 0x27c00d30, 0x7c02df00,
+0xc0c1f102, 0x005f0307, 0x05f2016c, 0x5f0007c0, 0xb0006c80, 0x0017c005,
+0x013c001f, 0x07c005f0, 0x00000c00, 0x00000000, 0x00cf0880, 0x23fc01b3,
+0xfcc007f0, 0xcc03df00, 0xc002f002, 0x403f001c, 0x12f04474, 0x3f001cc0,
+0xf003cc11, 0x004bc013, 0x04cc0073, 0x03c01330, 0x00000c22, 0x00000000,
+0x04e62081, 0x00740315, 0x65400d71, 0x7c13dd00, 0x400dd002, 0x89dd2024,
+0x1dd00774, 0xdd002450, 0xd0004580, 0x1077400d, 0x07440091, 0x07401d14,
+0x00000802, 0x00000000, 0x0804a001, 0x00740ad0, 0x34400dd1, 0x44005d00,
+0x400dd002, 0x009c0024, 0x49d01274, 0x8d002440, 0xd1004404, 0x41274049,
+0x12440091, 0x07404910, 0x00000200, 0x00000000, 0x00102210, 0x00240001,
+0x214044d0, 0x24064900, 0x5220d002, 0x004d0110, 0x04d00134, 0x4d111040,
+0xd0030400, 0x00134004, 0x01040041, 0x43400410, 0x00000080, 0x00000000,
+0x4006b000, 0x007c8093, 0x74c235f8, 0xcc375f21, 0xc020f03e, 0x0b1f0340,
+0xf1f23c7c, 0x1f02c4c0, 0xf0144c07, 0x0007c001, 0x000d0013, 0x03c00130,
+0x00000ac0, 0x00000000, 0x000f9805, 0x00fc003f, 0xefc1d178, 0x7e053f04,
+0xc01ff00e, 0x09ff0b7f, 0x9df0377c, 0xdf027740, 0xf0237c17, 0x003fc00f,
+0x03fc20ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x000fa003, 0x20e804ff,
+0x0fc083f0, 0xec263c08, 0xc20fb053, 0x00f3003e, 0x0f3003cc, 0xb3003fc0,
+0x3003ec80, 0x083ec00f, 0x83ec20ff, 0x0cc007f0, 0x00000e00, 0x00000000,
+0x02070801, 0x2844369d, 0x274a81d0, 0x44c61d00, 0x4009100b, 0x00110004,
+0x01140045, 0x11000740, 0x10004400, 0x00044601, 0x0045001d, 0x07c809d1,
+0x00000c20, 0x00000000, 0x0013a011, 0x122408cd, 0x01604451, 0x04020d00,
+0x50049003, 0x00014800, 0x00808014, 0x01480340, 0x16000500, 0x20005800,
+0x0004800d, 0x446408d1, 0x00000e80, 0x00000000, 0x0055a803, 0x0466408d,
+0x07400dd0, 0x44201d21, 0x440c1013, 0x08110004, 0x41902014, 0x01000340,
+0x10004410, 0x00044081, 0x0064101d, 0x0f4009d1, 0x00000620, 0x00000000,
+0x0007a802, 0x0c6c095f, 0x07c041f0, 0x6d001f00, 0xc04db007, 0x231304c6,
+0x01b0145c, 0x530307c0, 0x30186c00, 0x0006c051, 0x086c001f, 0x00c401f3,
+0x00000e20, 0x00000000, 0x000d8007, 0x005c003f, 0x67c007f0, 0xbc057f08,
+0xc05bf107, 0x01ff027f, 0x1f6007e4, 0xff103fc0, 0xf227fc00, 0x017fc00f,
+0x27dc05fb, 0x1e403ef0, 0x00000602, 0x00000000, 0x00a50802, 0x0a7c00df,
+0x35c00170, 0x7c104300, 0xc125f063, 0x40df2834, 0x2df08b7c, 0xdf00b7c0,
+0xf00b7c02, 0x00b7c02d, 0x0b7c1ac3, 0x0bc20df0, 0x00000420, 0x00000000,
+0x1464a013, 0x1044009d, 0xf7400d10, 0x74025101, 0x445db007, 0x26dd01f4,
+0x2dd00b74, 0xdd02b741, 0xd20b7487, 0x60b7492d, 0x4b7481d1, 0x4f41add0,
+0x00000200, 0x00000000, 0x0022a007, 0x0214060d, 0xd2680810, 0x24030104,
+0x4030100b, 0x111d1404, 0x10d06434, 0x0d22c245, 0x90646410, 0x06434111,
+0x44240209, 0x1f4810d0, 0x00000a00, 0x00000000, 0x00688004, 0x0684212d,
+0x7b409214, 0xb4116100, 0x501c9807, 0x81ed0878, 0x9ed087b4, 0xad007b42,
+0x9007b421, 0x0073401e, 0x07b421e9, 0x1b401ed0, 0x00000200, 0x00000000,
+0x82301012, 0x221c0a5d, 0x43e08c70, 0x7c8c4340, 0xe88c7403, 0x02cf3230,
+0x0cf0033c, 0x8f0133c0, 0xf0233c00, 0x0233c00c, 0x233c00cb, 0x4bc08cf0,
+0x00000040, 0x00000000, 0x083db802, 0x23dc007f, 0x0fce8ff0, 0xfc0a7f00,
+0xc60ff003, 0x00ff023f, 0x0ff803fe, 0xbf803fc2, 0xf283fc00, 0x003fc40f,
+0x83fc00f5, 0x0bc01ff0, 0x00000660, 0x00000000, 0x0017a015, 0x027c811f,
+0x56c209f2, 0x7c001300, 0xe0013423, 0x801f0007, 0x01f2007c, 0x531044c0,
+0xf2807e80, 0x0007c801, 0x805c001f, 0x57c001f0, 0x00000e00, 0x00000000,
+0x00198812, 0x03b4002d, 0x384004d0, 0xf4006b00, 0x600e5013, 0x00ed003b,
+0x0ed003b4, 0xe1183042, 0xd003b400, 0x003b400e, 0x839c00ed, 0x4b4a0ed1,
+0x00000600, 0x00000000, 0x00f90003, 0x46b400e5, 0x7a411ad0, 0xb6236100,
+0x4a1e100f, 0x11ed2079, 0x1ed107b4, 0xe5007a40, 0xd18fb401, 0x087b4a1e,
+0x0f9403ed, 0x0f401ed0, 0x00000402, 0x00000000, 0x10f32812, 0x033402cd,
+0xb0400dd2, 0x34015912, 0x420e5403, 0x40ed03fb, 0x3ed10bb4, 0xe5043a50,
+0xd04bb412, 0x00bb402e, 0x4b9401ed, 0x4b000ed0, 0x00000c20, 0x00000000,
+0x00dda817, 0x05fc007f, 0x5ec007f0, 0xbc015300, 0xc0051004, 0x035f0017,
+0x55f0117c, 0x570496c0, 0xf1017c01, 0x0417c525, 0x015c005f, 0x5fc107f8,
+0x00000620, 0x00000000, 0x01070012, 0x007c101f, 0x07c801d0, 0x7c021f04,
+0xc003f000, 0x403b200f, 0x03f148fc, 0x3a408dc1, 0xf000bc08, 0x118fc003,
+0x00fc043f, 0x4bc823f0, 0x00000c00, 0x00000000, 0x02270810, 0x064c088f,
+0x24c209f1, 0x4c41df20, 0xc0093404, 0x109f0027, 0x08f0024c, 0x9f0064c0,
+0xf0027c00, 0x0027c109, 0x027c009f, 0x43c009f0, 0x00000c20, 0x00000000,
+0x00262001, 0x2a44019d, 0xa44009d0, 0x44209d00, 0x40091082, 0x809d0027,
+0x09d00245, 0x9c03e458, 0x10827420, 0x00274009, 0x0274809d, 0x074129f0,
+0x00000800, 0x00000000, 0x0034a018, 0x4344009d, 0xa44009d0, 0x44089d00,
+0x40091022, 0x00a5082f, 0x0fd082c4, 0xbd002c48, 0x1402f000, 0x003e640b,
+0x03f600b9, 0x63400bd0, 0x00000200, 0x00000000, 0x00202010, 0x2204028d,
+0x2051c8d0, 0x4508cd02, 0x422a100a, 0x02ad00ab, 0x2ad00a84, 0xad00a84c,
+0x100ab442, 0x00ab482a, 0x02b602ad, 0x43400ad0, 0x00000080, 0x00000000,
+0x0506b01d, 0x584c001f, 0x80c061f0, 0x4c161f05, 0xc0013850, 0x00170007,
+0x00f0014c, 0x1d0004c4, 0xf0007c40, 0x0017c001, 0x007c801f, 0x77c203f0,
+0x00000a80, 0x00000000, 0x002fb819, 0x13fc02ff, 0x2f804bf0, 0xf8249f01,
+0xca29f000, 0x029f00a7, 0x29f00a7c, 0x9f00a7cc, 0xf00a7c22, 0x00a7c029,
+0x0a7c029f, 0x67c02970, 0x00000e60, 0x00000000, 0x002fa018, 0xc2cc04bb,
+0xacc06930, 0x4c06b301, 0xc1093016, 0x04930227, 0x09300a4c, 0x930427c0,
+0x301a4c04, 0x00a4c069, 0x024c009b, 0x67c00930, 0x00000e00, 0x00000000,
+0x0297081c, 0x0044341d, 0x84424510, 0x6e861141, 0x40611018, 0x16110287,
+0xe1140145, 0x51408748, 0x10104114, 0x03944045, 0x00440411, 0x72400714,
+0x00000c22, 0x00000000, 0x0023a010, 0x4224428d, 0xa0486810, 0x84028100,
+0x410a5c4a, 0x48a1492b, 0x0a100a84, 0xa1052b41, 0x141a8402, 0x4128506a,
+0x0aa532a1, 0x43402a10, 0x00000e80, 0x00000000, 0x0125a818, 0x0264089d,
+0x25444814, 0x2400c100, 0x430b5082, 0x10b1042b, 0x6b1002c4, 0xb108af4a,
+0x101a8400, 0x0028404e, 0x42e426a1, 0x63408b12, 0x00000620, 0x00000000,
+0x08e7a805, 0x0a6c0299, 0x24902930, 0x44009301, 0xc0297002, 0x00930027,
+0x3930064c, 0x930027c0, 0x300e4c01, 0x00e4c019, 0x026c009b, 0x17c03930,
+0x00000e20, 0x00000000, 0x00258014, 0x0e5c409c, 0x26c209f1, 0x7c189f01,
+0x8129b00e, 0x088f0167, 0x19f00e7c, 0x9f0127c4, 0xf2027803, 0x0127c019,
+0x221c009f, 0x52c009f0, 0x00000600, 0x00000000, 0x40850814, 0x187c0003,
+0x04d021f0, 0xfc001f20, 0xc4237100, 0x1033000c, 0x23f000fc, 0x33000cc1,
+0x3048cc00, 0x000cc003, 0x80cca23f, 0x530003f2, 0x00000420, 0x00000000,
+0x1154a014, 0x49f44271, 0x1d4005d0, 0x76927d21, 0x5405d001, 0x00514014,
+0x05d00174, 0x514016d2, 0x16014580, 0x00145005, 0x014d005d, 0x534005d2,
+0x00000200, 0x00000000, 0x0072a014, 0x07740cc1, 0x35400cd0, 0x3441cd01,
+0x420c4283, 0x00c10230, 0x0cd00374, 0xd1003440, 0x10030408, 0x0230400c,
+0x032400cd, 0x53440cd0, 0x00000a00, 0x00000000, 0x00608005, 0x03b481e1,
+0x38400cd0, 0xb400ed00, 0x4010d000, 0x20210800, 0x12d000b6, 0x01000042,
+0x10000420, 0x18084000, 0x0084200d, 0x174402d0, 0x00000200, 0x00000000,
+0x00781015, 0x85bc20a3, 0x59c33ef0, 0xb481ef20, 0xc01e7206, 0x01e30078,
+0x1cf085bc, 0xe3004846, 0x31078c01, 0x0058c01e, 0x07ac01ef, 0x57c016f0,
+0x00000040, 0x00000000, 0x0825b810, 0x007c0098, 0x17c40df0, 0x7c009f00,
+0xc801f001, 0x001f2007, 0x01f2027c, 0x1f2037c0, 0xf0007c80, 0x0027c801,
+0x007c001e, 0x43c209f8, 0x00000660, 0x00000000, 0x007bb000, 0x06fc8973,
+0x7f041ff1, 0xfc01ff02, 0xc0973027, 0x097f026c, 0x973007cc, 0xbf107cc0,
+0xf125cd09, 0x026cd01f, 0x07c801f3, 0x0bc01f30, 0x00000e00, 0x00000000,
+0x02398015, 0x82b408eb, 0x03400ed0, 0xf4006d00, 0x42cb1008, 0x08ad0318,
+0xcb102084, 0x6d020840, 0xd0b2840c, 0x021c4182, 0x60844831, 0x57480210,
+0x00000620, 0x00000000, 0x00290000, 0x60b63821, 0x3b408ed0, 0xb418ed10,
+0x44065082, 0x084d0028, 0x06100104, 0x8d000840, 0xd0018400, 0x0208400c,
+0x030400e1, 0x63401610, 0x00000400, 0x00000000, 0x10232804, 0x08360089,
+0x83400cd1, 0x34010c00, 0x54984081, 0x108d0010, 0x98102204, 0x4d02b050,
+0xd00e0483, 0x42f04030, 0x08050a01, 0x1b403810, 0x00000c20, 0x00000000,
+0x0035a815, 0x067c2113, 0xa7c82ff0, 0x3c21df00, 0xc0996401, 0x019f1414,
+0x19102a4c, 0x5f0074c0, 0xf04a4c10, 0x00744201, 0x0c4c0313, 0x77c10910,
+0x00000620, 0x00000000, 0x10230001, 0x4a70021f, 0x23011df0, 0x7c22df00,
+0xc005b006, 0x085f0023, 0x05f4017d, 0x9f1407c1, 0xf0117c12, 0x0407c90d,
+0x1b7c02df, 0x07c104f4, 0x00000c00, 0x00000000, 0x003f0880, 0x82fc0833,
+0x0fc20ff8, 0xfc857304, 0xc21a3000, 0x01b3041c, 0x5b3084bc, 0x7f000fc0,
+0xf006fc00, 0x001bc013, 0x04fc1033, 0x04c013f0, 0x00000c20, 0x00000000,
+0x00262081, 0x06740111, 0x47400dd0, 0x74231102, 0x40951003, 0x015b4024,
+0x05140774, 0x9d083740, 0xd0017424, 0x0827420d, 0x177404d1, 0x05460dd0,
+0x00000802, 0x00000000, 0x0034a001, 0x0e749051, 0x37400dd0, 0x74809100,
+0x04011001, 0x04110084, 0x01101274, 0x1d183740, 0x90107000, 0x08274241,
+0x10744811, 0x044249d0, 0x00000200, 0x00000000, 0x00302010, 0x023400c1,
+0x02400cd0, 0x74000108, 0x400c1002, 0x00c90030, 0x0c128134, 0xcd080340,
+0xd0033420, 0x0813400c, 0x032420c1, 0x41400490, 0x00000080, 0x00000000,
+0x0026a000, 0x007c0053, 0xb7c00fd0, 0x7c001340, 0xc0013000, 0x60130004,
+0x0131007c, 0x1f0007c4, 0xf0007c00, 0x0007c001, 0x007c0013, 0x04c401f0,
+0x00000ac0, 0x00000000, 0x002fa805, 0x00fc80ff, 0x4fc80ff0, 0xfc003f15,
+0xc00ff103, 0x40f7003f, 0x0ff003fc, 0xff003fc0, 0xf003fc00, 0x583fc00f,
+0x03fc00ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x030f8003, 0x03cc0833,
+0x3fc08114, 0x4c00f308, 0xc00f381b, 0x00ff003f, 0x0df0837c, 0x9f0034c0,
+0xf0037c00, 0x003f400f, 0x03fc00ff, 0x0cc007f0, 0x00000e80, 0x00000000,
+0x00970801, 0x2a442e01, 0xb8400110, 0xc402f194, 0x40091023, 0x401d2807,
+0x01900074, 0x1d000450, 0xd0007400, 0x00074201, 0x0074a019, 0x06c009d1,
+0x00000420, 0x00000000, 0x21a3a011, 0x03142081, 0x30604852, 0x3402c163,
+0x48045213, 0x800d1002, 0x00d00014, 0x0d000140, 0xd0003620, 0x00034000,
+0x0034a00d, 0x444008d0, 0x00000c80, 0x00000000, 0x0025a803, 0x02442011,
+0x34748950, 0x5540d010, 0x690d5083, 0x201d2007, 0x01d00074, 0x1d080540,
+0xd2007400, 0x06074a81, 0x8074b01d, 0x0e4089d2, 0x00000620, 0x00000000,
+0x4007a802, 0x215c8153, 0x36c03570, 0x5c20d110, 0xc00d5403, 0x041f2887,
+0x81e0087c, 0x5f0605c1, 0xf00c7c10, 0x00c7c011, 0x007c011f, 0x08c211f0,
+0x00000e20, 0x00000000, 0x001d8007, 0x00ad09af, 0x3ac307b0, 0xac40ff00,
+0xc08bb203, 0x08ff30bf, 0x1fb013ec, 0xff007ec0, 0xf117fc20, 0x047fc11f,
+0x0ffc09fb, 0x1fc11ef0, 0x00000600, 0x00000000, 0x00b10802, 0x094c04d3,
+0x35e02530, 0x6c80d700, 0xc045f203, 0x18d304b4, 0xec714b4c, 0xd301b7c0,
+0x30237c08, 0x12b4c68d, 0x034c0cd3, 0x0bc40d30, 0x00000420, 0x00000000,
+0x0834a013, 0x14540091, 0x3f420510, 0xec0ae100, 0x420d1003, 0x03d51c74,
+0x2d104b44, 0xd104f7c8, 0x10877002, 0x00b4402d, 0x2f4400d1, 0x4f402d10,
+0x00000200, 0x00000000, 0x0222a007, 0x8024a001, 0x30480192, 0x0482c108,
+0x40301003, 0x43011082, 0x20110c04, 0x0100c344, 0x00103446, 0x10424410,
+0x08244301, 0x1f441011, 0x00000a00, 0x00000000, 0x20788004, 0x05340961,
+0x7b419290, 0x248dc501, 0x511c1007, 0x01c14072, 0x1e141705, 0xa1507342,
+0x14073401, 0x4872501c, 0xc72701c1, 0x13401e14, 0x00000200, 0x00000000,
+0x01a41012, 0x102c1883, 0x71ca5cb0, 0x0409c342, 0xc01c3817, 0x09c333f2,
+0x9c300f0c, 0x830373c0, 0x10273c01, 0x8132c02c, 0x032c00c3, 0x4bc10c30,
+0x00000040, 0x00000000, 0x402db802, 0x01dc087f, 0x3fc00f70, 0xdc48db00,
+0xc00f742b, 0x28ff003d, 0x0db2037c, 0xbf003dc2, 0xf083f808, 0x003dc08f,
+0x03dc08ff, 0x0bc01ff0, 0x00000660, 0x00000000, 0x0067a015, 0x024c0053,
+0x36900936, 0x5c04df00, 0xc201302b, 0x001f1807, 0x0130007c, 0x5fa007e0,
+0xf0004c01, 0x0007c001, 0x004c011f, 0x57c001f0, 0x00000e00, 0x00000000,
+0x30398812, 0x030400c1, 0x38400a10, 0xc490ed0b, 0x400e1203, 0x80e7003b,
+0x0e1203b4, 0xcd203b40, 0xd00384a0, 0x203b480e, 0x038480fd, 0x4b480ed2,
+0x00000620, 0x00000000, 0x00790003, 0x068403e1, 0x78401e10, 0xb409ed02,
+0x621e1097, 0x03ed007b, 0x1e1047b4, 0xed007b48, 0xd2078441, 0x00fb421e,
+0x078621ed, 0x0f401ed0, 0x00000400, 0x00000000, 0x02332812, 0x0b0413d1,
+0x30401c10, 0x4440cd00, 0x640e1003, 0x00f5023b, 0x2e148ff4, 0xed0c3f40,
+0xd003c421, 0x00bf483f, 0x23c742ed, 0x4b409fd2, 0x00000c20, 0x00000000,
+0x405da817, 0x09c50373, 0x16c07730, 0x7c805f08, 0xc2053001, 0x095f02d7,
+0x9530097c, 0x5f0897c6, 0xf0494d12, 0x0057c0a5, 0x8d4c045f, 0x5fc007f0,
+0x00000620, 0x00000000, 0x00870012, 0x487c821f, 0x07c841f2, 0x5c001f00,
+0xc023f000, 0x8037808f, 0xa3f048fc, 0x3f028fc8, 0xd290fc86, 0x008fc8a3,
+0x08fc063f, 0x4bc023f0, 0x00000c00, 0x00000000, 0x00270810, 0x024c019f,
+0x24c009b1, 0x4c818300, 0xc0493202, 0x809f0167, 0x9932064c, 0x931264c0,
+0x31027c41, 0x2c24c219, 0x427c0493, 0x40c01930, 0x00000c20, 0x00000000,
+0x00a62001, 0x0204069d, 0x24400910, 0x440a9130, 0x40091482, 0x039d21e7,
+0x09146e45, 0x9140a458, 0x140e74a0, 0x406451b9, 0x02700391, 0x0451a914,
+0x00000800, 0x00000000, 0x0024a018, 0x4344049d, 0x20500c90, 0x44109140,
+0x47091002, 0x18bd002f, 0x0a1182c4, 0xb1002c49, 0x1123f408, 0x062c400b,
+0x13f400b1, 0x60400b10, 0x00000200, 0x00000000, 0x02202010, 0x0204088d,
+0x20488812, 0x05808102, 0x422a1122, 0x02ad00ab, 0x2a100a84, 0xa100b848,
+0x100ab402, 0x20a8402a, 0x0ab442e1, 0x40402a10, 0x00000080, 0x00000000,
+0x0592b01d, 0x504d161f, 0x84d020b0, 0x4c941325, 0xc0013058, 0x801f0807,
+0x0130000c, 0x53200482, 0x30817c00, 0x0004c001, 0x017c0013, 0x74c00330,
+0x00000ac0, 0x00000000, 0x012fb819, 0x02fc04ff, 0x27c04bf0, 0x7c008f11,
+0xc229f012, 0x229f00a7, 0x29f08a7c, 0x9f00a7c8, 0xf00a7c02, 0x00a7c829,
+0x0a7c029f, 0x67c229f0, 0x00000e60, 0x00000000, 0x00afa018, 0x02fc02bf,
+0x24c00a70, 0x4c00b310, 0x4049321a, 0x82930524, 0x29300a4c, 0x930024c1,
+0x30a24c12, 0x9024c889, 0x024c049f, 0x63c06930, 0x00000e00, 0x00000000,
+0x1087081c, 0x0074021d, 0x04400510, 0x04001101, 0x50615008, 0x00114184,
+0x01142845, 0x11010450, 0x102944c0, 0xa78450a1, 0x584d141d, 0x73686314,
+0x00000c20, 0x00000000, 0x01a3a010, 0x0234068d, 0xa0400850, 0x0402c154,
+0x418a140a, 0x02a10428, 0x0a100284, 0xa144a842, 0x14128500, 0x0028404a,
+0x0aa402ad, 0x4340ca10, 0x00000e80, 0x00000000, 0xa425a818, 0x8274009d,
+0x24500910, 0x04009100, 0x41885002, 0x82b91028, 0x0b1002c4, 0xa1002c41,
+0x1103c490, 0x043c410b, 0x42c410fd, 0x63400b10, 0x00000620, 0x00000000,
+0x0027a805, 0x027c029f, 0x24c00970, 0x4d009300, 0xc0293002, 0x83930464,
+0x3930e244, 0x9306e4c0, 0x10064c0a, 0x00a4c039, 0x0e6c029d, 0x17404930,
+0x00000e20, 0x00000000, 0x02658014, 0x027c009f, 0x27c289f0, 0x7c008f00,
+0xc009b202, 0x85872967, 0x89f0023c, 0x9f0c63c0, 0xf0a63c20, 0x0567c298,
+0x263c058f, 0x53c059f0, 0x00000600, 0x00000000, 0x04850814, 0xa07c801f,
+0x02c021f0, 0x4c001300, 0xc1033000, 0x003f010c, 0x03f0c0fc, 0x3f008cc0,
+0xd100cc02, 0x008fc823, 0x88fcb23b, 0x50c023f0, 0x00000420, 0x00000000,
+0x00dca014, 0x2db4007d, 0x144007d1, 0x44207100, 0x50351001, 0x4b5d0414,
+0xa5d00574, 0x5d001450, 0xd0094502, 0x44d74075, 0x2d740351, 0x514017d0,
+0x00000200, 0x00000000, 0x02f2a014, 0x073410cd, 0x32400dd0, 0x3400c100,
+0x42be1003, 0x02ed1838, 0x0fd00394, 0xeda07840, 0xd0478490, 0x003b404e,
+0x07b401e1, 0x50421ed2, 0x00000a00, 0x00000000, 0x00288005, 0x03b400ed,
+0x384203d0, 0xb400e10b, 0x400c1413, 0x10ed0038, 0x0cd00bb4, 0xcd10b841,
+0xd00b84a0, 0x0073400e, 0x43b410e1, 0x15411ed0, 0x00000200, 0x00000000,
+0x00781015, 0x05bc012f, 0x7ec01ef3, 0xbc010341, 0xc01e303f, 0x41ee2078,
+0x1ef007be, 0xef0078c0, 0xf0878c41, 0x207bc41e, 0x07bc01e3, 0x54c01cf0,
+0x00000040, 0x00000000, 0x0025b810, 0x017c00df, 0xb74001f0, 0x4d201f05,
+0xc801f803, 0x001f2007, 0x01f0007c, 0x5f0007c0, 0xf0007c80, 0x0007c001,
+0x807c0017, 0x43c001f0, 0x00000660, 0x00000000, 0x007fa000, 0x06fc01ff,
+0x75c89cf0, 0x7c49f32a, 0xc01d3007, 0x81d30074, 0x1ff207fc, 0xd31877c4,
+0x30277c45, 0x007c409f, 0x27cc09f3, 0x00c21f30, 0x00000e00, 0x00000000,
+0x00398815, 0x02b4006d, 0x704092d0, 0xb481c102, 0x40555007, 0x0fc10074,
+0x5ed03784, 0xe106fb42, 0x1227b415, 0x203849ae, 0x2b8480e1, 0x54488e12,
+0x00000620, 0x00000000, 0x00190000, 0x02b4002d, 0x31404fd0, 0xb4042140,
+0x404a1013, 0x2ce1043a, 0x4e922384, 0xe9123b44, 0x5233b484, 0x203a608e,
+0x238400e1, 0x00401e18, 0x00000400, 0x00000000, 0x00132804, 0x0234034d,
+0x304201d2, 0x34000100, 0x561c9003, 0x06015482, 0x30d06c05, 0x59640344,
+0x16043491, 0x46427100, 0x04050901, 0x1051101c, 0x00000c20, 0x00000000,
+0x0155a815, 0x03708edf, 0x3dc001f0, 0xfc40d330, 0xc00d3003, 0x80d300b6,
+0x2db00b5e, 0x9b8077c0, 0x504b7c41, 0x0836c01d, 0x4f4c01d3, 0x54c10d30,
+0x00000620, 0x00000000, 0x00070001, 0x227c009f, 0x37c02df0, 0x3c025f00,
+0xc08d7203, 0x08df0035, 0xadfb0b5e, 0x930037c0, 0xb04b7c02, 0x0835e00d,
+0x1b7c00df, 0x07c00df0, 0x00000c00, 0x00000000, 0x001b0880, 0x15bc0933,
+0x38d01334, 0x7c01fb00, 0xc90e7003, 0x00f30038, 0x9ff117fc, 0xbd217fc9,
+0xf107c881, 0x003fc80f, 0x03f093ff, 0x03c00ff2, 0x00000c22, 0x00000000,
+0x04c62081, 0x88740191, 0x35009d12, 0x74185500, 0x40010003, 0x09115684,
+0x01d00074, 0x1d10074c, 0xd00c449a, 0x0ac74681, 0x2864621d, 0x074091d1,
+0x00000802, 0x00000000, 0x0224a001, 0x097400d1, 0x36002110, 0x74009900,
+0x420dc003, 0x00110004, 0x01d08854, 0x15000741, 0xd0105500, 0x08074001,
+0x0074201d, 0x074209d0, 0x00000200, 0x00000000, 0x08202010, 0x00240001,
+0x30444c10, 0x34000101, 0x40441ac3, 0x10010880, 0x80d01836, 0x0d950342,
+0xd0201440, 0x00034000, 0x0024000d, 0x434008d0, 0x00000080, 0x00000000,
+0x4006b000, 0x017e2013, 0xfcc0b130, 0xfc059b02, 0xc0f97007, 0x21030844,
+0x71f0147c, 0x1f0043c1, 0xf01c1c1b, 0x0003c000, 0x003c000f, 0x03c008f0,
+0x00000ac0, 0x00000000, 0x080fb805, 0x00fe003f, 0x7f40dff0, 0xfc131f02,
+0xc89fb147, 0x15ff00ff, 0x5df01f74, 0xbf047fc0, 0xf237ec05, 0x003fc00f,
+0x03fc40ff, 0x17c007f0, 0x00000e60, 0x00000000, 0x0b0f8003, 0x33cc8c3f,
+0x2bc003f0, 0xfc063342, 0xc00fb033, 0x00ff003f, 0x0ff003cc, 0xbf003cc0,
+0x3003fc00, 0x003dc00f, 0x03cc00f3, 0x0cc007f0, 0x00000e00, 0x00000000,
+0x03070801, 0x324c0e5d, 0xaf40e1d0, 0x74061100, 0x4809100b, 0x800d0007,
+0x01d28064, 0x1d000450, 0x14007420, 0x00045001, 0x00440011, 0x044009d0,
+0x00000c20, 0x00000000, 0x0123a011, 0x1124000d, 0xa1490050, 0x34820521,
+0x4004908b, 0x800d2001, 0x00d20025, 0x0d000160, 0x92003480, 0x60004200,
+0x00270009, 0x445008d0, 0x00000e80, 0x00000000, 0x0005a807, 0x0044041d,
+0x276001d0, 0x74005100, 0x000d1003, 0x021d0507, 0x61d80064, 0x1d000440,
+0x90007620, 0x00844001, 0x00640819, 0x0c0009d0, 0x00000620, 0x00000000,
+0x00c7a802, 0x326d031d, 0x27c0d5f0, 0x7c801700, 0x847db003, 0x081f00c7,
+0x01f0144c, 0x1f0105c0, 0x90687c02, 0x0084c051, 0x386c011b, 0x08c281f2,
+0x00000e20, 0x00000000, 0x02158003, 0x02fc016f, 0x2ec01ff0, 0xa0083f00,
+0xc049f00b, 0x01ff0077, 0x1df00f5c, 0x9f0277c0, 0x70077c08, 0x0936c09d,
+0x075c00d3, 0x1fc01dd0, 0x00000600, 0x00000000, 0x44a50802, 0x004c089f,
+0x23c40530, 0x7c005304, 0xd005b807, 0x0ec340b4, 0x2d34035c, 0x934034d0,
+0x740b4d00, 0x4034d00d, 0x034d02d3, 0x08d00d34, 0x00000420, 0x00000000,
+0x00d48017, 0x10450890, 0x2c400db0, 0x5c055108, 0x42bd1807, 0x02d10af4,
+0xbd102f45, 0x9b0af400, 0x10af442b, 0x02f442bd, 0xaf440bd0, 0x4c40bd10,
+0x00000200, 0x00000000, 0x0212a007, 0x11040381, 0xa0400811, 0x24000100,
+0x40001083, 0x81010001, 0x01920004, 0x41000200, 0x10006400, 0x08044001,
+0x00240010, 0x1d400110, 0x00000a00, 0x00000000, 0x00688004, 0x058401e1,
+0x6c481898, 0xd4016100, 0x410e1007, 0x81e11479, 0x1e904786, 0xe9047a41,
+0x1047a411, 0x0478411e, 0xc7a431e1, 0x11419e10, 0x00000200, 0x00000000,
+0x80b01012, 0x214c4c53, 0x21c24c30, 0x3c080300, 0xe80c1003, 0x88c32031,
+0x4cb0031c, 0xc30132c0, 0x70132c02, 0x0230c00c, 0x132c02c3, 0x49c00c30,
+0x00000040, 0x00000000, 0x002db802, 0x01fc0874, 0xadc00fe0, 0xbc205f44,
+0xe00f7043, 0x08fe023e, 0x0d70037c, 0xf7003de0, 0xf003dc08, 0x203fc08f,
+0x03dc00ff, 0x0ac21ff8, 0x00000660, 0x00000000, 0x4017b011, 0x027c009b,
+0xa7ca01f0, 0x3c945b00, 0xd0013407, 0x00130804, 0x0134007c, 0x534007c0,
+0xf2804d80, 0x0007c001, 0x007c001f, 0x54d001f0, 0x00000e00, 0x00000000,
+0x803d8012, 0x03b420e3, 0x2f440ad0, 0x9c006101, 0x400f1013, 0x20e1003c,
+0x0e1003b4, 0xf1803b40, 0x70038400, 0x003b420e, 0x03a400ed, 0x48400ed0,
+0x00000620, 0x00000000, 0x00790003, 0x0eb401e5, 0x6b4016d0, 0xf4016100,
+0x401e1007, 0x01e5007a, 0x1e5887b4, 0xe9887b40, 0xd0078621, 0x007b401e,
+0x07b401ed, 0x0c401ed0, 0x00000400, 0x00000000, 0x80332812, 0x1f3640c5,
+0x23401dd8, 0x14004940, 0x400e1003, 0x1be544b8, 0x1e103bb4, 0xe900bb40,
+0x500b8012, 0x243b404e, 0x0ba40bed, 0x48400ed0, 0x00000c20, 0x00000000,
+0x081da817, 0x0df40277, 0x1740d7d0, 0xf4855b00, 0xe0053000, 0x025701d4,
+0xc570017c, 0x5b041740, 0xf0154400, 0x24174125, 0x1d7c005f, 0x5cc107f0,
+0x00000620, 0x00000000, 0x00070012, 0x007c9010, 0x07c001b0, 0x5c001700,
+0xe002f200, 0x003b008b, 0x22d008bc, 0x27210bca, 0x7010bc80, 0x000bc002,
+0xc0b0102f, 0x4bc022f2, 0x00000c00, 0x00000000, 0x02270810, 0x021c2593,
+0x25c20970, 0x7c00d300, 0xc009f000, 0x20932026, 0x0930027c, 0x932165ca,
+0x31026c00, 0x0024c009, 0x824c0093, 0x40c00938, 0x00000c20, 0x00000000,
+0x00662001, 0x0a744195, 0xe0480910, 0x5c499100, 0x5009d802, 0x209140a4,
+0x29144a74, 0x9b406459, 0x14024580, 0x4024d809, 0x02450491, 0x045d2904,
+0x00000800, 0x00000000, 0x0820a018, 0x427400d9, 0x24600958, 0x74009145,
+0x4219d0a2, 0x00b1002c, 0x0b1002f6, 0xb1882c40, 0x1002c400, 0x802e400b,
+0x02c400b1, 0x62400b90, 0x00000200, 0x00000000, 0x02202210, 0x0a3408c5,
+0x2441c810, 0x34088100, 0x403ad022, 0x02a100b8, 0x2a100ab4, 0xa980a840,
+0x100a8402, 0x00aa402a, 0x0a8482a1, 0x42402a18, 0x00000080, 0x00000000,
+0xa586a01d, 0x005c161b, 0x05d06170, 0x7c561305, 0xc001d0d8, 0x00130004,
+0x01300034, 0x130001c0, 0x32004c00, 0x0006e001, 0x814c0013, 0x76c20230,
+0x00000ac0, 0x00000000, 0x212f8819, 0x0afc04bf, 0x2fc04bf1, 0xdc049f0d,
+0x4029f010, 0x029f00a5, 0x29f20a7c, 0xd720a7c0, 0xe20a7c02, 0x00b5c02d,
+0x0a7c029f, 0x65c029f0, 0x00000e60, 0x00000000, 0x133faa18, 0x0afc10bf,
+0xa8c06978, 0xdc029301, 0xc049301d, 0x629f0224, 0x69f0027c, 0x9f8627c1,
+0xf0327c0c, 0x2827ca49, 0x0a7c209f, 0x63c009f0, 0x00000e00, 0x00000000,
+0x0307001c, 0x0874001d, 0x046441d0, 0x64001140, 0x5061101c, 0x421d0294,
+0x21d29874, 0x1d218748, 0xd0917484, 0x00074141, 0x0834021d, 0x734143d0,
+0x00000c20, 0x00000000, 0xa123a010, 0x1a34908d, 0xa2406850, 0x14068100,
+0x418a108a, 0x06ad0128, 0x4ad04ab4, 0xa5002b60, 0xd00ab402, 0x05ab402a,
+0x0ab416ad, 0x43402ad0, 0x00000e80, 0x00000000, 0xa425a818, 0x8274009d,
+0x264208d0, 0x64409110, 0x42491102, 0x00bd002c, 0x0bd802f4, 0xbd212f6b,
+0xd012f600, 0x002f440b, 0x8af410bd, 0x63404bd0, 0x00000620, 0x00000000,
+0x0027a005, 0x127cb09f, 0x26500970, 0x5c009300, 0xc1293402, 0x1b9f02e4,
+0x39f06e7c, 0x9f0127c4, 0xd08e7c03, 0x0267c899, 0x027c039d, 0x17c049f0,
+0x00000e20, 0x00000000, 0x00258014, 0x027c459f, 0x21c099f0, 0x6c08df00,
+0xc009f020, 0x009f0067, 0x99f0027c, 0x9f0067c8, 0xf0027c02, 0x0827c309,
+0x167c229f, 0x53c009f0, 0x00000600, 0x00000000, 0x00850014, 0x007c801f,
+0x07c80172, 0x6d001300, 0xd003f200, 0x0037000c, 0x233000cc, 0x33048fc0,
+0xf000fc00, 0x200fc003, 0x08fc023f, 0x53c02330, 0x00000420, 0x00000000,
+0x001ca014, 0x41dc007d, 0x1f400510, 0x44405106, 0x4005d084, 0x005c0814,
+0x05148145, 0x55401748, 0xd1817400, 0x08170605, 0x0174605d, 0x53400714,
+0x00000200, 0x00000000, 0x01328014, 0x032408cd, 0xf3400c50, 0x44894100,
+0x400dd007, 0x08c50230, 0x0c900324, 0xc1003364, 0xd023341a, 0x0233408c,
+0x233400cd, 0x53400c10, 0x00000a00, 0x00000000, 0x00388805, 0x049440ad,
+0x3f404e10, 0x84016140, 0x4002d073, 0x212d0008, 0x029004a4, 0x21004b62,
+0x9000b400, 0x000b4002, 0x84b4002d, 0x17400210, 0x00000200, 0x00000000,
+0x00780015, 0x073c016f, 0x5bc01e7a, 0x8c894300, 0xc013f207, 0x01f70058,
+0x16b005ec, 0xe3006fc0, 0xf007bc01, 0x007bc01e, 0x05bc016f, 0x57c01632,
+0x00000040, 0x00000000, 0x2025a810, 0x025c001f, 0x17e16de0, 0x5c005f00,
+0xc80df003, 0x801f2027, 0x0970025c, 0x1f2017c8, 0xf2007c80, 0x0007c801,
+0x027c809f, 0x43c009f0, 0x00000660, 0x00000000, 0x027fa000, 0x06ca49ff,
+0x7fc11ff0, 0xbc017f00, 0xc01f3007, 0x09bb426c, 0x9ff017fc, 0x3f025fc0,
+0xf026fc09, 0x026fc093, 0x36cd09ff, 0x03c01f34, 0x00000e00, 0x00000000,
+0x00198015, 0x188620ed, 0x1bc00ed8, 0xb4802d02, 0x40031003, 0x0c610018,
+0x829000b4, 0xed232a40, 0xd101b408, 0x001b440e, 0x31ec002d, 0x574802b0,
+0x00000620, 0x00000000, 0x08390200, 0xc284002d, 0x2b400ed0, 0xf4086d00,
+0x41021003, 0x00a10008, 0x86d811b4, 0x2d000960, 0x5002b408, 0x042b4102,
+0x3096006d, 0x034016d0, 0x00000400, 0x00000000, 0x24032804, 0x0604210d,
+0x01402cd0, 0x34000c00, 0x402c1003, 0x004500f0, 0xb8902234, 0xcd023260,
+0xd00d3403, 0x00d3403c, 0x0f160d8d, 0x13403850, 0x00000c20, 0x00000000,
+0x2805a815, 0x054405dd, 0x27400fd0, 0x7c055c00, 0xd09d3d17, 0x81530274,
+0x19f02a7c, 0xdf02f5c0, 0xf0497410, 0x0057401d, 0x4f54009f, 0x57c0a9d0,
+0x00000620, 0x00000000, 0x22330001, 0x017c020d, 0x27c10df2, 0x7c005f10,
+0xc801f003, 0x08930207, 0x05c0017c, 0x1f200748, 0xf01a7404, 0x28a7c001,
+0x0064805f, 0x07808580, 0x00000c00, 0x00000000, 0x020f0880, 0x05ec20fb,
+0x0cc40e72, 0xcc003300, 0xc003f003, 0x106f101c, 0x03f004cc, 0xff002c43,
+0x3281fc00, 0x041cc30f, 0x41fc0033, 0x03c213f0, 0x00000c22, 0x00000000,
+0x00a62081, 0x0f450411, 0x04400d10, 0x4d091110, 0x500dd003, 0x129d2024,
+0x9dd20745, 0x1d0014d0, 0x16124580, 0x4124d001, 0x025c48d5, 0x07401dd1,
+0x00000802, 0x00000000, 0x0084a001, 0x100400d1, 0x30400d50, 0x44804102,
+0x400cd293, 0x001d0024, 0x08d01244, 0x0d801540, 0x10000400, 0x00024000,
+0x02740091, 0x074049d0, 0x00000200, 0x00000000, 0x40102010, 0x01040041,
+0x10500c10, 0x04000100, 0x4000d003, 0x20cd8810, 0x04d00104, 0xcd902140,
+0x18030420, 0x0032420c, 0x81042041, 0x43400498, 0x00000080, 0x00000000,
+0x0006a000, 0x004c2083, 0x24c00f70, 0x44001340, 0xc001f003, 0x001f0000,
+0x01f00044, 0x1f000540, 0x32005c00, 0x0006e001, 0x007c0003, 0x03c001f0,
+0x00000ac0, 0x00000000, 0x800f9805, 0x03dc803f, 0x0fc00ff8, 0xdc003f00,
+0x400ff103, 0x00fc003f, 0x0ff003fc, 0xff003cc2, 0xf003de00, 0x003dc00f,
+0x03dc00ff, 0x17c00ff1, 0x00000e40, 0x00000000, 0x000fa003, 0x00fc083f,
+0x8fe003f0, 0xed801300, 0xc003f000, 0x003f000c, 0x01f0007c, 0xff203f80,
+0xf100f400, 0x006cc057, 0x03cc01bb, 0x0cc403f3, 0x00000e00, 0x00000000,
+0x00370801, 0x037400dd, 0x37410df0, 0x4400d500, 0x080dd003, 0x20cd0030,
+0x0dd00374, 0xdd003640, 0xd0002400, 0x20154005, 0x03540a55, 0x054005d0,
+0x00000c20, 0x00000000, 0x0013a011, 0x0234000d, 0x134048d0, 0x24000501,
+0x5200d003, 0x004d0012, 0x04d20034, 0xcd303360, 0x92003420, 0x02004284,
+0x0304808d, 0x446001d8, 0x00000e80, 0x00000000, 0x0035a803, 0x017400dd,
+0x27400550, 0x4402d518, 0x422cd000, 0x009d0826, 0x09908b64, 0xdd803641,
+0xd2a06480, 0x00354005, 0x83500055, 0x0d4101da, 0x00000620, 0x00000000,
+0x0077a802, 0x017c00df, 0x274605d0, 0x6c005718, 0xc401f800, 0x041f0026,
+0x01f0017c, 0xdf003740, 0xb3407c89, 0x008cc047, 0x024c00bf, 0x08802cf0,
+0x00000e20, 0x00000000, 0x00dd8007, 0x02fc003f, 0x1fc80bf0, 0xfc20bf00,
+0xc02ff803, 0x00ff101d, 0x0ff082fc, 0xff143fc4, 0xf000ec31, 0x003bc907,
+0x02fc204f, 0x1f810ff0, 0x00000600, 0x00000000, 0x00350802, 0x037c00db,
+0x36c04df0, 0x7c025b20, 0xc0e1f003, 0x12530437, 0xe5f0694c, 0xdf1036c0,
+0x31097c00, 0x0307c084, 0x034d0c97, 0x0bc00df0, 0x00000420, 0x00000000,
+0x0014a013, 0x80742d11, 0x874021d0, 0x74009c08, 0x401dd000, 0x82914047,
+0x29d00a45, 0xdd00fd52, 0x14057660, 0x00b74025, 0x43440251, 0x4dc23d71,
+0x00000200, 0x00000000, 0x0212a007, 0x1c240009, 0x076000d0, 0x34009d01,
+0x402cd000, 0x4a812083, 0x28d00604, 0xcd023140, 0x111434c0, 0x8043441c,
+0x1f340181, 0x1f4018d0, 0x00000a00, 0x00000000, 0x20788004, 0x47b401e1,
+0x7b405ed0, 0xb4016d04, 0x4212d01f, 0x0d61007b, 0x56d02584, 0xed107940,
+0x1034b409, 0x0833481e, 0x87a44161, 0x114c1e50, 0x00000200, 0x00000000,
+0x01141012, 0x023c000b, 0x53c058f0, 0x3c018f03, 0xc0dcf017, 0x0dc30653,
+0xddf0160c, 0xcd0371c0, 0x30573419, 0x0203c00c, 0x033c0083, 0x4bc300f8,
+0x00000040, 0x00000000, 0x403db802, 0x01f400ff, 0x27c087f0, 0xfc005f10,
+0xc003f000, 0x001e1027, 0x93f801fc, 0xff053cc8, 0xf123fc40, 0x013fc08f,
+0x23dc017f, 0x0be403f0, 0x00000660, 0x00000000, 0x1037a015, 0x017c80d3,
+0x27c005f0, 0x5c00d700, 0xc00df000, 0x019c0027, 0x0934034d, 0xd3407784,
+0x32064f21, 0x6044d21d, 0x86490093, 0x54901d3c, 0x00000e08, 0x00000000,
+0x00118812, 0x02b40021, 0x1b420ad0, 0xac003d08, 0x0402d283, 0x207d201b,
+0x061000c4, 0xe10139c0, 0x10828600, 0x003c400f, 0x02c40071, 0x48600f38,
+0x00000620, 0x00000000, 0x047d0003, 0x07b401e1, 0x7b403ed0, 0xb611ed00,
+0x401ed007, 0x01e9007b, 0x1e910784, 0xe1007b48, 0x1207c411, 0x0048401e,
+0x079401ad, 0x0c4c1e10, 0x00000400, 0x00000000, 0x04d72812, 0x24341201,
+0x874001d0, 0x24001d01, 0x4001d800, 0x200d0003, 0x00902004, 0x81003140,
+0x102f0601, 0x09b0420c, 0x27040049, 0x48408c12, 0x00000c20, 0x00000000,
+0x4095a817, 0x057c1053, 0x97c015f0, 0x7c005700, 0xc005fa01, 0x605b1017,
+0x05b0854c, 0x530017c4, 0x0001cc00, 0x00944005, 0x015c207b, 0x5c403730,
+0x00000620, 0x00000000, 0x000f0012, 0x00fc403f, 0x0fc403f1, 0xfc003f00,
+0xc023f808, 0x003f000f, 0x237108fc, 0x1f108740, 0xf5486c80, 0x100fcc21,
+0x08604227, 0x4bc10170, 0x00000c00, 0x00000000, 0x02670810, 0x027c009b,
+0x24c019f0, 0x6c209b00, 0xc219f00e, 0x039f04e4, 0x1930267c, 0x9f00e70a,
+0xf0027c22, 0x0027c259, 0x164c059f, 0x42c009f0, 0x00000c20, 0x00000000,
+0x00262001, 0x02741091, 0xa44aa9d8, 0x44009300, 0x5479d04a, 0x039f00e4,
+0x09140274, 0x9d10e64a, 0x70367c00, 0x00e74049, 0x1244849d, 0x05c039d0,
+0x00000800, 0x00000000, 0x00248018, 0x12f400b9, 0xac402bd3, 0xe640b100,
+0x404bd002, 0x22bd042c, 0x8b1042b4, 0x9d102762, 0xd0827480, 0xb1bf4809,
+0x024400bd, 0x624069d0, 0x00000200, 0x00000000, 0x02282010, 0x02b408a1,
+0x28608ad0, 0x8428a102, 0x422ad002, 0x02a588a8, 0x2a120ab4, 0xcd00b248,
+0x500a1422, 0x00ab4028, 0x8a0402ad, 0x434028d0, 0x00000080, 0x00000000,
+0x0086b01d, 0x017c221b, 0x84d021d0, 0x6c021300, 0x4201f000, 0x001d0804,
+0x0730007c, 0x0f000380, 0xe0807480, 0x2007c001, 0x004d003f, 0x76e001f2,
+0x00000ac0, 0x00000000, 0x012fb819, 0x027c049f, 0x27c049f0, 0x7c049f41,
+0xc409f002, 0x009f2027, 0x09e0027c, 0xbf00a7c0, 0x6082bc20, 0x00a7c029,
+0x82fc829f, 0x65c00bf0, 0x00000e60, 0x00000000, 0x002fa018, 0x02bc02b3,
+0x2cc00b70, 0xec089310, 0xc0093002, 0x809608a7, 0x29c0027c, 0x8f11a748,
+0xf0823c00, 0x00e4c499, 0x024c0793, 0x638029f0, 0x00000e00, 0x00000000,
+0x0107081c, 0x00740011, 0x00400170, 0x44001500, 0xc1411001, 0x40100105,
+0x41920074, 0x17000740, 0x92117640, 0x03044001, 0x50440411, 0x720047d2,
+0x00000c20, 0x00000000, 0x0423a010, 0x03348081, 0x205008d1, 0x25048100,
+0x440a1102, 0x14a1692b, 0x4ad052b4, 0xad222b64, 0x9042b490, 0x0128406a,
+0x02a4ccad, 0x43404ad0, 0x00000e80, 0x00000000, 0x4025a818, 0x82740091,
+0x244008d0, 0x46009500, 0x48091c02, 0x04f1002f, 0x0b9102f4, 0xb5003f02,
+0x9003f408, 0x082c400b, 0x12f440f9, 0x62448bd0, 0x00000620, 0x00000000,
+0x0027a805, 0x427c0093, 0x64c109f0, 0x2c809328, 0xc0093006, 0x00930067,
+0x19f0827c, 0x9f0827c0, 0xb0067400, 0x0424d009, 0x026c009b, 0x178009f0,
+0x00000e20, 0x00000000, 0x00e58014, 0x027c009f, 0x27c00970, 0x7c009f02,
+0xc009f212, 0x409f1125, 0x89b0027c, 0x970027c0, 0xb0ca7c40, 0x0027c009,
+0x424c0097, 0x52c009f0, 0x00000600, 0x00000000, 0x00050814, 0x005c5013,
+0x04c001b0, 0x6c001300, 0xc003f008, 0x843f100f, 0x43f000fc, 0x33000fc4,
+0xa180cc00, 0x248bc0c2, 0x00c00823, 0x53c003f2, 0x00000420, 0x00000000,
+0x0014a014, 0x21c41071, 0x1c4c0711, 0xc4005100, 0x4005d04d, 0xc25d0057,
+0x05d00974, 0x51509740, 0x50095413, 0x00d5c005, 0x09440b51, 0x534217d0,
+0x00000200, 0x00000000, 0x0036a014, 0x8b1483c1, 0x74500c90, 0x0480d100,
+0x420ed04f, 0x0be5013f, 0x3ed063b4, 0xe1863b22, 0x90878410, 0x403b402e,
+0x079501e1, 0x53400ed0, 0x00000a00, 0x00000000, 0x40288005, 0x078401a1,
+0x08440610, 0x8400e144, 0x420ed003, 0x00ed043b, 0x2ed003b4, 0xf1207b44,
+0x000fd481, 0x0479400e, 0x0b9401e1, 0x17410ed0, 0x00000200, 0x00000000,
+0x006c1015, 0x079c0173, 0x58d013b0, 0x8d05f300, 0xc01ef004, 0xe1ef007b,
+0x1ef907b4, 0xe3007fc0, 0xb1078e81, 0x1033c81e, 0x879c00c3, 0x57c01ef2,
+0x00000040, 0x00000000, 0x0025b810, 0x0174001f, 0x27c009f0, 0x5c60df08,
+0x4401f000, 0x001f0007, 0x01f8007c, 0x5f000780, 0xe0007c00, 0x0807c001,
+0x806c201d, 0x43c001b8, 0x00000660, 0x00000000, 0x407fa000, 0x05fc01f3,
+0x6fc01df0, 0x4c59ff00, 0xc09ff027, 0x29f3227f, 0x1df1a77c, 0x97107704,
+0xb6277c09, 0x407cd21f, 0x07cd01f3, 0x00d01f34, 0x00000e00, 0x00000000,
+0x022d8015, 0x21bc0021, 0x538054d0, 0x2c81fd01, 0x40dcd105, 0x0dc727f2,
+0x1ed02fa6, 0x81017341, 0xb0177c19, 0x003ac00e, 0x23ac00e3, 0x54400eb0,
+0x00000620, 0x00000000, 0x00290800, 0x03b400e1, 0x0b40c2d0, 0x8404ed02,
+0x424ed853, 0x24e5823b, 0x0ed933b4, 0xa5013b44, 0x1023b404, 0x0038400e,
+0x038400e9, 0x00401e10, 0x00000400, 0x00000000, 0x00632804, 0x19101101,
+0x3140a8d0, 0x2504dd10, 0x4020d001, 0x03050083, 0x10d22c24, 0x11000340,
+0x10001401, 0x02c00000, 0x00000b01, 0x10401010, 0x00000c20, 0x00000000,
+0x01f5a815, 0x033001d3, 0xb74a29f0, 0x0c83ff00, 0xc02df103, 0x53d70277,
+0xbdf0a37c, 0xd71837c0, 0x10033401, 0x00b4020d, 0x034002da, 0x54c04c10,
+0x00000620, 0x00000000, 0x01270001, 0x077c08df, 0x07c441f0, 0x7d08df06,
+0xc1a5f213, 0x22df00b6, 0x2df0836c, 0xdf8037e0, 0xf00b7c42, 0x01b7c02d,
+0x0b7c44df, 0x07c00df0, 0x00000c00, 0x00000000, 0x802f0880, 0x03cd0273,
+0x1cc04730, 0xfc80f320, 0xc05bb200, 0x11ff00bf, 0x0ff017fc, 0xf310b242,
+0x300fcd40, 0x083bc05f, 0x07cc01e3, 0x00c00f30, 0x00000c22, 0x00000000,
+0x20222081, 0x01440155, 0x24400d50, 0x4400db00, 0x487d3000, 0x0a1d2047,
+0x11d00874, 0x55200450, 0x50004410, 0x03c74471, 0x40144211, 0x06c29151,
+0x00000802, 0x00000000, 0x00348001, 0x05464081, 0x20400810, 0x7400d108,
+0x400d9012, 0x001d8007, 0xa0d00074, 0x11000542, 0x18004400, 0x00074001,
+0x10440411, 0x04400911, 0x00000200, 0x00000000, 0x00242010, 0x01060005,
+0x10506050, 0x0480c901, 0x49041110, 0x040d1803, 0x00d02034, 0x05030140,
+0x50584464, 0x40024000, 0x00450001, 0x42400950, 0x00000080, 0x00000000,
+0x0026a000, 0x034e0091, 0xc4c07530, 0x7c07d300, 0xc0f9b0ae, 0x091f03c7,
+0x31f00c7c, 0x130047c0, 0x301c440b, 0x1003c000, 0x800c0003, 0x00c00830,
+0x00000ac0, 0x00000000, 0x002fa805, 0x00fc003f, 0xf7c89ff0, 0xfc97dd05,
+0xc01d721c, 0x0ddf2277, 0x9ff137fc, 0xbf08fec1, 0xf987fc07, 0x003fe40f,
+0x03fe00ff, 0x17c007f8, 0x00000e60, 0x00000000, 0x003fa003, 0x03cc08f3,
+0x3f440f70, 0xcc00ff00, 0xc00ff183, 0xc0ff303f, 0x0fb103c4, 0xf6183c80,
+0x3003fc40, 0x003cc00f, 0x03bcc0f3, 0x0ed40f81, 0x00000e00, 0x00000000,
+0x10070801, 0x00450411, 0x070001b0, 0x54001d00, 0xc001d000, 0x001d0005,
+0x00500054, 0x15080548, 0x12007400, 0x00044801, 0x03f40011, 0x04410f50,
+0x00000c20, 0x00000000, 0x40210015, 0x001080c1, 0x32480810, 0x0480cd20,
+0x0008d203, 0x80cd2023, 0x0c520314, 0xc1202148, 0x10033080, 0x0030400c,
+0x033400c9, 0x45404c50, 0x00000e80, 0x00000000, 0x2017a807, 0x83540011,
+0x07600510, 0x54041d00, 0x40059000, 0x001d0014, 0x41500054, 0x15101540,
+0x14106400, 0x40045001, 0x83742019, 0x0c400d50, 0x00000620, 0x00000000,
+0x001fa882, 0x03dc82b3, 0x1ec00714, 0xcc007f08, 0xc007e000, 0x003f001f,
+0x077000dc, 0x37001dc0, 0x3001fc40, 0x025cc097, 0x037c897b, 0x0bc00cb4,
+0x00000e20, 0x00000000, 0x00298007, 0x006c006f, 0xafc00bb3, 0xfc41bf00,
+0xc00bf003, 0x00ff102f, 0x1af003fc, 0xff002fc4, 0xf006fc00, 0x002fc009,
+0x03fc00b7, 0x1fc00fb1, 0x00000600, 0x00000000, 0x00050802, 0x101c4593,
+0x17c04130, 0x4c044301, 0xc041f010, 0x04030104, 0x45b0100c, 0x131100c0,
+0x30114c04, 0x0214c045, 0x233c0c5f, 0x0bc40db0, 0x00000420, 0x00000000,
+0x0174a013, 0x07440051, 0x67401d90, 0x44039100, 0xc01dd007, 0x01d10076,
+0x19100744, 0xd0007440, 0x10064401, 0x08e44019, 0x03f4209d, 0x4f400fa0,
+0x00000200, 0x00000000, 0x0072a007, 0x0b240041, 0xa2402c90, 0x34028500,
+0x402cd08b, 0x02c900b0, 0x28100b04, 0xc800b240, 0x100a4402, 0x01e44029,
+0x4334038d, 0x1e424c10, 0x00000a00, 0x00000000, 0x00408004, 0x24a401a1,
+0x5b401294, 0xa4016140, 0x4210d004, 0x0929004a, 0x161c0484, 0x29024a40,
+0x10010501, 0x00584006, 0x07a4016d, 0x13401e90, 0x00000200, 0x00000000,
+0x40201012, 0x40348453, 0x26c14834, 0x3c109704, 0xc108f043, 0x18db0424,
+0x0830434c, 0xd90626c1, 0x30720c10, 0x0020c188, 0x033c008f, 0x4bc04c30,
+0x00000040, 0x00000000, 0x001db802, 0x83dd00bf, 0x1fc00750, 0xdd807f00,
+0xc807f000, 0x2837421f, 0x057000fd, 0x174215d0, 0xf0117c08, 0x001fc047,
+0x03fc417e, 0x0bc12ff0, 0x00000660, 0x00000000, 0x40512810, 0x034d0013,
+0x44c00530, 0x4c001300, 0xc0053800, 0x00100014, 0x0130004c, 0x130015d0,
+0x32006c00, 0x2844c811, 0x0b740013, 0x56801df0, 0x00000e00, 0x00000000,
+0x0029091a, 0x008400c1, 0x38480a11, 0x8440e100, 0x480a0003, 0x00e3002a,
+0x0e120384, 0xe1202842, 0x10038480, 0x0038400e, 0x33b400e1, 0x48404fd0,
+0x00000600, 0x00000000, 0x00490000, 0x04a4112d, 0x4a401290, 0xa4612900,
+0x4012d204, 0xa1298049, 0x109084a4, 0x2d004a40, 0x10049401, 0x00484012,
+0xb7b4a121, 0x0e405ed0, 0x00000400, 0x00000000, 0x00b12812, 0x030401cd,
+0xb2406d90, 0x6406c901, 0x406dd01f, 0x07c101b1, 0x6d901f24, 0xc104b240,
+0x101b1407, 0x01b0406c, 0x033406c1, 0x48400cd0, 0x00000c20, 0x00000000,
+0x00158017, 0x016d005f, 0x96e025b8, 0x64425b00, 0xc025f00d, 0x035b0095,
+0x25b00d6c, 0x5f009640, 0x30095c43, 0x0094c025, 0x017c0273, 0x5ec005d0,
+0x00000620, 0x00000000, 0x200f0812, 0x80dc0233, 0x8dd42376, 0xdd023750,
+0x50232420, 0x083f600e, 0x037420dd, 0x3c608cc0, 0xf400e10a, 0x400fd003,
+0x087c003f, 0x4bc001d0, 0x00000c00, 0x00000000, 0x06270810, 0x020c058f,
+0x64c29930, 0x4e008f00, 0xc0093002, 0x40870860, 0x0930020c, 0x832020c0,
+0x31060c00, 0x0027c019, 0x063c009f, 0x43c00930, 0x00000c20, 0x00000000,
+0x00260001, 0x0244049d, 0x64e0293c, 0x6e009f02, 0xc129b002, 0x009b0266,
+0x09b0026c, 0x9b04a4c0, 0xb0266c12, 0x00274099, 0x2274009d, 0x07400910,
+0x00000800, 0x00000000, 0x00248018, 0x82c600fd, 0x2e500b90, 0xc450bd20,
+0x400b1002, 0x00b5002c, 0x0b1002c4, 0xb1002c40, 0x9002c400, 0x002f400b,
+0x027480b9, 0x63400910, 0x00000200, 0x00000000, 0x00282010, 0x0a8508ad,
+0xa8402e18, 0xa422a500, 0x402a100a, 0x02a100a8, 0x2a900aa4, 0xa920aa44,
+0x900aa402, 0x00ab482a, 0x023480ad, 0x43482814, 0x000000a0, 0x00000000,
+0x0006b01d, 0x0004021d, 0x12400090, 0x04000d00, 0x40001000, 0x00050000,
+0x0130000c, 0x030000c0, 0xb0000c00, 0x0003c000, 0x017c003f, 0x77c20130,
+0x00000a80, 0x00000000, 0x00a79911, 0x0a7c269f, 0xa7c029f0, 0x7c029f00,
+0xd029f40a, 0x029f10a7, 0x29f00a78, 0x9f10a5d4, 0xf00a7e02, 0x00a7c029,
+0x0a7c029f, 0x67c029f8, 0x00000e20, 0x00000000, 0x016fa018, 0x1e4c0db7,
+0x64c05930, 0x7c079301, 0xc059301e, 0x05930167, 0x79f0164c, 0x9f8167c0,
+0xf0164c05, 0x0167c059, 0x02cc0593, 0x60d06b78, 0x00000e00, 0x00000000,
+0x1287081c, 0x28400e1d, 0x8540a100, 0x5c0a1502, 0x40a15028, 0x0a152287,
+0xa1d02844, 0x1d028448, 0xd0005e0a, 0x00074001, 0x08440031, 0x704041d8,
+0x00000c20, 0x00000000, 0x0023a012, 0x12a5048d, 0x28410a14, 0xb404a144,
+0x410a1012, 0x10a5042b, 0x4a504295, 0xad042a40, 0x904a9410, 0x04ab412a,
+0x0a0502a1, 0x40406850, 0x00000e80, 0x00000000, 0x0025a818, 0x0a44009d,
+0x2d440b18, 0xf400b500, 0x404b5002, 0x00b5012e, 0x0bd202d4, 0xbd012c40,
+0xd002d400, 0x002f400b, 0x824000b1, 0x604009d8, 0x00000620, 0x00000000,
+0x00278805, 0x026c809f, 0x24c40914, 0x7c009300, 0x40093002, 0x00970027,
+0x0970025c, 0x9d0026c0, 0xb0025c00, 0x0027c009, 0x024c0093, 0x14c00970,
+0x00000e20, 0x00000000, 0x02658016, 0x167c808f, 0x23c058f2, 0x58009f00,
+0xc009f002, 0x009f0027, 0x09f0026c, 0x9f0026c1, 0xf0027c00, 0x6027c009,
+0x427c008f, 0x53c008f0, 0x00000600, 0x00000000, 0x00050814, 0x088c0013,
+0x0cc00338, 0x8c083340, 0xc0033000, 0x00230008, 0x023010fc, 0x23200fc8,
+0x2380ec00, 0x0008c203, 0x007c003f, 0x50c601f0, 0x00000420, 0x00000000,
+0x01148014, 0x11440071, 0x16c00530, 0x44015100, 0x40051001, 0x00510014,
+0x05100174, 0x51001740, 0x10015400, 0x00144005, 0x11e4005d, 0x504027d0,
+0x00000200, 0x00000000, 0xc0622014, 0x4f0400c1, 0x30500c90, 0x0500c120,
+0x500c144b, 0x80c954b0, 0x0c1e0334, 0xc1403340, 0x174b0580, 0x04b0512c,
+0x073412c9, 0x504138d0, 0x00000a00, 0x00000000, 0x08620005, 0x00848021,
+0x0a400010, 0x86012100, 0x40121240, 0x02291008, 0x02180434, 0x21104b40,
+0x11048400, 0x00084012, 0x03a4002d, 0x144022d0, 0x00000200, 0x00000000,
+0x006a1015, 0x07cd01c3, 0x40c012b6, 0x0c014320, 0xc2143007, 0x01eb0060,
+0x1e3007bc, 0x430053c0, 0x30860e81, 0x0078ca18, 0x87bc01ef, 0x54d01bf1,
+0x00000040, 0x00000000, 0x0025b810, 0x007400dd, 0x37400df1, 0x7c609f08,
+0xc009f080, 0x20171015, 0x01f0807c, 0x9f0827c0, 0xf0015c00, 0x0007c805,
+0x807c001f, 0x43c001f0, 0x00000660, 0x00000000, 0x006fa000, 0x04fc01f3,
+0x7cc09f30, 0xfe09bf00, 0xc01f3004, 0x49bf005c, 0x17f005fc, 0xff007fc0,
+0xf005f801, 0x025f0417, 0x07fc017f, 0x00c017f0, 0x00000e00, 0x00000000,
+0x06298815, 0x03fc0020, 0x0905c210, 0xb40c6d02, 0xc0825213, 0x486d222b,
+0x8ad062b0, 0x2d220b40, 0xd022b408, 0x0a2a448a, 0x23b480af, 0x56d006d2,
+0x00000620, 0x00000000, 0x00290000, 0x00b400e9, 0x08000010, 0xa6402d00,
+0x40065000, 0x00ad0008, 0x06d00190, 0x6d001b40, 0xd000b400, 0x181b4002,
+0x03b4016d, 0x004004d0, 0x00000400, 0x00000000, 0x50e32804, 0x03540cc9,
+0xb1443c10, 0x3403cd82, 0x4038510f, 0x014d02f3, 0x28d00e24, 0x8d02e340,
+0xc0af340b, 0x026208bc, 0x00308a85, 0x124204d0, 0x00000c20, 0x00000000,
+0x02e7a815, 0x177422db, 0x34401d34, 0x6413df00, 0xc139704f, 0x115d00b4,
+0xf9f0067c, 0x9f00a7c0, 0xd00b7402, 0x00a7002d, 0x0330009d, 0x54c00dd0,
+0x00000620, 0x00000000, 0x00218001, 0x407c0217, 0x03c100f0, 0x7c041f14,
+0xc045e010, 0x129f0105, 0x04f0413c, 0x5f0117c0, 0xf0107c04, 0x0116c041,
+0x037c104f, 0x05c005f0, 0x00000c00, 0x00000000, 0x00e50880, 0x03ec0133,
+0x0cc00330, 0x0c006300, 0xc0003003, 0x00630028, 0x0b300ecc, 0x2380c8c0,
+0x30028c03, 0x0028c00a, 0x03cc00b3, 0x03c00f30, 0x00000c22, 0x00000000,
+0x00260081, 0x00440b14, 0x36c20d40, 0x44009100, 0x420d0000, 0x12990014,
+0x05100564, 0xd1007442, 0x10814421, 0x08144205, 0x60448051, 0x074015f2,
+0x00000802, 0x00000000, 0x0024a001, 0x006482c0, 0x34400d10, 0x44209100,
+0x40891000, 0x001d0014, 0x81100064, 0x91002440, 0x10016400, 0x02044005,
+0x00640811, 0x07404510, 0x00000200, 0x00000000, 0x80202010, 0x03146001,
+0x02500014, 0x04604140, 0x40041003, 0x00c94020, 0x0c140324, 0x41401040,
+0x14020500, 0x40305008, 0x000500c1, 0x43400490, 0x00000080, 0x00000000,
+0x4026b000, 0x006c8013, 0x04c00134, 0x4d001300, 0xd0013400, 0x00170004,
+0x0130004d, 0x110004d0, 0x38806c00, 0x0004e201, 0x004e8013, 0x03c40530,
+0x00000ac0, 0x00000000, 0x003fb805, 0x03ee003e, 0x3fc00ff0, 0xfc00ff00,
+0xc00fc003, 0x00f7003f, 0x0ff003dc, 0xfc003fc0, 0xf803fe00, 0x003fe00f,
+0x03fe00ff, 0x17c007f8, 0x00000e60, 0x00000000, 0x050da003, 0x60bc20ff,
+0x36c103b0, 0xfc881307, 0xc801f273, 0x18d30337, 0x0f700bcc, 0xf3023fc0,
+0x3003c400, 0x003dc00f, 0x02cc00f3, 0x0c400bf0, 0x00000e00, 0x00000000,
+0x00870801, 0x1b7400c7, 0xbf402110, 0x74041108, 0x4005d11b, 0x02f52307,
+0x4f100bc4, 0x11003f40, 0xf0034000, 0x02bc420f, 0x83450055, 0x054009d0,
+0x00000c20, 0x00000000, 0x00032011, 0x003414cd, 0x31614012, 0x34040500,
+0x40005013, 0x00c10103, 0x0c949b14, 0x11413349, 0x91030500, 0x0030400c,
+0x03260041, 0x465608d0, 0x00000e80, 0x00000000, 0x8085a803, 0x537400d5,
+0x33606190, 0x760a9100, 0x4805d807, 0x00c11037, 0x0d908347, 0x91003744,
+0xd1034674, 0x0034600d, 0x136400d5, 0x0f4009d9, 0x00000620, 0x00000000,
+0x00e78802, 0x007c40df, 0x36c23db4, 0x7c031510, 0x81b97103, 0x00d14037,
+0x0df20346, 0x030037c0, 0xb0034801, 0x0030d40c, 0x076c1a93, 0x02c009f0,
+0x00000e20, 0x00000000, 0x013d8007, 0x06bc00ff, 0x36401f72, 0x6c013f40,
+0xc80ff083, 0x00ff000f, 0x0f7003bc, 0x7f0037c0, 0xb003ae81, 0x003ec20f,
+0x03dc003f, 0x1dc008f0, 0x00000602, 0x00000000, 0x00250802, 0x104c00d7,
+0x35c12db0, 0x5d005300, 0xc089b103, 0x00da0007, 0x0db0037c, 0xd74032c0,
+0x34037c02, 0x0234c00d, 0x034c008f, 0x08d019f0, 0x00000420, 0x00000000,
+0x0034a013, 0x0a440add, 0x3dc03d10, 0x4400d100, 0x401d1903, 0x00fd0037,
+0x0f1203f4, 0xdb003c42, 0x1003f400, 0x007c19af, 0x3f4481dd, 0x4c400bd0,
+0x00000200, 0x00000000, 0x8012a007, 0x000409c1, 0x33608098, 0x2600c100,
+0x42701603, 0x80cd1035, 0x0cd08324, 0x05003240, 0x18033625, 0x0832180c,
+0x0f2401cd, 0x0c4008d0, 0x00000a00, 0x00000000, 0x80488004, 0x05a501ed,
+0x79405a10, 0xa401e100, 0x401a5807, 0x41ed034b, 0xdc002734, 0xed527840,
+0x1137b415, 0x007a009c, 0x07a401cd, 0x08409ad0, 0x00000200, 0x00000000,
+0x01301012, 0x000c00c3, 0x71c614b0, 0x2c251340, 0xc0501007, 0x45cf0843,
+0x5ce1173c, 0x470372c0, 0x32177c0d, 0x0032d00c, 0x232c104f, 0x58d008f0,
+0x00000040, 0x00000000, 0x002db802, 0x01dc80fe, 0x37e00db2, 0x5c08bf02,
+0xc0893023, 0x08df0037, 0x0fd023fc, 0xdb0a37c0, 0xf0037c00, 0x00bdc02f,
+0x03dc02fd, 0x0bc00bf0, 0x00000660, 0x00000000, 0x8017a015, 0x037c20df,
+0xb7c001f0, 0x4c01cb01, 0xe0057003, 0x40d22034, 0x2d00234c, 0x9305b4c3,
+0x74037800, 0x0334c04d, 0x4b4c00db, 0x54c099f0, 0x00000e00, 0x00000000,
+0x00198812, 0x039c80ed, 0x39c00a70, 0xce80ed04, 0x040e100b, 0x0ce00808,
+0x2e102384, 0xe1003fc0, 0x500bcc00, 0x0132c04c, 0x038500f1, 0x59400ad0,
+0x00000620, 0x00000000, 0x00790003, 0x479441ed, 0x796016d8, 0x84017502,
+0x60165007, 0x09c91040, 0x5c101724, 0xe10a7844, 0x1017b041, 0x007a409e,
+0x0f8541a9, 0x0c4048d0, 0x00000402, 0x00000000, 0x00b32812, 0x075400dd,
+0x3148fc5a, 0x4408cd00, 0x603c1003, 0x40c9c034, 0x0c100324, 0xc1203740,
+0x51030413, 0x0032420c, 0x030400d9, 0x494008d1, 0x00000c20, 0x00000000,
+0x009da817, 0x09dc005f, 0x15c007d0, 0xcc017e08, 0xc0467000, 0x005b001c,
+0x053001ec, 0x62001462, 0x10017c07, 0x0016c005, 0x054c0c5b, 0x5ce204f0,
+0x00000620, 0x00000000, 0x10070012, 0x405c001f, 0x05c00170, 0x5c021f00,
+0xc001f800, 0x00170007, 0x01f0801c, 0x1f0006e8, 0xf0006c00, 0x0007c001,
+0x087d0217, 0x4bc001f0, 0x00000c00, 0x00000000, 0x14230810, 0x024c009f,
+0x25c04970, 0x6c219f00, 0x0109b004, 0x009300a5, 0x08700244, 0x9b1024c0,
+0x30026c08, 0x0220c008, 0x074800d3, 0x40c009f0, 0x00000c20, 0x00000000,
+0x00262201, 0x0a450091, 0x24482910, 0x74039d00, 0xc0495026, 0x80915066,
+0x09100244, 0x91482540, 0x14025403, 0x20645009, 0x1a441a9b, 0x044019d0,
+0x00000800, 0x00000000, 0x0024a018, 0x0a448191, 0x24402810, 0x54049d10,
+0x40091002, 0x00810424, 0x09500254, 0x91002440, 0x10020402, 0x40244089,
+0x12550091, 0x604419d2, 0x00000200, 0x00000000, 0x40202010, 0x22040881,
+0x20508814, 0x34088982, 0x40095022, 0x28810222, 0x88122215, 0x81022140,
+0x100a1400, 0x2320600c, 0x02140889, 0x404088d0, 0x00000080, 0x00000000,
+0x2506b01d, 0x58442217, 0x85c16170, 0x5c025f05, 0xc0013058, 0x16130584,
+0x2142585c, 0x1b0584e0, 0x32004c80, 0x00c4d001, 0x005d1613, 0x74c021f0,
+0x00000ac0, 0x00000000, 0x002fb819, 0x92fc049f, 0x27c04bf8, 0xfc04bf11,
+0xc20af110, 0x049f012e, 0x69e0126c, 0xbf012780, 0xfc0a7c00, 0x4327c029,
+0x026c0496, 0x67c06bf0, 0x00000e60, 0x00000000, 0x80379018, 0x02fc02bf,
+0x24418b30, 0xcc00bf00, 0xc80b10c7, 0x0293002d, 0x8990326c, 0xbb0124c1,
+0x30e27400, 0x40a0c04b, 0x028d06b3, 0x64c143f0, 0x00000e00, 0x00000000,
+0x1007001c, 0x0874001d, 0x04d02114, 0x04000d11, 0x08015008, 0x0a114000,
+0x01140804, 0x55008540, 0xb4006440, 0x03854021, 0x00440653, 0x704031d0,
+0x00000c22, 0x00000000, 0x00a3a010, 0x0a34008d, 0xa24048d0, 0x46009d24,
+0x40090202, 0x80918021, 0x48101a64, 0x89872040, 0x91123620, 0x10204888,
+0x02240289, 0x405008d0, 0x00000e80, 0x00000000, 0x20a5a818, 0x0274009d,
+0x244049d2, 0x44009d00, 0x46091802, 0x80910020, 0x08100264, 0x95002564,
+0x94826400, 0x20254009, 0x12640491, 0x604209d0, 0x00000620, 0x00000000,
+0x0027a805, 0x027c809d, 0x26c009f4, 0x45188d00, 0xe0081206, 0x00919125,
+0x0920026e, 0x9b2024e0, 0xb2027c03, 0x0024d009, 0x026c029b, 0x14c009f0,
+0x00000e20, 0x00000000, 0x00258014, 0x027c009f, 0x27c00930, 0x5c019f00,
+0xc009f512, 0x009f0127, 0x0970025e, 0x9f5023c0, 0xf0022c44, 0x0033c109,
+0x425c009f, 0x53c000f0, 0x00000600, 0x00000000, 0x00050814, 0x005c041f,
+0x04c04170, 0x6c821220, 0xc001b000, 0x001b1007, 0x0132005c, 0x1f000480,
+0x32004c86, 0x0004d000, 0x004c0213, 0x50c00130, 0x00000420, 0x00000000,
+0x0014a014, 0x05f4117d, 0x144067d0, 0x8c807110, 0x40171209, 0x0051011f,
+0x05100104, 0x75001546, 0xf0014540, 0x04555007, 0x09c48871, 0x52c00110,
+0x00000200, 0x00000000, 0x0032a014, 0x077401cd, 0x30502d10, 0x2409c180,
+0x420cd81b, 0x00d10133, 0x0c510306, 0xc5103260, 0x10032402, 0x806242bc,
+0x0b040a91, 0x50400c10, 0x00000a00, 0x00000000, 0x00388005, 0x41b4006d,
+0x7a400cd8, 0xa400e101, 0x402e1103, 0x04e1003b, 0x8e508384, 0xf1013340,
+0x9013a411, 0x002b400c, 0x838400a1, 0x1640ac10, 0x00000200, 0x00000000,
+0x00780015, 0x079c21af, 0x7ce41672, 0xac812340, 0xc416f106, 0x09f1404b,
+0x5c72078c, 0xe723fac1, 0x3017e401, 0x407ac81e, 0x038d01f3, 0x54c05e30,
+0x00000040, 0x00000000, 0x0035a810, 0x817c405f, 0xb56209f8, 0x5c801f07,
+0xc0057202, 0x0ed50007, 0x6d900b78, 0xc50035c0, 0xf45b5c00, 0x24b5c00d,
+0x037d009f, 0x43c00df0, 0x00000660, 0x00000000, 0x007fa000, 0x26fa81f3,
+0x7cc09b32, 0xdc019202, 0xc09e3015, 0xc9f3004d, 0x1d306f4c, 0xf3007dc8,
+0xb067cc01, 0x007cd01f, 0x078c01ff, 0x0bc81f30, 0x00000e20, 0x00000000,
+0x00398815, 0x209c022b, 0x7ac054b0, 0x0441bb02, 0x40da116d, 0x41f00048,
+0x1d502744, 0x81027040, 0x50172c01, 0x003ac006, 0x2bac04fd, 0x57408eb0,
+0x00000620, 0x00000000, 0x00310000, 0x423408a1, 0x3a400010, 0x94006c20,
+0x49c61000, 0x00e1043b, 0x0e9003a5, 0x61813948, 0x10138430, 0x0038400a,
+0x43c4006d, 0x23400e10, 0x00000400, 0x00000000, 0xa0732804, 0x00144009,
+0x32402091, 0x04024000, 0x40001100, 0x00c10072, 0x0cc20324, 0x01403060,
+0xd2032600, 0x20325200, 0x0724100d, 0x1b400c90, 0x00000c00, 0x00000000,
+0x0435a815, 0x0a7c00d1, 0x3cc02d30, 0x54885c40, 0x40193104, 0x40f34077,
+0x0fbd03ec, 0xd1103d40, 0xb003cc00, 0x0024c00c, 0x870401df, 0x57800d30,
+0x00000600, 0x00000000, 0x00370001, 0x1a5c00df, 0x33c24df0, 0x7cc05f10,
+0xc041f808, 0x00cf2031, 0x0d70035c, 0x5f0033c2, 0x72037c86, 0x0037c029,
+0x037c01df, 0x27c00df0, 0x00000c00, 0x00000000, 0x003f0880, 0x20fc00b7,
+0x3fc007f0, 0xcd00b300, 0x821bf801, 0x00f70406, 0x0ef003cc, 0xb7003ec0,
+0x2003fc03, 0x003cc055, 0x07cd00f3, 0x04c03e30, 0x00000c00, 0x00000000,
+0x08362081, 0x0c7400dd, 0x374009d0, 0x44469500, 0x4031d889, 0x80d14007,
+0x0dd20354, 0x1b403448, 0x50037006, 0x00354021, 0x0e540185, 0x84501d50,
+0x00000802, 0x00000000, 0x0034a001, 0x4354005d, 0x37420990, 0x44200980,
+0x414dd012, 0x00d10004, 0x0dd00346, 0xd5003648, 0x50032400, 0x0230402d,
+0x1345c1d1, 0x04400d10, 0x00000220, 0x00000000, 0x00302010, 0x0334000d,
+0x3340c4d0, 0x04040143, 0x4880d012, 0x2cc56803, 0x0cd81b16, 0x0908b002,
+0x59133010, 0x00314000, 0x011400c5, 0x40400c50, 0x00000080, 0x00000000,
+0x0036b000, 0x015c0017, 0x7bc051f0, 0x0c07db00, 0xc11dd02f, 0x01f302f6,
+0xdff217cc, 0x1781fac9, 0x703fbc2f, 0x0034c001, 0x034c0053, 0x04c00d30,
+0x00000ac0, 0x00000000, 0x003fb805, 0x01fc403f, 0x77c0d1f0, 0x7c1dff8b,
+0xc051f19f, 0x0ddb08f7, 0x1ff01ffc, 0xcf09f7c0, 0xf0277c05, 0x003fc00f,
+0x02fc803f, 0x17c00ff0, 0x00000e60, 0x00000000, 0x002f8003, 0x18ec00ff,
+0x0fc14330, 0xfc08ff00, 0xc00fb003, 0x00f3203c, 0x0f3003ec, 0xf3003fc0,
+0x7003cc00, 0x183cc00f, 0x03dc00fb, 0x0cc00f30, 0x00000e00, 0x00000000,
+0x08270801, 0x314450dd, 0x34402110, 0x74041d00, 0x40011100, 0x00114004,
+0x01140045, 0x11400744, 0x11804500, 0x00045001, 0x00450011, 0x04400f10,
+0x00000c20, 0x00000000, 0x0023a011, 0x002004cd, 0x02400050, 0x34044d00,
+0x400cd000, 0x00890021, 0x08500214, 0xc1002340, 0x14021400, 0x40304a08,
+0x012400c5, 0x45640c14, 0x00000e80, 0x00000000, 0x2425a803, 0x084400dd,
+0x14400154, 0x74009d00, 0x60015303, 0x22490010, 0x05504114, 0x01341340,
+0x52011420, 0x00004804, 0x8224a005, 0x0d400c12, 0x00000620, 0x00000000,
+0x0067a802, 0x006c00df, 0x46c8dd70, 0x7c01df11, 0xd015f003, 0x22db0cb5,
+0x05700b7c, 0x5310b7c8, 0x30015c01, 0x0004c005, 0x276c129f, 0x09500d30,
+0x00000e20, 0x00000000, 0x016d8007, 0x237c20cf, 0x7ec00bb0, 0x7c081f12,
+0xc489b000, 0x00172007, 0x09b00064, 0x9f1007c9, 0xb0426c08, 0x0437c509,
+0x044c005b, 0x1ec10ff0, 0x00000600, 0x00000000, 0x00650802, 0x000c40df,
+0x07c00530, 0x4c005304, 0xc0453000, 0x129304a4, 0x0130127c, 0x530124c2,
+0x30004c00, 0x0804c481, 0x014c0293, 0x0ac08d30, 0x00000420, 0x00000000,
+0x10a4a013, 0x464404fd, 0x17400110, 0x6c119140, 0xc109b003, 0x025b0456,
+0x3db0156c, 0x9b0496c1, 0xb0136c09, 0x04f6c02d, 0x066c045b, 0x4c422fb0,
+0x00000200, 0x00000000, 0x0102a007, 0x020407cd, 0x02400191, 0x64008102,
+0x04391003, 0x0a490092, 0x0c900904, 0x8900d040, 0x10032401, 0x0072400c,
+0x4a341141, 0x1c400c10, 0x00000a00, 0x00000000, 0x00488004, 0x058501ed,
+0x6b621698, 0xa6016180, 0x60169824, 0x21a9806a, 0x1298a6a6, 0x69826a60,
+0x9804a609, 0x024a6092, 0xc5a409a9, 0x10401c90, 0x00000200, 0x00000000,
+0x00001012, 0x230420cd, 0x27400894, 0x24000102, 0x40081020, 0x04091002,
+0x08900014, 0x89000040, 0x30022c10, 0x0032c008, 0x103c0043, 0x48d08c30,
+0x00000040, 0x00000000, 0x000db802, 0x01fd00ff, 0x2fc00f70, 0xfc00ff02,
+0xc087f023, 0x00ff023f, 0x07f003fc, 0x7f0037c0, 0xf001fc00, 0x000fc007,
+0x07fc00bf, 0x09c08ff0, 0x00000660, 0x00000000, 0x0007a015, 0x824d00df,
+0x16c01df1, 0x6c019f20, 0xc0013007, 0x015b0014, 0x1530054c, 0x1b0856c0,
+0x30054c41, 0x0044c015, 0x064c0113, 0x57c04d30, 0x00000e00, 0x00000000,
+0x20098812, 0x038402ed, 0x38500fd0, 0x14004d00, 0x400c5000, 0x008d0029,
+0x08500214, 0xc5002140, 0x50021400, 0x00314008, 0x011400c5, 0x4b092e50,
+0x00000620, 0x00000000, 0x00690003, 0x078405ed, 0x79401ed0, 0x84012d80,
+0x60125004, 0x012d0048, 0x12500484, 0x25004840, 0x10049401, 0x00494012,
+0x04840125, 0x0f025e10, 0x00000400, 0x00000000, 0x00332812, 0x0b4400dd,
+0x31402cd0, 0x1400cd00, 0x640c5003, 0x00cd0031, 0x0c500314, 0xc5083140,
+0x50031400, 0x1071400c, 0x031601c5, 0x4b400c50, 0x00000c20, 0x00000000,
+0x009da817, 0x81cc005f, 0x1fc137f0, 0x6c005f01, 0xc8857001, 0x005d0014,
+0x8570014c, 0x5f0816c0, 0x30215c08, 0x0615c085, 0x01cc1057, 0x5fc60530,
+0x00000620, 0x00000000, 0x20c70012, 0x407c021f, 0x064101f0, 0xdc003f00,
+0xc003d000, 0x003f000b, 0x03e000fc, 0x3f008fc0, 0xf008fc80, 0x000fc003,
+0x00fc023f, 0x4bc001f0, 0x00000c00, 0x00000000, 0x00270810, 0x064c009f,
+0x27c00970, 0x7c019f00, 0xc049f102, 0x00932024, 0x19f0027c, 0x9f0067c0,
+0xf0267c00, 0x00a7c029, 0x1674089f, 0x43c409f2, 0x00000c20, 0x00000000,
+0x04a62001, 0x0644079d, 0x27400910, 0x74089d00, 0x5129d002, 0x1b9b06e4,
+0x19d06e74, 0x9d00a641, 0xd0027402, 0x00274009, 0x0a74249d, 0x0740a9d0,
+0x00000800, 0x00000000, 0x0024a018, 0x9244889d, 0x27400950, 0xf6009d00,
+0x400ad002, 0x00b1002c, 0x4bd002f4, 0xb901af40, 0xd042f418, 0x002f400b,
+0x42e400bd, 0x634029d0, 0x00000200, 0x00000000, 0x00202010, 0x2204488d,
+0x33408812, 0xb488ad02, 0x402ad0a2, 0x42a900a8, 0x2ad00ab4, 0xad30aa40,
+0xd00ab402, 0x00bb402e, 0x0ab402ad, 0x434028d0, 0x00000080, 0x00000000,
+0x0006b01d, 0x584d020f, 0x87c56150, 0x7c021f05, 0xc001f008, 0x00130004,
+0x01f0007c, 0x1f0007c0, 0xf0007c00, 0x0007c001, 0x00fc001f, 0x77c001f0,
+0x00000ac0, 0x00000000, 0x002fb819, 0x12fc069f, 0x2f404bd0, 0x7c869d01,
+0x4429d01a, 0x029d00a7, 0x29d00a74, 0x9d00a740, 0xd00a7402, 0x00a74029,
+0x0a7c829f, 0x67c029f0, 0x00000e60, 0x00000000, 0x003fa018, 0x52cc04ba,
+0x2c0589f2, 0xfc049302, 0xc069f012, 0x849f1024, 0x29f0125c, 0x9f01a4c0,
+0xf01a7c06, 0x0427c029, 0x027c549f, 0x60c049f0, 0x00000e00, 0x00000000,
+0x0007081c, 0x0844061d, 0x844001d0, 0x74001102, 0x4061d118, 0x161d2584,
+0x61d05074, 0x1d018440, 0xd0187406, 0x00074061, 0x5874161d, 0x704143d0,
+0x00000c20, 0x00000000, 0x0063a010, 0xc2041289, 0x204048d1, 0x36568101,
+0x402a5062, 0x08ad00a9, 0x6ad00ab4, 0xad032850, 0xd00ab408, 0x042b402a,
+0x0ab400ad, 0x40402ad0, 0x00000e80, 0x00000000, 0x0025a818, 0x0245009d,
+0x240609d0, 0x74009100, 0x4009d002, 0xa0bd002d, 0x0ed002f4, 0xbd002c40,
+0xd002f480, 0x002f400b, 0x03f400fd, 0x60400bd0, 0x00000620, 0x00000000,
+0x02e7a805, 0x024c009b, 0x249049f0, 0x7c109341, 0xd009706a, 0x289f2025,
+0x19f0225c, 0x9f1224c0, 0xf0067ca0, 0x0027c019, 0x4274009f, 0x14d009f0,
+0x00000e20, 0x00000000, 0x00658014, 0x127c008f, 0x23c208f0, 0x7c00df00,
+0xc009f002, 0x009f10e6, 0x49f0027c, 0x9f0427c2, 0xf0127c00, 0x0027c049,
+0x027c809f, 0x53c009f0, 0x00000600, 0x00000000, 0x03050814, 0x104c201f,
+0x06c001f0, 0x7c201f00, 0xc0037008, 0x003f000f, 0x83f000fc, 0x3f020fc2,
+0xf000fc00, 0x010fc003, 0x00fc183f, 0x505003f0, 0x00000420, 0x00000000,
+0x005ca014, 0x09c5007d, 0x5c4005d0, 0x74015d04, 0x00151001, 0x035d0117,
+0x05d00574, 0x5d001740, 0xd0097403, 0x001740a5, 0x1d74035d, 0x504007d0,
+0x00000200, 0x00000000, 0x0012a014, 0x030510cd, 0x33400cd0, 0x34004d00,
+0x401f5002, 0x0ded04bb, 0x2ed013b4, 0xed007b41, 0xd063b413, 0x02bb408e,
+0x1bb401ed, 0x50409fd0, 0x00000a00, 0x00000000, 0x00088005, 0x038400cd,
+0x39404ed1, 0xb4426d00, 0x442e1206, 0x00ed003b, 0x0ed043b4, 0xed203b40,
+0xd003b430, 0x003b400e, 0x03b400ed, 0x14400cd0, 0x00000200, 0x00000000,
+0x00581015, 0x078c012f, 0x5bc01ff1, 0xfc016f00, 0xc01e601e, 0x01ef007b,
+0x1ef007bc, 0xef007bc0, 0xf007bc01, 0x207bc01e, 0x07bc81ef, 0x54c01ef0,
+0x00000040, 0x00000000, 0x0005b810, 0x027c00df, 0x36c08df0, 0x7c121f00,
+0xc001f002, 0x001f0007, 0x01f0007c, 0x5f0007c0, 0xf0007c00, 0x0007c801,
+0x007c001f, 0x43c601f0, 0x00000660, 0x00000000, 0x004ba000, 0x07ec01f3,
+0x7cc21f30, 0x8c097340, 0xc01f3206, 0x01ff207f, 0x1ff007fc, 0xbf007fc0,
+0xf227fc01, 0x027fc09f, 0x07fc01ff, 0x03401ff0, 0x00000e00, 0x00000000,
+0x22098815, 0x83844061, 0x28420eb0, 0x84006100, 0x400e1402, 0x00ed023b,
+0x8ed003b4, 0xad003b41, 0xd003b408, 0x083b402e, 0x23a400ed, 0x57400ed0,
+0x00000620, 0x00000000, 0x040d0000, 0x03a40021, 0x18400c10, 0x80406100,
+0x400a1002, 0x00ed003b, 0x0ed003b4, 0xad003b40, 0xd103b400, 0x103b480e,
+0x43b400ed, 0x03401ed0, 0x00000400, 0x00000000, 0x00232804, 0x32042041,
+0x60421d90, 0x44070110, 0x40f51066, 0x111d03c7, 0x01d04474, 0x1d01c641,
+0xd0087411, 0x01874071, 0x18641b1d, 0x134000d0, 0x00000c20, 0x00000000,
+0x0005a815, 0x036800d3, 0xe4c05f30, 0xcd005200, 0xc01d300e, 0x40df2077,
+0x0df10b7c, 0xdf0037c4, 0xf1037c02, 0x0137c00d, 0x0b7801df, 0x57c00df0,
+0x00000620, 0x00000000, 0x00070001, 0x037c009f, 0x13c00df0, 0x7c085f02,
+0xc005f002, 0x0adf00b7, 0x2df02b7c, 0xdf0237c0, 0xf0bb7c0a, 0x00b7c08d,
+0x0b6cc0df, 0x07c00df0, 0x00000c00, 0x00000000, 0x00cf0880, 0x03dd0903,
+0x0dc00ff0, 0xfc007304, 0xc00f7002, 0x05f3013c, 0x4f3027cc, 0xf3003cc0,
+0x3007cc00, 0x003cc00f, 0x23cc03f3, 0x03c00f30, 0x00000c22, 0x00000000,
+0x00422081, 0x02440191, 0x55400dd0, 0x74081102, 0x40691002, 0x031100c4,
+0x21101c44, 0x5100c440, 0x10044446, 0x02044011, 0x88442211, 0x07409111,
+0x00000802, 0x00000000, 0x0004a001, 0x895400d1, 0x25420dd0, 0x74001100,
+0x400d5002, 0x02110c04, 0x01100044, 0x11028440, 0x12504400, 0x04044881,
+0x00440011, 0x07400910, 0x00000200, 0x00000000, 0x20002010, 0x01040001,
+0x40500cd0, 0x34000100, 0x42041002, 0x00010000, 0x00100004, 0x01000048,
+0x10000400, 0x00004000, 0x00040001, 0x43400810, 0x00000080, 0x00000000,
+0x0006b000, 0x011c0013, 0x01c00df0, 0x7c000340, 0xc0097002, 0x00130004,
+0x0131004c, 0x130004c0, 0x32004c00, 0x0004c401, 0x004c0013, 0x03c00930,
+0x00000ac0, 0x00000000, 0x002fb805, 0x00fc003f, 0x0fc00ff0, 0xfc003f00,
+0xc00ff002, 0x00ff003f, 0x0ff003fc, 0xbf203fc0, 0xf003fc00, 0x003fc00f,
+0x03fc00ff, 0x17c007f0, 0x00000e60, 0x00000000, 0x000fa003, 0x10fcc433,
+0x35c001b0, 0x7c5cff07, 0xc04d7272, 0x00d32337, 0xc33070cc, 0xdb40b4c1,
+0xf0137c08, 0x003dc003, 0x01c8003f, 0x0cc00bf0, 0x00000e00, 0x00000000,
+0x43170801, 0x5b741201, 0x3c448510, 0xf406fd10, 0x41ec041a, 0x06f103b7,
+0x21500a44, 0xd5103d40, 0xd0237462, 0x00334809, 0x0144005d, 0x045009d0,
+0x00000c20, 0x00000000, 0x0423a011, 0x20140c81, 0x30400810, 0x5444cc20,
+0x400c0082, 0x12c10137, 0x4c100004, 0xc1113144, 0xd0833406, 0x08334000,
+0x0324000d, 0x444209d0, 0x00000e80, 0x00000000, 0x0035a803, 0x0b341891,
+0x34480512, 0x7400dd18, 0x400d1402, 0x00d10077, 0x8d500244, 0xd5003548,
+0xd0037400, 0x00374009, 0x2b64039d, 0x0c4009d0, 0x00000620, 0x00000000,
+0x0287a802, 0x047c0353, 0x34d011b4, 0x3c80df00, 0xc09d3002, 0x00d30037,
+0x1930074d, 0xd35034c0, 0xf0037c20, 0x0035c015, 0x0c6d035f, 0x08c008f0,
+0x00000e20, 0x00000000, 0x0c458007, 0x17fc117f, 0x3ec08af2, 0x7c00ff00,
+0xc00fb102, 0x00cf083f, 0x0bf027bc, 0xff003bc0, 0xf003fc50, 0x003fe05f,
+0x44dc006f, 0x1fc00bf0, 0x00000600, 0x00000000, 0x40850802, 0x405d0313,
+0x35f00970, 0x5d00df18, 0xc00d7c02, 0x00d30035, 0x0cf0034c, 0xd34037c0,
+0x30037c00, 0x0234c005, 0x025d0213, 0x08c009f0, 0x00000420, 0x00000000,
+0x0044a013, 0x1b440011, 0xbc400950, 0xe480fd02, 0x400db802, 0x0af10030,
+0x0dd00344, 0xfb103f4a, 0x5003f400, 0x02fd400d, 0x4644651b, 0x4ec00bd0,
+0x00000200, 0x00000000, 0x0006a007, 0x0c040201, 0x30400010, 0x24c0cd00,
+0x400c9082, 0x80c10031, 0x04d10104, 0xc1003348, 0x50033480, 0x80704000,
+0x05042081, 0x1c4008d1, 0x00000a00, 0x00000000, 0x00588004, 0x24040921,
+0x7a60d650, 0xa409ed00, 0x405e1036, 0x15e10278, 0x16d007a6, 0xe90a7340,
+0x5087b429, 0x0079401a, 0x05810069, 0x12401ad0, 0x00000200, 0x00000000,
+0x06a01012, 0x021c08c1, 0x71e09970, 0x1c45df03, 0xc01cd006, 0x01c30371,
+0x5cd0150c, 0xc34373c0, 0x70077405, 0x0030e041, 0x021e08d3, 0x48c009f0,
+0x00000040, 0x00000000, 0x103db802, 0x02fc28ff, 0x3dcc05f0, 0x5c00ff00,
+0xc50ff8a2, 0x8afe0c3b, 0xcdf02358, 0xdf0237c0, 0xf0037c28, 0x003fc00f,
+0x02fd60ff, 0x0bc00bf0, 0x00000660, 0x00000000, 0x0037a015, 0x014c00df,
+0x34ca0530, 0x4c04df05, 0xc00d3012, 0x02d33037, 0x0d30076d, 0xd30534c2,
+0x31034c41, 0x2037c005, 0x004c41df, 0x57c009f0, 0x00000e00, 0x00000000,
+0x00398812, 0x01c480ed, 0xb8600f10, 0xc516ed00, 0x400eb02a, 0x06c1213b,
+0x0f108314, 0xe1013848, 0x101bc424, 0x103b410e, 0x0084006d, 0x4b402ad0,
+0x00000620, 0x00000000, 0x00f90003, 0x078601c5, 0x78411e10, 0x8405cd01,
+0x405e1096, 0x81e1187b, 0x1e904784, 0xe1027840, 0x9007840d, 0x027b4012,
+0x0c8400cd, 0x0f401ad0, 0x00000400, 0x00000000, 0x00f32812, 0x230402dd,
+0x34400d15, 0x0400cd20, 0x400c9002, 0x00c10033, 0x0c104304, 0xc1003040,
+0x91030400, 0x2033420c, 0x1004014d, 0x4b4008d0, 0x00000c20, 0x00000000,
+0x00dda817, 0x05cd057f, 0x14d42732, 0xcc005f00, 0xc0013001, 0x4053400f,
+0x87b301cc, 0x534014c2, 0xb0014c00, 0x1017c805, 0x05cc027f, 0x5fc005f0,
+0x00000620, 0x00000000, 0x01070012, 0x807c001f, 0x07c101f0, 0x3c201f00,
+0xc001f000, 0x001f0007, 0x01f0005c, 0x1f0003c0, 0x75007c02, 0x0006c081,
+0x087c8c1f, 0x4bc001f0, 0x00000c00, 0x00000000, 0x00270810, 0x0a0c109f,
+0x64d00930, 0x4c009302, 0xc000b002, 0x00934000, 0x09f0024c, 0x930026ca,
+0x71023c02, 0x0267c00d, 0x024c088f, 0x40c008f0, 0x00000c20, 0x00000000,
+0x04262001, 0x0a44019d, 0xa5400912, 0x44409150, 0x40091002, 0x00912024,
+0x09d00244, 0x91002448, 0x10027403, 0x20274009, 0x1a44419d, 0x054009d0,
+0x00000800, 0x00000000, 0x0024a018, 0x42440a9d, 0xa5400910, 0x64408120,
+0x40099202, 0x00812024, 0x08d00244, 0x91002640, 0x10027400, 0x20a74209,
+0x2264009c, 0x604009d0, 0x00000200, 0x00000000, 0x02202010, 0x2205288d,
+0x2151c814, 0x25888100, 0x50881022, 0x08810820, 0x88d02207, 0x81022040,
+0x18a23408, 0x15234028, 0x0225088d, 0x414008d0, 0x00000080, 0x00000000,
+0x2586b01d, 0x584c361f, 0x05d06131, 0x6c361305, 0xc361b0d8, 0x16130500,
+0x61f0584c, 0x434582c1, 0x74587c16, 0x0107c941, 0x006c161f, 0x74c001f0,
+0x00000ac0, 0x00000000, 0x012fb819, 0x12fc04bf, 0x27c04bf2, 0xdc049f05,
+0xc843f012, 0x849f050f, 0x4bf012fc, 0x9f0127c0, 0xf3127c04, 0x0527c009,
+0x02dc04bf, 0x67c16bf0, 0x00000e60, 0x00000000, 0x00af2018, 0x02fc02b3,
+0xaec049f0, 0x4c849301, 0x403f3202, 0x02b3007c, 0x69f0024c, 0xb31627c9,
+0xf012cc0c, 0x40a6c129, 0x024c12b3, 0x60c14930, 0x00000e00, 0x00000000,
+0x0007081c, 0x1874001b, 0x044000d2, 0x6c061141, 0x50201050, 0x04110084,
+0x60d2a854, 0x15008740, 0xd008540e, 0x00044061, 0x00440211, 0x70502114,
+0x00000c20, 0x00000000, 0x00a32010, 0x4a340281, 0xa24968d0, 0x04988121,
+0x4428000a, 0x468124a0, 0x48d04204, 0x81412340, 0xd8720400, 0x80224048,
+0x026500c1, 0x40400910, 0x00000e80, 0x00000000, 0x0025a818, 0x8a740299,
+0x244029d0, 0x64409100, 0x40191482, 0x00d18064, 0x09d00254, 0x9500274b,
+0xd0025400, 0x00244009, 0x02640491, 0x60400910, 0x00000620, 0x00000000,
+0x04a7a805, 0x027c0093, 0x26c029f0, 0x4d009300, 0xc0191002, 0x00934064,
+0x39f0024c, 0x93002742, 0xd0024c00, 0x0026c009, 0x162c0593, 0x14c00830,
+0x00000e20, 0x00000000, 0x00258014, 0x027c199f, 0x27c009f0, 0x5c008f00,
+0xc009f002, 0x009f0027, 0x99f0027c, 0x8f4023c0, 0xf0027c80, 0x0033c099,
+0x0f5c018f, 0x53c009f0, 0x00000600, 0x00000000, 0x00810814, 0x007c021f,
+0x01c220f0, 0x0c001f04, 0xc0013100, 0x001f0004, 0x2130005c, 0x130004c0,
+0xb2804400, 0x2407c800, 0x084c021d, 0x50c001f0, 0x00000420, 0x00000000,
+0x015ca014, 0x41f4017d, 0x5d4805d0, 0x44005d00, 0xc0051001, 0x057d2017,
+0x0510014c, 0x71001440, 0x10014411, 0x04174605, 0x4544005d, 0x514005d0,
+0x00000200, 0x00000000, 0x0032a014, 0x1b340bcd, 0x71500cd0, 0x0400cd90,
+0x40095803, 0x00dd0024, 0x0c100324, 0xc1003042, 0x10a20400, 0x00b3400c,
+0x040400cd, 0x52400cd0, 0x00000a00, 0x00000000, 0x10388005, 0x02b400ad,
+0x19404ed0, 0xc400ed04, 0x444a1033, 0x20ed002b, 0x5e100784, 0xc1093848,
+0x10060400, 0x001b400e, 0x008480cd, 0x17400cd1, 0x00000200, 0x00000000,
+0x00581015, 0x85b421ef, 0x6942bef0, 0x8c81cf20, 0xc05a7207, 0x01cf00e8,
+0x7e3407ed, 0xe340fcc0, 0x30068c21, 0x926bc01e, 0x048cc1ef, 0x56c01ef0,
+0x00000040, 0x00000000, 0x2035b810, 0x007c001f, 0x07c06df0, 0x3c02df00,
+0xc029d483, 0x00df0526, 0x2de07b78, 0x5f05b7c0, 0x73827c20, 0x0137c08d,
+0x187d00df, 0x41c08df0, 0x00000660, 0x00000000, 0x006fb000, 0x07f80977,
+0x74081ff0, 0xcc1bd302, 0xc1b93007, 0x01df1065, 0xbf4027fc, 0xf3427cc4,
+0xa027cc49, 0x405cc09f, 0x0c8c01f3, 0x00c21f30, 0x00000e00, 0x00000000,
+0x00298015, 0x01b4086d, 0x78545fd0, 0x8401d102, 0x401b1007, 0x0dad0b68,
+0x1d380734, 0xf5007840, 0xd0279449, 0x009ac00f, 0x018400e1, 0x54400e30,
+0x00000620, 0x00000000, 0x00090000, 0x22a600a5, 0x0850ced0, 0xc4c0e103,
+0x404a9003, 0x04ed0028, 0x0e5023b4, 0xa1023040, 0xd8038400, 0x003a400e,
+0x00c40aa1, 0x00400f90, 0x00000400, 0x00000000, 0x00632804, 0x0034400d,
+0x00400cd0, 0x0400c100, 0x4088d003, 0x008d1060, 0x0c128334, 0x05503040,
+0xd0031400, 0x1032419d, 0x00040091, 0x10400c10, 0x00000c20, 0x00000000,
+0x0035a815, 0x0b6c00d7, 0x34c02ff0, 0x8d40f340, 0xd01b8003, 0x00df3469,
+0x0f500bfc, 0xd3003cd0, 0xb1034420, 0x1036c80f, 0x014d0092, 0x54c00fb4,
+0x00000620, 0x00000000, 0x02070001, 0x327c408f, 0x17c18df0, 0x7c00cf00,
+0xc0093003, 0x825f0027, 0x0d70437c, 0xdf0033c0, 0xf0037c20, 0x0097c00d,
+0x0a7c01df, 0x07c00df0, 0x00000c00, 0x00000000, 0x005f0880, 0x01cc00f3,
+0x74d40ff0, 0xcf00f300, 0xc00b3003, 0x00f3002f, 0x0e1403f4, 0xfb003cc0,
+0xf007f420, 0x0076c00f, 0x04c4019f, 0x03c00f30, 0x00000c22, 0x00000000,
+0x06060081, 0x00444011, 0x57d00dd1, 0x4480d500, 0x42095003, 0x02510027,
+0x0d100374, 0x550036c0, 0xd0037400, 0x00bd400d, 0x101401dd, 0x07400d50,
+0x00000802, 0x00000000, 0x8030a001, 0x03440051, 0x22400cd2, 0x4400d501,
+0x40095003, 0x40d13027, 0x0d500334, 0xd9403640, 0xc1237400, 0x0236440d,
+0x215508dd, 0x07400d10, 0x00000200, 0x00000000, 0x00002010, 0x01040041,
+0xa2506cd0, 0x4408c511, 0x00481813, 0x120100a7, 0xcc101334, 0xc5033240,
+0xd0033090, 0x0011400c, 0x031500cd, 0x43400c50, 0x00000080, 0x00000000,
+0x0016a000, 0x024c0093, 0xc4d07ff2, 0x4401f700, 0x85fb7877, 0x87d340ef,
+0x3f7097bc, 0x9b057ec1, 0xf00f784f, 0x2036c00d, 0x005d009f, 0x03c00d30,
+0x00000ac0, 0x00000000, 0x200fa805, 0x00fc003f, 0xcfc29df0, 0x3c0dff00,
+0xc05bf097, 0x053f026f, 0x1de0e774, 0x1f2177c8, 0xf05f7c25, 0x003fc00f,
+0x00fc00bf, 0x17c00ef0, 0x00000e60, 0x00000000, 0x802fa803, 0x23fc08f3,
+0x8fc143f0, 0xdc003f00, 0xc00ff053, 0x00f7003c, 0x0fb003cc, 0xf7003ec0,
+0x30c5fc00, 0x046cc01b, 0x11ec00f3, 0x0fc00f30, 0x00000e00, 0x00000000,
+0x00270801, 0x0a748251, 0x324825d0, 0xa4021700, 0x400fd00b, 0x22e10038,
+0x0f108394, 0xc1003042, 0x10894400, 0x009040a5, 0x094400c1, 0x07480f10,
+0x00000c20, 0x00000000, 0x0023a011, 0x193486c1, 0x314540d0, 0x14020d01,
+0x400cd003, 0x48c50030, 0x0c900314, 0xc5103248, 0x50013400, 0x00224400,
+0x212400c1, 0x47400c50, 0x00000e80, 0x00000000, 0x4065a003, 0x01760051,
+0x376011d0, 0x64845d00, 0x480dd003, 0x00d12034, 0x0d110354, 0xd1203400,
+0x50016420, 0x2016480c, 0x414400d1, 0x0f400d50, 0x00000620, 0x00000000,
+0x0037a002, 0x077c0213, 0x05c029f2, 0x5c001f10, 0xd00dd006, 0x00d70034,
+0x0db2035c, 0xd71036c8, 0x7403fc00, 0x402ed003, 0x0d6c00d3, 0x0bc00d70,
+0x00000e20, 0x00000000, 0x003d8007, 0x22fc0237, 0x3ec005f0, 0xfc007700,
+0xc00ff04e, 0x00ff003b, 0x0ef003bc, 0xef203bc0, 0xb003dcc0, 0x0019c00f,
+0x253c00ef, 0x1fc00fb6, 0x00000600, 0x00000000, 0x00750002, 0x214c2017,
+0x36d02930, 0x4c001300, 0xe10c3402, 0x00c34035, 0x0d30034d, 0xd30037c0,
+0xf0030d00, 0x4025c001, 0x094d00d3, 0x0bc00d70, 0x00000420, 0x00000000,
+0x00b4a013, 0x09540011, 0x74400150, 0x450f5100, 0x400f1002, 0x11f1047f,
+0x1f1047c4, 0xf1117c41, 0xd0474401, 0x0454411d, 0x054411f1, 0x4f420f10,
+0x00000200, 0x00000000, 0x0426a807, 0x1024808d, 0x41400090, 0x00000120,
+0x400c1006, 0x12c104b1, 0x2c104b04, 0xc104b141, 0xd0490412, 0x04a04120,
+0x490412c1, 0x1f400cd1, 0x00000a00, 0x00000000, 0x40788004, 0x043403c1,
+0x78401ed0, 0x84012100, 0x411e1026, 0x01e1107b, 0x9c182784, 0xe1027940,
+0xd0858401, 0x0259401e, 0x058401e5, 0x12401e90, 0x00000200, 0x00000000,
+0x00241012, 0x202c828f, 0x31c6a4b1, 0x0c085304, 0xc00c3042, 0x08c30031,
+0x8c34030c, 0xc34031c0, 0xf0010c10, 0x0221d0a1, 0x520c08c3, 0x4bc00cf0,
+0x00000040, 0x00000000, 0x003db802, 0x81dc00f5, 0x3dc00f58, 0xfc007f02,
+0xc08fb006, 0x00ff003f, 0x8ff8c3fc, 0xff003cc1, 0xf001fc80, 0x0a5ec80f,
+0x02fc80fb, 0x0bc02f71, 0x00000660, 0x00000000, 0x0037a015, 0x027c0017,
+0x07c009f0, 0x7c125f00, 0xc10d3083, 0x06d701b7, 0x4cb0537c, 0xdb0a74d0,
+0xf0036c01, 0x4027c801, 0x017c00d3, 0x57c08df8, 0x00000e00, 0x00000000,
+0x00398812, 0x02b480ed, 0x3b400ed0, 0x34006d08, 0x402e7023, 0x16e105b3,
+0xce1013b4, 0xe1213840, 0xd0038482, 0x0013400e, 0x01b422e1, 0x4b404ed0,
+0x00000620, 0x00000000, 0x00790003, 0x06b40121, 0x7b401ed0, 0xb4016d00,
+0x405e900f, 0x01ed007b, 0x1f900734, 0xc9007140, 0xd807a401, 0x106b4012,
+0x06b401e1, 0x0f441ed8, 0x00000400, 0x00000000, 0x80732812, 0x0b3400cd,
+0x33400cd8, 0x34094d00, 0x400c5007, 0x80c90033, 0x0c100334, 0xc1003148,
+0xd2032400, 0x0013402c, 0x023400c1, 0x4b400cd0, 0x00000c20, 0x00000000,
+0x0115a817, 0x29f48073, 0x1b4027d0, 0x7c015f00, 0xc005b005, 0x005f0017,
+0x07b1017c, 0x5b001dc0, 0xf0096c00, 0x401fc085, 0x01fc0053, 0x5fc005f0,
+0x00000620, 0x00000000, 0x00070012, 0x087c011f, 0x07e101f0, 0x7c800f00,
+0xc001f080, 0x00170003, 0x01f0803c, 0x1f0006c0, 0xf0485c20, 0x008bc002,
+0x087c001f, 0x4bc001f0, 0x00000c00, 0x00000000, 0x00230810, 0x020c0097,
+0x67800930, 0x2c00d301, 0xc4093002, 0x00870024, 0x0970024c, 0x9f002480,
+0x30027c00, 0x0024c009, 0x025c0083, 0x43c009f0, 0x00000c20, 0x00000000,
+0x10660005, 0x0a540291, 0x26c00952, 0x45809100, 0x40095102, 0x00910024,
+0x0910027c, 0x9c002440, 0x104a7400, 0x04a54009, 0x4a448095, 0x074009d0,
+0x00000800, 0x00000000, 0xc224a01c, 0x03448185, 0x27400910, 0x44009140,
+0x40181002, 0x01950064, 0x18d00640, 0x9d006540, 0x10063401, 0x006c401b,
+0x06540191, 0x634009d0, 0x00000200, 0x00000000, 0x80e02010, 0x0b140281,
+0x26440850, 0x0408c102, 0x5028505a, 0x868180a0, 0x28100a34, 0x8d00a150,
+0x140a3602, 0x00a9402a, 0x0a040285, 0x434028d0, 0x00000080, 0x00000000,
+0x0006b019, 0x004c0057, 0x87614130, 0x4c161310, 0xc0013110, 0x01170004,
+0x0170004c, 0x1f0005c0, 0x30007c00, 0x000cc001, 0x005c0013, 0x77c001f0,
+0x00000ac0, 0x00000000, 0x40afb019, 0x0afc02bf, 0x2cc54bf0, 0xfc049f01,
+0xc029f002, 0x089f00a7, 0x29f30a6c, 0x9f00a6c0, 0xf00a7c02, 0x08a7c02d,
+0x0afc829f, 0x67c029f0, 0x00000e60, 0x00000000, 0x052fa018, 0x32fc02fb,
+0xa5c149f0, 0x7c40bf00, 0xc029f05a, 0x069b01a4, 0xc9b0327c, 0x9701a6c0,
+0x301e6c14, 0x0164c079, 0x0a4c1293, 0x60d489f2, 0x00000e00, 0x00000000,
+0x01870818, 0x385c0011, 0x164021d0, 0x760a1d00, 0x4001d818, 0x04110385,
+0xe1103874, 0x11038440, 0xb0184402, 0x15054041, 0x80840411, 0x704821d0,
+0x00000c20, 0x00000000, 0x0423a010, 0x02300289, 0x236008d2, 0xb4148d00,
+0x406ad012, 0x02a92028, 0x0a900294, 0xa5092a40, 0x1022a410, 0x40aa502a,
+0x1e8400a1, 0x404068d0, 0x00000e80, 0x00000000, 0x0025a818, 0x82542099,
+0x266009d8, 0x74809d02, 0x400bd003, 0x00b1002d, 0x0b1802f6, 0xb1002c40,
+0x9002e400, 0x002f400b, 0x02c400b1, 0x604009d2, 0x00000620, 0x00000000,
+0x1027a805, 0x467c009b, 0xe7c689f0, 0x74099f10, 0xc009d002, 0x009b0024,
+0x09b0025c, 0x970026c0, 0x30026c00, 0x0026c029, 0x064c2093, 0x14c409f0,
+0x00000e20, 0x00000000, 0x00218210, 0x567c1097, 0x35c009f0, 0x7c019f00,
+0xe009f002, 0x009f0023, 0x0970023c, 0x8f0023c0, 0xf0025c00, 0x0021c008,
+0x927d209f, 0x53c009f0, 0x00000600, 0x00000000, 0x02050814, 0x004c0813,
+0x07c001f0, 0xfc201f00, 0xc0023100, 0x0437010f, 0x02b010fc, 0x33010cc0,
+0x30008c04, 0x000cc043, 0x00fc0433, 0x50c40130, 0x00000420, 0x00000000,
+0x201ca014, 0x01d48171, 0x174805d2, 0x74117d04, 0x48051001, 0x00512017,
+0x05108164, 0x57001444, 0x10014400, 0x00144005, 0x01f40051, 0x50400510,
+0x00000200, 0x00000000, 0x0072a014, 0x2b0402c9, 0x53600d90, 0x3400cd20,
+0x400c5003, 0x00c54033, 0x2c100334, 0xc9403041, 0x10030400, 0x0030500c,
+0x033400d1, 0x50440d90, 0x00000a00, 0x00000000, 0x40308005, 0x00b401c1,
+0x1b608e90, 0xb400ed00, 0x4802520c, 0x0021000b, 0x021000b4, 0x25000840,
+0x10008400, 0x00094002, 0x04b48021, 0x14400e90, 0x00000200, 0x00000000,
+0x00681015, 0x078e4163, 0x5bc41ef2, 0xfc016f10, 0xc01a5407, 0x01a70063,
+0x1b3406fe, 0xbb806cd0, 0x3404cd01, 0x404cc018, 0x04bc01a3, 0x54d01cb4,
+0x00000040, 0x00000000, 0x4025b010, 0x005c805f, 0x87c00df0, 0x7c005f00,
+0xc005b000, 0x005f8817, 0x0570016c, 0x5b0017c0, 0xf0037c00, 0x0036c205,
+0x037c005f, 0x43c1ed70, 0x00000660, 0x00000000, 0x007fa000, 0x25cc81bb,
+0xdcc01fb0, 0xfc01f310, 0xc41f7006, 0x0173105c, 0x17b005cc, 0x73005ac0,
+0x3007fc01, 0x007cc217, 0x07ec8173, 0x00c01f31, 0x00000e20, 0x00000000,
+0x00298815, 0x00ec9431, 0x1ac20eb0, 0xb000a100, 0x40031001, 0x00bf002c,
+0x0a100294, 0xab002940, 0x5000b640, 0x0009c00a, 0x80c420ab, 0x54488e10,
+0x00000620, 0x00000000, 0x00290000, 0x038640a1, 0x1e408c10, 0x14006100,
+0x400a5022, 0x0029020a, 0x02900024, 0x21000e40, 0x90003400, 0x00084000,
+0x04a40821, 0x00400e10, 0x00000400, 0x00000000, 0x00272804, 0x22200301,
+0x80601c90, 0x30810000, 0x40041001, 0x80c11032, 0x0c920324, 0xc9203044,
+0xd0033480, 0x033148ac, 0x030480c9, 0x10500c10, 0x00000c00, 0x00000000,
+0x0075a815, 0x06480093, 0x96423f30, 0x7c049341, 0xd0057001, 0x00d94036,
+0x0db1036d, 0xd30036c0, 0xb0037c00, 0x00b4c02d, 0x032c00d3, 0x54c00f34,
+0x00000600, 0x00000000, 0x40570001, 0x007c409f, 0x17c0cdf2, 0x7c805f00,
+0xc029f00a, 0x401f0001, 0x0170005c, 0x170007c0, 0x70003e00, 0x0005c441,
+0x006c001f, 0x07c00df0, 0x00000c00, 0x00000000, 0x00070880, 0x02fc107f,
+0x5fc00fb0, 0x8e05bf05, 0xc002b001, 0x00b7002e, 0x087002bc, 0xaf002dc0,
+0x3100dc00, 0x0000c00a, 0x00dc0083, 0x00c00d34, 0x00000c02, 0x00000000,
+0x04462081, 0xa4740955, 0x06420d53, 0x44005d00, 0x412d100a, 0x00510014,
+0x05b20174, 0x5d2016c0, 0x50034400, 0x00354005, 0x034c805b, 0x04400d10,
+0x00000822, 0x00000000, 0x0064a001, 0x01340095, 0x07600d11, 0x44028d00,
+0x40059000, 0x80550016, 0x05500170, 0x5c001540, 0x10035400, 0x00344805,
+0x03540051, 0x05400c51, 0x00000200, 0x00000000, 0x08002010, 0x01340001,
+0x03440c50, 0x06000d08, 0x40081003, 0x00810020, 0x08100234, 0x8d102040,
+0x50000400, 0x00014008, 0x00440089, 0x40400c10, 0x00000080, 0x00000000,
+0x0006b000, 0x037c80d7, 0x07c40d30, 0x44009d00, 0xc001b000, 0x00170006,
+0x0150007c, 0x1f200548, 0x30005c20, 0x0004c001, 0x005c0013, 0x00d00f32,
+0x00000ac0, 0x00000000, 0x000fb005, 0x03fc007f, 0x0ac00ff0, 0xec003f00,
+0xc80ff203, 0x00ff203f, 0x0ff003fc, 0xff003fc0, 0xf003fc00, 0x083fc00f,
+0x03dc80ff, 0x17c00ff0, 0x00000e40, 0x00000000, 0x840fa003, 0x10cd943f,
+0xbfe44190, 0x7c3c3301, 0xe34ff28b, 0x14ff092c, 0x2df0234c, 0xd300b6c6,
+0x30034c04, 0x003cc04f, 0x02cc00e7, 0x0ce00f30, 0x00000e00, 0x00000000,
+0x00b70801, 0x5a6c021d, 0x3de16110, 0xde061102, 0x416fd10b, 0x16f11624,
+0x0fd01bd4, 0xe140bc40, 0x542bc502, 0x403d502c, 0x02440051, 0x06c00c14,
+0x00000c20, 0x00000000, 0x0003a011, 0x2114144d, 0x33048010, 0x14044501,
+0x400cd01b, 0x00cd0920, 0x4cd08b04, 0xc101b170, 0x10830508, 0x0030408c,
+0x030480d5, 0x44400c10, 0x00000e80, 0x00000000, 0x0235a803, 0x8314048d,
+0x35400590, 0x74015560, 0x500cd003, 0x00d10024, 0x0dd00345, 0xd1083540,
+0x50034400, 0x4035400d, 0x034408d5, 0x0e000d10, 0x00000620, 0x00000000,
+0x0047a802, 0x2854019d, 0x37402db4, 0x5c121700, 0x480df003, 0x80df4024,
+0x0dd0834c, 0xd30035c0, 0x34034c00, 0x4034c80d, 0x134c02d5, 0x08000d30,
+0x00000e20, 0x00000000, 0x104d8007, 0x806c813f, 0x3dc40572, 0xdc001b00,
+0xc00df103, 0x00d70023, 0x0df2037c, 0xef003ec0, 0xf0033c80, 0x003bc00e,
+0x0bfd11fb, 0x1fc00ef4, 0x00000600, 0x00000000, 0x40250802, 0x1d7c40d3,
+0x32d029fc, 0x6c809f10, 0xd00d7083, 0x80c7a064, 0x0c32034c, 0xd70032c0,
+0x74234c00, 0x1034c00d, 0x034c00db, 0x08c80d30, 0x00000420, 0x00000000,
+0x00248013, 0x01740091, 0x3c40a5b8, 0xc4019d00, 0x400f1083, 0x20fb806c,
+0x0f1103c4, 0xf1003d40, 0xf007d500, 0x403c412f, 0x2f4413c3, 0x4c40ef10,
+0x00000200, 0x00000000, 0x0002a007, 0x08248f09, 0x31440010, 0x04288d00,
+0x480c1003, 0x00c50020, 0x0c108305, 0xc1003148, 0x521f0480, 0x5030413c,
+0x0f4583c9, 0x1d600c10, 0x00000a00, 0x00000000, 0x00708004, 0x06b40161,
+0x79605a92, 0x8605ad00, 0x401e10b7, 0x09e10368, 0xde101784, 0xe1017940,
+0xd4079609, 0x5270501e, 0x478449f9, 0x11601e11, 0x00000200, 0x00000000,
+0x00001012, 0x083c084b, 0x71c0f050, 0x4d014f00, 0xc05c3027, 0x05c50960,
+0x5c10070c, 0xc30075c4, 0x60070c05, 0x4230c80c, 0x034e80cb, 0x49d08c30,
+0x00000040, 0x00000000, 0x003db802, 0x02fc00ff, 0x3cc00f70, 0xdc005f06,
+0xc08fe023, 0x08ff122f, 0x8df0237c, 0xff023d03, 0xb00ffc08, 0x023fc00f,
+0x01fe20f7, 0x0ac20ff0, 0x00000660, 0x00000000, 0x2017b015, 0x037c409f,
+0x37c00d70, 0x7c80d325, 0xc44d30b3, 0x16df8224, 0x4df0634c, 0xd30334d0,
+0xf60b4c08, 0x4334da8d, 0x034c01d3, 0x57800df2, 0x00000e00, 0x00000000,
+0x08198012, 0x03b4606d, 0x3b420ed0, 0xb420e148, 0x44cc11c3, 0x06f64168,
+0xced08384, 0xc10c3840, 0xf4170408, 0x0338401e, 0x038400a1, 0x4b404ed0,
+0x00000620, 0x00000000, 0x00790003, 0x07b401ed, 0x7b401ad0, 0xb403e101,
+0x40de1017, 0x01ed0160, 0x5ed197a4, 0xe9017240, 0x90278405, 0x0170405e,
+0x078501e1, 0x0f029ed0, 0x00000400, 0x00000000, 0x00732812, 0x237412cd,
+0x33403d90, 0x3402c100, 0x400c1003, 0x00c90020, 0x0cd00324, 0xc9003240,
+0xd0030400, 0x0030400c, 0x030453c1, 0x4b400cd2, 0x00000c20, 0x00000000,
+0x009da817, 0x05fc007f, 0x17c1a7f0, 0x7c007300, 0x10073001, 0x005f001c,
+0x05f0016c, 0x5b0016c0, 0xf0014c00, 0x4014c005, 0x49cc8373, 0x5fc005f0,
+0x00000620, 0x00000000, 0x02070012, 0x487c001f, 0x07c001f0, 0x3c100f00,
+0xc001f400, 0x00170007, 0x01f0004c, 0x175005c2, 0xf0007c00, 0x0007c201,
+0x0c7c881f, 0x4bc021f0, 0x00000c00, 0x00000000, 0x04270810, 0x067c029f,
+0x20c03970, 0x4c809300, 0xc009b202, 0x00974020, 0x0934020e, 0x930024c0,
+0x30020c00, 0x4024c008, 0x02680093, 0x40c009f0, 0x00000c20, 0x00000000,
+0x00262001, 0x3e74009d, 0x24501911, 0x44009110, 0x40091002, 0x00950064,
+0x09100244, 0x91002440, 0x30025400, 0x0a24dc09, 0x2a60c291, 0x045129d0,
+0x00000800, 0x00000000, 0x0024a018, 0x0274009d, 0x24400910, 0x44019100,
+0x40089202, 0x00850064, 0x08100244, 0x81002050, 0x14824480, 0x48204a29,
+0x026400d1, 0x604008d0, 0x00000200, 0x00000000, 0x00202010, 0x2234088d,
+0x20008810, 0x045c8102, 0x50881022, 0x28850220, 0x88102206, 0x814a2060,
+0x04221402, 0x02304088, 0x22240881, 0x414088d0, 0x00000080, 0x00000000,
+0x0506a01d, 0x587c161f, 0x80c16174, 0x0d061305, 0xc561b058, 0x16152584,
+0x20305845, 0x130584c0, 0x20584c54, 0x0584c160, 0x096c0243, 0x74c021f2,
+0x00000ac0, 0x00000000, 0x002fa819, 0x92fc04bf, 0x27c04bf8, 0x7804bf41,
+0xc049e012, 0x049f012f, 0x69f0127c, 0x9f012700, 0x70927c40, 0x0125c049,
+0x12fc04bf, 0x66c069f0, 0x00000e60, 0x00000000, 0x0127a018, 0x02fc06b3,
+0x2cc00bf0, 0x4c043313, 0xc0693052, 0x0093008d, 0x0970224c, 0x931524e0,
+0x710acc90, 0x01a6c209, 0x0a4c0093, 0x60c16936, 0x00000e00, 0x00000000,
+0x0007001c, 0x18748011, 0x045141d2, 0x0c151140, 0x40411050, 0x10111044,
+0xc1142014, 0x112102c1, 0x12105506, 0x0007c041, 0x00054451, 0x70400310,
+0x00000c20, 0x00000000, 0x00a3a010, 0x4a348681, 0xa04028d8, 0x06028120,
+0x40681002, 0x48810131, 0x48500204, 0x81052040, 0x50122414, 0x00aa510a,
+0x82c490a1, 0x40400a10, 0x00000e80, 0x00000000, 0x0425a818, 0x82740091,
+0x244008d0, 0x44349100, 0x40091002, 0x00910024, 0x09100244, 0x91002646,
+0x10027080, 0x402f400b, 0x42c408a1, 0x60400b10, 0x00000620, 0x00000000,
+0x0027a805, 0x267c0493, 0x244409f2, 0x4c009300, 0xc0093402, 0x00934025,
+0x0970024d, 0x93402440, 0x71026c00, 0x0026c009, 0x06480393, 0x14d00930,
+0x00000e20, 0x00000000, 0x48218014, 0x067c049f, 0x27c089f0, 0x1d201f00,
+0xc008f402, 0x009f2007, 0x09f0027c, 0x9f0023c0, 0xd1025c00, 0x0027c008,
+0x127d209f, 0x53d009f0, 0x00000600, 0x00000000, 0x00850814, 0x005c061f,
+0x07c001f0, 0x5c021300, 0xc0013000, 0x00038004, 0x0030000c, 0x130004c0,
+0x34404c80, 0x0106c001, 0x084d0213, 0x50408130, 0x00000420, 0x00000000,
+0x2014a014, 0x01d4807d, 0x174017d0, 0x74013100, 0x40051401, 0x005f0004,
+0x05100144, 0x51001542, 0xf0092c40, 0x00d6c045, 0x01040151, 0x51403514,
+0x00000200, 0x00000000, 0x0032a014, 0x4b0000cd, 0x27451cd2, 0x1401d100,
+0x400c1083, 0x20c10034, 0x0c500304, 0xd1003060, 0x100a3400, 0x00f6401c,
+0x031401c1, 0x50413d10, 0x00000a00, 0x00000000, 0x00388805, 0x0284818d,
+0x2b4106d2, 0xb498e100, 0x480e1003, 0x04c58230, 0x8e191384, 0xe1013960,
+0xd0023404, 0x04324008, 0x039410e1, 0x15400011, 0x00000200, 0x00000000,
+0x00780015, 0x859d01ef, 0xefc81ed2, 0x9c05e315, 0x503f3007, 0x01e10178,
+0x5c701784, 0xc301f8c0, 0x3406b891, 0x407ac81e, 0x049c0173, 0x54c11e34,
+0x00000040, 0x00000000, 0x0035a810, 0x027c009f, 0x27c005f0, 0x7c00df00,
+0xc96de10b, 0x4adf0037, 0x0db18b7c, 0xde00b7c5, 0xf0026c08, 0x4037c009,
+0x016c00df, 0x43c009f0, 0x00000660, 0x00000000, 0x007fb000, 0x07c881ff,
+0x64c099f0, 0x4c01f303, 0xc01d304f, 0x0bdb1874, 0x1f306fcc, 0xd302f448,
+0xb1064c01, 0x004dc01f, 0x07cc81b3, 0x03801f30, 0x00000e00, 0x00000000,
+0x02398015, 0x0084302d, 0x604052d0, 0xc409c100, 0x401d3037, 0x01d21071,
+0x1f5007c4, 0xf1027c40, 0x54368401, 0x000c500b, 0x038400b1, 0x57408210,
+0x00000620, 0x00000000, 0x00390000, 0x218408cd, 0x2840a8d0, 0x9408e022,
+0x400e9003, 0x00e1003c, 0x4e108384, 0xe1003a44, 0x94120440, 0x0029400e,
+0x00a41821, 0x03400e10, 0x00000400, 0x00000000, 0x04b32804, 0x0804021d,
+0x204090d0, 0x1400c100, 0x400c1003, 0x00c90031, 0x0c500304, 0xc1203250,
+0x54020500, 0x00204008, 0x09241291, 0x13400010, 0x00000c20, 0x00000000,
+0x04f5a815, 0x234c005f, 0x28500df0, 0xd500d348, 0xc00eb503, 0x00f10030,
+0x0f3403cd, 0xf3403ec0, 0xb0014c00, 0x4035c005, 0x0b6d83d1, 0x57c00d34,
+0x00000620, 0x00000000, 0x10370001, 0x033c105f, 0x27c00df0, 0x2c00df00,
+0xc00df003, 0x00d70037, 0x0df0837c, 0xdf0031c0, 0xf0007c00, 0x2033c005,
+0x0b5c02df, 0x07c805f0, 0x00000c00, 0x00000000, 0x003f0880, 0x20dc003f,
+0x2dc00b31, 0xdc05f300, 0xc00f3003, 0x00fb003c, 0x0ef003cc, 0xf3003cc4,
+0xb00dfc00, 0x003cc03e, 0x46cc0873, 0x00c08f20, 0x00000c22, 0x00000000,
+0x00360081, 0x0644e01d, 0x25c00910, 0x7420d100, 0x400d1503, 0x00d10034,
+0x0dd08354, 0xd1083540, 0x10007440, 0x02f54025, 0x14058251, 0x04401d10,
+0x00000802, 0x00000000, 0x8034a001, 0x03440add, 0x27401510, 0x7400d158,
+0x400d1003, 0x00c10074, 0x0dd00344, 0xd1003448, 0x90433400, 0x40944025,
+0x134602d1, 0x04400c50, 0x00000200, 0x00000000, 0x80302010, 0x0104004d,
+0xa3489410, 0x2404c100, 0x400d1043, 0x04c18234, 0x0cd03314, 0xc1403141,
+0x14303480, 0x40114000, 0x03460081, 0x40400050, 0x00000080, 0x00000000,
+0x0036a000, 0x005d009f, 0xebcc5130, 0xfc4bd301, 0xc0df30b7, 0x49f32174,
+0x1ff01fcc, 0xf3237cc0, 0xb0877c2f, 0x4004c80d, 0x020c0053, 0x00d00d74,
+0x00000ac0, 0x00000000, 0x083fa805, 0x00fc803f, 0x6de2d3f4, 0xfc0dce02,
+0xc2dff017, 0x07ff037b, 0x5df2277c, 0xff037fc1, 0xf01cfc09, 0x400fc003,
+0x00fc003f, 0x17c003b0, 0x00000e40, 0x00000000, 0x003fa003, 0x70fc0437,
+0x0fc1c3f0, 0xde023f02, 0xc00f70a0, 0x0cfb083e, 0x0fb003fc, 0xf7003ac0,
+0x3000cc04, 0x000cc00b, 0x00e440f3, 0x0cc40fb0, 0x00000e20, 0x00000000,
+0x00370801, 0x096c0a01, 0x874469d1, 0x44441d02, 0x400fd008, 0x88e5033c,
+0x0d009234, 0xfd003440, 0x50015408, 0x0034400d, 0x034402f5, 0x0d400d50,
+0x00000c20, 0x00000000, 0x0033a011, 0x82340015, 0x21404450, 0x04c04d09,
+0x614cd030, 0x20c92432, 0x0c904330, 0xcd007240, 0x11000400, 0x0031420c,
+0x002402c1, 0x4d440c94, 0x00000e80, 0x00000000, 0x0035a803, 0x03751111,
+0x270009d8, 0x44600c00, 0x400dd091, 0x00d90034, 0x0d109274, 0xdd007441,
+0x500454a0, 0x0035440d, 0x074440d5, 0x0d400d40, 0x00000620, 0x00000000,
+0x0133a802, 0x087c03d7, 0x15c021f0, 0x45049e06, 0xc00d7818, 0x00db0036,
+0x3cb0037c, 0xdf0036c0, 0x30874c00, 0x0005d008, 0x076c00d3, 0x89c00da0,
+0x00000e02, 0x00000000, 0x003d8007, 0xa16d007f, 0x57c021f0, 0xec007d08,
+0xc00ef006, 0x00f7103b, 0x8fe007fc, 0xff003fc0, 0xf003bc00, 0x003ac00f,
+0x81bc00ef, 0x1fd80ef2, 0x00000600, 0x00000000, 0x00b50802, 0x485c025b,
+0xb45035b4, 0x7e30d700, 0xc00df001, 0x80d70037, 0x0d710354, 0xd78837c0,
+0x11225e00, 0x2237c00d, 0x036d0cd3, 0x09400d92, 0x00000400, 0x00000000,
+0x02b4a013, 0x09440441, 0x3540a190, 0x72035102, 0x420fd203, 0x00f1203f,
+0xbd180344, 0xfa06f4c0, 0x10064480, 0x02b740ad, 0x034400fb, 0x6ec00fb2,
+0x00000200, 0x00000000, 0x0032a007, 0x00140449, 0x01400050, 0x348b0100,
+0x420cd000, 0x20c50833, 0x8c500354, 0xd1003140, 0x10061400, 0x30434008,
+0x010403c1, 0x1e420c10, 0x00000a00, 0x00000000, 0x007c8004, 0x04840161,
+0x48401e50, 0xb401a500, 0x001ed105, 0x09e10073, 0x1e108786, 0xc9007c40,
+0x10038401, 0x0073401e, 0x278441e9, 0x36409e94, 0x00000200, 0x00000000,
+0x00301012, 0x1b1c044b, 0x11c024f2, 0x34084740, 0x804cd000, 0x28c70033,
+0x0c50031c, 0xc10031c0, 0x30225400, 0x0033c08c, 0x014c08c3, 0x4bc00d30,
+0x00000040, 0x00000000, 0x1039b802, 0x03fc007f, 0x1fc20fb0, 0xfc009b00,
+0xc02ff209, 0x28ff003f, 0x0cd1237c, 0xfc103fcc, 0xf013fc00, 0x003f800f,
+0x03de38ee, 0x0bc00ff1, 0x00000660, 0x00000000, 0x0497a015, 0x067c005f,
+0x24c009b0, 0x7c009f00, 0xc8ed7013, 0x42df0037, 0x4df8035c, 0xdb2033c8,
+0xf0034c08, 0x0007c009, 0x037c12df, 0x54c00d38, 0x00000e00, 0x00000000,
+0x00398812, 0x02b4006d, 0x28680cb0, 0xb400ed00, 0x424ed003, 0x14cf043b,
+0x2ed003ac, 0xe42539c1, 0xf0039088, 0x003b400e, 0x019c00ed, 0x4d404e50,
+0x00000624, 0x00000000, 0x00790003, 0x07b6016d, 0x78401e90, 0xb4a1ed00,
+0x601e5007, 0x09ed037b, 0x5ed00784, 0xe1267b41, 0xd0078605, 0x007b401e,
+0x07b405ed, 0x04409c10, 0x00000400, 0x00000000, 0x08b32812, 0x0334424d,
+0xf1402d92, 0x3400dd00, 0x400cd033, 0x40c51033, 0x0cd02734, 0xc5083140,
+0xd02b1640, 0x0033400c, 0x071400cd, 0x49000d50, 0x00000c20, 0x00000000,
+0x22918817, 0x21fc1a7f, 0x5cd087b2, 0x7c027f01, 0x40057001, 0x405d0017,
+0x03d001c4, 0x51100b40, 0xd005cc00, 0x001f4405, 0x05f4005d, 0x5cc00510,
+0x00000620, 0x00000000, 0x10070012, 0x0870c01d, 0x06c02170, 0x7c101f04,
+0xc000f100, 0x001f0807, 0x01f00068, 0x170007c0, 0x70005c00, 0x8007c001,
+0xa07c020f, 0x4bc001f0, 0x00000c00, 0x00000000, 0x00370810, 0x067c0097,
+0x64c019f8, 0x4c089300, 0xc409b003, 0x408f8025, 0x41b1024e, 0x930505c1,
+0x30426c00, 0x0020c008, 0x425c4393, 0x40c00970, 0x00000c20, 0x00000000,
+0x04262001, 0x62740291, 0xa4585978, 0x44419112, 0x4009d002, 0x809fa024,
+0x7012022c, 0x9101c448, 0x36060c40, 0x6026d809, 0x02448091, 0x04400910,
+0x00000800, 0x00000000, 0x0024a018, 0x02748295, 0xa04089d1, 0x44009100,
+0x4809d002, 0x009d3025, 0x01900244, 0x85400540, 0x94077400, 0x00244009,
+0x02160091, 0x60400950, 0x00000200, 0x00000000, 0x00242010, 0x22342881,
+0x20408850, 0x07088142, 0x4008d002, 0x0c8d0220, 0x89182264, 0x81022464,
+0x900a4640, 0x90224008, 0x0a0604c1, 0x40542812, 0x00000080, 0x00000000,
+0x0006b01d, 0x583c1617, 0x844161d0, 0x4c961305, 0x4801b350, 0x031d8585,
+0x61b80846, 0x078585e1, 0xb8007c9e, 0x8004e001, 0x001e0113, 0x74c00178,
+0x00000ac0, 0x00000000, 0x0037b819, 0x12fc04fe, 0x2fc04bf0, 0x7c04bf01,
+0xe169e252, 0x8c970127, 0x4be012f8, 0x9f012fc0, 0x780adc01, 0x00afc02b,
+0x0afc089d, 0x67c029f0, 0x00000e64, 0x00000000, 0x0027a018, 0x42cc88b7,
+0x2dc10bb8, 0x4c08f305, 0xc049f00a, 0x149b0126, 0x1b30222c, 0x93206fc1,
+0x3132dc80, 0x0023c009, 0x0a482093, 0x60c329b0, 0x00000e00, 0x00000000,
+0x1007081c, 0x48450a11, 0x84482110, 0x440a1141, 0x40a1d000, 0x14130504,
+0x31109044, 0x1502c740, 0x10384404, 0x00074401, 0x08440a31, 0x70402150,
+0x00000c20, 0x00000000, 0x0027a010, 0x12240485, 0x21414810, 0x16248504,
+0x4008d022, 0x008d0322, 0x48101264, 0x810d2341, 0x54021412, 0x006b4008,
+0x1e05c0a5, 0x48404890, 0x00000e80, 0x00000000, 0x0825a818, 0x0b648091,
+0x24480812, 0x56049501, 0x4809d8a2, 0x00990020, 0x01140244, 0x95040701,
+0x10024480, 0x002f4009, 0x024400b5, 0x60400950, 0x00000620, 0x00000000,
+0x00a7a805, 0x066c0297, 0x25801918, 0x5d009704, 0xc009e102, 0x009f0026,
+0x0130026c, 0x93000340, 0x70065c00, 0xc0a7c019, 0x024c0096, 0x14c009b0,
+0x00000e20, 0x00000000, 0x28358014, 0x0a5c009f, 0x27804974, 0x6c008b08,
+0xc009f086, 0x00970027, 0x81f0027c, 0x9f0107c0, 0xf00e1c40, 0x8927c459,
+0x023c009b, 0x5bd008f0, 0x00000600, 0x00000000, 0x01050814, 0x084c0013,
+0x87c881f2, 0x5c001f02, 0xc0007000, 0x40060006, 0x01b0005c, 0x1f0005cc,
+0x60007c20, 0x000fc001, 0x807c0033, 0x50c00132, 0x00000420, 0x00000000,
+0x80908014, 0x11c40075, 0x1f400770, 0x74107c20, 0x4005b001, 0x00510014,
+0xa3100104, 0x5d028c44, 0x14154000, 0x40134005, 0x01740041, 0x50400514,
+0x00000200, 0x00000000, 0x20b2a014, 0x034401d1, 0x37401cd0, 0x1401cd00,
+0x400c9003, 0x00c50032, 0x8c900314, 0xdd223140, 0x50071040, 0x0033400c,
+0x03340045, 0x50500c10, 0x00000a00, 0x00000000, 0x003c8005, 0x038442c5,
+0x3b4c02d0, 0xb400ed00, 0x400c8117, 0x08e10038, 0x5f1823c4, 0xcd013944,
+0x1003c400, 0x000b4006, 0x133400a5, 0x14400c10, 0x00000200, 0x00000000,
+0x00781015, 0x078d0161, 0x4bc41ef3, 0x1c01ef00, 0xc41eaa07, 0x8df705fe,
+0x9eb1379c, 0xef0079c0, 0x70079c01, 0x087bc01e, 0x37bc01a7, 0x54c01e30,
+0x00000040, 0x00000000, 0x0131b810, 0x017c00df, 0x27c00d70, 0x7ea09f00,
+0xc00db023, 0x22df10b7, 0xecc08b74, 0xdf31b64e, 0xf0031c0a, 0x00070005,
+0x237c005b, 0x43c00df1, 0x00000660, 0x00000000, 0x00ffa000, 0x27f401f9,
+0x7fc01fe0, 0xfc01ff00, 0xc11fb01f, 0x01fe007c, 0x1ff007cc, 0xff06ffc0,
+0xf007cc03, 0x007fc01f, 0x07fc017f, 0x00c19f30, 0x00000e00, 0x00000000,
+0x00398015, 0x23b604a1, 0x3b4082d0, 0xb480ed00, 0xc04f1053, 0x04ed003a,
+0x4ed003ac, 0xf9103b44, 0xd0038404, 0x000b4006, 0x13b400ad, 0x5550cf54,
+0x00000620, 0x00000000, 0x00390000, 0x82b4406d, 0x1b400ad0, 0xb408e500,
+0x640ed133, 0x00ed0038, 0x0ed00386, 0xed203b4c, 0xd0028600, 0x023b400e,
+0x4bb401ad, 0x00700e12, 0x00000400, 0x00000000, 0x00132804, 0x04361085,
+0x334038c0, 0x70108d00, 0x400c5003, 0x00cd0032, 0x0cd00726, 0xc9003340,
+0xd0020400, 0x00030004, 0x0734404d, 0x11400d50, 0x00000c20, 0x00000000,
+0x2235a815, 0x407c809f, 0x37c13df0, 0xf443df00, 0x400ff80f, 0x00fd003c,
+0x8dd01384, 0xfd063741, 0xd2074500, 0x0077041d, 0x07b4005d, 0x54400f14,
+0x00000620, 0x00000000, 0x00b70001, 0x083c005b, 0x93c061e0, 0x7c484f20,
+0xc00cb813, 0x00df0037, 0x2df0037c, 0xdf0037c0, 0xf0227c00, 0x0443c815,
+0x037c209f, 0x07c00df0, 0x00000c00, 0x00000000, 0x003f0880, 0x03fc003b,
+0x8fc00730, 0xcc01f300, 0xd00f3603, 0x00df003c, 0x1f3003fc, 0xff003fc0,
+0xf007fc00, 0x003fc00f, 0x035e80b3, 0x00d00f30, 0x00000c22, 0x00000000,
+0x01322081, 0x2d740051, 0x87402552, 0x44111100, 0x420d1083, 0x80dd2034,
+0x4d120374, 0xdd203748, 0xd2037480, 0x60074805, 0x03748051, 0x04400df2,
+0x00000800, 0x00000000, 0x0034a001, 0x00740399, 0xa7410d10, 0x44089100,
+0x400d5103, 0x00dd0034, 0x4d140374, 0xdd007740, 0xd0237400, 0x0037440d,
+0x03740051, 0x04400d12, 0x00000200, 0x00000000, 0x00302810, 0x00340001,
+0x03400010, 0x04000108, 0x400c1003, 0x00cd0030, 0x0c100374, 0xcd007340,
+0xd0023420, 0x00026004, 0x03740081, 0x40500cd0, 0x00000080, 0x00000000,
+0x0036a000, 0x027c001b, 0x07c00134, 0x8c009300, 0xe20d3003, 0x00ff883c,
+0x0d3803fe, 0xfd8037e0, 0xf8027e00, 0x8037e00d, 0x03de0093, 0x00e00d38,
+0x00000ac0, 0x00000000, 0x003ba825, 0x00fc803f, 0x0fc003f0, 0xfc003f00,
+0xc00ff003, 0x00ff003f, 0x0ff003f8, 0xff003fc0, 0xf002fc00, 0x100f8007,
+0x03fc007d, 0x17c00ff0, 0x00000e60, 0x00000000, 0x003fa003, 0x40fc002b,
+0x3fc423b8, 0xcec09522, 0xc24fb033, 0x0c33133f, 0xc1704b7c, 0xf300bcc1,
+0x2093fca0, 0x411cc08f, 0x00fc08b3, 0x0ce06f30, 0x00000e00, 0x00000000,
+0x08331801, 0x091c8013, 0xbdc26514, 0xcc16b100, 0x40cf1033, 0x02c101bf,
+0x6c100bc4, 0xf100bc40, 0x100b7410, 0x0494c04d, 0x005c44d1, 0x0c40ad10,
+0x00000c20, 0x00000000, 0x0023a011, 0x52340045, 0x33606012, 0x14888102,
+0x410c5113, 0x06d58333, 0x40100326, 0xc521b048, 0x10237444, 0x0306440c,
+0x007400c1, 0x4c404c10, 0x00000e80, 0x00000000, 0x0225a007, 0x23541015,
+0x31628510, 0x54009180, 0x400dda83, 0x00d50037, 0x1d140306, 0xd5003440,
+0x10037400, 0x0014408d, 0x095408d1, 0x0c440d10, 0x00000620, 0x00000000,
+0x0077a882, 0x147c0917, 0x37c00910, 0x5c409300, 0xc00d7403, 0x00154037,
+0x0878036c, 0xd74034c0, 0x30037860, 0x0056c030, 0x097c0093, 0x00400d30,
+0x00000e22, 0x00000000, 0x607d8007, 0x04fc813b, 0x3fc40f73, 0x2d00af20,
+0xc00f3003, 0x20fb383b, 0x0ff3036c, 0xfb003bd0, 0xf4037c00, 0x015fc01b,
+0x01dc01ff, 0x1fc80df4, 0x00000602, 0x00000000, 0x40250802, 0x0a6c0253,
+0x37c809b4, 0x4c009700, 0xc80db083, 0x08db2037, 0x0934036d, 0xd30034c0,
+0xb0134c00, 0x0025c021, 0x097c00df, 0x08c04d30, 0x00000420, 0x00000000,
+0x2024a013, 0x02441110, 0xff413d10, 0xc50bbd02, 0x41af1003, 0x00d302bf,
+0x0d1083e8, 0xf0003c40, 0x10039400, 0x0112c009, 0x133400dd, 0x0d402f10,
+0x00000200, 0x00000000, 0x00262003, 0x00641189, 0x33613012, 0x04088502,
+0x401c1003, 0x801110b3, 0x04000304, 0xc1003040, 0x90031400, 0x00114808,
+0x483400cd, 0x1c400d10, 0x00000a00, 0x00000000, 0x006a0804, 0x058509b1,
+0x7b401210, 0x8601bd00, 0x405e1017, 0x05e92173, 0x9e000784, 0xc1017040,
+0x10079401, 0x105a4496, 0x04f401ed, 0x7d409e14, 0x00000200, 0x00000000,
+0x00321012, 0x802c2003, 0x33423813, 0x0e018721, 0xc01c3827, 0x01c30173,
+0x54201704, 0xc30070c0, 0xb0071c05, 0x0011c629, 0x023c68cf, 0x48c08c30,
+0x00000040, 0x00000000, 0x003da802, 0x01fc207f, 0x37c08b72, 0xfc148f00,
+0x880d70ab, 0x00d740b7, 0x8ff263fc, 0xff02bfd2, 0xf143fc04, 0x003fc007,
+0x23bc40ff, 0x0bc18ff0, 0x00000660, 0x00000000, 0x00278014, 0x074c000f,
+0x37e00530, 0x4c029f04, 0xd04df02b, 0x401f12b4, 0x0d70937c, 0xdf12b4c4,
+0xf0034e06, 0x00149003, 0x017c80df, 0x54c00df0, 0x00000e00, 0x00000000,
+0x00299912, 0x03ac002d, 0x39c80630, 0x84148d21, 0x432c7003, 0x00ef0038,
+0x0f103334, 0xed003844, 0xd3079c08, 0x00184208, 0x01b400ed, 0x4c504ed0,
+0x00000624, 0x00000000, 0x00790000, 0x072401ad, 0x7b601e55, 0xb401ad12,
+0x405ed017, 0x01ed017a, 0x1e1017b4, 0xcd017844, 0xd107a409, 0x08ea4832,
+0x87b401ed, 0x06501ed0, 0x00000402, 0x00000000, 0x10332016, 0x432640cd,
+0x35400c50, 0x35409d00, 0x400d5003, 0x00cd0032, 0x0c100334, 0xcd003040,
+0xd0031400, 0x00724008, 0x233400dd, 0x4a4c0cd0, 0x00000c20, 0x00000000,
+0x80178817, 0x11c4027d, 0x17400750, 0x7c807f00, 0x4805f001, 0x007f0016,
+0x0712017c, 0x5f8014c8, 0xf001ec00, 0x009ec037, 0x0df4005f, 0x5ed005d0,
+0x00000620, 0x00000000, 0x00058012, 0x007c101f, 0x05c04138, 0x0c001f80,
+0xc0217000, 0x02170005, 0x11a0007c, 0x1f8007c0, 0xf0005c00, 0x0045c001,
+0x047c001f, 0x49c001f0, 0x00000c00, 0x00000000, 0x00210810, 0x024d009b,
+0x27ca0970, 0x4c029308, 0xc009b002, 0x00930260, 0x0830023c, 0x8f2024c0,
+0x30820c20, 0x0024d108, 0x224c009f, 0x40c018f2, 0x00000c20, 0x00000000,
+0x00260001, 0x42448083, 0xa7c02971, 0x45039b40, 0x51291202, 0x02950164,
+0x09b10274, 0x9d002440, 0x500e5400, 0x00644009, 0x0644009d, 0x06c019d0,
+0x00000800, 0x00000000, 0x0024801c, 0x02440099, 0xa74029d0, 0x46109100,
+0x48091402, 0x00910024, 0x09920276, 0x95002440, 0x10224400, 0x00746009,
+0x02440095, 0x604089d0, 0x00000200, 0x00000000, 0x82202814, 0x22040089,
+0x234088d0, 0x04808108, 0x40081022, 0x08c50220, 0x88902234, 0x8d022050,
+0x50021408, 0x82206428, 0x0205088d, 0x424088d0, 0x00000080, 0x00000000,
+0x1586b01d, 0x584c001b, 0x07c161f9, 0x4c141105, 0xe141b058, 0x56130584,
+0x61b0587c, 0x1f0584c5, 0x32514402, 0x2584c941, 0x814e021f, 0x74c161f8,
+0x00000ac0, 0x00000000, 0x012fa919, 0x12fc00b7, 0x25c04b70, 0x7c34bf05,
+0xc149f412, 0x04bf0127, 0x4bb0127c, 0x9f0127c8, 0xf0027c06, 0x013fc00b,
+0x03fca4bf, 0x67c048f2, 0x00000e64, 0x00000000, 0x00a7a018, 0x0adc00bf,
+0x2cc02ff0, 0x7c4cb701, 0xc90b320a, 0x00bf00af, 0x69f0127c, 0x9314a4c9,
+0x3012cc10, 0x01acc049, 0x02cc0093, 0x64c02bf0, 0x00000e00, 0x00000000,
+0x2003181c, 0x086d001d, 0x84d00078, 0x5c0e1147, 0x4021b008, 0x001d0187,
+0x20d01064, 0x11008442, 0x18287406, 0x01044271, 0x00445411, 0x704821d0,
+0x00000c22, 0x00000000, 0x00a10012, 0x1a34009d, 0x200828d0, 0x36008100,
+0x4548509a, 0x168d81a3, 0x08d04a34, 0x85812040, 0x10026410, 0x01a24188,
+0x02040091, 0x484068d0, 0x00000e80, 0x00000000, 0x00252018, 0x0364009d,
+0x344029d0, 0x1420d008, 0x40095d02, 0x109d1027, 0x09d00264, 0x85102042,
+0x10027480, 0x00664209, 0x12450891, 0x604009d0, 0x00000620, 0x00000000,
+0x0067a805, 0x127c1b9f, 0x24c009d0, 0x7c809300, 0x40095902, 0x219f3027,
+0x08f80274, 0x974024c0, 0x10024c00, 0x00a6c009, 0x0e4c0083, 0x14d009f0,
+0x00000e20, 0x00000000, 0x01258012, 0x027d009f, 0x27c00970, 0x5c009f28,
+0xc009b002, 0x049f0027, 0x09f0027c, 0x9b4027d0, 0xf4025c00, 0x4025c009,
+0x027c009f, 0x5bc009f0, 0x00000600, 0x00000000, 0x00050810, 0x084c0213,
+0x00e0a170, 0x7c001300, 0xc001b000, 0x12130007, 0x01f0006c, 0x131004c0,
+0x31004c00, 0x4084c000, 0x044c0013, 0x50c001f0, 0x00000420, 0x00000000,
+0x0014a014, 0x01c43361, 0x5d4007d0, 0x74007d30, 0x40174081, 0x0371001f,
+0x07920168, 0x51001448, 0x10019400, 0x00545007, 0x09c40051, 0x505007d0,
+0x00000200, 0x00000000, 0x0032a014, 0x630406c9, 0x70451d93, 0x3400c108,
+0x601c1003, 0x0bc90033, 0x0c500304, 0xc8083040, 0x10030600, 0x4034440c,
+0x030400c1, 0x504189d0, 0x00000a00, 0x00000000, 0x01788801, 0x03858029,
+0x19600e90, 0xb4426d04, 0x41025013, 0x41e9005b, 0x8e9203a4, 0xe9083040,
+0x14019404, 0x0420405e, 0x838404e1, 0x144002d0, 0x00000200, 0x00000000,
+0x43781011, 0x858c81e3, 0x786216f0, 0xfc41a300, 0xc01e341f, 0x01cb0073,
+0x5ee0078c, 0xcb0278c0, 0x32048c07, 0x0078e02c, 0x078d05f3, 0x54c01ff0,
+0x00000040, 0x00000000, 0x0235a810, 0x017d0007, 0x17c00df0, 0x7c005f00,
+0xc009305b, 0x80d70037, 0x2db02b7c, 0xd713b7c4, 0xf0003c50, 0x0027c01d,
+0x037c09df, 0x43c007f2, 0x00000660, 0x00000000, 0x007d2000, 0x27fe0137,
+0x7cc05df2, 0x4c09f902, 0xc01f7027, 0x01f3027c, 0xfd320f4c, 0xd30374c0,
+0x30170c01, 0x007dc01f, 0x05bc01f3, 0x08c89f30, 0x00000e00, 0x00000000,
+0x02391815, 0x238c0863, 0x4ac01030, 0x0c0d2102, 0x40105207, 0x018f0054,
+0x9f1007c4, 0xcb007441, 0x50250c61, 0x423c408f, 0x23b400e1, 0x5440ce10,
+0x00000620, 0x00000000, 0x00390000, 0xa114003d, 0x38438610, 0xa448a101,
+0x600ed003, 0x0c601039, 0x0e121384, 0xe5c23860, 0x9000b424, 0x0028400e,
+0x03b410e1, 0x20400a10, 0x00000400, 0x00000000, 0x80312004, 0x01040041,
+0x00400091, 0x04000100, 0x40089003, 0x01150031, 0x3c100304, 0xd9003040,
+0xd4801440, 0x00a0402c, 0x0b3400c1, 0x18500810, 0x00000c20, 0x00000000,
+0x003d8815, 0x435c1117, 0x24500938, 0xec00d340, 0xd00df003, 0x06d10025,
+0x0f3403cc, 0xf7203cd0, 0xb0037c80, 0x00b4d05f, 0x0f7c01f3, 0x54c00934,
+0x00000620, 0x00000000, 0x00370001, 0x035c8297, 0xb7c00c30, 0x7c02d708,
+0x40057003, 0x04df2006, 0x4cf0037c, 0xdc1033c0, 0x70014c40, 0x0167c10d,
+0x077c00df, 0x27c001f0, 0x00000c00, 0x00000000, 0x80330884, 0x23cd0933,
+0x04c001f0, 0xcc003e00, 0xc055f103, 0x00d3187c, 0x0f3003c4, 0xf3203ce0,
+0x3401cc00, 0x003cc00e, 0x43fc00f3, 0x07c009e0, 0x00000c20, 0x00000000,
+0x00360085, 0x0f558485, 0x96c09d70, 0x44024900, 0xc225f003, 0x40db0036,
+0x0d15036c, 0xd1103440, 0x10010500, 0x0020400f, 0x065c00db, 0x874011d0,
+0x00000800, 0x00000000, 0x0034a001, 0x80440011, 0x254009d0, 0x4440dd82,
+0x4028d003, 0x00d10120, 0x0d100314, 0xd1003440, 0x10074600, 0x0034400d,
+0x237400d1, 0x074019d0, 0x00000200, 0x00000000, 0x88302810, 0x00140005,
+0x236060d0, 0x04109901, 0x4100d883, 0x10890202, 0x6c10c334, 0xc1043040,
+0x10410410, 0x0034500c, 0x071400c9, 0x434008d0, 0x00000080, 0x00000000,
+0x003eb000, 0x00440011, 0x455031d9, 0x8c0b0f00, 0xc091f137, 0x41532174,
+0x3f10a7dc, 0xe301fc50, 0x303d4c8f, 0x0024c00d, 0x037c00d3, 0x07c009f0,
+0x00000ac0, 0x00000000, 0x003fa805, 0x00fd002f, 0x84023370, 0xec011f00,
+0xc0517037, 0x111f0377, 0x3ff017ec, 0xff457fc8, 0xf015fd05, 0x002fc00f,
+0x02dc00ff, 0x17c00bf0, 0x00000e60, 0x00000000, 0x002fa003, 0x00fc003b,
+0x0fc00fb0, 0xfcc43302, 0xc08ff030, 0x003b001e, 0x0fb010ec, 0xfb003bc0,
+0x3002fc04, 0x003ec003, 0x00ec00f3, 0x0cc00f30, 0x00000e00, 0x00000000,
+0x20270801, 0x00748081, 0x84480f10, 0x74c81102, 0x404fd020, 0x12d11194,
+0x0d502354, 0xf10435c0, 0x34023408, 0x02bd4601, 0x024400d5, 0x05400f10,
+0x00000c60, 0x00000000, 0x0023a011, 0x82348889, 0x32500c90, 0x14a04109,
+0x404cd010, 0x060d0492, 0x0c100024, 0xc9013340, 0x10001400, 0x00304208,
+0x022400c1, 0x44440c10, 0x00000e80, 0x00000000, 0x0025a803, 0x43740391,
+0x34440d10, 0x7406d102, 0x400dd013, 0x00c10010, 0x0d510344, 0xd1083740,
+0x900664a0, 0x0035430d, 0x036400d5, 0x0d400d10, 0x00000600, 0x00000000,
+0x00278802, 0x087c839b, 0xc6c00db2, 0x7c201300, 0xc80df084, 0x803b011e,
+0xad3400ec, 0xdb02b7c0, 0x300e7c40, 0x0036c025, 0x256c00d3, 0x08400d30,
+0x00000e22, 0x00000000, 0x01298007, 0x15fc00bf, 0x4e400ef0, 0xf401bf44,
+0xc00ef083, 0x00fd001f, 0x1ff003fc, 0xdf107cc8, 0x7003bc00, 0x0037c03e,
+0x079c00ef, 0x1fc00ef2, 0x00000600, 0x00000000, 0x00250802, 0x0a0c00df,
+0xb4c00d70, 0x4c025f08, 0xc00df100, 0x003f001e, 0x0db020bc, 0xd340b6c0,
+0x700a5c40, 0x2030c101, 0x025d00d7, 0x08d00d30, 0x00000420, 0x00000000,
+0x0024a013, 0x034400dd, 0xf6c02f10, 0x4507dd00, 0x400fd003, 0x00dd0017,
+0x7d100340, 0xf1003740, 0x10136c00, 0x083c481d, 0x034400f1, 0x4c400f1a,
+0x00000200, 0x00000000, 0x0022a007, 0x000405cd, 0x05411c50, 0x14074d10,
+0x420c9000, 0x000d2033, 0x7cd04010, 0xc5403640, 0x10060400, 0x003044a0,
+0x011400cd, 0x0d400c10, 0x00000a80, 0x00000000, 0x00788004, 0x048401ed,
+0x4b509c10, 0x84096d04, 0x401ed004, 0x41ed007b, 0x1e103784, 0xe5007b40,
+0x1003a601, 0x00780000, 0x270481e9, 0x10401c10, 0x00000820, 0x00000000,
+0x02201012, 0x004c10cf, 0x81c18c70, 0x1c00df00, 0x480cf00b, 0x041f8033,
+0x0cf0101c, 0xc700b2c0, 0x702a1c20, 0x0030c08c, 0x221c00df, 0x48c08c10,
+0x00000040, 0x00000000, 0x002db802, 0x20fc08ff, 0x0ec08ff0, 0xfc00ff00,
+0x410ff003, 0xc0ff003f, 0xadf0139c, 0xdb0037c0, 0xf0136c02, 0x023fc04f,
+0xa3fc00f7, 0x0bc00ff2, 0x00000620, 0x00000000, 0x0027a015, 0x044d00d3,
+0x35c08d30, 0x4d00df00, 0xc07df013, 0x00330036, 0x4c3400cd, 0xd30230c0,
+0xf002fc02, 0x01b4c00d, 0x847c00d3, 0x43c04d32, 0x00000e00, 0x00000000,
+0x00398812, 0x000400f7, 0x38c08c10, 0x8400cd08, 0x40ccd043, 0x00c10830,
+0x4e100304, 0xf5023840, 0xd0038404, 0x033c500e, 0x02b440e5, 0x4b414e50,
+0x00000664, 0x00000000, 0x00f90003, 0x048401e5, 0x7b405e10, 0x8481ed00,
+0x405ed08f, 0x0121007a, 0x9f100484, 0xe5017c40, 0xd004b409, 0x0278401e,
+0x06340de1, 0x13429e10, 0x00000400, 0x00000000, 0x20772812, 0x00042ac5,
+0xb1400c10, 0x0404cd01, 0x400cd003, 0x00c14034, 0x2c100305, 0xd5203040,
+0xd0070400, 0x0030406d, 0x033400c5, 0x5b400c50, 0x00000c00, 0x00000000,
+0x005d8817, 0x45cc0173, 0x9fc00534, 0x4c007d10, 0xc005f005, 0x00530016,
+0x0231014c, 0x57160cd1, 0xf045fc00, 0x0014c077, 0x41f40053, 0x5fc00534,
+0x00000e20, 0x00000000, 0x00070012, 0x007c921d, 0x868420f0, 0x7ca01f00,
+0xc001f240, 0x203f0007, 0x21f008fc, 0x1f0007c0, 0xf0407c00, 0x0007c021,
+0x007c001f, 0x4bc801f0, 0x00000600, 0x00000000, 0x00270810, 0x024c008b,
+0x20e409f0, 0x4c009300, 0xc009b003, 0x40870027, 0x01360e4c, 0x970004c1,
+0x74021c00, 0x0825c059, 0x024c0097, 0x43c009f0, 0x00000420, 0x00000000,
+0x00260001, 0x06540091, 0xa4e0c970, 0x54009100, 0x4409d002, 0x00910027,
+0x91100a2c, 0x91000440, 0x52064400, 0x00244019, 0x82440091, 0x174009d0,
+0x00000800, 0x00000000, 0x0024a018, 0x06440098, 0x265409d0, 0x44018100,
+0x40099202, 0x00b50027, 0x055202c4, 0x95080040, 0xd0225400, 0x10234809,
+0x02440085, 0x734009d0, 0x00000200, 0x00000000, 0x12202010, 0x721408c1,
+0x21400850, 0x1408c102, 0x4008d202, 0x2ca10323, 0x8c1032a4, 0x81022050,
+0xd00a0402, 0x0122402c, 0x0a040085, 0x534028d0, 0x000000a0, 0x00000000,
+0x0586b01d, 0x184c161b, 0x964141f0, 0x4c161345, 0xc001a050, 0x031700c7,
+0x61700dcc, 0x170584c1, 0xf0005c14, 0x02c7c001, 0x004d1e17, 0x67c001f0,
+0x00000ac0, 0x00000000, 0x092fb819, 0x12fc04bf, 0x3ec009f2, 0x7c04bf01,
+0xc169f052, 0x0c9f0327, 0x4bf03278, 0x9f012fc0, 0x740afc00, 0x0265442a,
+0x0afc819b, 0x67c029f0, 0x00000e24, 0x00000000, 0x0227a018, 0x42fc08bf,
+0x3cc14930, 0x7c10bf00, 0xc109f042, 0x01930067, 0x5a3016cc, 0x930663c1,
+0xf0324c20, 0x0424c34a, 0x027c049b, 0x60c049b0, 0x00000e00, 0x00000000,
+0x0387081c, 0x00740a1d, 0x805021b0, 0x5c021d0a, 0x4021d000, 0x1e114087,
+0x7150146c, 0x15008740, 0xd039453e, 0x00854061, 0x00740211, 0x60414110,
+0x00000c60, 0x00000000, 0x0023a010, 0x5234048d, 0x20400810, 0x34148d14,
+0x4008d002, 0x008105a3, 0x08904a04, 0x81012741, 0xd0020400, 0x05204518,
+0x52341c89, 0x48402890, 0x00000400, 0x00000000, 0x0825a818, 0x0274009d,
+0x24400990, 0x54109d01, 0x4009d282, 0x00910027, 0x01d00064, 0x95042740,
+0xd2824440, 0x00254009, 0x2a742095, 0x60400910, 0x00000600, 0x00000000,
+0x3067a805, 0x1e7c139f, 0xa4c00930, 0x74289f00, 0xc409f24e, 0x00934027,
+0x41b0004c, 0x830023c0, 0xf08a4c00, 0x0024c009, 0x0a7c009b, 0x149009b0,
+0x00000e20, 0x00000000, 0x00a58014, 0x127c049c, 0x27c00df0, 0x5c019f00,
+0xc009f026, 0x009f0027, 0x9170007c, 0x9f1227c8, 0xf2437c00, 0x0827c139,
+0x067c009b, 0x4bc009f0, 0x00000600, 0x00000000, 0x00050814, 0x807c021f,
+0x860240f0, 0x7c201301, 0xc001f008, 0x40030801, 0x2132100c, 0x131004d0,
+0x30085c00, 0x0006c801, 0x887c2013, 0x43c001f0, 0x00000420, 0x00000000,
+0x0014a014, 0x4574007d, 0x5d4815d0, 0x74007101, 0x4005d001, 0x005b0014,
+0xa3100cc5, 0x75001c41, 0x160d4400, 0x00144017, 0x01748051, 0x534005d0,
+0x00000200, 0x00000000, 0x0032a014, 0x037401c9, 0x32400cd0, 0x3480c110,
+0x400cd883, 0x00c10031, 0x1c100305, 0xc1003040, 0x10071400, 0x08365425,
+0x037400c1, 0x53400dd8, 0x00000a00, 0x00000000, 0x08388005, 0x03b442ad,
+0x79502ed0, 0xb400e100, 0x405cd013, 0x04c90138, 0x1f122b14, 0xe5023848,
+0x1446c488, 0x1038502e, 0x23b400e1, 0x07404ed8, 0x00000220, 0x00000000,
+0x00781015, 0x06bc01ef, 0x7ac01cd0, 0xbc012300, 0xc01ef01f, 0x01e32071,
+0x1e34478d, 0xf34378c1, 0x30a79c05, 0x417ed016, 0x07bc01e3, 0x47c0bef0,
+0x00000040, 0x00000000, 0x0235b810, 0x827c001f, 0x17c269f0, 0x7c80df40,
+0x408df003, 0x84df0137, 0xcdf29364, 0xdb00b7c0, 0xf2033c00, 0x07b7c00d,
+0x037c22df, 0x43c02df0, 0x00000620, 0x00000000, 0x007ba800, 0x26cc01f3,
+0x5fc03ff2, 0xfc81ff00, 0xc01f7027, 0x13f304fd, 0x1f3007cc, 0xf3007fc0,
+0x3004cc01, 0x087fc09f, 0x87cc93f3, 0x00c01f30, 0x00000400, 0x00000000,
+0x08399015, 0x828408ab, 0x2840aed0, 0xf400ed02, 0x400f10c3, 0x10e10038,
+0x4e501384, 0xe1213b40, 0x10008404, 0x013b40ce, 0x038c00fb, 0x54680e14,
+0x00000460, 0x00000000, 0x063d0000, 0x428400e1, 0x184006d8, 0xb4002d00,
+0x400e5003, 0x00e10031, 0x0e110384, 0xe1203b40, 0x9020a420, 0x083b440a,
+0x03a400e1, 0x00400e10, 0x00000400, 0x00000000, 0x10332004, 0x02040201,
+0x004000d0, 0x3406cd00, 0x440c1007, 0x45c14030, 0x3c521704, 0xc100f340,
+0x92012540, 0x00334208, 0x0b0000c9, 0x10400c11, 0x00000400, 0x00000000,
+0x0079a035, 0x074d0041, 0x24d00df0, 0xfc00df00, 0xc00f7003, 0x03f3003d,
+0x8d344f4d, 0xf3063fc1, 0xb0036c00, 0x003fc235, 0x1fed00f3, 0x54d00f20,
+0x00000620, 0x00000000, 0x00370001, 0x037c00df, 0x31c024f0, 0x3c001f00,
+0xc40cf003, 0x20cf0037, 0x0df0037c, 0xcf0037c0, 0x72475c00, 0x0037c059,
+0x031c00df, 0x07c00df0, 0x00000c00, 0x00000000, 0x803f0080, 0x02cc1173,
+0x2cc03ff0, 0xcc002300, 0xc00f0043, 0x00df003d, 0x0f38030c, 0xff003cc0,
+0xf2131c00, 0x0037c00f, 0x434c00f3, 0x13c00f30, 0x00000c22, 0x00000000,
+0x00362081, 0x02540351, 0x554011d0, 0x440b1102, 0x400db003, 0x00dd0834,
+0x0c100344, 0xdd083440, 0x10024400, 0x0037411d, 0x036c80db, 0x17400d10,
+0x00000802, 0x00000000, 0x0034a001, 0x07440611, 0x044009d0, 0x4402d110,
+0x400d5003, 0x00dd2035, 0x1d520774, 0xdd083440, 0x90005600, 0x0033401d,
+0x034400c1, 0x07400d10, 0x00000200, 0x00000000, 0x00342810, 0x03140091,
+0x204000d0, 0x04200500, 0x400cd003, 0x00cd0030, 0x1c100735, 0xcd003052,
+0x10010400, 0x00334008, 0x032600c9, 0x43400c10, 0x000000a0, 0x00000000,
+0x0036a000, 0x024c0001, 0x04c001f0, 0x4d001340, 0xc00d7003, 0x00ff003d,
+0x0d54037c, 0xdf083c40, 0xf0005c00, 0x003fc009, 0x034c40f3, 0x03c00e34,
+0x00000ac0, 0x00000000, 0x003fa805, 0x02fc003f, 0x0fd002f0, 0xfc003b00,
+0x800fb003, 0x40ff103f, 0x0ff003cc, 0xef003bc0, 0xf100fc00, 0x003fc00b,
+0x03fc00ff, 0x17c00ff0, 0x00000e20, 0x00000000, 0x023fa003, 0x50ed003f,
+0x37c083f0, 0xfc04d300, 0xc2cdb002, 0x06df01bf, 0x0f3019fc, 0xf3003cc0,
+0xf023dc04, 0x023cd08e, 0x12fc04ff, 0x0cc04b31, 0x00000e00, 0x00000000,
+0x01370801, 0x1845021d, 0xbb4081d2, 0x7402fb22, 0x40cf7032, 0x8edd00bf,
+0x0d100874, 0xf106b440, 0xd003441e, 0x0130404d, 0x227402dd, 0x0c402d10,
+0x00000c20, 0x00000000, 0x0033a011, 0x4134020d, 0x334000d0, 0x3416c10d,
+0x400cd140, 0x00cd0333, 0x1c101914, 0xc1813444, 0xd0131404, 0x0030600c,
+0x023408cd, 0x4c428c12, 0x00000e80, 0x00000000, 0x0035a803, 0x0154081d,
+0x374401d0, 0x7440d910, 0x400dd006, 0x40dd0037, 0x1d100174, 0xd1003442,
+0xd0034400, 0x0035410d, 0x027400dd, 0x0c404d11, 0x00000620, 0x00000000,
+0x0037a802, 0x0b7d101f, 0x37c03df0, 0x7c00d300, 0xc00db047, 0x00dd0037,
+0x0c310938, 0xd30034d0, 0xf0035c00, 0x0034d08c, 0x027c00df, 0x08c00934,
+0x00000e22, 0x00000000, 0x203d8007, 0x036c817f, 0x3fc09df2, 0xfc00ff00,
+0xc20d5203, 0x80ff003f, 0x0ff000fc, 0xdf003fc0, 0xf00bfc00, 0x003ec01f,
+0x163c00df, 0x1fc21ef8, 0x00000600, 0x00000000, 0x02350802, 0x096c009f,
+0x31d02134, 0x7c80d308, 0xd00d3401, 0x00d70034, 0x4db0095c, 0xd70037c0,
+0xf0435c00, 0x4034c80d, 0x024c00d3, 0x08d00d30, 0x00000420, 0x00000000,
+0x087ca013, 0x294500dd, 0x3c40a110, 0x7400f100, 0x000f1003, 0x00f5003c,
+0x0d100144, 0xfd103b40, 0xd1034491, 0x003c500d, 0x025400f1, 0x6c40ad10,
+0x00000200, 0x00000000, 0x0072a007, 0x000440dd, 0x30400090, 0x3400c100,
+0x409c1002, 0x20c50030, 0x2c908104, 0xd5003340, 0xd00b1401, 0x0032500c,
+0x830080c5, 0x1c402c10, 0x00000a00, 0x00000000, 0x00788004, 0x048409cd,
+0xf8409290, 0xf409e102, 0x409e1037, 0x8de51070, 0x5e1024c4, 0xec007b41,
+0xd2878405, 0x007a429e, 0x279421e5, 0x74001e14, 0x00000200, 0x00000000,
+0x00301012, 0x2b0c00cf, 0x71c0fcb0, 0x3c85c301, 0xc05c3406, 0x01d70030,
+0x9cb0290c, 0xc70173c0, 0xf21f1c01, 0x2832c88c, 0x030c00c7, 0x48c00830,
+0x00000040, 0x00000000, 0x003db802, 0x03dc00ff, 0x37e00d70, 0x3c0aff42,
+0xc08df083, 0x38df00b7, 0x0ff0a3ae, 0xde0237c0, 0xf0237c10, 0x023dc08f,
+0x03fc10fb, 0x0bc00af0, 0x00000660, 0x00000000, 0x0037a015, 0x034c001f,
+0x36c00df0, 0x6c08d301, 0xc04d3082, 0x00df033c, 0x2db0034c, 0xd30237c0,
+0x311b4c06, 0x0034c04c, 0x02fc01d3, 0x57c00d30, 0x00000e00, 0x00000000,
+0x00b98812, 0x03ac006d, 0xb8000ed0, 0x8404c105, 0x42cc1003, 0x04ed1138,
+0x0e100094, 0xc1013f41, 0x1053c40c, 0x00bd40ce, 0x02b405e1, 0x4f400e10,
+0x00000624, 0x00000000, 0x00790003, 0x0f8503ad, 0x71401ed0, 0x0401e100,
+0x40de1046, 0x05ed007a, 0x9e1007c4, 0xe1007b40, 0x5037a401, 0x007a40ff,
+0x063400e1, 0x07401a10, 0x00000400, 0x00000000, 0x00332812, 0x436400cd,
+0x31400dd0, 0x0400c100, 0x400c1403, 0x00cd0036, 0x4c100314, 0xc1003340,
+0x50132440, 0x1037445d, 0x223400c1, 0x4b400810, 0x00000c20, 0x00000000,
+0x0015a817, 0x01cc007f, 0x17d0f7f0, 0xac005300, 0xc0053005, 0x005f0016,
+0x333409cc, 0x63001fc1, 0x704ced00, 0x40168033, 0x053c0053, 0x5fc00538,
+0x00000620, 0x00000000, 0x00070012, 0x007c041f, 0x02c001f0, 0x7c801f00,
+0xc001f000, 0x401f0005, 0x2170047c, 0x1f0007c4, 0x90005e00, 0x0005c001,
+0x007c001f, 0x4bc021f4, 0x00000c00, 0x00000000, 0x00230810, 0x0a4c0083,
+0x24c00930, 0x4c008300, 0xc0283402, 0x00930026, 0x31b0020c, 0x9b2023c0,
+0x30804c05, 0x0024c401, 0x024c0083, 0x40d00870, 0x00000c20, 0x00000000,
+0x40a62001, 0x0a440091, 0x24540914, 0x44009110, 0x40091002, 0x80910024,
+0x01300244, 0x91002744, 0x10004400, 0x00244001, 0x0a440091, 0x04407910,
+0x00000800, 0x00000000, 0x00a4a018, 0x0a440091, 0x64401910, 0x44489100,
+0x68091002, 0x00810026, 0x01900244, 0x99002740, 0x10040500, 0x00244001,
+0x22440091, 0x60404950, 0x00000200, 0x00000000, 0x02202010, 0x22058881,
+0x20408810, 0x44048100, 0x40881072, 0x88816320, 0x0c102204, 0x91022340,
+0x14220608, 0x02204088, 0x02040081, 0x40400810, 0x00000080, 0x00000000,
+0x2586b01d, 0x584c5603, 0x04cb6030, 0x4d011105, 0xc1613018, 0x160320c6,
+0x41b0584d, 0x1b0587c1, 0x32584c16, 0x4084d161, 0x514c1413, 0x74c14170,
+0x00000ac0, 0x00000000, 0x0927b819, 0x12fc04bf, 0x27c04ff0, 0xfc1c9f45,
+0xc249f012, 0xa49f0327, 0x0b7012bc, 0x9e0127c8, 0xf012fc04, 0x01a7c04b,
+0x02fc009f, 0x67c00bf0, 0x00000e64, 0x00000000, 0x00afa018, 0x8acdc29f,
+0x2fc04bf0, 0x6c3cb308, 0xc86b321a, 0x849f00a7, 0x1bf2224c, 0xa320afc1,
+0x301ec014, 0x00a4c879, 0x02fc00b0, 0x63c00b30, 0x00000e00, 0x00000000,
+0x0807081c, 0x0844020d, 0x874161d0, 0x04461115, 0x40211000, 0x841d0283,
+0x01d0102c, 0x11010340, 0xb0184402, 0x11845000, 0x08740a1b, 0x71c02114,
+0x00000c20, 0x00000000, 0x01a3a010, 0x9a04028d, 0xb34088d0, 0x64008100,
+0x40685c1a, 0x128d0123, 0x18d00a14, 0x8100a760, 0x5a364414, 0x01a04078,
+0x0a340081, 0x4b402c10, 0x00000e80, 0x00000000, 0x0025a818, 0x4245028d,
+0x274009d0, 0x44209100, 0x4009500a, 0x009d0027, 0x19d00a74, 0x91202760,
+0x99064420, 0x00244019, 0x02740099, 0x61401910, 0x00000620, 0x00000000,
+0x0027a805, 0x064d009f, 0x27c039f0, 0x6c809340, 0xc0097402, 0x009f0027,
+0x09f0065c, 0x930027c0, 0x70020f00, 0x0024c808, 0x023c0093, 0x17c00930,
+0x00000e20, 0x00000000, 0x00258014, 0x167d009f, 0x23c039f0, 0x7c009f10,
+0xc009b002, 0x008f0027, 0x09f0266c, 0x9f4027c0, 0xf0427c00, 0x0023c009,
+0x427c009f, 0x59c009f0, 0x00000600, 0x00000000, 0x01050814, 0x006c001f,
+0x07c06130, 0x7c000704, 0xc0013008, 0x00130006, 0x4130007c, 0x030005c0,
+0xf0006c04, 0x0004d001, 0x006c801b, 0x53c01130, 0x00000420, 0x00000000,
+0x005ca014, 0x01c4005d, 0x1f403711, 0x34015100, 0x40050401, 0x00510015,
+0x071081f0, 0x71019840, 0x7009c402, 0x00144007, 0x09f41151, 0x53400714,
+0x00000200, 0x00000000, 0x0072a014, 0x072500cd, 0xb3000c12, 0x3409c580,
+0x400c9003, 0x00c10030, 0x28100334, 0xc1013340, 0xd0032408, 0x8032400c,
+0x212401c9, 0x53400410, 0x00000a00, 0x00000000, 0x0c388005, 0x0d8404ed,
+0x3f402610, 0xb440e100, 0x401a9003, 0x04e10079, 0x161837b4, 0xa1003a60,
+0x10038400, 0x0132404e, 0x013400e1, 0x17400610, 0x00000200, 0x00000000,
+0x00581015, 0x072c05ef, 0x7fc01a34, 0xbc01a710, 0xc41cb017, 0x07e1007a,
+0x1a3007bc, 0xe3007bc0, 0xf007ac01, 0x04fac03e, 0x04ac01eb, 0x57c01e30,
+0x00000040, 0x00000000, 0x2015b810, 0x017d38df, 0x37c001f0, 0x7c009f00,
+0xc00d714b, 0x02df42b7, 0x00f00b7c, 0xdf0035c0, 0xf0037c00, 0x01b5c04d,
+0x007c00df, 0x43c005f0, 0x00000660, 0x00000000, 0x006fa000, 0x86ec4df3,
+0x4fc01f30, 0xac81d340, 0xc01f2c47, 0x03f302fc, 0x91202f4c, 0x7f237cc0,
+0xf007c801, 0x007cc03f, 0x04fc09b1, 0x03c01ff0, 0x00000e00, 0x00000000,
+0x20b98015, 0x80ad08f1, 0x0f400c11, 0x0409e101, 0x484b5003, 0x00f1007d,
+0x144007c4, 0x0d007043, 0xf0150404, 0x1038410e, 0x10b400a1, 0x574006d0,
+0x00000620, 0x00000000, 0x02090000, 0x02a454e9, 0x0b408e90, 0xe408a020,
+0x440e5003, 0x08e10038, 0x4b1803a4, 0x6d203a40, 0xd0638600, 0x0038400e,
+0x02b480a1, 0x03400ad0, 0x00000400, 0x00000000, 0x80172804, 0x002500c9,
+0x03400c90, 0x44009100, 0x400c582f, 0x00c10031, 0x20582b24, 0x4d003240,
+0xd0850400, 0x0030402c, 0x02340081, 0x134000d0, 0x00000c20, 0x00000000,
+0x4035a815, 0x036d21fb, 0x37c00db4, 0xec00d300, 0xc00d700b, 0x00f3403c,
+0x28342fed, 0x5d0036c0, 0xf0070d00, 0x403cd02f, 0x017c0083, 0x57c005f0,
+0x00000620, 0x00000000, 0x28a70001, 0x037c00d7, 0x17e00470, 0x7c00df00,
+0xc009e403, 0x00df0837, 0x05f0035c, 0x1f0035c0, 0x70137c00, 0x0037c00d,
+0x017c009b, 0x07c085f0, 0x00000c00, 0x00000000, 0x003f0880, 0x08cd00f3,
+0xecc01bf0, 0xcc43df30, 0xc00f3043, 0x00fb003b, 0x0b3003bc, 0x132038c1,
+0x3012fc01, 0x0038c10f, 0x088d00b3, 0x00d05b30, 0x00000c22, 0x00000000,
+0x00e60081, 0x005400d1, 0x86c421d0, 0x6c00d909, 0x400d1083, 0x00d10037,
+0x01120374, 0x1b013440, 0x50027403, 0x0036c00c, 0x88440095, 0x04402010,
+0x00000800, 0x00000000, 0x4204a001, 0x0b4400c1, 0x344141d0, 0x44009d00,
+0x400d1003, 0x40d91037, 0x01100374, 0x51820440, 0x10037434, 0x0034400d,
+0x0b440491, 0x04402d14, 0x00000200, 0x00000000, 0x00002010, 0x031580c1,
+0x124000d0, 0x24508900, 0x40081003, 0x00c10433, 0x45504334, 0x09030040,
+0x50117400, 0x0032400d, 0x03040085, 0x40400410, 0x00000080, 0x00000000,
+0x0002a000, 0x000c00f3, 0xa4c001f0, 0xcc0b9f02, 0xc40d1403, 0x00fb007f,
+0xd93407f4, 0x538544c9, 0x30367c08, 0x0038c00e, 0x024c0093, 0x00c00130,
+0x00000ac0, 0x00000000, 0x000f9805, 0x00fc00ff, 0x4cc113f0, 0xdd41bb01,
+0xc11ff047, 0x11ff0037, 0x52b003fc, 0x7f0147c4, 0xf0347c05, 0x003fc00f,
+0x02fc00bf, 0x17c003f0, 0x00000e60, 0x00000000, 0x000fa803, 0x02bc00ff,
+0x2fc00bb0, 0xfc006300, 0xc04f32a0, 0x20bf022d, 0x02f003cc, 0xef003ec0,
+0x7011fc00, 0x010cc003, 0x03cd0473, 0x0fc00fb0, 0x00000e00, 0x00000000,
+0x00270801, 0x004400fd, 0x36400810, 0x7400d108, 0x408d1403, 0x009d2033,
+0x491013c5, 0xdd003440, 0xd2097400, 0x00b5422d, 0x03540251, 0x07400d10,
+0x00000c20, 0x00000000, 0x0803a211, 0x021400c5, 0x314208d2, 0x34800100,
+0x400c1013, 0x008d0023, 0x04504304, 0xcd007363, 0x50093401, 0x02015080,
+0x03240841, 0x47400c90, 0x00000e80, 0x00000000, 0x0045a803, 0x104400dd,
+0x364049d0, 0x74009142, 0x420d1011, 0x00dd0037, 0x45500344, 0xdd887540,
+0xd0017021, 0x0035400d, 0x03740811, 0x0f400d90, 0x00000620, 0x00000000,
+0x00c78002, 0x1a5400d7, 0x33c409f0, 0x7c21d200, 0xc00d3003, 0x408f0015,
+0x0d74034c, 0xdf0037c0, 0x7003fc00, 0x400dc203, 0x036c0253, 0x0bc00db0,
+0x00000e20, 0x00000000, 0x000d8007, 0x069800df, 0x7fc00b20, 0xf8037f00,
+0xc00df007, 0x02bf101f, 0x1f3083fc, 0xff203cc2, 0xf003fc20, 0x003bc00e,
+0x038c015f, 0x1fc00f72, 0x00000600, 0x00000000, 0x00450002, 0x2a6c84d3,
+0x75c049b1, 0x5c00df00, 0xd00d300a, 0x00930054, 0x2530039c, 0xdf1136c0,
+0x7047cc00, 0x000fc103, 0x034c225f, 0x08c00d70, 0x00000420, 0x00000000,
+0x4014a013, 0x064440f1, 0x76c06d50, 0x450e5d00, 0x400fb003, 0x20d14854,
+0x050003c4, 0xdd003400, 0x100b441b, 0x0037405d, 0x03ec001d, 0x4c410fb0,
+0x00000200, 0x00000000, 0x0012a007, 0x072402d1, 0xb0602800, 0x44400d01,
+0x409c1003, 0x52810000, 0x0d100314, 0xcd00f050, 0x90091700, 0x04034020,
+0x0304095d, 0x1c401c10, 0x00000a00, 0x00000000, 0x0a788004, 0x068401e1,
+0x7a401a51, 0x8401ed10, 0x401e9006, 0x81e10258, 0x1e9007e4, 0xed807840,
+0x18059481, 0x007b421e, 0x07a609ed, 0x10400e90, 0x00000200, 0x00000000,
+0x00801012, 0x212c10c1, 0x31c0c830, 0x5c080f00, 0xc00c301b, 0x00830080,
+0x0430031c, 0xcd043040, 0xb0011c00, 0x0003c000, 0x034c02cf, 0x48c08d70,
+0x00000040, 0x00000000, 0x0029b802, 0x20fc00fe, 0x3fe08f70, 0xfc00ff00,
+0xc00ff003, 0x00ef401f, 0x0772039c, 0xfd0035c0, 0xf001ac42, 0x003fc00f,
+0x43fc00ff, 0x0bc04ff0, 0x00000660, 0x00000000, 0x0053a015, 0x035c88d3,
+0xb38009f1, 0x7c009300, 0xc00df801, 0x00934053, 0x1db013fc, 0xc70037c0,
+0x30034c0a, 0x600fc003, 0x834c00d3, 0x57c00df2, 0x00000e00, 0x00000000,
+0x00398012, 0x03840cfb, 0x3b400ad0, 0xb4406102, 0x405ed003, 0x00e1081b,
+0x0e814bf4, 0xed03bb40, 0x50030400, 0x003b400e, 0x138480e5, 0x4b402ed0,
+0x00000620, 0x00000000, 0x04490003, 0x059625e1, 0x7b403a50, 0xb401a100,
+0x449ed007, 0x01a1005f, 0x061013b4, 0xed007b60, 0x10079507, 0x00434012,
+0x078401c1, 0x0f401e50, 0x00000400, 0x00000000, 0x00332812, 0x091420d9,
+0x73441cd0, 0x74124942, 0x4a0cd010, 0x00c10413, 0x14100374, 0xcd003340,
+0x501b1400, 0x0037400c, 0x030402d5, 0x4b400cd0, 0x00000c20, 0x00000000,
+0x001da817, 0x0ddc0051, 0x13c01572, 0x74135300, 0xc005f80d, 0x005330df,
+0x27b001fc, 0x2f040bc0, 0x10095c00, 0x0017c005, 0x014c0273, 0x5fc00570,
+0x00000620, 0x00000000, 0x01070012, 0x3024001f, 0x87c021d0, 0x7c401700,
+0xc001f020, 0x001f1207, 0x91f0007c, 0x1f0007c0, 0xf0002804, 0x000fc002,
+0x007d101f, 0x4bc801f0, 0x00000c00, 0x00000000, 0x00270810, 0x024c0097,
+0x75c08870, 0x4c008300, 0xc0293102, 0x019f0227, 0x0930026c, 0x134405c0,
+0x30064c00, 0x0064d019, 0x024d0093, 0x43c00970, 0x00000c20, 0x00000000,
+0x00262001, 0x2254029d, 0xe4405910, 0x6c0191c0, 0xc0191002, 0x818d0025,
+0x09b00245, 0x1106c444, 0x10066c20, 0x02644019, 0x02440195, 0x074009b0,
+0x00000800, 0x00000000, 0x0064a018, 0x0245109d, 0x256809d0, 0xc6049502,
+0x40091002, 0x089d0027, 0x0c180244, 0x11800440, 0x10224406, 0x002c408b,
+0x02040491, 0x63404950, 0x00000200, 0x00000000, 0x02202010, 0x0314088d,
+0x30408810, 0xa400a100, 0x41481422, 0x008d0021, 0x88902204, 0x91022040,
+0x10062488, 0x00a8402a, 0x0a040285, 0x43408890, 0x00000080, 0x00000000,
+0x0586a01d, 0x5044021f, 0x05c161f1, 0xcc141510, 0x40413008, 0x005f0287,
+0x2130084c, 0x110585c0, 0x34004c16, 0x000cc001, 0x804c0013, 0x77c02170,
+0x00000ac0, 0x00000000, 0x092f9819, 0x02fc869f, 0x27c04bf2, 0x7c00bf00,
+0xc009f012, 0x00bf006f, 0x4bf01a7c, 0xbf012f40, 0xf00a7c04, 0x00a7c029,
+0x0a7c02bf, 0x67c069f0, 0x00000e60, 0x00000000, 0x050ba018, 0x02ec18ab,
+0x2cc14b30, 0x4c14bf00, 0xc9083022, 0x00a30027, 0x2830025c, 0xa200ecc0,
+0xf016fc15, 0x04e8c059, 0x1a4c44b3, 0x63c0cbb0, 0x00000e00, 0x00000000,
+0x00c7081c, 0x00444211, 0x06c06110, 0x44021d00, 0x40211000, 0x00112103,
+0x01101044, 0x11004440, 0xd1087407, 0x01854160, 0x00440015, 0x73400110,
+0x00000c20, 0x00000000, 0x4023a010, 0x0f240481, 0x20410850, 0x24009d00,
+0x40081416, 0x20814c23, 0x48024a14, 0x8900a540, 0xd10a3410, 0x01205028,
+0x1a241689, 0x43406890, 0x00000e80, 0x00000000, 0x2125a818, 0x02440091,
+0x26621954, 0x64009d10, 0x40091a02, 0x01910023, 0x09920244, 0x51040553,
+0xd0827604, 0x10254009, 0x0264009d, 0x63400998, 0x00000620, 0x00000000,
+0x0467a805, 0x0a6c0093, 0x24c01976, 0x6c819f08, 0xe2093102, 0x00930027,
+0xa834025c, 0x1b4001c0, 0xf8027c12, 0x0024c209, 0x026c049b, 0x17c009b2,
+0x00000e20, 0x00000000, 0x00458014, 0x025c0097, 0x27c00830, 0x5d438f02,
+0xcc0df092, 0x109f0037, 0x1970025c, 0x1f0206ca, 0xf0027c01, 0x4027d00d,
+0x025c0597, 0x53c00970, 0x00000600, 0x00000000, 0x40850814, 0x047c0003,
+0x47c081f0, 0x4d011f00, 0xc001f000, 0x001b0004, 0x21b0006c, 0x194106c4,
+0x30004c32, 0x4400c180, 0x004c0013, 0x53c001f0, 0x00000420, 0x00000000,
+0x0048a014, 0x09840571, 0x1f4027d0, 0x44067d00, 0x4105d001, 0x05615054,
+0x07100144, 0x31080c00, 0x5001ec80, 0x041c5015, 0x01441151, 0x534005d0,
+0x00000200, 0x00000000, 0x0032a014, 0x013440c1, 0x33412cd0, 0x4401cd00,
+0x401cd003, 0x03c90070, 0x0c980344, 0xc500f240, 0x9403240b, 0x0030400c,
+0x034400d1, 0x534008d0, 0x00000a00, 0x00000000, 0x15388005, 0x018400e1,
+0x3b420ed0, 0x8400ed24, 0x401ed203, 0x00f95438, 0x0f121304, 0xf501bc40,
+0x9806a601, 0x00380006, 0x23840181, 0x17400ad0, 0x00000200, 0x00000000,
+0x01f81011, 0x05bd01e3, 0x7bc01ef0, 0x8d01ef00, 0x409ef017, 0x01eb0078,
+0x3eb10f8d, 0xe7157ac1, 0xb0072c41, 0x1068c01a, 0x078d00e3, 0x57e01ef2,
+0x00000040, 0x00000000, 0x0035b010, 0x815c00df, 0x37c005f1, 0x7c00cf20,
+0xd26df003, 0x00d701b7, 0x2d70075c, 0xd21133c0, 0x72017808, 0x0027d921,
+0x037c009f, 0x43c00bf0, 0x00000660, 0x00000000, 0x007ba000, 0x07fd01fc,
+0x7fc097b0, 0xcc09ff20, 0xc01f7047, 0x217300ff, 0x1f3007fc, 0xff0c7cc0,
+0xb007fc0b, 0x226dc0db, 0x0fcc01ff, 0x03c01bf0, 0x00000e00, 0x00000000,
+0x04398815, 0x03ac06fb, 0x3b4086b0, 0xc41ced10, 0x400e4003, 0x00e1022b,
+0x4e1003f4, 0xe9243840, 0x1002b44c, 0x0308408e, 0x039400bd, 0x57400a7a,
+0x00000620, 0x00000000, 0x00390000, 0x019400e1, 0x3b600610, 0x8600ed00,
+0x400e100b, 0x00e1003b, 0x0e5003b4, 0xed003800, 0x1003b400, 0x0028414a,
+0x038400ed, 0x03400ed0, 0x00000400, 0x00000000, 0x10732820, 0x092400d9,
+0x53420090, 0x0402cd00, 0x42085007, 0x40c10263, 0x2c500334, 0xcd8c7040,
+0x90013402, 0x00006008, 0x031442cd, 0x13400840, 0x00000c20, 0x00000000,
+0x00f5a811, 0x2f5c00d3, 0x17400531, 0xcd01df00, 0xc00d7003, 0x00534057,
+0x2e7403fc, 0xdf00f4c0, 0xb0037c18, 0x01f4c011, 0x03c41bcf, 0x57c009d0,
+0x00000620, 0x00000000, 0x04370001, 0x0f3d025f, 0x17c035f0, 0x7c02df02,
+0xc00de023, 0x085f2007, 0x0d92033c, 0xdb0037d0, 0x740b7c22, 0x0137d101,
+0x037c809f, 0x07c00970, 0x00000c00, 0x00000000, 0x003b0880, 0x074d01f3,
+0x1c800f30, 0xcc50fd00, 0xc00ef003, 0x0073001c, 0x0fb003c4, 0xf3407ec3,
+0x3015fc20, 0x002fc053, 0x03cd01f3, 0x00d00af0, 0x00000c22, 0x00000000,
+0x00362085, 0x036501d5, 0x95481550, 0x4402cd14, 0x400dd003, 0x02411091,
+0x0d100344, 0xd104b040, 0x10023402, 0x00234121, 0x03440195, 0x04401990,
+0x00000802, 0x00000000, 0x0074a001, 0x62650491, 0x5540a410, 0x4403dd80,
+0x408dd003, 0x065100d4, 0x0d900354, 0xd1013640, 0x1c0b6408, 0x00274801,
+0x034404d1, 0x044089d0, 0x00000200, 0x00000000, 0x00302014, 0x03240045,
+0x11400450, 0x04204d20, 0x400cc003, 0x00510005, 0x0d100314, 0xc1083040,
+0x10033640, 0x40034000, 0x03040091, 0x40400890, 0x00000088, 0x00000000,
+0x0036b000, 0x036c0093, 0x15c00531, 0x4d00df00, 0xc00df003, 0x00130010,
+0x0fb0035d, 0xd30036c0, 0x30017c00, 0x2027c000, 0x03cc0093, 0x00c009f9,
+0x00000ac0, 0x00000000, 0x003fb805, 0x03dc00ff, 0x0f8007f0, 0xfc002f00,
+0xc00ff003, 0x003f001f, 0x0ef003ec, 0xff003fc0, 0xf002bc00, 0x000fc603,
+0x83fe00bf, 0x97c00bf0, 0x00000e60, 0x00000000, 0x003da003, 0x20cc002b,
+0x3ec08330, 0xfc08f310, 0xc40f7053, 0x00f7023c, 0x8e3053cc, 0xf3023cc0,
+0xf0034c08, 0x333cc00f, 0x73fc08fb, 0x0cd003b0, 0x00000e00, 0x00000000,
+0x20330801, 0x18040011, 0xbcc88530, 0xf424f105, 0x48cd10cb, 0x56f1013c,
+0x0d100bc4, 0xf10037c0, 0x92535424, 0x11bc480d, 0x0b7484d5, 0x04410110,
+0x00000c20, 0x00000000, 0x40332011, 0x091414c1, 0x33620050, 0x1600c122,
+0x410c1413, 0x08c42032, 0x5d110305, 0xc5113048, 0xd0072404, 0xd1b0401d,
+0x033404c1, 0x44404190, 0x00000e80, 0x00000000, 0xa035a803, 0x00550011,
+0x364465d0, 0x7600d120, 0x430d1003, 0x00d51036, 0x1d180344, 0xd508b740,
+0x90077400, 0x0034401d, 0x037400dd, 0x0c400910, 0x00000620, 0x00000000,
+0x00378802, 0x4e5c8013, 0x36403170, 0x5e40d340, 0xd03d3003, 0x60d70036,
+0x0c34034c, 0xd74074c0, 0xf0036c00, 0x0034d00c, 0x037c00db, 0x08c011b0,
+0x00000e20, 0x00000000, 0x003d8007, 0x24ac103f, 0x3dc01730, 0x7c00ff04,
+0xc886b303, 0x00fb0035, 0x0ff003fc, 0xfb0a3ec0, 0xf003dd00, 0x0037c00f,
+0x03bc00f2, 0x1fc033f0, 0x00000600, 0x00000000, 0x00350802, 0x035c0017,
+0x37c00930, 0x2c01df20, 0xc02d3413, 0x00c34030, 0x0d30435c, 0xd300b5c0,
+0xb0237c00, 0x4037c80d, 0x037c00db, 0x0bc001f0, 0x00000420, 0x00000000,
+0x00348013, 0x004406d9, 0xfe80bd71, 0xc500fd00, 0x4005000f, 0x08f3403c,
+0x0d108b84, 0xfb083440, 0xd0877420, 0x003f40dd, 0x03f400f1, 0x4f4008d0,
+0x00000200, 0x00000000, 0x0036a007, 0x40250019, 0xf404a890, 0x1400c900,
+0x400c1003, 0x00c90033, 0x0c900716, 0xd1003640, 0xd0873400, 0x0037400c,
+0x033400c1, 0x1f4000d0, 0x00000a00, 0x00000000, 0x02788004, 0x07a50139,
+0x7a441b50, 0x8409cd24, 0x401c5247, 0x05c1027a, 0x1e9067c4, 0xe9027f50,
+0xc087b401, 0x027b421e, 0x07b401e1, 0x134012d0, 0x00000200, 0x00000000,
+0x00301012, 0x013d00c3, 0x31c28990, 0x1e00cf00, 0xd00c1023, 0x40cb0033,
+0x0cb0031c, 0xc30232c0, 0xb0073c00, 0x0033c20c, 0x033c00c3, 0x4bc004f0,
+0x00000040, 0x00000000, 0x483db802, 0x23dc8837, 0x3fc889f0, 0x5c00ff06,
+0xc08fb043, 0x24ff003d, 0x0d70033c, 0xdf0230c8, 0xf00b7808, 0x003fc00f,
+0x23fc10f7, 0x0bc08ff0, 0x00000660, 0x00000000, 0x0037a015, 0x064c0003,
+0x77c20530, 0x4d04db04, 0xc001f01b, 0x12db0134, 0x4d30730c, 0xd20134c0,
+0x320f4c04, 0x0034807d, 0x034c00d3, 0x54c001f0, 0x00000e00, 0x00000000,
+0x003d8812, 0x03050021, 0x3b020610, 0x8412f100, 0x500ad053, 0x04e103bc,
+0x2e100394, 0xe144b841, 0xb01b8510, 0x0332c0ce, 0x039400e1, 0x4bc003d0,
+0x00000620, 0x00000000, 0x00790003, 0x87840131, 0x7b421e58, 0xa405e101,
+0x6400d007, 0x09e98878, 0x5e9407e4, 0xc1297b40, 0x9887c4ad, 0x0378409e,
+0x27b405c1, 0x0c4016d0, 0x00000400, 0x00000000, 0x10332812, 0x030433c1,
+0x33412c58, 0x2400c110, 0x4109d203, 0x00cd8030, 0x0d900334, 0xc101b340,
+0x98030400, 0x0032400c, 0x033400c1, 0x4b400dd0, 0x00000c20, 0x00000000,
+0x0015a817, 0xa9cd0763, 0x17407774, 0x6c005b40, 0xd237d001, 0x007b0014,
+0x03b001ec, 0x6301cfc0, 0xb000cd00, 0x0014c003, 0x017c4053, 0x5cc007f0,
+0x00000620, 0x00000000, 0x60070012, 0x007c001f, 0x87c001b3, 0x5c000f00,
+0xc881f000, 0x00111003, 0x1170001c, 0x1f000450, 0xf0847e00, 0x4003c011,
+0x0050001f, 0x4ac001f0, 0x00000c00, 0x00000000, 0x00270810, 0x064d0193,
+0x27c809f0, 0x6c009f00, 0xc009f006, 0x43830026, 0x0134024c, 0x931007c0,
+0xf0004c20, 0x0027c001, 0x824c0083, 0x40c409f3, 0x00000c20, 0x00000000,
+0x00262001, 0x06444191, 0xa74009d0, 0x44029d00, 0x4009d026, 0x01918024,
+0x01102e54, 0x9b000040, 0x30004400, 0x00274001, 0x02540091, 0x050009d0,
+0x00000800, 0x00000000, 0x0020a018, 0x12454499, 0xa7420950, 0x66109d00,
+0x4009d002, 0x00916026, 0x01100244, 0x99080660, 0x50005400, 0x00274011,
+0x02460091, 0x604009d0, 0x00000200, 0x00000000, 0x02202010, 0x22040899,
+0x234088d0, 0x040c8d02, 0x41c8d002, 0x0c818120, 0x88102216, 0x99022440,
+0x18220404, 0x02234098, 0x32140881, 0x414088d0, 0x00000080, 0x00000000,
+0x0086b01d, 0xd84c021b, 0x83c36172, 0x6c031f05, 0xc061d050, 0x030102c6,
+0x6130594c, 0x1b0586c5, 0x60585c0b, 0x4587c161, 0x0c4c0213, 0x74c021f0,
+0x00000ac0, 0x00000000, 0x6127b819, 0x12fc04b7, 0x27c04bf0, 0x7c0c9f01,
+0xc04bf052, 0x2c9f0a67, 0x4af0127c, 0x9f012ad0, 0x3012bd09, 0x0127c04a,
+0x327c069f, 0x67c04bf0, 0x00000e60, 0x00000000, 0x00a7a018, 0x0acc02a3,
+0x2cc04bf0, 0xcc5cbf03, 0xc0c9f00a, 0x0cb70326, 0x9d3012e8, 0x9101e4c1,
+0x3117cc14, 0x01a4c07f, 0x524c0893, 0x634008f0, 0x00000680, 0x00000000,
+0x4003001c, 0x08448011, 0x0451e1d0, 0x04420d01, 0x4060d088, 0x46110184,
+0x20100c44, 0x11010440, 0x50004c06, 0x01004051, 0x10440811, 0x734041d0,
+0x00000c20, 0x00000000, 0x0123a010, 0x1a1444c1, 0xa04008d0, 0x04048d00,
+0x5088d01a, 0x028500a0, 0x48105b24, 0x8100e040, 0x105a2410, 0x41a0407d,
+0x42040481, 0x434118d0, 0x00000c80, 0x00000000, 0x4021a818, 0x02540181,
+0x246008d0, 0x44009d00, 0x4009d002, 0x20910024, 0x28100044, 0x91006040,
+0x501a0400, 0x00244011, 0x02440091, 0x634009d0, 0x00000620, 0x00000000,
+0x0027a805, 0x065d0693, 0x24c049f0, 0x4d009f00, 0xd009f002, 0x00970024,
+0x0934002c, 0x93402490, 0x30026d00, 0x0024d001, 0x02450093, 0x17c019f0,
+0x00000e20, 0x00000000, 0x00258014, 0x226c009f, 0x27c009f0, 0x7c008f08,
+0xc009f042, 0x008f0021, 0x99f0007c, 0x8f0027c4, 0xf0027c20, 0x0023c001,
+0x827c009f, 0x53c039f1, 0x00000600, 0x00000000, 0x00050814, 0x104c0313,
+0x04c121f0, 0x4c041f02, 0xc0003000, 0x081f0004, 0x2132044c, 0x1f0004c0,
+0xf1104c00, 0x4005c011, 0x004c0013, 0x50c001f0, 0x00000420, 0x00000000,
+0x4014a014, 0x19c40071, 0x5c4007d0, 0xc4007d00, 0x4005100d, 0x03790015,
+0x071000c4, 0x5d001c40, 0xd201c500, 0x00174002, 0x01540051, 0x504005d0,
+0x00000200, 0x00000000, 0x0032a014, 0x070500c1, 0x32402cd0, 0x0400cd00,
+0x400c100f, 0x10cd0030, 0x0c100304, 0xcd003340, 0xd00b0500, 0x0031400c,
+0x030400d1, 0x50400cd0, 0x00000a00, 0x00000000, 0x21388805, 0x038480b1,
+0x3a400cd0, 0x8402ad00, 0x401e100f, 0x00fd0139, 0x4e101304, 0xed013b40,
+0x90038400, 0x013b404e, 0x039404c1, 0x14409fd0, 0x00000200, 0x00000000,
+0x45780015, 0x078c01e3, 0x5ad01ef0, 0x8d01ef10, 0xc04e3007, 0x01ef08f8,
+0x5e34178c, 0xcf02fbd0, 0xd0078c05, 0x00f9c01e, 0x178c05e3, 0x54d05ef0,
+0x00000040, 0x00000000, 0x03b5a810, 0x837d009f, 0x35c00df0, 0x7c009f00,
+0xc02df483, 0x00cb0037, 0xedf42b7d, 0xdf0034c0, 0xf0037c68, 0x0037c14d,
+0x277c08df, 0x43c01df0, 0x00000660, 0x00000000, 0x407fa000, 0x04cc01e3,
+0x6cd01730, 0xdc01f300, 0xc5bd3005, 0x01e3007c, 0x3f300fcc, 0xf3007cc0,
+0x3027dc01, 0x00ffc11f, 0x13fc01f3, 0x03c01f30, 0x00000e00, 0x00000000,
+0x003d8815, 0x00ecca61, 0x38c18710, 0xc400e100, 0x401f1001, 0x00610238,
+0x0e100384, 0xf1063850, 0xf023ec00, 0x023bc10e, 0x03fc00e1, 0x57400eb0,
+0x00000620, 0x00000000, 0x00390000, 0x009410b1, 0x02400610, 0x94086100,
+0x400e9001, 0x00b10030, 0x0e100304, 0xe1003a40, 0x1803b400, 0x003b400e,
+0x03b400e1, 0x03400e10, 0x00000400, 0x00000000, 0x40372804, 0x0c340301,
+0x30400414, 0x24004120, 0x400c9001, 0x00110034, 0x8c100304, 0xc100b240,
+0x500f2480, 0x8035403c, 0x031400d1, 0x13412d10, 0x00000c20, 0x00000000,
+0x003da815, 0x475c0153, 0x36400d30, 0x5c005300, 0xd00fb403, 0x00d3403c,
+0x0e34030c, 0xf3407ed0, 0x10273c00, 0x403f402c, 0x03f400f3, 0x57c02f10,
+0x00000620, 0x00000000, 0x00370001, 0x096c121f, 0x07c020f0, 0x5c001f20,
+0xc10d7081, 0x00df0037, 0x0df0037d, 0xcf0435c3, 0xf0227c00, 0x0037c00d,
+0x037c00df, 0x07c80df0, 0x00000c00, 0x00000000, 0x003f0880, 0x46cc0073,
+0x58c00ff0, 0xcc004300, 0xc00ef007, 0x00f6003c, 0x0f3407cc, 0xf3003cc0,
+0x300fcd00, 0x003cc10f, 0x03cc00f3, 0x00c00ff0, 0x00000c22, 0x00000000,
+0x00362081, 0x60556001, 0xc44191d2, 0x450a1102, 0x420d7024, 0x00db8834,
+0x0d104f6c, 0xd1083140, 0x311e4420, 0x0035400d, 0x035400db, 0x05400dd0,
+0x00000802, 0x00000000, 0x0034a001, 0x034440d1, 0x24400dd0, 0x40029104,
+0x400dd003, 0x00d12034, 0x0d161344, 0xd1003444, 0x10014620, 0x0034401d,
+0x034400d5, 0x04400dd0, 0x00000200, 0x00000000, 0x00302010, 0x01140051,
+0x004000d0, 0x04408120, 0x510c5085, 0x00490030, 0x0d100364, 0xc1003160,
+0x10804400, 0x0030401c, 0x030400c9, 0x41000cd0, 0x00000080, 0x00000000,
+0x003eb000, 0x024c0091, 0x04400dd0, 0x4c001300, 0xc05ff003, 0x00910034,
+0x0f10034c, 0xd34038c0, 0x31294c00, 0x2038d00d, 0x034d00d7, 0x00c40df0,
+0x00000ac0, 0x00000000, 0x403fb805, 0x00fc003f, 0x0fc003f0, 0xfc003f00,
+0xc20ff081, 0x003b003f, 0x0ef003fc, 0xff003f80, 0x7004fc00, 0x003fc00f,
+0x03fc00ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x030b8003, 0x10cc0433,
+0x1fc00a38, 0xfc043301, 0xc00f3030, 0x0473000b, 0x0f3000cc, 0x33400ec0,
+0x3003bc80, 0x001fc28f, 0x02ec007f, 0x0ec00fb0, 0x00000e00, 0x00000000,
+0x02870801, 0xab6c0ad1, 0x97400d18, 0x34b8d104, 0x400d501b, 0x02d10087,
+0xad100144, 0x91243440, 0x1003f400, 0x0017404f, 0x024428dd, 0x04400c10,
+0x00000c20, 0x00000000, 0x8103a011, 0x00040001, 0x12400810, 0x34040103,
+0x400c1020, 0x08c10203, 0x0c500204, 0x45001640, 0x50033400, 0x0013404c,
+0x0224c01d, 0x47400c90, 0x00000e80, 0x00000000, 0x0005a803, 0x036400d1,
+0x17420d10, 0x7400d500, 0x000d5003, 0x00d14047, 0x0d514304, 0x95003440,
+0x50037428, 0x0117400d, 0x0644301d, 0x0d400d90, 0x00000620, 0x00000000,
+0x402fa802, 0x008c0033, 0x1ec09510, 0xfc003301, 0x400d3400, 0x0b530147,
+0x0d740e4c, 0x170086c0, 0x74037c03, 0x0407c00d, 0x4e6c014f, 0x0bc00db0,
+0x00000e20, 0x00000000, 0x002d8007, 0x03fc10ff, 0x1fc10ff0, 0xfc00fb28,
+0xc00ff003, 0x004f000b, 0x0cb017fc, 0xbb083fc0, 0xb043fc00, 0x043fc00f,
+0x02bc087f, 0x1ec00e70, 0x00000600, 0x00000000, 0x01610802, 0x005c0013,
+0x10c61d32, 0x1c001300, 0xc00d3020, 0x00530024, 0x0d340a4c, 0x570014d0,
+0x30030c08, 0x0007c00d, 0x0865005f, 0x09c00d34, 0x00000420, 0x00000000,
+0x00a4a013, 0x474420d1, 0x14403d12, 0x6c0ad100, 0x400f100b, 0x005104a4,
+0x2f112f44, 0x91017041, 0xb003c001, 0x0037400f, 0x2c540bdd, 0x4c40af10,
+0x00000200, 0x00000000, 0x0002a007, 0x48340019, 0x30402c99, 0x06000000,
+0x409c5044, 0x20c10121, 0x1c100305, 0x0449c041, 0x000b0406, 0x0213400c,
+0x0204004d, 0x0d408c10, 0x00000a00, 0x00000000, 0x024c8004, 0x87a401e9,
+0x70481e14, 0xa611c100, 0x401e1007, 0x21a10269, 0x1e107784, 0x61005c40,
+0x90878405, 0x025b401e, 0x468419ed, 0x00401e10, 0x00000200, 0x00000000,
+0x00001012, 0x003c041b, 0x30c00cb1, 0x1c000300, 0xc00c7000, 0x00c10021,
+0x4c30334c, 0x471810c0, 0x30030c00, 0x1213e80c, 0x024c001f, 0x59c00c30,
+0x00000040, 0x00000000, 0x080db802, 0x239c00f7, 0x3f800f72, 0xfc80ff00,
+0xd10ef003, 0x00bf082e, 0x0ff033fc, 0x6f021bc0, 0xf003fd04, 0x021fc10f,
+0x02dc20bf, 0x0bc18ff0, 0x00000660, 0x00000000, 0x1027aa15, 0x006d0013,
+0x37c405b4, 0x4c001300, 0xc00db000, 0x005f4037, 0x0d32034c, 0x930004c0,
+0xf0136c01, 0x0024c07d, 0x024d2013, 0x54c00d34, 0x00000e00, 0x00000000,
+0x002d8812, 0x038400e1, 0x3b420e14, 0x9500e100, 0x400e5403, 0x80210038,
+0x5e1003c4, 0xe1003850, 0xd04b8540, 0x002ec14f, 0x038400a1, 0x48404f10,
+0x00000620, 0x00000000, 0x40690003, 0x04250101, 0x7b601e14, 0x84012100,
+0x405c9104, 0x01650061, 0xde900784, 0xf1005862, 0xd017a401, 0x00f8401e,
+0x05040101, 0x8e401e10, 0x00000400, 0x00000000, 0x00232812, 0x030600c1,
+0x33681c14, 0x1400c140, 0x400c5403, 0x200104b0, 0x0d900305, 0xc1003460,
+0xd0032400, 0x0072400c, 0x07040081, 0x4a420c10, 0x00000c20, 0x00000000,
+0x0095a017, 0x816c8053, 0x17c02734, 0x4c405300, 0xc005b001, 0x0275009d,
+0x05b409cc, 0x73001cd0, 0xf0016e28, 0x40d8c005, 0x49cc0373, 0x5ed00530,
+0x00000620, 0x00000000, 0x04030012, 0x00bc002f, 0x03c18174, 0xfc003f00,
+0xc001f000, 0x01170087, 0x0170407c, 0x1f4107c0, 0xe0005c00, 0x0047c001,
+0x407c091f, 0x49c801f0, 0x00000400, 0x00000000, 0x00270010, 0x0e5c8997,
+0x27c00930, 0x2d009340, 0xc0083002, 0x00930062, 0x0930025d, 0x932824c0,
+0xf0027c41, 0x0027c009, 0x024c0097, 0x40c00930, 0x00000c20, 0x00000000,
+0x50662001, 0x06440791, 0xa740a910, 0x45009120, 0x4019b002, 0x828142e4,
+0x09140244, 0x9100a440, 0xd00274c1, 0x00274009, 0x02450091, 0x04500914,
+0x00000080, 0x00000000, 0x0224a018, 0x42d400b5, 0x27600910, 0xc420a144,
+0x40891002, 0x10d18426, 0x09500214, 0xd101b540, 0xd0027448, 0x00274009,
+0x02040085, 0x60400810, 0x00000200, 0x00000000, 0x12202010, 0x028408a1,
+0x23601810, 0x8408a102, 0x40089022, 0x04910120, 0x08d00204, 0xc1022150,
+0xc0023008, 0x00274028, 0x42040881, 0x40404810, 0x00000080, 0x00000000,
+0x0584301d, 0x50dc9615, 0x83c40130, 0xac960305, 0xc1413058, 0x0b030046,
+0xe070285c, 0x134585c1, 0xf0517c02, 0x0287c541, 0x004c5015, 0x74c0d130,
+0x00000ac0, 0x00000000, 0x212fb019, 0x027c849f, 0x27400be4, 0x7c049f41,
+0xc009f012, 0x09bf822f, 0x193106fc, 0xaf212ac0, 0xf0027e04, 0x012fc009,
+0x42fc00bf, 0x67c0c9f0, 0x00000e60, 0x00000000, 0x056f8018, 0x06cc09af,
+0x27c00b30, 0x4e029306, 0xc04bb41a, 0x0093053f, 0x69300a4c, 0xb3052fc0,
+0xf052fc02, 0x0224c129, 0x0a7c069f, 0x63c02930, 0x00000e00, 0x00000000,
+0x0487001c, 0x8044201d, 0x43400130, 0xfd0b1100, 0x4081100c, 0x15010084,
+0x52140444, 0x11410740, 0xd0087401, 0x01004071, 0x08740e1d, 0x7340a3b1,
+0x00000c20, 0x00000000, 0x0023a010, 0x0a0502cd, 0x23400810, 0x8500a101,
+0x400814a2, 0x08810061, 0xca1002c4, 0x85452340, 0xd0023600, 0x00284048,
+0x1ab404ad, 0x43404a10, 0x00000e80, 0x00000000, 0x1025a818, 0x024480dd,
+0x27402910, 0xf580b100, 0x40091002, 0x20818824, 0x0b1042c5, 0x95002748,
+0xd2827480, 0x02244009, 0x0af408bd, 0x63400b90, 0x00000620, 0x00000000,
+0x0827a805, 0x024d009f, 0x27c80934, 0x44009340, 0xc009b002, 0xa49340e5,
+0x0930820c, 0x170027c0, 0xf1027640, 0x0024d009, 0x2e7c139f, 0x17c00930,
+0x00000e20, 0x00000000, 0x00258214, 0x027c009f, 0x27c20970, 0x1d008f00,
+0xc008f402, 0x809f0121, 0x09f0027c, 0x1b08a3c8, 0xf0027c02, 0x0027c009,
+0x063c009f, 0x53c409f0, 0x00000600, 0x00000000, 0x01050814, 0x002c8003,
+0x03c01134, 0xfc003700, 0xc001b000, 0x02130306, 0x033408cc, 0x132004c0,
+0x74047c98, 0x000cc000, 0x00fc0237, 0x53c003f0, 0x00000420, 0x00000000,
+0x0c1ca014, 0x01c50871, 0x17002710, 0x4d005100, 0x40271001, 0x0053205c,
+0x05100144, 0x30201c40, 0x100dd501, 0x00144005, 0x01740051, 0x534005d0,
+0x00000200, 0x00000000, 0x00f2a034, 0x212400c1, 0x33001c1a, 0x1580c500,
+0x41081483, 0x00c100a2, 0x0c500304, 0xc1027040, 0x50071420, 0x0030400c,
+0x033400c5, 0x53400cd0, 0x00000a00, 0x00000000, 0x00788005, 0x03840061,
+0x3b402218, 0xa4002180, 0x400c1000, 0x00e10020, 0x125000c4, 0xf1000c40,
+0x10c58005, 0x0048404e, 0x00b42021, 0x174002d0, 0x00000200, 0x00000000,
+0x40600015, 0x072c81e3, 0x5bc01614, 0x1d01f720, 0xc01a3007, 0x0163086a,
+0x1e72078d, 0xe32058d0, 0x74079c81, 0x0078d05f, 0x07bc01e7, 0x57c01ef2,
+0x00000040, 0x00000000, 0x0035b810, 0x027c005f, 0x17c001e1, 0x5d001f00,
+0xc2097000, 0x005f4827, 0x01b0003c, 0x4f6013c0, 0xf0011c40, 0x4007c09d,
+0x007c001f, 0x43c001f0, 0x00000660, 0x00000000, 0x406fa000, 0x05cc01b3,
+0x7fc49772, 0xec01f300, 0xc01b3007, 0x21ff006c, 0x1f3007cc, 0x73406cc0,
+0x3026ec91, 0x087c881f, 0x07fc01ff, 0x03c01fe0, 0x00000e00, 0x00000000,
+0x003d8815, 0x1b848821, 0x3b402210, 0x84082141, 0x400e1220, 0x00ed0029,
+0x031000c4, 0xe1000850, 0x10308404, 0x0008400e, 0x40b4082d, 0x574002d0,
+0x00000620, 0x00000000, 0x00290000, 0x028400a1, 0x1b480612, 0xa400e180,
+0x400a1003, 0x106d0228, 0x0e904384, 0x61001a40, 0x1080a500, 0x0038400c,
+0x03b400ed, 0x03400ed0, 0x00000400, 0x00000000, 0x10332804, 0x0a040001,
+0x1348201a, 0x450a0160, 0x40081028, 0x474d0021, 0x01900424, 0x41205248,
+0x10000405, 0x03c4400c, 0x4c34100d, 0x134000c0, 0x00000c20, 0x00000000,
+0x0035a815, 0x17452553, 0x37c04130, 0x6c00d300, 0x400d308b, 0x03cf0064,
+0x0db0074d, 0xc30152c0, 0x34006c07, 0x0034c00f, 0x0b7c80cd, 0x57400de0,
+0x00000620, 0x00000000, 0x00370001, 0x433c324f, 0x37c021f0, 0x7c100f00,
+0xc00df010, 0x00df00e7, 0x0170005c, 0xdf0415c0, 0xf0083c80, 0x0007c00d,
+0x007c801f, 0x07c001f0, 0x00000c00, 0x00000000, 0x403f0880, 0x03cc0097,
+0x1fc10370, 0x4400f310, 0xc09f7003, 0x005b003b, 0x0f3003cd, 0xf70144c0,
+0xb0024c00, 0x003cc00e, 0x038c00fb, 0x83c00f30, 0x00000c22, 0x00000000,
+0x41f22081, 0x0a442311, 0x1f40b112, 0xc4003160, 0x411d1480, 0x007100b7,
+0x031000c4, 0x5b21c448, 0x112c4c01, 0x0004440f, 0x00548011, 0x07400110,
+0x00000802, 0x00000000, 0x4064a001, 0x03440195, 0x33400550, 0x5500d900,
+0x40055103, 0x20d10627, 0x0d180304, 0x55000440, 0x10094408, 0x4834400d,
+0x034400d1, 0x07400d10, 0x00000200, 0x00000000, 0x00102010, 0x03040001,
+0x33400014, 0x15000900, 0x40041000, 0x00d00003, 0x00100004, 0xc9000440,
+0x10012500, 0x0000400c, 0x00160011, 0x43400010, 0x00000080, 0x00000000,
+0x0026b000, 0x024c0097, 0x13c00170, 0x5c80cb00, 0x40055403, 0x00530037,
+0x0d30034c, 0x574004d0, 0xb4014e20, 0x8034c80d, 0x034c00d3, 0x03e00d32,
+0x00000ac0, 0x00000000, 0x101fb805, 0x82bc003f, 0x1fc003f0, 0xed003608,
+0xc006f000, 0x007f602f, 0x03f000fc, 0x6f000fc0, 0xf001dc00, 0x000fc00f,
+0x00fc0037, 0x17c003f0, 0x00000e60, 0x00000000, 0x023fa003, 0x20ec023b,
+0x3bc023f0, 0x8c0c3700, 0xc00f3022, 0x0073012f, 0x4fd000cd, 0xf3401fc0,
+0xb003ec0c, 0x083cc88f, 0x02cc0073, 0x0cc00ff0, 0x00000e00, 0x00000000,
+0x21370801, 0x1844025d, 0x3748a5d0, 0x444edb00, 0x480d5009, 0x121b04a7,
+0x8fd0024c, 0xd100b440, 0x50abc488, 0x2475405e, 0x564515d1, 0x04400cd0,
+0x00000c20, 0x00000000, 0x1033a011, 0x1804460c, 0x17404850, 0x24000500,
+0x414c1009, 0x26458323, 0x0cd02330, 0xc1021344, 0x90032484, 0x0131504c,
+0x022400c9, 0x44400cd0, 0x00000e80, 0x00000000, 0x0835a803, 0x0044104d,
+0x174005d0, 0x6400c901, 0x402d5081, 0x00190063, 0x0dd10344, 0xc0011448,
+0xd0034400, 0x0131400d, 0x426480c9, 0x0c400dd2, 0x00000620, 0x00000000,
+0x0037a802, 0x164c029b, 0x478025f0, 0x6d071700, 0x80a93001, 0x88c30047,
+0x0df1016c, 0xd30153c2, 0xb0036c00, 0x4035c40d, 0x086404db, 0x08d00df0,
+0x00000e20, 0x00000000, 0x003d8007, 0x09dd40bf, 0x4fc005f0, 0xdc04df00,
+0xc01fd003, 0x411f400f, 0x0eb103d0, 0xdf080fc0, 0x7003fc00, 0x007fc10f,
+0x02dc00f7, 0x1fc00ef0, 0x00000600, 0x00000000, 0x00350802, 0x025c025f,
+0x24d0adb0, 0x5c0c1300, 0xc00d3003, 0x06ff0027, 0x0df0a34c, 0xd300d4c9,
+0x70030c20, 0x0034c00c, 0x084c00df, 0x08800d32, 0x00000420, 0x00000000,
+0x0134a013, 0x0174025d, 0x2040a511, 0x4401d500, 0x444d1083, 0x059903a7,
+0x5fd08f4c, 0xfb2806c0, 0x1003ec00, 0x0134405f, 0x3a4400dd, 0x4c400f10,
+0x00000200, 0x00000000, 0x0072a007, 0x0134500d, 0x21401012, 0x64010180,
+0x400c9102, 0x02cd2822, 0x2cd04c34, 0xc5040140, 0x50030400, 0x04f0401c,
+0x060407cd, 0x1e400c10, 0x00000a00, 0x00000000, 0x00788004, 0x07b4056d,
+0x6d401e10, 0xe4012500, 0x401e9005, 0x496d007b, 0x9cc00684, 0xed206f40,
+0x1107a401, 0x0078101e, 0x06c411ed, 0x12401e11, 0x00000200, 0x00000000,
+0x02301012, 0x015c008f, 0x0140a832, 0x35000310, 0x40048401, 0x22cf0022,
+0x0cf0233c, 0xc70001c0, 0x70034c0c, 0x0030c00c, 0x100d00df, 0x4ac04c30,
+0x00000040, 0x00000000, 0x003db802, 0x23fc24ff, 0x0ee20f70, 0xdc003f00,
+0xc00f7301, 0x00fb003f, 0x0ff003fc, 0xfa000ac0, 0xf003fc38, 0x003fd00f,
+0x00bc00ff, 0x09c00ff0, 0x00000660, 0x00000000, 0x0037a015, 0x064c219f,
+0x15c00530, 0x4c00df00, 0xc00df201, 0x00530005, 0x0de0014d, 0xdf2014c0,
+0xb0337c40, 0x64b7c14d, 0x487c12db, 0x54c00d30, 0x00000e00, 0x00000000,
+0x00398812, 0x030640ad, 0x1b400e30, 0xb400ed00, 0x400ed003, 0x0001001f,
+0x6ed00384, 0xed003ac1, 0xb043b404, 0x803f400e, 0x02b400e1, 0x48403e10,
+0x00000620, 0x00000000, 0x80790003, 0x068401cd, 0x7b681e98, 0xb401e510,
+0x601ed007, 0x0161407b, 0x1ed00785, 0xed005840, 0x90073405, 0x007b409e,
+0x04b641e1, 0x0c405e90, 0x00000400, 0x00000000, 0x00332812, 0x130610cd,
+0x33609c10, 0x348acd00, 0x401dd00b, 0x07011023, 0x0cd02704, 0xcd008240,
+0x90037400, 0x0227400d, 0x083412c9, 0x48400c90, 0x00000c20, 0x00000000,
+0x0015a817, 0x05cd057f, 0x1bc007b4, 0xec017f00, 0xc067f005, 0x1373001f,
+0x07d005cc, 0x5f0098c0, 0xb0017c00, 0x2057c007, 0x017c0253, 0x5cd005b4,
+0x00000620, 0x00000000, 0x00070012, 0x207c001f, 0x47c00170, 0x7c901f00,
+0xc011f020, 0x000f0287, 0x00f0007c, 0x1f0407c8, 0xf0007c00, 0x0087c001,
+0x187c0217, 0x4bc00170, 0x00000c00, 0x00000000, 0x01270810, 0x067c029f,
+0x27c009f0, 0x7c009300, 0xc0893442, 0x019304e4, 0x09b0020c, 0x9300e5c0,
+0x34027c00, 0x0036c009, 0x074c08d3, 0x40c00930, 0x00000c20, 0x00000000,
+0x00a62001, 0x3274039d, 0x274029d2, 0x3c029500, 0x40191002, 0x01914024,
+0x0910026c, 0x95006440, 0x10827400, 0x01654029, 0x26440091, 0x06c00914,
+0x00000800, 0x00000000, 0x0424a018, 0x02540299, 0x26402990, 0x74029180,
+0x40091002, 0x08910020, 0x19901a44, 0x91002540, 0x10027400, 0x91265009,
+0x02050081, 0x60400818, 0x00000200, 0x00000000, 0x02202010, 0x2234088d,
+0x274088d8, 0x74088580, 0x50081052, 0x08c50230, 0xd8102224, 0x85006440,
+0x10123604, 0x80a1502c, 0x0a040281, 0x42416810, 0x00000080, 0x00000000,
+0x0086b01d, 0x585c161f, 0x074161f0, 0x7c161300, 0xc0013010, 0x16130584,
+0x31b0584d, 0x130505c0, 0x302c740b, 0x0006c141, 0x010c0053, 0x74d00032,
+0x00000ac0, 0x00000000, 0x01279819, 0x12fc04bf, 0x2fc04ff0, 0xdc24bf00,
+0xc14bf053, 0x04bb012f, 0xc8f012dc, 0x9f282fc0, 0xf0267c09, 0x4026c009,
+0x027c009f, 0x67c009f0, 0x00000e60, 0x00000000, 0x822fa018, 0x8afc02b3,
+0x30c00b30, 0x4c22b300, 0xc00bf01a, 0x00b300ac, 0x0bd032dc, 0x9f0834c0,
+0x300a6c02, 0x0024c049, 0x024c0093, 0x60d049f0, 0x00000e00, 0x00000000,
+0x0107081c, 0x08740e1b, 0x06514110, 0x490e1b00, 0x4141f008, 0x0e1b2084,
+0xb1d02c44, 0x1d108540, 0x12084402, 0x40004001, 0x01c40011, 0x714000d0,
+0x00000c20, 0x00000000, 0x0023a010, 0x1a340481, 0x266028d2, 0x24008528,
+0x601cd932, 0x108121a0, 0x48d01216, 0x8d00a241, 0x901a2406, 0x0828502a,
+0x02a400a1, 0x424028d0, 0x00000e80, 0x00000000, 0x0021a818, 0x02740299,
+0x264009d1, 0x44009d00, 0x4049d012, 0x00990034, 0x01d00444, 0x9d002740,
+0x90020400, 0x002c4008, 0x02e402b1, 0x634009d0, 0x00000620, 0x00000000,
+0x0027a805, 0x027c0393, 0xa6c029f4, 0x64009701, 0xd009f90e, 0x109344e4,
+0x01f0445c, 0x9f0466c0, 0xb4026c20, 0x0024c009, 0x0a6d0093, 0x16d009f2,
+0x00000e20, 0x00000000, 0x00258014, 0x023c449f, 0x25c00930, 0x7c009b00,
+0xc0097006, 0x009f0127, 0x00f0007c, 0x9f00b5c0, 0x70027c40, 0x0267c109,
+0x025c109f, 0x51c009f0, 0x00000600, 0x00000000, 0x01050814, 0x844c8217,
+0x07c121f0, 0x7c001300, 0xc0013008, 0x12130004, 0x01f0c04e, 0x130884c9,
+0x30007c00, 0x1004c001, 0x084c0013, 0x50c00134, 0x00000420, 0x00000000,
+0x085ca014, 0x01c4047d, 0x134037d1, 0x74407400, 0x40051001, 0x107106dc,
+0x13d00ccd, 0x5f011540, 0xf081f400, 0x0296c005, 0x01449251, 0x50400510,
+0x00000200, 0x00000000, 0x0232a014, 0x230401cd, 0x33600d90, 0x3400d010,
+0x400d9003, 0x021140c6, 0x3cd02726, 0xd5001040, 0x91033480, 0x000c4012,
+0x3c840331, 0x50400d10, 0x00000a00, 0x00000000, 0x08288005, 0x038441ed,
+0x3f430ad0, 0xb400e500, 0x400b9817, 0x0061083a, 0x4ed01384, 0xedc05d49,
+0x9007b408, 0x042a4900, 0x06840031, 0x14404e10, 0x00000200, 0x00000000,
+0x00781015, 0x078d01c7, 0x7b4016f1, 0xfc016300, 0xd01e9417, 0x0141004e,
+0xdef05fa4, 0xe70268c0, 0xb403fc0d, 0x0058c012, 0x24cc2163, 0x54d0be32,
+0x00000040, 0x00000000, 0x0025b810, 0x037c005f, 0x37c009f0, 0x7c00df00,
+0xc00c7027, 0x005f0035, 0x0cf1037c, 0xdb0003c0, 0x705b7c02, 0x4017c001,
+0x1b7d008c, 0x43c00df0, 0x00000660, 0x00000000, 0x007fa000, 0x25fc01bf,
+0x78c01ff2, 0xce01f720, 0xc01f7007, 0x01b7205c, 0x1ec007c9, 0xf30048c1,
+0xb047cc01, 0x0848c016, 0x85cc01b3, 0x00c01f34, 0x00000e00, 0x00000000,
+0x02398815, 0x01b440a7, 0x384086d0, 0x8c0aeb00, 0xc00b0013, 0x04ed0218,
+0x4ed00384, 0xff001ac0, 0x12239400, 0x0098400a, 0x00cc0861, 0x54400e10,
+0x00000620, 0x00000000, 0x00090000, 0x40b400ad, 0x3c4006d8, 0x24004d00,
+0x400e5143, 0x202d000a, 0x0fd00b84, 0xe1002c40, 0x50038400, 0x400c400f,
+0x038400e1, 0x00400e10, 0x00000400, 0x00000000, 0x00072804, 0x10360815,
+0x304004d8, 0x0408c940, 0x402d1043, 0x2b4d0070, 0x0cd00304, 0xcd04c040,
+0x10031420, 0x00304000, 0x0b0400d1, 0x10400c10, 0x00000c20, 0x00000000,
+0x0015a815, 0x0e7c015f, 0x34d07df0, 0xcc01df00, 0xd02d7007, 0x009f2466,
+0x0cf08b4c, 0xf3449450, 0x7203cc80, 0x0144c008, 0x08450213, 0x54d00f30,
+0x00000620, 0x00000000, 0x00070001, 0x027c0057, 0x37c108f0, 0x5c461f00,
+0xc019f003, 0x045f0017, 0x0df0033c, 0xdb4007c0, 0xf2037c00, 0x0037c021,
+0x005c101f, 0x07c00df0, 0x00000c00, 0x00000000, 0x003f0880, 0x01cc00b3,
+0x3cc037f0, 0xfc017300, 0x010ff003, 0x05430029, 0x0f3003cd, 0xf31088c0,
+0x3003dc00, 0x006cc053, 0x53c804b3, 0x00c00ef0, 0x00000c22, 0x00000000,
+0x00262081, 0x25442111, 0x30501910, 0x74001500, 0xc60dd003, 0x03510016,
+0x0db00345, 0xd1408440, 0x10032c00, 0x40354039, 0x1e440751, 0x05400dd0,
+0x00000802, 0x00000000, 0x0414a001, 0x0a041851, 0x34400910, 0x7404d100,
+0x4019d003, 0x02910014, 0x1d100754, 0xc0041440, 0x50034400, 0x02204109,
+0x00540051, 0x04400dd0, 0x00000200, 0x00000000, 0x40102010, 0x02050041,
+0x34400010, 0x36000580, 0x520cd003, 0x00c10010, 0x1d900715, 0xc1200050,
+0x11032400, 0x0021400d, 0x03140081, 0x41400cd0, 0x00000080, 0x00000000,
+0x00043000, 0x00440093, 0x34c00074, 0x7c005100, 0x400df003, 0x00534024,
+0x0d30035c, 0xf30004d0, 0x3003dc40, 0x0014c009, 0x015d00c3, 0x00c00ef0,
+0x00000ac0, 0x00000000, 0x000fb005, 0x00fc003f, 0x3fc003f0, 0xfc003f00,
+0xc00ff003, 0x007f001e, 0x0fb003ec, 0xff000fc0, 0xf003bc00, 0x003ec00f,
+0x03ec00ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x133fa003, 0x02cc00bf,
+0x0cc00ff0, 0xcc607f00, 0xc0cff081, 0x00f3023c, 0x0ff003ec, 0x63003fc0,
+0x30028c04, 0x223cc00b, 0x53cc08fb, 0x0fc0cf30, 0x00000e00, 0x00000000,
+0x03270801, 0x004400dd, 0x054004d0, 0x44205d08, 0x406dd103, 0x00d100b4,
+0x0dd00944, 0x5b053f41, 0x10094412, 0x03b6c024, 0x0b6c04c1, 0x0740c914,
+0x00000c20, 0x00000000, 0x0033a011, 0x060400cd, 0x01400cd0, 0x1400dd00,
+0x408cd007, 0x00cd01a0, 0x0cd00f24, 0x41013364, 0x5e201402, 0x20304088,
+0x830484c9, 0x47440c10, 0x00000e80, 0x00000000, 0x0035a803, 0x024400dd,
+0x054005d0, 0x5400dd00, 0x4005d103, 0x00dd0024, 0x0dd00344, 0x59003760,
+0x50035480, 0x30364005, 0x036420d1, 0x0f408d10, 0x00000620, 0x00000000,
+0x0067a802, 0x034c12cf, 0x64d04df1, 0x5c00df01, 0xd069f002, 0x00ff006c,
+0x0df0026c, 0xf30037c0, 0x7208dd00, 0x0034e20b, 0x034c00db, 0x03c00d30,
+0x00000e20, 0x00000000, 0x026d8007, 0x03fc80ff, 0x6ec08ff0, 0xed00ff01,
+0xc003f001, 0x00e34267, 0x0ff002fc, 0xff0037c0, 0xb003ac00, 0x0033c407,
+0x033c00ff, 0x1fc01bf1, 0x00000602, 0x00000000, 0x02250802, 0x037c03df,
+0x07c0acf0, 0x7c084f00, 0xd028f003, 0x04d34034, 0x0df0077c, 0xc34034d0,
+0x30084c00, 0xc034c018, 0x134800db, 0x0bc00d34, 0x00000420, 0x00000000,
+0x0024a013, 0x037409dd, 0x44400fd0, 0x74005d02, 0x4401d022, 0x06f10134,
+0x0fd00344, 0xd1603c40, 0x10036c0a, 0x003c4005, 0x1bec00f1, 0x4f400d10,
+0x00000200, 0x00000000, 0x0032a007, 0x0234200d, 0x01400cd0, 0x34014d00,
+0x406cd00b, 0x03c90024, 0x0cd00334, 0x41003640, 0x90002402, 0x00324008,
+0x0b0400d1, 0x1f400c10, 0x00000a00, 0x00000000, 0x00688004, 0x06b401ed,
+0x48441ed0, 0xb4016d10, 0x4014d007, 0x01e90068, 0x1ed02785, 0x61827a40,
+0x9007a401, 0x087a4026, 0x07a400e1, 0x1b409a10, 0x00000200, 0x00000000,
+0x01301012, 0xa23c084f, 0x01c20cf0, 0x3c00cf14, 0x504cf021, 0x00db4120,
+0x8df0233c, 0x43003240, 0xb4082c00, 0x0232c088, 0x030c08c3, 0x4bc00c30,
+0x00000040, 0x00000000, 0x00bdb802, 0x0afc08ff, 0x0fc08ff0, 0xfc48df02,
+0xc007f003, 0x00f7202f, 0x0df0a37c, 0x7f003dc0, 0x7003fc80, 0x083dc0d7,
+0x03fc80ff, 0x0bc00bf0, 0x00000660, 0x00000000, 0x0037a015, 0x0b7c00d3,
+0x60c009f0, 0x5800d300, 0xc049f002, 0x00d30034, 0x0d30020c, 0xdb0135c0,
+0x26004c00, 0x2034c009, 0x034ca0df, 0x54c01ff2, 0x00000e00, 0x00000000,
+0x10318812, 0x03b400e1, 0x285028d0, 0xbc00e100, 0x4502d003, 0x00f10038,
+0x4e100285, 0xc302b9c0, 0xb0032c00, 0x017ac006, 0x17ac04fd, 0x48400bd0,
+0x00000620, 0x00000000, 0x00790003, 0x47b401e5, 0x6e415ad0, 0xb4016100,
+0x401ad007, 0x01e10078, 0x9e100785, 0xe9017b40, 0xd204a401, 0x027a6018,
+0xa7840ded, 0x0d521ed2, 0x00000402, 0x00000000, 0x00332812, 0x033400c5,
+0x706008da, 0x34004100, 0x4090d120, 0x00c10274, 0x0c100704, 0xc1003740,
+0xd00b2480, 0x00324004, 0x032420cd, 0x494008d0, 0x00000c20, 0x00000000,
+0x4015a817, 0x0d7c1077, 0xded027f0, 0x1c024341, 0xd435f005, 0x00534014,
+0x05349dcc, 0x5b0017c0, 0xf0016c02, 0x8816c007, 0x014c005f, 0x5dc005f0,
+0x000004a0, 0x00000000, 0x00030012, 0x107c0119, 0x47c041f0, 0x5c521f00,
+0xc101f004, 0x001f0007, 0x01f0047c, 0x1f0005c8, 0x9000bc10, 0x0007c002,
+0x007c001f, 0x4a4001f0, 0x00000c00, 0x00000000, 0x00370810, 0x037c0097,
+0x27c008f0, 0x6c259f00, 0xc00d3022, 0x00830024, 0x09b0020c, 0x970025c0,
+0x30424c01, 0x0024c009, 0x025c008f, 0x43c009f0, 0x00000420, 0x00000000,
+0x20262001, 0x1a740191, 0x264019d1, 0x4c009d00, 0x44291116, 0x04912024,
+0x09100244, 0x81202740, 0xb002540a, 0x0026c009, 0x2244009d, 0x07400970,
+0x00000800, 0x00000000, 0x0064a018, 0x02740195, 0x25408950, 0xc4029d01,
+0x40281002, 0x04910024, 0x09900645, 0x95002540, 0x1202c410, 0x0026601b,
+0x0274009d, 0x634009d0, 0x00000200, 0x00000000, 0x02202010, 0x023400c1,
+0x224088d0, 0x8700ad00, 0x40881902, 0x00814a20, 0x08101204, 0x81012340,
+0x90229400, 0x0322509a, 0x2624208d, 0x43408850, 0x00000080, 0x00000000,
+0x0d86b01d, 0x007c4017, 0x15c16170, 0xcc801f20, 0xd1603400, 0x9e110580,
+0xe1b00444, 0x1522c1c1, 0x30084c0a, 0x0186c023, 0xc0740e1f, 0x77c161f0,
+0x00000ac0, 0x00000000, 0x21279819, 0x027c00bf, 0x3dc04bf0, 0x7c00df00,
+0xc049f103, 0x019f012f, 0x19f022fc, 0x9f0267c0, 0xf01a7c03, 0x01a7c069,
+0x025c099f, 0x67c04b70, 0x00000e60, 0x00000000, 0x40b7a018, 0x82fca0b3,
+0x2cc029f0, 0xbc80bf00, 0xd069f002, 0x01bb00ec, 0x89f042dc, 0xb30024c1,
+0x30164c07, 0x01a4c05b, 0x1afc049f, 0x67c0c930, 0x00000e00, 0x00000000,
+0x0083081c, 0x00740011, 0x044040d0, 0x74001d00, 0x5060d000, 0x02130044,
+0x01d0094c, 0x1b150440, 0x1038440a, 0x01844000, 0x1074240d, 0x73400110,
+0x00000c22, 0x00000000, 0x20a3a010, 0x86348085, 0x205029d0, 0x36008d00,
+0x4028d002, 0x168120a0, 0x48d00216, 0x8100a150, 0x14420400, 0x03204168,
+0x1a34128d, 0x43406810, 0x00000e80, 0x00000000, 0x0021a818, 0x027404d5,
+0x646009d0, 0x74409d00, 0x4108d102, 0x80992020, 0x09d00264, 0x99002040,
+0x128a4400, 0x00244009, 0x0276009d, 0x63400910, 0x00000620, 0x00000000,
+0x0227a805, 0x8a7c0197, 0xe4c008f0, 0x7c009f00, 0xc809f006, 0x00934064,
+0x09f0065c, 0x830025c0, 0x30024d00, 0x9024c009, 0x827c009f, 0x17c01930,
+0x00000e20, 0x00000000, 0x00358034, 0x027c009b, 0x27c00df0, 0x7c009f10,
+0xd00df066, 0x00870127, 0x08f0265c, 0x9f0027c0, 0xf0023c00, 0x0027d109,
+0x027c009f, 0x53c099f4, 0x00000600, 0x00000000, 0x80050814, 0x107c0113,
+0x04c001f0, 0x7c021f00, 0xd0213208, 0x00130004, 0x01b0084c, 0x130007c0,
+0x30804c01, 0x0004c000, 0x004c0017, 0x50c001f0, 0x00000420, 0x00000000,
+0x4414a014, 0x19f40370, 0x1d6805d0, 0xf4007d14, 0x4885b011, 0x0c712014,
+0x0510014c, 0x71001740, 0x1001c402, 0x00154017, 0x45d40051, 0x505005d0,
+0x00000200, 0x00000000, 0x0072a014, 0x063409c1, 0x724084d0, 0x3408cd00,
+0x400c100b, 0x03c10070, 0x0c900325, 0xc5003340, 0x54030400, 0x0030401c,
+0x076400c5, 0x50500cd0, 0x00000a00, 0x00000000, 0x00388005, 0x02b40021,
+0x3b4006d0, 0xb420ed10, 0x480e9007, 0x00e100a8, 0x4e100704, 0xe5013b40,
+0x50038400, 0x0179002a, 0x03b009e1, 0x14401cd0, 0x00000200, 0x00000000,
+0x04781015, 0x06bc01a1, 0x7a4016f0, 0xbc016f00, 0xc01e3007, 0x01f3407c,
+0x3eb086ac, 0xf740f3c0, 0x701fcc01, 0x00fcc01a, 0x05ac0de7, 0x54c07ef0,
+0x00000040, 0x00000000, 0x01b5b810, 0x027c801f, 0x35c045f0, 0x7c801f00,
+0xc22df001, 0x001f2427, 0x1df0037c, 0xdb05b7c0, 0xb0037d00, 0x0077c80d,
+0x035c02df, 0x43c00ff0, 0x00000660, 0x00000000, 0x007fa000, 0x27bc0133,
+0x7c003730, 0xcc09fd02, 0xc03ff007, 0x01f3006c, 0x1ff017dc, 0xf3007cc0,
+0x3207cc01, 0x007dc01f, 0x07fc01ff, 0x0bc01ff0, 0x00000e00, 0x00000000,
+0x28398815, 0x03b41021, 0x38504210, 0x8408ed00, 0x402e7011, 0x04710038,
+0x0fd00390, 0xe1023ac2, 0xb0039400, 0x0139400f, 0x23b404ed, 0xd7414ed0,
+0x00000620, 0x00000000, 0x04310000, 0x01f40021, 0x38400412, 0x84086d00,
+0x408cd002, 0x80e90068, 0x0ed01294, 0xc9003840, 0x50038400, 0x1038408e,
+0x01b640ed, 0x43600ed0, 0x00000400, 0x00000000, 0x00632804, 0x41341001,
+0x20400010, 0x04000d00, 0x400c5020, 0x00894030, 0x0cd00b04, 0x49003240,
+0xd0331400, 0x0031409c, 0x033400cd, 0x1b401cd0, 0x00000c20, 0x00000000,
+0x0065a815, 0x0b7c0293, 0x74d02510, 0x4c005f00, 0xd02df02f, 0x00db4034,
+0x0ff0231c, 0xdb403cd0, 0x700bcc00, 0x003dc02d, 0x027c00ff, 0x77c01ff0,
+0x00000620, 0x00000000, 0x002f0001, 0x837c029f, 0xf7c105f4, 0x7d025f00,
+0xc06df003, 0x00d70027, 0x0df0037c, 0xd70031c0, 0xb0033c82, 0x0037c04d,
+0x027c80df, 0x07c00df0, 0x00000c00, 0x00000000, 0x023f0880, 0x03fc0033,
+0x1fc00330, 0xfc017f00, 0xc00ff202, 0x00f30038, 0x0f3002fc, 0xb30037c0,
+0x30034c05, 0x003cc01e, 0x02cc00ef, 0x07c00f10, 0x00000c20, 0x00000000,
+0x08362081, 0x07340011, 0x37409110, 0x74411d08, 0x402dd004, 0x0111002c,
+0x0d10037c, 0x850035c0, 0x50035401, 0x0037c07d, 0x060400dd, 0x07440d14,
+0x00000802, 0x00000000, 0x0020a001, 0x23740411, 0xb7480510, 0x74941d00,
+0x400cd0a3, 0x01d11024, 0x0d900374, 0xd5003740, 0x10034410, 0x0034404d,
+0x476400dd, 0x07400d50, 0x00000200, 0x00000000, 0x40202010, 0x03340001,
+0x33400010, 0x34000d00, 0x4004d001, 0x00012031, 0x0c940354, 0xc5003140,
+0x50031400, 0x00335004, 0x022400cd, 0x43400c10, 0x00000080, 0x00000000,
+0x0036b000, 0x017c0013, 0x17400134, 0x74001f00, 0xc00df002, 0x00d34028,
+0x0db00274, 0x97003fc0, 0x30034c00, 0x0034c005, 0x026c00ff, 0x07c00d70,
+0x00000ac0, 0x00000000, 0x002fb805, 0x01fc003f, 0x2fc003f2, 0xfc402f00,
+0xc00fd000, 0x00bf003e, 0x0f7003fc, 0xbf003fc0, 0xf003fc00, 0x003fc40f,
+0x02dd00ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x003f8003, 0x33fc1c33,
+0x3fc08ff0, 0xad00f300, 0xc00f3001, 0x0033200f, 0x0fb083c4, 0x7f053cc1,
+0x3212fc00, 0x133cc84b, 0x33c40c73, 0x0cc00ff0, 0x00000e00, 0x00000000,
+0x12b70801, 0x33740251, 0x3740edd0, 0x4400d140, 0x400d1201, 0x00510007,
+0x2f900344, 0x5d00b440, 0x5021744a, 0x00b54085, 0x0b440291, 0x04400dd0,
+0x00000c00, 0x00000000, 0x0833a011, 0x03140481, 0x33420c50, 0x4400c100,
+0x480c1501, 0x0045c007, 0x0c108305, 0x4d103048, 0x10003440, 0x0b344008,
+0x0a240c11, 0x44400cd0, 0x00000e80, 0x00000000, 0x2835a803, 0x03760091,
+0x37400dd0, 0x4401d100, 0x400d1001, 0x00450c07, 0x0d901304, 0x5d003440,
+0x50037410, 0x00354005, 0x03640ad1, 0x0c400dd0, 0x00000620, 0x00000000,
+0x4037a802, 0x037c2213, 0x37c00df0, 0x2c019300, 0xc01d3001, 0x03d700e7,
+0x0d34134c, 0x7f0034d0, 0x3018fc02, 0x0034c00b, 0x036c0043, 0x08d00cf0,
+0x00000e20, 0x00000000, 0x00318007, 0x03fc247f, 0x3fc00ff2, 0xfc108f00,
+0xc49ff063, 0x42fb015f, 0x0d7007fc, 0x7f003fc0, 0xf003bc00, 0x003fc004,
+0x03dd01ff, 0x1fc00ff0, 0x00000600, 0x00000000, 0x00350802, 0x037c409b,
+0x37c00df0, 0x5c029300, 0xc00d7401, 0x46d340b4, 0x0c30034c, 0x534035c0,
+0xb0085c02, 0x0035d009, 0x124d8213, 0x0bc00d72, 0x00000420, 0x00000000,
+0x203ca013, 0x13f40091, 0x3f400fd0, 0x6c009140, 0x400d1001, 0x02d10070,
+0x0f164344, 0x5b007c48, 0xb0176c00, 0x20384205, 0x8a440091, 0x4f400f10,
+0x00000200, 0x00000000, 0x0032a007, 0x07240009, 0x36600c90, 0x04094100,
+0x480c1101, 0x004c0020, 0x6c100614, 0xc1a1b140, 0x90001100, 0x00314008,
+0x0b040041, 0x1f400c54, 0x00000a00, 0x00000000, 0x00788004, 0x87b405e1,
+0x7b401ed8, 0xa401e108, 0x401e1005, 0x01e90458, 0x1e1027a7, 0xc906784c,
+0x90072429, 0x007c4016, 0x0784c131, 0x13401e10, 0x00000200, 0x00000000,
+0x00301012, 0x033c884b, 0x37c08cfa, 0x1c04c302, 0x404c5021, 0x025d0034,
+0x0c30005c, 0xc30035c0, 0xb0001c08, 0x0031c008, 0x024c8083, 0x4bc00c74,
+0x00000000, 0x00000000, 0x003db802, 0x43fc0cff, 0x37c20ffa, 0xfc00df00,
+0xd00cf001, 0x08f70237, 0x8ff203dc, 0xff0c3fc0, 0xf003fc08, 0x003bc017,
+0x23fc08ef, 0x0bc00ff0, 0x00000660, 0x00000000, 0x0037a015, 0x036c011f,
+0x36c08df0, 0x4c20df22, 0xc01df001, 0x01c30064, 0x2dbc036c, 0xd30034c0,
+0xa4004c00, 0x3074d009, 0x034c0013, 0x54c00db2, 0x00000e00, 0x00000000,
+0x00f98812, 0x038400fd, 0x3b404ed0, 0x8400ed00, 0x400ad083, 0x00e10018,
+0xae500384, 0xc1013840, 0x10030400, 0x11fc4006, 0x03c40031, 0x48504f14,
+0x00000620, 0x00000000, 0x01790003, 0x17840165, 0x7b4c1ed0, 0x8401cd21,
+0x401ed005, 0x01f90078, 0x5e100f84, 0xe1007850, 0x90048501, 0x01784018,
+0x068400e1, 0x0c409ed4, 0x00000400, 0x00000000, 0x20332812, 0x030480cd,
+0x33400dd2, 0x0400cd00, 0x501cd104, 0x01c14070, 0x0cd00704, 0xd1403040,
+0x10030400, 0x20304004, 0x020401c1, 0x48400c50, 0x00000c20, 0x00000000,
+0x0015a817, 0x014d007f, 0x16c005f0, 0x8d046f00, 0xd005f049, 0x127b00dc,
+0x07b10d8d, 0x530014c0, 0xb0090d00, 0x001cc007, 0x054c0173, 0x5cc005f0,
+0x00000620, 0x00000000, 0x08070012, 0x087c401f, 0x07c201f0, 0x7c101f08,
+0xc081f00c, 0x811f0247, 0x0070485c, 0x1f0007c0, 0xf040fc00, 0x4007c802,
+0x287c080f, 0x4bc021a0, 0x00000c00, 0x00000000, 0x00270810, 0x063c009f,
+0x24c00970, 0x4d009f00, 0xc0893816, 0x019f2027, 0x0930027c, 0x930024c6,
+0x70064c00, 0x0025c009, 0x020ca09f, 0x40c00871, 0x00000c20, 0x00000000,
+0x10262001, 0x9674409d, 0x24400910, 0x44429d00, 0x40291002, 0x809d00a7,
+0x29101274, 0x9b08a458, 0x04266c40, 0x00244009, 0x0a44009d, 0x04512910,
+0x00000800, 0x00000000, 0x0024a018, 0x927400dd, 0x26500950, 0x4402dd20,
+0x43091002, 0x869d0427, 0x49100274, 0x91052040, 0x1002c400, 0x0025400b,
+0x0244009d, 0x60400950, 0x00000200, 0x00000000, 0x07202010, 0x7234008d,
+0x20400810, 0x05149d02, 0x40885802, 0x288d0223, 0x881c2274, 0x89222040,
+0x1002a408, 0x0220508a, 0x0a05088d, 0x40402810, 0x00000080, 0x00000000,
+0x0186b01d, 0x987c941f, 0x84c14170, 0x4c041f05, 0x40201081, 0x021f0083,
+0x6430083c, 0x131580c1, 0x74004c02, 0x0585c023, 0x014c561f, 0x74c00170,
+0x00000ac0, 0x00000000, 0x2127b819, 0x127c14bf, 0x27c149f0, 0xfc00bf21,
+0x404bb402, 0x04bf012f, 0x49f012fc, 0x9f0927c0, 0xf00a7c06, 0x0127c069,
+0x8afc24bf, 0x67c029f0, 0x00000e60, 0x00000000, 0x0527a018, 0x0acc0093,
+0xa7c049f0, 0x8c048f01, 0xc00b3002, 0x08930024, 0xc9308a7c, 0x9f0324c1,
+0x3006cc0d, 0x042ec119, 0x12f40093, 0x60d02ab0, 0x00000e00, 0x00000000,
+0x2187081c, 0x08440411, 0x834941d0, 0x45021d01, 0x0340b000, 0x00110d04,
+0x21000074, 0x0d0008c0, 0xb1285402, 0x08844141, 0x90749515, 0x71404110,
+0x00000c20, 0x00000000, 0x4423a010, 0x0a041281, 0x234028d0, 0x44088d03,
+0x40091002, 0x04a10028, 0x4a0102b4, 0x8d01a950, 0x1402040c, 0x05224008,
+0x4a344081, 0x40484890, 0x00000e80, 0x00000000, 0x0025a818, 0x02640291,
+0x274009d0, 0x44209d00, 0x58099042, 0x00b1402c, 0x0b108af4, 0x8d082d40,
+0x92025400, 0x00244009, 0x02744495, 0x61500910, 0x00000620, 0x00000000,
+0x0027a805, 0x024d0193, 0x27c009f0, 0x0c129f00, 0xc008302e, 0x40932124,
+0x0934027c, 0x9f1825c0, 0x30424c00, 0x4026c809, 0x267c8493, 0x14d009b4,
+0x00000e20, 0x00000000, 0x00258014, 0x025c099f, 0x27c009f0, 0x7d00cf00,
+0xc099f042, 0xe89f0667, 0x08f0027c, 0x9f0024c0, 0xf0027c00, 0x0027c009,
+0x463c009f, 0x53d009f4, 0x00000600, 0x00000000, 0x00050814, 0x104c0003,
+0x07c00134, 0x4c001300, 0xc1013c00, 0x001f0084, 0x01f0084c, 0x130004c0,
+0x30084c00, 0x0004c800, 0x007c0213, 0x50c011f0, 0x00000420, 0x00000000,
+0x0014a014, 0x05c40051, 0x17400510, 0xc4085100, 0x40051041, 0x535d0094,
+0x05d04144, 0x5b081400, 0xb0010400, 0x10544005, 0x4df40055, 0x504076d1,
+0x00000200, 0x00000000, 0x0036a014, 0x0f0500c1, 0x33400c10, 0x25000100,
+0x403c1007, 0x13cd0234, 0x1cd04744, 0xc1003060, 0x10030400, 0x2074540c,
+0x023000c1, 0x50400cd0, 0x00000a00, 0x00000000, 0x01308005, 0x478404e1,
+0x7b408e10, 0xa4006101, 0x442e1003, 0x016d1028, 0x2ed00284, 0xe9206860,
+0x94028404, 0x0438404e, 0x02b440e5, 0x14400ed1, 0x00000200, 0x00000000,
+0x41781015, 0x07cc03f3, 0x7bc25e31, 0xac11a341, 0xd0161006, 0x01fd0058,
+0x17f2078c, 0xe32458d0, 0x30078d05, 0x007ce47c, 0x06bc41e3, 0x54d016f0,
+0x00000040, 0x00000000, 0x0235b810, 0x027c00df, 0xb7c00df0, 0x5c06df02,
+0xc005f002, 0x00df0007, 0x0dd0027d, 0xdf0037c0, 0xf002241c, 0x0037c00d,
+0x007c01fe, 0x43c005f0, 0x00000660, 0x00000000, 0x007fb000, 0x06cc0dff,
+0xffc01f30, 0x9c012300, 0xc81f2007, 0x21fa027f, 0x1b3007cd, 0xf2007cc0,
+0x34078c01, 0x006fc21f, 0x07fc01f3, 0x03801332, 0x00000e00, 0x00000000,
+0x00398015, 0x028418ed, 0x3b400e10, 0x950a6100, 0x044eb0a3, 0x0061002b,
+0x2a3402c4, 0xf100a840, 0x5002bc00, 0x002b400e, 0x23b400e1, 0x56408210,
+0x00000620, 0x00000000, 0x02390000, 0x018604ed, 0x3b408e90, 0xd400b100,
+0x09021003, 0x12e1043b, 0x06904384, 0xe1001a40, 0x1003a400, 0x002b400e,
+0x03b418e1, 0x03400214, 0x00000400, 0x00000000, 0x00332804, 0x000606cd,
+0x33400c90, 0x1406c100, 0x44109023, 0x015100e3, 0x0c100204, 0xc1003040,
+0x54363400, 0x0027402d, 0x017406c1, 0x12400010, 0x00000c20, 0x00000000,
+0x003da815, 0x014d03ff, 0x3fc00fb4, 0x1d021340, 0xc00d300f, 0x41934077,
+0x0cb00d4c, 0xf30034f0, 0x300b6d00, 0x4037c07f, 0x077c01f3, 0x57c00930,
+0x00000620, 0x00000000, 0x00370001, 0x017c00df, 0x37c20d70, 0x7c005f00,
+0xc00df41b, 0x80170037, 0x2df0417c, 0xdf20a7c0, 0xf0037c00, 0x1037c04d,
+0x077c00df, 0x06c009f0, 0x00000c00, 0x00000000, 0x003f0880, 0x01fc00df,
+0x34c00ef0, 0xcd00a300, 0xe01f3002, 0x08b6061f, 0x173201cc, 0xf32050c0,
+0x70028c00, 0x0134c00f, 0x037c00f3, 0x03c00371, 0x00000c22, 0x00000000,
+0x00362081, 0x007400dd, 0x35400dd0, 0x6c02d100, 0x601d5108, 0x00910017,
+0x35100904, 0xd108c440, 0x10027c00, 0x0034400d, 0x057400df, 0x07400110,
+0x00000802, 0x00000000, 0x0034a001, 0x027400dd, 0x30400dd8, 0x64009120,
+0x498d1043, 0x00d100b3, 0x89192b44, 0xc1223440, 0x50234400, 0x0034400d,
+0x057420d1, 0x07401550, 0x00000200, 0x00000000, 0x00302010, 0x063400cd,
+0x31400cd0, 0x65004100, 0x400c5003, 0x00410823, 0x09180245, 0xc1002040,
+0x14033700, 0x0030400c, 0x053400cd, 0x43400410, 0x00000080, 0x00000000,
+0x0036a000, 0x013c00df, 0x3cc00df0, 0x4c009300, 0x40053003, 0x80834013,
+0x0014014c, 0xf30014c0, 0x72024c00, 0x0034d00d, 0x017c00d3, 0x03c00570,
+0x00000ac0, 0x00000000, 0x003f8805, 0x00fc00ff, 0x3fc00fd0, 0xfc00ff20,
+0xc007f003, 0x003b000f, 0x039000fc, 0xff000f80, 0xf002fc00, 0x083fc00f,
+0x01fc20fc, 0x17c007f0, 0x00000e60, 0x00000000, 0x002f8003, 0x008c4033,
+0x0fc003d2, 0xfc20ff02, 0xc00f3410, 0x80f3043d, 0x8fb013ec, 0x3b053ec0,
+0x7000dc28, 0x403fc007, 0x83cc0073, 0x0fc08ff2, 0x00000e00, 0x00000000,
+0x24170801, 0x80440051, 0x174105d0, 0x7418df00, 0x400d1148, 0x10f500b4,
+0x6e103bc4, 0x11013c40, 0x10004404, 0x0437400d, 0x13c40051, 0x07404dd0,
+0x00000c20, 0x00000000, 0x0103a011, 0x00340009, 0x13400050, 0x7404cd00,
+0x400c9030, 0x48c50031, 0x2c104324, 0x8d053240, 0x50003400, 0x4137480c,
+0x43140051, 0x47404cd0, 0x00000e80, 0x00000000, 0x0875a803, 0x04750019,
+0x974005d0, 0x7400d510, 0x400d9042, 0x00c50034, 0x0d900364, 0x95003040,
+0x14006400, 0x0117400d, 0x03561050, 0x0f400dd0, 0x00000620, 0x00000000,
+0x44b7a802, 0x447c058b, 0x07c8c1f0, 0x7c009d10, 0xc08db000, 0x00d70035,
+0x0da4036c, 0x1f0036c0, 0x700c7c01, 0x0037c09d, 0x03590052, 0x0bc20df2,
+0x00000e20, 0x00000000, 0x201d8007, 0x00cc0277, 0x3fc007f2, 0x7c00bf10,
+0xc00f7000, 0x80ff103f, 0x0f70031c, 0x9b0037c0, 0xf0249c09, 0x087fc80b,
+0x03ec023f, 0x1fc00ff2, 0x00000600, 0x00000000, 0x00b50802, 0x007c009f,
+0xb5c08970, 0x4d00df00, 0xc01db04b, 0x00df1037, 0x0d70434c, 0x8b4035c0,
+0x34284c00, 0x0035c00d, 0x034c025f, 0x0b400d30, 0x00000420, 0x00000000,
+0x02b4a013, 0x28740a1d, 0x34400d50, 0x0800dd00, 0x400c500b, 0x00fd043f,
+0x0f100fc4, 0x90003ec0, 0x10804400, 0x03b0400d, 0x03ec00cd, 0x4f440f10,
+0x00000200, 0x00000000, 0x0026a007, 0x0834000d, 0x03413840, 0x2400cd08,
+0x48089000, 0x00cc0077, 0x0d502704, 0x41003140, 0x10070400, 0x00a1400c,
+0x0334094d, 0x1f400c10, 0x00000a00, 0x00000000, 0x00788004, 0x04a481ed,
+0x7a481812, 0x8421ed00, 0x40be1006, 0x49cd007b, 0x9e502784, 0x61027844,
+0x10070401, 0x0068601e, 0x2734017d, 0x13401e10, 0x00000200, 0x00000000,
+0x00101032, 0x003c084f, 0x33c00c70, 0x2400df02, 0xc00cb000, 0x00cf0033,
+0x0c70030c, 0xcb003140, 0x301b0c00, 0x0091c00d, 0x033c004f, 0x4bc08c34,
+0x00000040, 0x00000000, 0x003db002, 0x03fc20ff, 0x3dc00ffa, 0xf400ff02,
+0xc00ff002, 0x10ff003f, 0x0db04bfd, 0xff0437c3, 0xf0037d08, 0x021fc08f,
+0x03ec006f, 0x0bc30ff0, 0x00000660, 0x00000000, 0x0037a015, 0x0074409f,
+0x07c001f0, 0x7c009e05, 0xc00cf002, 0x04d3403c, 0x0d700f6c, 0x530936c1,
+0x32135c00, 0x4037c00d, 0x334c0041, 0x57c00db0, 0x00000e20, 0x00000000,
+0x84398812, 0x00b420ed, 0x3b4402d0, 0xb400ad00, 0x480ef002, 0x10f1007c,
+0x4e011304, 0xe5033040, 0x10438400, 0x003b440e, 0x43c40065, 0x4b404e10,
+0x00000620, 0x00000000, 0x94790003, 0x469401ed, 0x7b401ed0, 0xb401ed00,
+0x401ed007, 0x05e10078, 0x1c4103a4, 0xc1017b40, 0x90071401, 0x005b401e,
+0x13a58169, 0x0f401e51, 0x00000400, 0x00000000, 0x80732812, 0x963404cd,
+0xb3402cd0, 0x3401cd04, 0x528c40a7, 0x00c10034, 0x0c100304, 0xc5003140,
+0x90030412, 0x1057407c, 0x0324424d, 0x4b400c50, 0x00000c20, 0x00000000,
+0x00d5a817, 0x05bc027f, 0x97c007f0, 0xfc105f00, 0xc014d00d, 0x40533014,
+0x0570016c, 0x530017c0, 0xb6015d00, 0x51dfc037, 0x016c106b, 0x5fc005f0,
+0x00000600, 0x00000000, 0x04870012, 0x007c400f, 0x07c041f0, 0x7c001f00,
+0xc001f20c, 0x000f0007, 0x01f0007c, 0x1f0000c8, 0x74003c00, 0x00c7c081,
+0x005c3017, 0x4bc001a0, 0x00000c00, 0x00000000, 0x00770810, 0x025c0893,
+0x34c01870, 0x7c009f08, 0xc009f006, 0x00930024, 0x08300a5c, 0x870024f0,
+0x30026c00, 0x0024c809, 0x020c0591, 0x43c00930, 0x00000c00, 0x00000000,
+0x43262001, 0x22540391, 0x24405950, 0x74209d00, 0x4009d00a, 0x00935024,
+0x09101a04, 0x91002444, 0x10024400, 0x01654008, 0x026c4095, 0x07400910,
+0x00000800, 0x00000000, 0x0020a018, 0x02541091, 0x24408950, 0x74009d00,
+0x5019d062, 0x00910024, 0x09100254, 0x95002440, 0x1002e500, 0x0064500d,
+0x02440095, 0x63400910, 0x00000200, 0x00000000, 0x02202010, 0x02040081,
+0x20508810, 0x34088d02, 0x4018d022, 0x08810020, 0x48104204, 0xa1032040,
+0x10029406, 0x90204089, 0x32260491, 0x43400814, 0x00000080, 0x00000000,
+0x0086b01d, 0x505c1413, 0x84c16153, 0x7c561f00, 0xc141f058, 0x10130384,
+0xc130005c, 0x17050440, 0x1010ec04, 0x4004c001, 0x0c4c0417, 0x77c1e130,
+0x000008c0, 0x00000000, 0x0137b819, 0x02fc00bf, 0x27c24bf0, 0xfc04bf01,
+0xc00bf012, 0x009f0327, 0xc9f04274, 0x9f0127c0, 0xf4226426, 0x042bc01b,
+0x327c08bf, 0x67c019f0, 0x00000ce0, 0x00000000, 0x18afa018, 0x02cc009f,
+0xa6c92bf0, 0xcc029f10, 0xd60bf01a, 0x009b0368, 0x49b052cc, 0x9b00a4c1,
+0x3042ec00, 0x082bc809, 0x027c14b3, 0x60c2c9b0, 0x00000e00, 0x00000000,
+0x0007081c, 0x00442a1d, 0x044021d0, 0x44021d01, 0x4021d001, 0x04050184,
+0x61501844, 0x51208040, 0x10084406, 0x01174441, 0x00740251, 0x70406150,
+0x00000c20, 0x00000000, 0x0123a010, 0x0a24008d, 0x204008d0, 0x24228d00,
+0x4028501a, 0x128140b0, 0x08904234, 0x8820a041, 0x50022532, 0x04234108,
+0x0a340081, 0x40402810, 0x00000e80, 0x00000000, 0x0125a818, 0x5264209d,
+0x264028d2, 0x64009d14, 0x4009d002, 0x00950024, 0x08100244, 0x81002440,
+0x50024400, 0x00274069, 0x02742895, 0x60400950, 0x00000620, 0x00000000,
+0x00a7a805, 0x8265009f, 0xe6d019f1, 0x6d089f20, 0xc088f00e, 0x00930024,
+0x09b1025d, 0x9b0024d0, 0x54026c02, 0x40e7c009, 0x027c0193, 0x14d009b4,
+0x00000e20, 0x00000000, 0x00658014, 0x025c08cf, 0x25c029f0, 0x5c008f22,
+0xc019f012, 0x008f2027, 0x09f0027c, 0x9f0023c0, 0xb0025c00, 0x0167c009,
+0x023c009b, 0x53c009f1, 0x00000600, 0x00000000, 0x44850814, 0x047c1013,
+0x04c10150, 0x4d001f00, 0xc0013020, 0x00130044, 0x01f0404c, 0x170005e0,
+0x31006d02, 0x0087cc01, 0x004c0013, 0x50c00130, 0x00000420, 0x00000000,
+0x105ca014, 0x09f40051, 0x14423750, 0xc4005d10, 0x40071029, 0x0051001c,
+0x05900dd4, 0x51c01442, 0x00110400, 0x24df4005, 0x016c1051, 0x504005b0,
+0x00000200, 0x00000000, 0x0032a014, 0x243400c1, 0x32402c50, 0x2400cd00,
+0x50041007, 0x80c10034, 0x0cd00144, 0xc1003148, 0x90072400, 0x0487480c,
+0x030401c1, 0xd2400d10, 0x00000a00, 0x00000000, 0x04588005, 0x04240061,
+0x38402e50, 0x8400ed22, 0x490c1005, 0x08e10038, 0x4ed00984, 0xe1013840,
+0x14028404, 0x801f40ce, 0x13a401f1, 0x16404e90, 0x00000200, 0x00000000,
+0x005c1015, 0x05bc1123, 0x78d01c72, 0x8c85ff00, 0xc0163405, 0x05e30078,
+0x7cf0058c, 0xc1017940, 0xb0072c07, 0x505bc01e, 0x0fcc01a3, 0x56d05f30,
+0x00000040, 0x00000000, 0x0815b810, 0x817c061f, 0x35e20df0, 0x3408df00,
+0xe005f001, 0x10df4036, 0x2db1097d, 0xdf0637d0, 0xf0027d02, 0x0817c00d,
+0x077c00cf, 0x41c29df0, 0x00000660, 0x00000000, 0x006fa000, 0x07fc09fb,
+0x7bc01fb0, 0xcc01f300, 0xc0133005, 0x01f3005f, 0x3f320dcc, 0xf3207ec0,
+0xf206ec03, 0x006fc01f, 0x07fc01f3, 0x00c01f30, 0x00000e00, 0x00000000,
+0x01298811, 0x09bc00e1, 0x3b4006f0, 0xa400f100, 0x408e1001, 0x00f1480b,
+0x4f1001c4, 0xf1003c40, 0x10028400, 0x001f400e, 0x03f400eb, 0x55400e10,
+0x00000620, 0x00000000, 0x90b90000, 0x03b60021, 0xbf400ad0, 0x8400e100,
+0x40061001, 0x00e9001b, 0x0e900184, 0xe1023842, 0x50021400, 0x008b400e,
+0x03b410a1, 0x00400e10, 0x00000400, 0x00000000, 0x00332804, 0x49140301,
+0x37409150, 0x6400c100, 0x40041011, 0x00c90003, 0x0c900005, 0xd1403448,
+0x10021502, 0x0017408c, 0x033403c1, 0x11400c10, 0x00000c20, 0x00000000,
+0x4021a815, 0x11740613, 0x3f400dd0, 0x4d00f340, 0xc0003403, 0x00f90017,
+0x0fb4014c, 0xf1003cd2, 0x70037d02, 0x0087403e, 0x03fc03d1, 0x54c00f34,
+0x00000620, 0x00000000, 0x00670001, 0x097c021f, 0x77c009f0, 0x5c00df00,
+0xc019f001, 0x00d70007, 0x0d70097c, 0xdf0035c0, 0x70026c90, 0x0017c10d,
+0x033c30df, 0x07c40df0, 0x00000c00, 0x00000000, 0x00cf0880, 0x01fc1933,
+0x3cc84770, 0xfa00f300, 0xe02370a4, 0x00e70014, 0x0f7001dc, 0xf7003fc0,
+0xb0038c00, 0x000cc00f, 0x03c000e3, 0x03c00d30, 0x00000c22, 0x00000000,
+0x00062081, 0x0d740311, 0x354131d1, 0x7400d100, 0x50011000, 0x00dd8004,
+0x0d100144, 0xd10037c0, 0x50026c00, 0x0054400d, 0x036c00d1, 0x07480d10,
+0x00000802, 0x00000000, 0x0c24a001, 0x11741011, 0x34400dd0, 0x7440d100,
+0x40015000, 0x00dd2074, 0x0d545114, 0xd5003740, 0x90024400, 0x00c4400d,
+0x03540891, 0x07400d10, 0x00000200, 0x00000000, 0x00242010, 0x01340001,
+0x30500090, 0x2400c100, 0x40081000, 0x00cd8070, 0x0c100304, 0xd1003140,
+0x90022400, 0x0010400d, 0x033600c1, 0x43400c14, 0x00000080, 0x00000000,
+0x0022b000, 0x017c0013, 0x34c00170, 0x7400d340, 0x48017200, 0x20ff2034,
+0x0f7002dc, 0xf7003f40, 0xb0024c00, 0x0004c00d, 0x035c0093, 0x03c00d30,
+0x00000ac0, 0x00000000, 0x002fb805, 0x01fc003f, 0x3fc003f0, 0xbc00ff10,
+0xc003f000, 0x00ff003f, 0x0ff003fc, 0xff003fc0, 0x7002fc00, 0x001fc00f,
+0x03ec00fd, 0x17c00ff0, 0x00000e48, 0x00000000, 0x001fa003, 0x23fc00f3,
+0x3cc40f70, 0xbc08ff02, 0xc007b003, 0x003f000d, 0x033000fc, 0xf3400cc0,
+0x3013fc00, 0x003cc402, 0x02ed0033, 0x0cc04f30, 0x00000e00, 0x00000000,
+0x00170801, 0x035c0adb, 0x36c00fd8, 0x7684dd00, 0xc40dd203, 0x001d2806,
+0x01300074, 0xd1083442, 0x100b7410, 0x00344001, 0x0304005b, 0x06c20c10,
+0x00000c00, 0x00000000, 0x4033a011, 0x103400c5, 0x31480cd3, 0x14444d01,
+0x4000d003, 0x00451011, 0x08100234, 0xc1100142, 0x540b3408, 0x00304005,
+0x03448041, 0x44502c10, 0x00000e80, 0x00000000, 0x0035a803, 0x427400d5,
+0xa5600dd1, 0x7400dd00, 0x410dc082, 0x085d0415, 0x09900270, 0xd1063540,
+0x50077400, 0x40704105, 0x03440051, 0x0c400d10, 0x00000620, 0x00000000,
+0x20b38802, 0x0a7c20d5, 0xf4500d78, 0x7c01df10, 0x402db007, 0x059f00f5,
+0xad340b38, 0xd31045d0, 0x70037c40, 0x0074d095, 0x260c0151, 0x084c0d34,
+0x00000e20, 0x00000000, 0x003d8007, 0x8edc00db, 0x3e880ff1, 0xfc04ff09,
+0xc10fe122, 0x819d023e, 0x0d7057fc, 0xfe0046c0, 0xb003bc00, 0x003fc007,
+0x03fc09ff, 0x1fc00ef2, 0x00000608, 0x00000000, 0x00750802, 0x025d00db,
+0x36c80cf0, 0x7c01df08, 0xc0093403, 0x08970094, 0xac300b4d, 0xd74100c0,
+0x70027c00, 0x0034c00d, 0x036c005b, 0x08c00d30, 0x00000420, 0x00000000,
+0x20748013, 0x8a4400f1, 0xb4c00ff0, 0x7402dd00, 0x400c1082, 0x01910054,
+0x0d100b44, 0xf1000440, 0xe2037400, 0x02b6c20c, 0x2b440ad1, 0x4c40af10,
+0x00000200, 0x00000000, 0xc192a007, 0x120400c1, 0x20404c90, 0x3406cd02,
+0x40345023, 0x27c50060, 0x14500914, 0xc100b062, 0xd0033400, 0x0030400c,
+0x23260951, 0x1c408c90, 0x00000a00, 0x00000000, 0x00788004, 0x268401e1,
+0xea489cd0, 0xf481ed20, 0x511c5005, 0x81e1066c, 0x16502511, 0xe102786c,
+0xd00fb401, 0x007a401f, 0x0784a1f1, 0x10401e90, 0x00000200, 0x00000000,
+0x00b01012, 0x621c00c3, 0x20d00cf0, 0x3c084f20, 0xc2007003, 0x6445aa34,
+0x00700014, 0xc70030d0, 0x70033800, 0x4030c00c, 0x032c0243, 0x48d00cb4,
+0x00000000, 0x00000000, 0x00b9b802, 0x22fc08f7, 0x1dc00d71, 0x7e28ff02,
+0xc80db221, 0x007f8a37, 0x03b480ec, 0xdf203fe0, 0x72037c00, 0x043bc00f,
+0x23fc08e7, 0x0bc08f70, 0x00000660, 0x00000000, 0x00f7b015, 0x027c00d3,
+0x71c32d38, 0x3c809b00, 0xc005a003, 0x00d30824, 0x0d30035c, 0xd34037c0,
+0xf0037c81, 0x0034c00d, 0x034c005f, 0x54c00d31, 0x00000e00, 0x00000000,
+0x00398012, 0x02f405e1, 0x38402f1a, 0xb400a100, 0xc00e1003, 0x00c10822,
+0x0e108380, 0xe1043f40, 0xd803b402, 0x0079400f, 0x03c400ed, 0x48485f10,
+0x00000620, 0x00000000, 0x00790003, 0x079409e1, 0x7d425e14, 0xb481e900,
+0x48129847, 0x03e18078, 0x1e100705, 0xe900fb40, 0x5007b480, 0x0178401e,
+0x0784116d, 0x0c40de10, 0x00000400, 0x00000000, 0x00322812, 0x073420d1,
+0x10600c10, 0x340fd100, 0x410c114f, 0x10c10432, 0x9c140704, 0xc900f740,
+0xd0033420, 0x0a71404d, 0x830441cd, 0x48400c11, 0x00000c20, 0x00000000,
+0x0095a817, 0x09dc0051, 0x1dc00532, 0xfc827b04, 0xc025b005, 0x415350d0,
+0x25301d5d, 0x5b30d7c0, 0xf0117c40, 0x000cc107, 0x014d027f, 0x5cd00534,
+0x00000620, 0x00000000, 0x41070012, 0x247c001f, 0x07c001f0, 0x7c001f00,
+0xc021f200, 0x020f0207, 0x01f0007c, 0x170187c9, 0xf0087c00, 0x2007c401,
+0x007c011f, 0x4bc001f2, 0x00000c00, 0x00000000, 0x00370810, 0x8e4c809f,
+0x24c08850, 0x5cc09f00, 0xc009300e, 0x01930064, 0x0930420c, 0x800027c0,
+0x30024c00, 0x0004c019, 0x024c0093, 0x40c00930, 0x00000c20, 0x00000000,
+0x02662001, 0x0604409d, 0x64400910, 0x04019d20, 0x42281002, 0x05930065,
+0x09120a44, 0x91412700, 0x111a0480, 0x4027c889, 0x02450091, 0x04540914,
+0x00000800, 0x00000000, 0x0024a018, 0x0245009d, 0xe4400910, 0x56019d00,
+0x40095003, 0x04b0022c, 0x8f1043c4, 0x95002f00, 0x10024400, 0x00204009,
+0x02040081, 0x60400810, 0x00000200, 0x00000000, 0x00202010, 0x03441c8d,
+0x20508c54, 0x04018d08, 0x400c5402, 0x00a10029, 0x0a100284, 0x81822b40,
+0x10024408, 0x40a34088, 0x0a040281, 0x40402810, 0x00000080, 0x00000000,
+0x0006a01d, 0x804c261f, 0x04c16152, 0x5c001f00, 0xc1417001, 0x14130d04,
+0x41345044, 0x17058fc5, 0x30504c16, 0x0504c021, 0x004c0003, 0x74c00130,
+0x00000ac0, 0x00000000, 0x0823a819, 0x52fc049f, 0x2fc849b0, 0xfc14bf0d,
+0xc00ab002, 0x00d74027, 0x09f0027d, 0x9a0127c0, 0xfc02fc04, 0x000fc04b,
+0x02fc00bf, 0x67c029f0, 0x00000e60, 0x00000000, 0x002fa018, 0x0abc149f,
+0x2cc02bf0, 0xfc40bb02, 0xc04bd002, 0x04a3012c, 0x083212fc, 0x9300afc0,
+0x30520c00, 0x006cc02b, 0x224c009f, 0x63c40932, 0x00000e00, 0x00000000,
+0x8017081c, 0x0074861d, 0x06e021d0, 0x74941101, 0x40a1d200, 0x02110005,
+0xa1102870, 0x110187c0, 0x10085400, 0x00454001, 0x0445011d, 0x73487312,
+0x00000c20, 0x00000000, 0x0023a010, 0x1234108d, 0x244028d0, 0x34008900,
+0x4208d002, 0x088900a0, 0x08100234, 0x8101a340, 0x10024400, 0x05a04408,
+0x128614ad, 0x43412a10, 0x00000e80, 0x00000000, 0x2025a818, 0x4274009d,
+0x244009d0, 0x74049100, 0x4049d002, 0x00990524, 0x09100274, 0x91002540,
+0x10025400, 0x10654029, 0x02c400bd, 0x63400b11, 0x00000620, 0x00000000,
+0x0027a805, 0x0a7c009d, 0xa45009d0, 0x7c059b01, 0xc009f002, 0x439b4024,
+0xd934167c, 0x93402740, 0x30060c00, 0x0024c009, 0x024c009f, 0x17c00934,
+0x00000e20, 0x00000000, 0x00258014, 0x4e7c809f, 0xe7c109f0, 0x7c809f08,
+0xd019f012, 0x45970063, 0x0df0527c, 0x9f0027c0, 0xfc277c00, 0x0027c059,
+0x267c059f, 0x53c009f0, 0x00000600, 0x00000000, 0x00850814, 0x007c801f,
+0x04c00034, 0x7c021700, 0xc040f020, 0x03130005, 0x0130004c, 0x1f0200c0,
+0x30007c00, 0x2004c081, 0x00cc003f, 0x50d00330, 0x00000420, 0x00000000,
+0x001ca014, 0x45e4005d, 0xd8400710, 0xf4387100, 0x4037d10d, 0x02714114,
+0x05140585, 0x59001c43, 0x10297400, 0x2016c005, 0x0144005d, 0x51400510,
+0x00000200, 0x00000000, 0x01b2a014, 0x0b2400cd, 0xf0403c10, 0x3442c526,
+0x4038d04f, 0x01c90071, 0x0c100d24, 0xdd807040, 0x10003400, 0x0020401d,
+0x036400dd, 0x50400c10, 0x00000a00, 0x00000000, 0x00288005, 0x06f40ced,
+0x384a2410, 0xb480e100, 0x4027d003, 0x11e10020, 0x1e1041b4, 0xe9881840,
+0x1600f400, 0x200a400e, 0x00a4402d, 0x15401010, 0x00000200, 0x00000000,
+0x00781015, 0x07bc85ef, 0x7cd01234, 0xbc01e720, 0xc013f007, 0x01e30079,
+0x1a320724, 0xef0058d0, 0x3044bc15, 0x0068e01f, 0x07ed01ff, 0x54d01e34,
+0x00000040, 0x00000000, 0x0035b810, 0x036c00df, 0x37c001f0, 0x7c00df20,
+0xc005f003, 0x009f0037, 0x2df0034c, 0xdb0017c0, 0xf0187c8e, 0x0007e00d,
+0x005c001f, 0x42c001f0, 0x00000660, 0x00000000, 0x007fb000, 0x068c01f3,
+0x78c213f0, 0xfc49f320, 0xc0dbc004, 0x01f3007c, 0x3f3006cc, 0xf3007cc0,
+0xf024dc81, 0x006cc01e, 0x07fc01f3, 0x00c21ff2, 0x00000e20, 0x00000000,
+0x00a98015, 0x228408e1, 0x1ac28a10, 0x9c88e106, 0x418ad041, 0x00630038,
+0x0e100284, 0xe1021c40, 0xd0308400, 0x0008400e, 0x00b4102b, 0x544083d0,
+0x00000620, 0x00000000, 0x02390000, 0x03d500e1, 0x0c400650, 0xb600e940,
+0x4040d020, 0x00e10238, 0x0e900284, 0xe1001a40, 0xd000b400, 0x002c400a,
+0x63b400e1, 0x00400ed0, 0x00000400, 0x00000000, 0x40332804, 0x410400c1,
+0x90700410, 0x16848900, 0x4000d004, 0x00010030, 0x0c900204, 0xc1421242,
+0xd2002400, 0x00004009, 0x80344409, 0x104000d1, 0x00000c20, 0x00000000,
+0x00a5a815, 0x824480f1, 0x64400c70, 0x3c008b02, 0xd029f00c, 0x80535034,
+0x0db4024d, 0xf30016d0, 0xf0447c00, 0x0024c00d, 0x077c00d3, 0x54d00df0,
+0x00000600, 0x00000000, 0x00070001, 0x027c00df, 0xa7c005f2, 0x7c009700,
+0xc045f040, 0x00572033, 0x0c70027c, 0xdf0415c0, 0xf1085c00, 0x2047d00d,
+0x007c001f, 0x07c001f0, 0x00000c00, 0x00000000, 0x04ff0880, 0x0ffc20d3,
+0x2cc003b0, 0xcc00bb00, 0xc0033003, 0x04d30074, 0x4df0164c, 0xd3005cc0,
+0x7000cc00, 0x002cc00b, 0x03cc00f3, 0x00c00f30, 0x00000c02, 0x00000000,
+0x00d22081, 0x073400d1, 0x64500110, 0x44059d04, 0xc004100b, 0x03811876,
+0x1dd00244, 0xd142d050, 0x10082c00, 0x00084009, 0x00c5003b, 0x04400310,
+0x00000802, 0x00000000, 0x0024a001, 0x027440d1, 0x64400190, 0x54819900,
+0x5009102a, 0x90194234, 0x0dd04344, 0xc1008460, 0x50084400, 0x0024404d,
+0x030400c5, 0x04400c10, 0x00000200, 0x00000000, 0x00202010, 0x033400c1,
+0x20400810, 0x44009d00, 0x40091402, 0x00010030, 0x0cd00304, 0xc1000040,
+0x10022400, 0x0004500c, 0x0004000d, 0x40400014, 0x00000080, 0x00000000,
+0x0036a000, 0x037400d3, 0x04c005b0, 0x5d009b00, 0x40013001, 0x00930034,
+0x0dd0014d, 0xf30004c0, 0x70804c00, 0x1024c009, 0x034c00d7, 0x00d00d30,
+0x00000ac0, 0x00000000, 0xc03ba805, 0x81fe00ff, 0x0fc006f0, 0xfc003f08,
+0xc003f081, 0x003f403f, 0x0ff003fc, 0xff000fc0, 0xf000fc00, 0x000bc00b,
+0x00fc003b, 0x17c003f1, 0x00000e60, 0x00000000, 0x401fa003, 0x008c003b,
+0x2cd00bb0, 0xfc00f300, 0xc00f1103, 0x80f7003c, 0x0f3093fc, 0x33309cc0,
+0x3000cc48, 0x1038d02b, 0x03e4c8f3, 0x0cc40ff2, 0x00000e00, 0x00000000,
+0x08170801, 0x034640d1, 0x2c440911, 0x7402c140, 0x440d1000, 0x00d0103c,
+0x8f512bf0, 0xc1001050, 0x50432c04, 0x40b44024, 0x03440a81, 0x04420fd0,
+0x00000c20, 0x00000000, 0x0013a011, 0x00240009, 0x20420cd2, 0x7402c140,
+0x480c1203, 0x40c12030, 0x0c100330, 0x01011040, 0x10002400, 0x60b540c4,
+0x03040481, 0x44400cd0, 0x00000e80, 0x00000000, 0x0415a803, 0x036420d1,
+0x64500d90, 0x7000d100, 0x40181042, 0x00d12834, 0x0d500374, 0xd1001440,
+0x50036400, 0x44754005, 0x03440081, 0x0c400dd0, 0x00000620, 0x00000000,
+0x009aa802, 0x80e1003b, 0x64c809f0, 0x3800d340, 0xd03d300f, 0x21d72034,
+0x0d30037c, 0x13403484, 0x30006c00, 0x20f5c01d, 0x036d0093, 0x00d00de0,
+0x00000e20, 0x00000000, 0x401d8007, 0x03df00ef, 0x3bc08b70, 0xfc80ff00,
+0xc00ff411, 0x89ff103b, 0x0ef2037c, 0xff003fc4, 0xf003fc00, 0x003ec857,
+0x03fd00ff, 0x1fc00ff0, 0x0000060a, 0x00000000, 0x00950802, 0x006c0013,
+0xa4404d21, 0x4c00d704, 0xc005300b, 0x48d30034, 0x0d72234c, 0x074033c8,
+0x70001c00, 0x2234c015, 0x034d00d3, 0x09c00c10, 0x00000420, 0x00000000,
+0x0114a013, 0x0b4c00d1, 0xf4402d10, 0x4400f104, 0x40a5106b, 0x0ad106bc,
+0x0f102bc4, 0xd1003740, 0x10834420, 0x00704014, 0x03c400db, 0x4c400f10,
+0x00000200, 0x00000000, 0x00728007, 0x48540001, 0x60408d14, 0x1440c540,
+0x480c1007, 0x01c14870, 0x0c500744, 0x05001348, 0x50001400, 0x08724804,
+0x030400c1, 0x1d400c54, 0x00000a00, 0x00000000, 0x00708004, 0x87b401e1,
+0x78409e11, 0xd401e100, 0x431f1007, 0x05e01070, 0x1e102784, 0xe1025b40,
+0x1007860d, 0x00ca4016, 0x278401a9, 0x18401e50, 0x00000200, 0x00000000,
+0x00301012, 0x001c0003, 0xa4c88d30, 0x1c00c740, 0xc00c3603, 0x00d20030,
+0x0c50030d, 0x070013c0, 0x70001c04, 0x4022c064, 0x034c0083, 0x49c00d70,
+0x00000040, 0x00000000, 0x023db802, 0x03cd80ef, 0x3fd08ff0, 0xad00ff02,
+0x000ef023, 0x24ff003f, 0x0ff083fc, 0xfe281f40, 0xf023fc04, 0x001dd007,
+0xc3fc00bf, 0x0bc00fb0, 0x00000648, 0x00000000, 0x0037a015, 0x044c0013,
+0x22c00d30, 0x4c00d304, 0xc20d3003, 0x409323b4, 0x0db0134c, 0x130037e1,
+0x34004c00, 0x0024c005, 0x834c009f, 0x57c12db6, 0x00000e00, 0x00000000,
+0x00318832, 0x03c500c1, 0x38500e12, 0x8401e100, 0x520e1083, 0x00e1253c,
+0x2e135304, 0xe10033c0, 0x10030400, 0x00285006, 0x03c400ed, 0x4b402e10,
+0x00000620, 0x00000000, 0x08790203, 0x04840121, 0x4e401c11, 0xa409e100,
+0x501c9007, 0x01e14178, 0x1e9027a4, 0x29087b40, 0x90048421, 0x00784116,
+0x178401cd, 0x0f405e10, 0x00000402, 0x00000000, 0x00372812, 0x032400c1,
+0xb2500c16, 0x2520c100, 0x409c9007, 0x09c10030, 0x0c100324, 0xc9403540,
+0x90834400, 0x00304414, 0x030500dd, 0x4b480c90, 0x00000c20, 0x00000000,
+0x4015a817, 0x014c0043, 0x5ec00510, 0xec805353, 0xc027b585, 0x00510014,
+0x05b00165, 0x5b009740, 0x98014d00, 0x221cc017, 0x0144415f, 0x5fc005b0,
+0x00000620, 0x00000000, 0x00870012, 0x80dc203f, 0x05c021f0, 0x5c001f00,
+0xc5017020, 0x001f0007, 0x0070005c, 0x270407c0, 0x7a00fc40, 0x0007c021,
+0x007c081f, 0x4bc00170, 0x00000c00, 0x00000000, 0x00270810, 0x024c0093,
+0x24d888f0, 0x4c009340, 0xc0093002, 0x00930024, 0x0930024c, 0x930024c0,
+0x73024c00, 0x0164d009, 0x020c009f, 0x43c00930, 0x00000c20, 0x00000000,
+0x40262001, 0x8a448091, 0x244239d0, 0x44029b00, 0x5809b402, 0x00934024,
+0x0915024d, 0x9b002440, 0x10026c40, 0x10244429, 0x0244009d, 0x07400910,
+0x00000800, 0x00000000, 0x00648018, 0x1ac600b1, 0x205009d2, 0x04308140,
+0x400c1202, 0x00890820, 0x09100204, 0xb1102660, 0x5902c400, 0x20244018,
+0x0244009d, 0x63400914, 0x00000080, 0x00000000, 0x02202010, 0x228400a1,
+0x205888d0, 0x06188902, 0x40881022, 0x08890320, 0xc8182204, 0xa9002460,
+0x180aa408, 0x1220400c, 0x2205108d, 0x43402810, 0x00000080, 0x00000000,
+0x0596b01d, 0x58cd1411, 0x945165d2, 0x0c020305, 0x41611008, 0x020b4184,
+0x3132484c, 0x030706e8, 0x7850cc14, 0x241448e0, 0x084e001f, 0x77c00130,
+0x00000a40, 0x00000000, 0x0127b819, 0x127c009f, 0x2fc84bf8, 0xfd049f41,
+0xc04bf012, 0x04b781a7, 0xc9f0927e, 0x9f0127f0, 0xf0127c24, 0x002fc0cf,
+0x1a7e30bf, 0x67c029f0, 0x00000e60, 0x00000000, 0x016f8018, 0x16cc01b3,
+0x2cc14bb0, 0x6c069302, 0xc0c9f00a, 0x088b8324, 0x29300a7c, 0x9300a4c0,
+0x30226800, 0x003cc00b, 0x0a4c00b3, 0x67c029f0, 0x00000e00, 0x00000000,
+0x0307081c, 0x00448013, 0x14444190, 0x440f1103, 0x40351014, 0x011392c4,
+0xa01104f4, 0x11000440, 0x50004404, 0x01044041, 0x1c440411, 0x734060d0,
+0x00000c22, 0x00000000, 0x0523a010, 0x4b050281, 0x20414810, 0x84008101,
+0x40ca5102, 0x04a10128, 0x48101ab4, 0x81002050, 0x10122410, 0x44a04128,
+0x0a051281, 0x434068d0, 0x00000e80, 0x00000000, 0x00258818, 0x02448099,
+0x24504910, 0xc5009100, 0x404b1042, 0x00b9202c, 0x081082f0, 0x91002442,
+0x50024460, 0x0924520c, 0x02442091, 0x634009d0, 0x00000620, 0x00000000,
+0x0023a805, 0x024c8093, 0x24c019b4, 0x6c009340, 0xc829f002, 0x21914024,
+0x0934027c, 0x934024c8, 0x30026c00, 0x2024c089, 0x024d0193, 0x17c009f0,
+0x00000e20, 0x00000000, 0x44258014, 0x027c0087, 0x23c009f6, 0x7c008f40,
+0xd008f002, 0x05970027, 0x09f0023c, 0x9f0027c0, 0xf4023c00, 0x0463c019,
+0x027c049f, 0x53c009f0, 0x00000600, 0x00000000, 0x08050814, 0x040c001e,
+0x05d1813a, 0xfc001300, 0xd023f008, 0x0033000c, 0x013000cc, 0x170000c0,
+0x30004c00, 0x2004cd01, 0x004d0013, 0x50c00130, 0x00000420, 0x00000000,
+0x049c8014, 0x01ec005d, 0xdc402738, 0x5c005b04, 0x4005d001, 0x00530814,
+0x05100144, 0x51001440, 0xb0016c00, 0x005c4137, 0x01440051, 0x50400510,
+0x00000200, 0x00000000, 0x00f28014, 0x8004c8cd, 0x3140319a, 0x7600c141,
+0x400cd003, 0x00c14034, 0x0c1c8314, 0xd5003060, 0x10030500, 0x4270403c,
+0x030409d1, 0x50400c94, 0x00000a00, 0x00000000, 0x00388005, 0x022600ed,
+0x38440810, 0x9600e900, 0x4002d000, 0x01390000, 0x4e180094, 0xe1003840,
+0x90132404, 0x0030400c, 0x078400c1, 0x14405e90, 0x00000200, 0x00000000,
+0x00581015, 0x078c81ef, 0x71d01a94, 0xbc016300, 0x401ff007, 0x01e12078,
+0x5e30071d, 0xc70bfcd1, 0x30478c05, 0x0078c812, 0x07cc01e3, 0x54d05eb0,
+0x00000040, 0x00000000, 0x2015b810, 0x037c40cf, 0x37c00bf0, 0x7c005f00,
+0xd001f000, 0x00170007, 0xedf0006c, 0xdf01b740, 0xf0337c02, 0x0037d001,
+0x037c10df, 0x43c8ad70, 0x00000660, 0x00000000, 0x004fa000, 0x26fc09b3,
+0x7cc01bb0, 0xcc01fb00, 0xc01f3007, 0x01fb007c, 0x1f3007fc, 0xf3007cd0,
+0x3007cc13, 0x087cc01b, 0x07cd01b3, 0x08c03ff0, 0x00000e00, 0x00000000,
+0x020d8815, 0x32b40ca1, 0x28402a12, 0xc400e102, 0x40821400, 0x4020400c,
+0x0f1000b4, 0xf1003c40, 0x50438400, 0x0038400e, 0x039400a1, 0x54400ed0,
+0x00000620, 0x00000000, 0x00090000, 0x829400a5, 0x30400a90, 0x84006940,
+0x400e1003, 0x10e10038, 0x0e9003b4, 0xe1423a40, 0x90230400, 0x0438508a,
+0x038401a1, 0x00400ed0, 0x00000400, 0x00000000, 0x08072804, 0x06340a81,
+0xa4500812, 0x05204102, 0x40001004, 0x00110000, 0x0c900074, 0xc1003240,
+0xd213040b, 0x00f44018, 0x03550891, 0x18400cd0, 0x00000c20, 0x00000000,
+0x4035a815, 0x4e7c0097, 0xf4c00db0, 0x4c20db40, 0x500d3047, 0x01d30034,
+0x0fb40374, 0xf3003ec0, 0xb00fcd02, 0x40749055, 0x03cc0093, 0x54d00ff0,
+0x00000620, 0x00000000, 0x00370001, 0x127c108f, 0x37c02df0, 0x7c00df00,
+0xc081f010, 0x001f0007, 0x0d72807c, 0xdf0031c0, 0x70037c04, 0x01b7c265,
+0x037c009f, 0xa7c00df1, 0x00000c00, 0x00000000, 0x011f0880, 0x038c05b3,
+0x1c800930, 0xcc004346, 0xd00c3003, 0x00f3803c, 0x0f3003cc, 0xe3003cc0,
+0x32038c00, 0x0034c008, 0x03cc08b3, 0x07c00d30, 0x00000c20, 0x00000000,
+0x10462081, 0x03440091, 0xf4403810, 0xc4007100, 0x40031000, 0x0031000c,
+0x0d1500c5, 0xdb003440, 0xb2036c00, 0x00f44029, 0x83ec0091, 0x07400d14,
+0x00000802, 0x00000000, 0x4004a001, 0x02440091, 0xb7401d10, 0x0400d100,
+0x420d1203, 0x00d10030, 0x0c100344, 0xd1003444, 0x10034400, 0x04765009,
+0x034400d1, 0x07400d10, 0x00000200, 0x00000000, 0x00002010, 0x06050081,
+0x33500810, 0x0400c110, 0x40000200, 0x00012000, 0x0c180006, 0xc9003040,
+0x98032500, 0x4012400c, 0x032500c1, 0x43400c10, 0x00000080, 0x00000000,
+0x0006b000, 0x024c2093, 0x37c00934, 0x4c005340, 0x480d1403, 0x40d14034,
+0x0f30030e, 0xf3403c48, 0x3003cc00, 0x1036d009, 0x034d00e3, 0x07c00f30,
+0x00000ac0, 0x00000000, 0x000fb805, 0x02bc00bf, 0x3cc00bf0, 0xfce07f00,
+0xe203f200, 0x003f000f, 0x0ff000fc, 0xff003fc0, 0xd003fc80, 0x002dc00b,
+0x03fc00ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x000f8003, 0x0bcc20b3,
+0x3cc40fb4, 0xec00f300, 0xc00f7081, 0x04b3412d, 0x0331538c, 0x37100fc0,
+0x30218c00, 0x010fc14e, 0x00fc00a3, 0x0cc00bf0, 0x00000e00, 0x00000000,
+0x00071801, 0x2b441019, 0xb4496d30, 0x4402d020, 0x440d1203, 0x0a9b00a4,
+0x09500bc4, 0x91251740, 0x100b6430, 0x0007402d, 0x00740091, 0x06c009d0,
+0x00000c20, 0x00000000, 0x0013a011, 0x13240409, 0xb2488c10, 0x2442c100,
+0x440cd001, 0x01810221, 0x08910374, 0x41016346, 0x54226420, 0x0203400c,
+0x02340981, 0x444008d0, 0x00000e80, 0x00000000, 0x0115a007, 0x01640019,
+0x36400914, 0x54005104, 0x401d9007, 0x01590225, 0x29d00374, 0xd1407740,
+0x50076480, 0x0087400d, 0x037401d1, 0x0c4009d0, 0x00000620, 0x00000000,
+0x01538882, 0x476c0193, 0xb6d03d32, 0x2c01d340, 0xc02cf01d, 0x01934025,
+0x25b0037c, 0xd72037c0, 0x70070d02, 0x80c7800d, 0x247c2193, 0x084009f0,
+0x00000e20, 0x00000000, 0x245d8007, 0x0f5c0237, 0x59c09ff1, 0x4c09ff01,
+0xc00f7003, 0x000f006e, 0x8f7003cc, 0xef003fc4, 0xb003dd04, 0x214b880f,
+0x00fc00bf, 0x1fd00bf0, 0x00000600, 0x00000000, 0x00950802, 0x033c881f,
+0xb4d024b2, 0x4c018b00, 0xc01d3029, 0x059f8024, 0x2db0034c, 0xd32437c0,
+0x34034d00, 0x0284c10d, 0x034c081f, 0x08c009f0, 0x00000420, 0x00000000,
+0x0834a013, 0x0174421d, 0x56d11110, 0x68009104, 0x40ad1003, 0x02dd0024,
+0x2d502bc0, 0xd1403740, 0xb43f4402, 0x0056c04f, 0x174480dd, 0x4ec00dd0,
+0x00000200, 0x00000000, 0x80122003, 0x0334139d, 0x70401c18, 0x0400c920,
+0x04041000, 0x42cd24a4, 0x2c500750, 0xc10a3745, 0x80852410, 0x8001423c,
+0x8024908d, 0x1c4009d0, 0x00000a00, 0x00000000, 0x085a0804, 0x06b4016d,
+0x6a42dc18, 0xa42bc100, 0x40971024, 0x01ad0268, 0x16506794, 0x410a7b62,
+0x9437e009, 0x006b401e, 0x04a441ad, 0x12401ad0, 0x00000200, 0x00000000,
+0x00121012, 0x033c000f, 0x34d06c34, 0x0c08cb00, 0xc08c3020, 0x00cd1230,
+0x8cf00315, 0xc3023780, 0xb0332502, 0x0011c04c, 0x932c208f, 0x48c009f0,
+0x00000040, 0x00000000, 0x001da802, 0x02fc007f, 0x2fc04f72, 0x7c887f02,
+0xc08ef822, 0x00ff223f, 0x0ff04b6c, 0x7f023fc0, 0xf033dc20, 0x003ec10f,
+0x03dc00ff, 0x0bc08bf0, 0x00000660, 0x00000000, 0x0013a014, 0x037c8493,
+0x34c01df1, 0x0c04d300, 0xc00d7101, 0x00d30024, 0x0934030d, 0x934007c0,
+0x33034c12, 0x2024c81c, 0x484c009f, 0x54c019f2, 0x00000e00, 0x00000000,
+0x00399912, 0x839c4863, 0x30c20ef1, 0x9410e520, 0xc40a1403, 0x0021102e,
+0x02309384, 0xa1001b40, 0x12038500, 0x0028404e, 0x00ad00ad, 0x49400b70,
+0x00000620, 0x00000000, 0x40d90000, 0x07b40125, 0x79441cd0, 0xc621c100,
+0x601f5105, 0x01c50078, 0x1a1017c4, 0xe1006340, 0x1007c403, 0x0078401e,
+0x078403cd, 0x0c401ad0, 0x00000400, 0x00000000, 0x00332016, 0xa7140105,
+0xb0404c51, 0x1686c502, 0x78081013, 0x04c50032, 0x88100304, 0xd1003340,
+0x123b0422, 0x1230400c, 0x030400cd, 0x49400c50, 0x00000c20, 0x00000000,
+0x009ba817, 0x017c0057, 0x55d025d0, 0xcd075340, 0xd0267009, 0x00776014,
+0x0530018c, 0x532017c2, 0x348dcc01, 0x009cd005, 0x8144036f, 0x5cd055f0,
+0x00000620, 0x00000000, 0x00c58012, 0x001c0813, 0x05c001f1, 0x7c000f21,
+0xc011f100, 0x001b0007, 0x0170007c, 0x1f00c380, 0xf4007c10, 0x0047c001,
+0x007c101f, 0x4bc00170, 0x00000c00, 0x00000000, 0x40650810, 0x024d00d3,
+0x63c00930, 0x4c089300, 0xc0093602, 0x08830060, 0x09300244, 0x930024c0,
+0x30024c09, 0x00a7c089, 0x034c009f, 0x43c00932, 0x00000c20, 0x00000000,
+0x01262001, 0x02440081, 0x67400914, 0x04019108, 0x40291002, 0x40910ae4,
+0x08500244, 0x9100e440, 0x140a4512, 0x00e74209, 0x0a040e9d, 0x07400910,
+0x00000800, 0x00000000, 0x0124a01c, 0x02440091, 0x2f480b10, 0x4400b102,
+0x581d1002, 0x009100a4, 0x29100654, 0xb1012c50, 0x10020400, 0x0c274809,
+0x0a45809d, 0x63400910, 0x00000200, 0x00000000, 0x20202814, 0x52840080,
+0x2b414a10, 0x0415a145, 0x40191053, 0x15814520, 0x89502615, 0xa1422840,
+0x10220408, 0x00234018, 0x0204008d, 0x43408814, 0x00000080, 0x00000000,
+0x0006b01d, 0x104c0012, 0x07c04130, 0x4d043301, 0xc0013010, 0x04130104,
+0x6130585c, 0x230594c5, 0x34594c16, 0x0507c541, 0x004c141f, 0x77c02130,
+0x00000ac0, 0x00000000, 0x002fa919, 0x5374149d, 0x27c149d0, 0xfc409f05,
+0xc00ef003, 0x00bf052f, 0x4bf0126c, 0x9f0127c8, 0xf012bd84, 0x002fc009,
+0x027c80bd, 0x67c06bf2, 0x00000e60, 0x00000000, 0x002f8018, 0x8a4c22a3,
+0x2dc06b70, 0xcc04b303, 0xc00f3013, 0x00b700ac, 0x29300acc, 0x930137c0,
+0x50124c84, 0x012cc04a, 0x03fc04bf, 0x60c669f0, 0x00000e00, 0x00000000,
+0x1007181c, 0x18460411, 0x044021b1, 0x54221121, 0xc0013108, 0x02114186,
+0x25100c6c, 0x014d8340, 0xb100c400, 0x00044001, 0x0074001d, 0x704041d0,
+0x00000c20, 0x00000000, 0x00250012, 0x1a240499, 0xa340c8d0, 0x24028100,
+0x40099022, 0x028108a0, 0x68140a44, 0xa1022b40, 0x515aa416, 0x08a24228,
+0x0634228d, 0x404028d0, 0x00000e80, 0x00000000, 0x00e50018, 0x02640499,
+0x26482951, 0x74029100, 0x50091402, 0x03910026, 0x09100064, 0xa100b740,
+0x1613e500, 0x00665c09, 0x067000dd, 0x604019d2, 0x00000620, 0x00000000,
+0x00e78805, 0x0a65129b, 0x274839d0, 0x6c429340, 0xc829a10a, 0x01974024,
+0x2930004c, 0x930027c0, 0x50126c01, 0x0066c009, 0x0e78069f, 0x14c009f0,
+0x00000e20, 0x00000000, 0x40258012, 0x025c2097, 0x21c059a0, 0x1c189f00,
+0xc2097002, 0x008f0127, 0x0df0007c, 0x9f0827c0, 0xf0021c04, 0x0025c008,
+0x027c499f, 0x53d009f0, 0x00000600, 0x00000000, 0x02450810, 0x084c021f,
+0x04d021b2, 0x4c020310, 0xc2113000, 0x00130004, 0x2130107c, 0x130004d0,
+0x31284c80, 0x0204c801, 0x204c0b13, 0x50d001f0, 0x00000420, 0x00000000,
+0x0898a014, 0x0144056d, 0x16d01550, 0xec907b00, 0x40261045, 0x0a71011c,
+0x855404b4, 0x51601440, 0x10854523, 0x005c4087, 0x05c40371, 0x505005d0,
+0x00000200, 0x00000000, 0x0072a014, 0x0346514d, 0x32421d98, 0x3401c100,
+0x400c5005, 0x0ac12134, 0x0c100734, 0xc1003540, 0x10032491, 0x00304228,
+0x971500c1, 0x50400dd0, 0x00000a00, 0x00000000, 0x80388801, 0x138600ad,
+0x2a41085c, 0x3600e910, 0x50075001, 0x00e10010, 0x1e5053b4, 0x61403940,
+0x1101a402, 0x107c4006, 0x029401c1, 0x14404ed0, 0x00000200, 0x00000000,
+0x00781011, 0x0fcd016e, 0x72d01eb2, 0xbc014300, 0xc8167005, 0x01a34068,
+0x1c30373c, 0xe30049c0, 0x2407ec01, 0x0878d016, 0x079c01a3, 0x54c03ff0,
+0x00000040, 0x00000000, 0x0035a810, 0x077c009f, 0x37c009d0, 0x6c00df20,
+0xc004b401, 0x009f2007, 0x2df0037c, 0xdf0036c0, 0xf0135c00, 0x4023c005,
+0x026c005f, 0x43c00df0, 0x00000660, 0x00000000, 0x005d2000, 0x07fc01bf,
+0x7cc01b30, 0x8c21e300, 0xc0167005, 0x0973004c, 0x3f30478c, 0xf3007cc0,
+0x302fbc01, 0x007bc013, 0x07fc01f3, 0x00c01ff0, 0x00000e00, 0x00000000,
+0x02391815, 0x03b400ed, 0x28c00b10, 0x8406e502, 0x08061000, 0x00230008,
+0x2e100394, 0xe1023840, 0x1131a400, 0x02bb4006, 0x4bb418e1, 0x54408ed0,
+0x00000620, 0x00000000, 0x00b90000, 0x233400ad, 0x38400a54, 0xc440e100,
+0x41075001, 0x10290008, 0x8c1003c4, 0xe1000840, 0x58c3f400, 0x003f4006,
+0x03b400e9, 0x00400ed0, 0x00000400, 0x00000000, 0x20312004, 0x2f3407dd,
+0xb0400850, 0x0410c500, 0x40141118, 0x03410000, 0x0c100314, 0xd1003042,
+0x500f6402, 0x46334004, 0x07340149, 0x10400dd0, 0x00000c20, 0x00000000,
+0x00b5a815, 0x0ffc03df, 0xf4d01d74, 0x0c02d300, 0xc01c700a, 0x08db4034,
+0x2d34034c, 0x935174d0, 0x70867c02, 0x00b7c009, 0x033c005b, 0x54d05ff0,
+0x00000620, 0x00000000, 0x00370001, 0x437c0adf, 0x27c08ca0, 0x7c02df06,
+0xd005f20a, 0x00df0017, 0x6df0037c, 0x1f00b3c0, 0xb00b7c00, 0x0037c005,
+0x027c0257, 0x07c40df0, 0x00000c00, 0x00000000, 0x003f0884, 0x038c00ff,
+0x20c05f30, 0xcc05b302, 0xc81f3004, 0x01d34014, 0x0f302788, 0xf30034c0,
+0x3042cc10, 0x001cc006, 0x07fc1033, 0x00c00d30, 0x00000c22, 0x00000000,
+0x01360085, 0x034507dd, 0x26c00d10, 0x4400cb08, 0x4071b040, 0x0b410250,
+0x2d508f54, 0xd102b6c0, 0x122f4409, 0x00804e05, 0x0a740251, 0x06c00d12,
+0x00000802, 0x00000000, 0x82348001, 0x034601dd, 0x34480914, 0x4400d100,
+0x404d1113, 0x42510404, 0x0c100b54, 0xd1003440, 0x11034400, 0xe0344001,
+0x217420d1, 0x04400d10, 0x00000200, 0x00000000, 0x00302810, 0x030620cd,
+0x22400c12, 0x0400c908, 0x40049002, 0x80410000, 0x0c500314, 0xc1403242,
+0x10030400, 0x00304004, 0x007420c1, 0x42400c10, 0x00000080, 0x00000000,
+0x0026b000, 0x034c00dd, 0x24c00930, 0x4400d300, 0xc00d3001, 0x00530004,
+0x0d30035c, 0xd30034c0, 0x34034500, 0x0014c405, 0x037c00d3, 0x00d00d34,
+0x00000ac0, 0x00000000, 0x002fa805, 0x03f000ff, 0x2fc00ff4, 0xfc00ff00,
+0xd003e100, 0x007f000f, 0x07d003fc, 0xff003fc0, 0xf003fd00, 0x001fd007,
+0x02fc007f, 0x17c00ff0, 0x00000e60, 0x00000000, 0x492fa003, 0x02cd0033,
+0x3cc00730, 0xcc203301, 0xc00ff000, 0x003f023c, 0x07f001fc, 0x3f000cc0,
+0xf020ec00, 0x000ec083, 0x0bcc02f3, 0x0fc04730, 0x00000e08, 0x00000000,
+0x02270801, 0x02840a91, 0xb4480512, 0x44281500, 0x400fd000, 0x001140b0,
+0x05d20174, 0xdd203549, 0xd0034480, 0x1034444d, 0x03d400f5, 0x07402550,
+0x00000c20, 0x00000000, 0x0023a011, 0x022494c1, 0xb0400011, 0x24000100,
+0x4008c100, 0x80cd01b0, 0x44d08134, 0x0d000000, 0xd0102400, 0x00024000,
+0x932484c1, 0x47408410, 0x00000e80, 0x00000000, 0x0025a803, 0x226440d1,
+0x34400114, 0x44041500, 0x5249d010, 0x40516434, 0x05d00174, 0xd9003502,
+0xd0034400, 0x0034600d, 0x037400d5, 0x1f408550, 0x00000620, 0x00000000,
+0x0067a802, 0x036c0053, 0x34d12534, 0x6d009300, 0xc80cf001, 0x121f40b4,
+0x27f0017c, 0x3f000c40, 0xd000ec00, 0x200ec003, 0x036c00d3, 0x0bc01538,
+0x00000e20, 0x00000000, 0x00a58007, 0x039c80ef, 0x37c00ef0, 0xfc813f20,
+0xc01df005, 0x053f013f, 0x07f021fc, 0xef003fc8, 0xf203fc00, 0x8037c80e,
+0x035c00ff, 0x0fc017f0, 0x00000600, 0x00000000, 0x00350802, 0x027c00d3,
+0x35800132, 0x4c009309, 0xd009b200, 0x025742b4, 0x35b0a14c, 0x130004d0,
+0x70005404, 0x4007c001, 0x034c00d3, 0x08d00534, 0x00000420, 0x00000000,
+0x4034a013, 0x1b7400d1, 0x78451d10, 0x45018104, 0x4029d80d, 0x2b5142f4,
+0x05110144, 0xdb003440, 0x10834483, 0x0073400d, 0x03cd00f1, 0x4c400110,
+0x00000200, 0x00000000, 0x0036a007, 0x1e340001, 0xf1432410, 0x14090108,
+0x4138d21c, 0x00454014, 0x0d900305, 0x01000140, 0x5800140a, 0x20034000,
+0x036480d1, 0x1c400410, 0x00000a00, 0x00000000, 0x02788004, 0x26b401a1,
+0x78405614, 0x84090160, 0x411ad044, 0x11712058, 0x9c1005c4, 0xc9007840,
+0x1007040d, 0x047b401e, 0x078429e1, 0x90401610, 0x00000200, 0x00000000,
+0x00301012, 0x023c08c3, 0x31c00030, 0x1c000308, 0xc80cd228, 0x08474020,
+0x2cb0010c, 0x03100540, 0x70101c04, 0x1003c800, 0x032c00d3, 0x48c00531,
+0x00000040, 0x00000000, 0x003db802, 0x02f400ff, 0x3fc24af0, 0xfc003f10,
+0xc08ff000, 0x006d403f, 0x0ff000b4, 0xff003ec4, 0xd003f804, 0x003f400f,
+0x03fc10ff, 0x0bc003f2, 0x00000660, 0x00000000, 0x0037a015, 0x127c0057,
+0x34ca04b0, 0x4c00d300, 0xc069f018, 0x80530034, 0x0df0817c, 0x134846c0,
+0x30004401, 0x4046c001, 0x374c14d3, 0x47c00fb2, 0x00000e00, 0x00000000,
+0x003d8812, 0x433400e1, 0x78440e14, 0x84006501, 0x0508d021, 0x80610038,
+0x0fd001b4, 0xf1003940, 0x10039400, 0x0030420f, 0x239400f1, 0x4b400e10,
+0x00000620, 0x00000000, 0x00790003, 0x0eb401e5, 0x78401390, 0x8601f102,
+0x081ed005, 0x01690062, 0x1ed005b4, 0x21804040, 0x11842401, 0x004a4012,
+0x178405e9, 0x0f421e90, 0x00000400, 0x00000000, 0x00372812, 0x833000d1,
+0x30448c10, 0x0400c500, 0x400cd007, 0x02490136, 0x0cd00834, 0xc1003060,
+0x18037640, 0x0030400c, 0x031600c9, 0x4b400c90, 0x00000c20, 0x00000000,
+0x0055a817, 0x017c1175, 0x145027b0, 0x4c407300, 0xd005f01d, 0x007b401e,
+0x05f029fc, 0x532014c2, 0x35816c00, 0x0016c005, 0x014c005b, 0x5fc077b0,
+0x00000620, 0x00000000, 0x02070012, 0x087c001f, 0x07c101f6, 0x7d011f20,
+0xc001f240, 0x00175805, 0x00f0007c, 0x3f000dd0, 0xf000dd40, 0x200fc802,
+0x007c0007, 0x4be01170, 0x00000c00, 0x00000000, 0x00270830, 0x024c0197,
+0x20800834, 0x4f009300, 0xe008f017, 0x12930024, 0x0930024c, 0x9f0024c0,
+0x70027c40, 0x0026c009, 0x024c009f, 0x41c008f0, 0x00000c20, 0x00000000,
+0x00262001, 0x0a440291, 0x24400912, 0x44028100, 0x4009d006, 0x02814224,
+0x09340604, 0x9d0024c0, 0x30025c02, 0x00244009, 0x0244009d, 0x044009d0,
+0x00000800, 0x00000000, 0x00242018, 0x0a040a95, 0x25400910, 0x44819100,
+0x4829d042, 0x00910024, 0x19100745, 0xbd002c50, 0x5202d410, 0x002c400b,
+0x0245009d, 0x61400dd0, 0x00000200, 0x00000000, 0x02202010, 0x22040881,
+0x21500810, 0x04008108, 0x4048d002, 0x0081c230, 0x88110204, 0xad202860,
+0x10229408, 0x0028502a, 0x9204048d, 0x404008d8, 0x00000080, 0x00000000,
+0x0586901d, 0x584d5617, 0x05c14130, 0x44105101, 0x5051f000, 0x94514504,
+0x6131004c, 0x1f3504c1, 0x70505c56, 0x050cc141, 0x2c0c0b1f, 0x75c1e1f0,
+0x00000ac0, 0x00000000, 0x812fb819, 0x12f404bf, 0x22c00bf2, 0x7c00af42,
+0xc08bf042, 0x00be012f, 0x49f002fc, 0x9f0425c0, 0x70125c04, 0x0027c249,
+0x267c099f, 0x67c40bf0, 0x00000e60, 0x00000000, 0x01a7a018, 0x1acc02b7,
+0x26c10830, 0x7c10f301, 0xc04bf002, 0x00b7042c, 0x5bf002cc, 0xb304e4c1,
+0x30264c19, 0x016c0419, 0x42441493, 0x63c04930, 0x00000e00, 0x00000000,
+0x0187081c, 0x18440611, 0x0c400118, 0x74021100, 0x4021d050, 0x00110584,
+0x01d10044, 0x11018440, 0x10004402, 0x080442c1, 0x08440611, 0x73414110,
+0x00000c20, 0x00000000, 0x00a3a010, 0x0b240285, 0xaa400b10, 0x34008100,
+0x4088d002, 0x0185c060, 0x48d00604, 0x81092049, 0x141a0404, 0x42204108,
+0x52051081, 0x43402814, 0x00000e80, 0x00000000, 0x0125a818, 0x86640091,
+0x2c484910, 0x74009148, 0x408dd00a, 0x60912064, 0x09d00345, 0x91402400,
+0x10824400, 0x08244209, 0x0264a081, 0x63401910, 0x00000620, 0x00000000,
+0x00678805, 0x026c0797, 0x26806914, 0x74109300, 0xd019f006, 0x02974024,
+0x09f10a44, 0x930024d0, 0x30024c00, 0x2024c009, 0x024c2093, 0x17c00930,
+0x00000e20, 0x00000000, 0x00658014, 0x025d049f, 0x22c009f6, 0x7c009f00,
+0xc118f00b, 0x098f0023, 0x09f00a7c, 0x8f0023c0, 0xf1023d00, 0x1023d008,
+0x025c009f, 0x53c009f0, 0x00000600, 0x00000000, 0x00050814, 0x047c0407,
+0x0c400330, 0x7c2a1310, 0xd0013000, 0x00132004, 0x01f0a47c, 0x112004c2,
+0xf0006d00, 0x1007c001, 0x004c001f, 0x53c00130, 0x00000420, 0x00000000,
+0x0014a014, 0x01f40371, 0x16c00410, 0x74097100, 0x4507102d, 0x0971001c,
+0x05d109dc, 0x71001452, 0xd0016d11, 0x00574005, 0x0144005d, 0x53400510,
+0x00000200, 0x00000000, 0x8036a014, 0x037400c5, 0x31400c10, 0x3442c120,
+0x400c1824, 0x41c904a0, 0x0dd80334, 0xc1403140, 0xd0032406, 0x0073600c,
+0x034400cd, 0x53400c10, 0x00000a00, 0x00000000, 0x02388005, 0x03b482e1,
+0x03480214, 0xf480a100, 0x400a1006, 0x1029401c, 0x0ad00394, 0xe9103940,
+0xd003a440, 0x043b40ce, 0x13044ced, 0x17408e10, 0x00000200, 0x00000000,
+0x007c1015, 0x073c81e7, 0x79421e30, 0xbc016308, 0x40143407, 0x012b1858,
+0x1bf006bc, 0xf301f1c4, 0xf007ac01, 0x007bc05e, 0x178d05cf, 0x57c05e34,
+0x00000040, 0x00000000, 0x0035b810, 0x037c00dd, 0x06c201f0, 0x3c405f40,
+0xd001f003, 0x00170033, 0x0df1037c, 0xd70036d0, 0xf1277d00, 0x0037c00d,
+0x2b7c16df, 0x43c00df0, 0x00000660, 0x00000000, 0x007fa000, 0x07cd01f3,
+0x7cc2df32, 0xfc013300, 0xc012f00e, 0x01330869, 0x1ff005fc, 0xfd107cc0,
+0x1007e809, 0x007f849f, 0x0fcc01f3, 0x02c01f20, 0x00000e00, 0x00000000,
+0xa03d8815, 0x03c40aeb, 0x08418214, 0xb4002100, 0x4002d013, 0x02212038,
+0x4bd001a0, 0xfd013848, 0x1003c41c, 0x002a418e, 0x038400e1, 0x44400e10,
+0x00000620, 0x00000000, 0x40390000, 0x23840021, 0x38044e10, 0xb4002102,
+0x4002d843, 0x0029023c, 0x0ad061b4, 0xe9303a60, 0x90038400, 0x0033408e,
+0x032500e1, 0x02400e10, 0x00000400, 0x00000000, 0x00332804, 0x05000401,
+0x01403010, 0x34020100, 0x4000d003, 0x00094030, 0x0dd00134, 0xcd00b242,
+0x942b0402, 0x0322402c, 0x032400c1, 0x10400c10, 0x00000c20, 0x00000000,
+0x003da815, 0x474802d1, 0x34900d30, 0x7c02d300, 0xd00cf006, 0x0a1b0034,
+0x0de00c3c, 0xdb21fec2, 0xb003cc4b, 0x40b7c0bf, 0x03e400f1, 0x56c00e34,
+0x00000620, 0x00000000, 0x00370001, 0x837c20df, 0x06c801f0, 0x7c429f40,
+0xc029f002, 0x42170227, 0x09f0106c, 0xcf0131c0, 0x70431d02, 0x0036c00c,
+0x035d00df, 0x07c01df0, 0x00000c00, 0x00000000, 0x003f0880, 0x07bc40ff,
+0x34c10c30, 0xfe30ff20, 0xc0073057, 0x44338038, 0x0b1084fc, 0xfb003ce2,
+0xb003cc00, 0x017c800f, 0x03cc00df, 0x00d00df0, 0x00000c22, 0x00000000,
+0x00362081, 0x077422dd, 0x04400114, 0x7402dd08, 0x4001104f, 0x031b0634,
+0x0d100874, 0xd10036c0, 0x30034441, 0x0034420d, 0x036c80d7, 0x04400dd0,
+0x00000802, 0x00000000, 0x0034a001, 0x2374211d, 0x34400d14, 0x34021d00,
+0x40011003, 0x00111034, 0x0d501274, 0xd9103450, 0x50034403, 0x0035400d,
+0x034400cd, 0x04400dd0, 0x00000200, 0x00000000, 0x00302010, 0x0234000d,
+0x00400010, 0x36000d00, 0x40001402, 0x80012000, 0x08560234, 0x01003040,
+0x1c030600, 0x0031640c, 0x032600cd, 0x40400dd0, 0x00000080, 0x00000000,
+0x1036b000, 0x037c000f, 0x34c00d14, 0x74801f00, 0xd0013003, 0x00110014,
+0x0954027c, 0xdb003440, 0x30034d00, 0x0035d00d, 0x03cc00ff, 0x00c00df0,
+0x00000ac0, 0x00000000, 0x203fb205, 0x00fc003c, 0x0fc403f1, 0xfc003f00,
+0xc20bf003, 0x003f203f, 0x0fb102fc, 0xbf003fd0, 0x7003fc00, 0x003ec00f,
+0x03fc00f7, 0x17c00ff0, 0x00000e60, 0x00000000, 0x000ba003, 0x03cc82e3,
+0x3fc00f34, 0x8c04f308, 0xc0033000, 0x34b320bf, 0x4f3203cc, 0x33003fc0,
+0x3073ec04, 0x030cc023, 0x73cc083f, 0x0fc28f30, 0x00000e00, 0x00000000,
+0x20070801, 0x0b442051, 0x97400d10, 0x452ad11a, 0x420d1103, 0x029b003f,
+0x4d143b44, 0x11203349, 0x100bf428, 0x03a54c01, 0x1b54449d, 0x07484d14,
+0x00000c20, 0x00000000, 0x4203a011, 0x23148491, 0x33480c58, 0x0400c100,
+0x40001000, 0x808d0133, 0xcc104351, 0x01403340, 0x10132400, 0x00214049,
+0x0304004d, 0x47400c55, 0x00000e80, 0x00000000, 0x1045a803, 0x03560611,
+0x37423d5c, 0x5600d100, 0x400d5003, 0x03dc0037, 0x0d100344, 0x51003344,
+0x10037424, 0x10254029, 0x0354081d, 0x0f400d50, 0x00000620, 0x00000000,
+0x0047a802, 0x071d0113, 0x27c62d70, 0x4d005300, 0xc4013000, 0x019f0037,
+0x0d30035c, 0x130037c0, 0x32036c05, 0x2025d020, 0x014c201f, 0x0bc00d74,
+0x00000e20, 0x00000000, 0x082d8007, 0x936c01bf, 0x17880fb2, 0xec894f08,
+0xc30fb003, 0x008a203f, 0x0ff083fc, 0x3f083fc0, 0xf003fc00, 0x212fcb33,
+0x0bfe01bf, 0x1fc00fb2, 0x00000600, 0x00000000, 0x00050802, 0x234d0013,
+0x28c05d30, 0x4c00f302, 0xc01131a0, 0x069b0037, 0x0d30035c, 0xd34036c0,
+0x32034c02, 0x0024d02d, 0x034d0153, 0x0bc00d30, 0x00000420, 0x00000000,
+0x20308013, 0xaf400081, 0xb4002d24, 0x050ad102, 0x403d1007, 0x0250403f,
+0x0f340390, 0xd1003c42, 0x1003c5a0, 0x0064001d, 0x03542391, 0x4f400d00,
+0x00000200, 0x00000000, 0x0022a007, 0x0e240001, 0x70422c10, 0x22088100,
+0x48200080, 0x00c50037, 0x0c900304, 0x01003200, 0x10034448, 0x03804004,
+0x13448415, 0x1f400c00, 0x00000a00, 0x00000000, 0x60488004, 0x27a441b1,
+0x58401614, 0xa485e100, 0x601e120f, 0x0165427b, 0x9e108794, 0x40407840,
+0x10070405, 0x02604016, 0x261481a5, 0x13001e10, 0x00000200, 0x00000000,
+0x02a01012, 0x022c20c3, 0x30c00c30, 0x2c008100, 0xc0003020, 0x208f4037,
+0x0db0234c, 0x830032c0, 0x32030c00, 0x0220d14d, 0x230c8257, 0x4bc04c34,
+0x00000040, 0x00000000, 0x200db802, 0x03dc00ff, 0x3fc80af0, 0xdc04ff40,
+0xc80fd083, 0x407b00bf, 0x0ff003fc, 0xbf203fc1, 0xd003fc84, 0x223fc00f,
+0xa3fc80bb, 0x0bc00ff4, 0x00000660, 0x00000000, 0x0027a015, 0x025c01df,
+0x2dc20d70, 0x4c201340, 0xd011f000, 0x21d30af5, 0x1df0034c, 0x530037c0,
+0xf3134c01, 0x0024c80c, 0x014c0013, 0x57c20d30, 0x00000e00, 0x00000000,
+0x00298812, 0x038400fd, 0x18600e14, 0x86004108, 0x400e9103, 0x00e1003c,
+0x0ed00384, 0x4101bc40, 0xd0c38400, 0x102c400e, 0x02c480b1, 0x4b400e50,
+0x00000620, 0x00000000, 0x00790003, 0x0694816d, 0x61401f51, 0x8401a120,
+0x4012d004, 0x8181813a, 0x5cd83784, 0xa1007940, 0xd8278451, 0x006b401f,
+0x07848321, 0x0f401e58, 0x00000400, 0x00000000, 0x88332812, 0x030682cd,
+0x30400850, 0x0424c100, 0x420c9003, 0x10c18032, 0x0cd10305, 0x81403040,
+0xd0030423, 0x0037413c, 0x13450191, 0x4b400c50, 0x00000c20, 0x00000000,
+0x015da817, 0x015c047f, 0x1dc02670, 0x4dc07301, 0xc005f081, 0x02730017,
+0x05f001cc, 0x730015c0, 0xf0014d00, 0x001fd106, 0x01cc0273, 0x5fc00570,
+0x00000620, 0x00000000, 0x00470012, 0x007c041f, 0x07c011a0, 0xfc001f10,
+0xc203f000, 0x021f5005, 0x01f0007c, 0x1f0005c0, 0xf0007c00, 0x44044421,
+0x007c011f, 0x4bc001d0, 0x00000c00, 0x00000000, 0x00670810, 0x023c009f,
+0x20c00934, 0x44008300, 0xc009e002, 0x00930223, 0x8900023c, 0x930027e0,
+0x20023c10, 0x08a4c009, 0x024c029b, 0x43c20931, 0x00000c20, 0x00000000,
+0x22662001, 0x0274009d, 0x24400910, 0x45009140, 0x4029d002, 0x06918827,
+0x09340274, 0x91002740, 0xf0027400, 0x08e55849, 0x0a6c0391, 0x074009b0,
+0x00000800, 0x00000000, 0x0024a018, 0x2a74009d, 0x24400914, 0x54009548,
+0x600bd002, 0x00910027, 0x09500274, 0x91002340, 0x50027440, 0x04246009,
+0x06448099, 0x63600910, 0x00000200, 0x00000000, 0x25202010, 0x5234208d,
+0x20400910, 0x95148505, 0x621ad002, 0x14810023, 0x48502234, 0x81022341,
+0x90123400, 0x02216089, 0x26244981, 0x43402890, 0x00000080, 0x00000000,
+0x0106b01d, 0x107c401f, 0x04c00131, 0x5c041501, 0xc002f000, 0x04110007,
+0x4170587c, 0x11058740, 0x70047c14, 0x0584c021, 0xd84c821b, 0x77c20130,
+0x00000ac0, 0x00000000, 0x082fb819, 0x02bc14bf, 0x2f500af4, 0x6c00bb20,
+0xc149f002, 0x00bf05a7, 0x4930127c, 0xbf4127c1, 0xf1727c20, 0x492f404b,
+0x12fc84bf, 0x67c009f2, 0x00000e60, 0x00000000, 0x012da018, 0x02fc029f,
+0x25c00870, 0x4c049301, 0xc02bf082, 0x04bf01af, 0x6b304a7c, 0xb30127c0,
+0xf0124c04, 0x00a8c00b, 0x4acc00b3, 0x63c62930, 0x00000e00, 0x00000000,
+0x0087081c, 0x0874045d, 0x84420112, 0xc4021118, 0x4001d000, 0x001d0107,
+0x41100874, 0x11158744, 0xd2104402, 0x21044041, 0x8854b411, 0x73400110,
+0x00000c20, 0x00000000, 0x02332010, 0x0a36008d, 0x69400b50, 0x8409a112,
+0x4048d002, 0x038d00a3, 0x28141234, 0x81422340, 0xd04a0509, 0x21e07108,
+0x12248081, 0x4340081c, 0x00000e80, 0x00000000, 0x2225a818, 0x0274019d,
+0x2c586910, 0xc000b120, 0x4009d002, 0x049d0027, 0x09100274, 0x91002740,
+0xd0824420, 0x00644209, 0x0a741891, 0x63400918, 0x00000620, 0x00000000,
+0x0027a805, 0x023c029f, 0xa5c02870, 0x4d029340, 0xc009e002, 0x009f0027,
+0x0930027c, 0x934027c0, 0xf1024c2a, 0x4024c109, 0x066c0093, 0x17c20930,
+0x00000e20, 0x00000000, 0x00258014, 0x027c009f, 0x27c009f0, 0x7c409e00,
+0xc009f002, 0x009f0027, 0x09f0027c, 0x8f0027c0, 0xf0027c01, 0x0427c039,
+0x0a5c819f, 0x53c009f0, 0x00000600, 0x00000000, 0x00050814, 0x404c821b,
+0x08c00331, 0xcd002340, 0xc001f000, 0x00130004, 0x01f2004c, 0x130007c2,
+0xf0007c00, 0x0000d001, 0x404cba13, 0x53c00130, 0x00000420, 0x00000000,
+0x229ca014, 0x01c42051, 0x14420510, 0x45005100, 0x4007d001, 0x00714014,
+0x05d0016c, 0x51001740, 0xd2017401, 0x301cc017, 0x05d4c271, 0x53400510,
+0x00000200, 0x00000000, 0x00b2a014, 0x032400c9, 0x30600c14, 0x1400c100,
+0x500cd003, 0x01c10020, 0x0cd00344, 0x81003740, 0xd0033401, 0x00724129,
+0x0f4402d1, 0x53400c90, 0x00000a00, 0x00000000, 0x00788005, 0x032405e1,
+0x08420318, 0x94002100, 0x411ad800, 0x03410068, 0x0ed01384, 0xe1803340,
+0xd013b410, 0x443c410a, 0x43940021, 0x17408e91, 0x00000200, 0x00000000,
+0x00781015, 0x07ad05fb, 0x70501e30, 0x9c01c300, 0xc017f007, 0x0163007c,
+0x1ef10f85, 0xa3407bc0, 0xf00fbc01, 0x087ac01b, 0x06cc81f3, 0x57c01eb4,
+0x00000040, 0x00000000, 0x0031b810, 0x005c89df, 0x07c001f0, 0x6e001f00,
+0xc009f000, 0x00df2037, 0x0df0037c, 0xdf07b7c0, 0x90077c00, 0x0017c001,
+0x027c003f, 0x43c00d70, 0x00000660, 0x00000000, 0x007fb000, 0x17fc01ff,
+0x7cc01f70, 0x8c01f340, 0xc01b3007, 0x01f7006c, 0x1f3007cc, 0xf3007fc0,
+0x3007cc01, 0x087cc01f, 0x07cd01ff, 0x03c21f34, 0x00000e00, 0x00000000,
+0x00398015, 0x11b480ed, 0x08418210, 0x86082102, 0x480b1000, 0x84610028,
+0x0e100390, 0xa3003b48, 0x1003c400, 0x00395006, 0x4bc4002d, 0x57400e10,
+0x00000620, 0x00000000, 0x00290000, 0x73b400ed, 0x30400e50, 0xc500c100,
+0x40021003, 0x20650030, 0x0e100380, 0xe9003b40, 0xd0238400, 0x0618400f,
+0x008408fd, 0x03400e50, 0x00000400, 0x00000000, 0x04e32804, 0x003400cd,
+0x00400012, 0x04000100, 0x40281000, 0x40c10034, 0x0c100314, 0x81403742,
+0xd0030421, 0x00914404, 0x0c04025d, 0x13400d50, 0x00000c20, 0x00000000,
+0x00b5a815, 0x073c00ff, 0xf4d0ac70, 0x4c01d300, 0xc07d310b, 0x09870034,
+0x0934038c, 0xdb003fc0, 0xf403cd24, 0x00b4c009, 0x0b4f909f, 0x57c00f70,
+0x00000620, 0x00000000, 0x02370001, 0x027c10df, 0x43c001f0, 0x7c011f04,
+0xc04df404, 0x039f0037, 0x09f0037c, 0x9f0037c4, 0x10037c00, 0x2027c00d,
+0x017c001f, 0x07c00d80, 0x00000c00, 0x00000000, 0x003b0880, 0x037c80f3,
+0x3cc00f31, 0xc500e300, 0xc8073043, 0x0593107c, 0x0f30034e, 0xc3003fc0,
+0xf003cd03, 0x043cc00b, 0x42cc903f, 0x00c20f30, 0x00000c22, 0x00000000,
+0x04b60081, 0x047440d1, 0x06c00110, 0x04001170, 0x400d1000, 0x90950234,
+0x1d120344, 0x91003744, 0xd1034400, 0x0057d414, 0x0c04411d, 0x05400d10,
+0x00000802, 0x00000000, 0x8014a001, 0x237400d1, 0x34420d11, 0x5500d100,
+0x40181003, 0x40d14034, 0x89100344, 0xd1803540, 0xd2034400, 0x0074401d,
+0x0644019d, 0x04400d10, 0x00000200, 0x00000000, 0x00102010, 0x003400c1,
+0x02400110, 0x54000100, 0x40081000, 0x00c50030, 0x08100344, 0x81103340,
+0xd0030400, 0x08335004, 0x0044410d, 0x41400c10, 0x00000080, 0x00000000,
+0x4006a000, 0x037c00d3, 0x34c00d34, 0x5c00d300, 0xc8013003, 0x00d31034,
+0x0d320344, 0xd34039c4, 0xf0034c00, 0x2014d00d, 0x004d009f, 0x00c00d34,
+0x00000ac0, 0x00000000, 0x200fa805, 0x00fc00ff, 0x0fc002f0, 0xec003f00,
+0xc00bb080, 0x00ff003f, 0x0ff083fc, 0xb9003fc0, 0xf203fc00, 0x001fc006,
+0x00fc002f, 0x17c00ff2, 0x00000e60, 0x00000000, 0x002ba003, 0x0084807b,
+0x2ec00f21, 0xec00f348, 0xc00f1501, 0x003300bf, 0x0b3410cc, 0x33040cd0,
+0x3023cc00, 0x00bcc02f, 0x03cc06f3, 0x0cc10f30, 0x00000e00, 0x00000000,
+0x04a70821, 0x034490dd, 0x24420b10, 0x5400d104, 0x400d1008, 0x140102a3,
+0x29100844, 0x1105b4c0, 0x50134416, 0x203d480f, 0x43c402f1, 0x04402d50,
+0x00000c20, 0x00000000, 0x0323a011, 0x0025048d, 0x26400c90, 0x6400c101,
+0x400c1023, 0x80010923, 0x61902020, 0x41400041, 0x90030408, 0x4930404c,
+0x03250cc9, 0x44400c90, 0x00000e80, 0x00000000, 0x0125a803, 0x236400dd,
+0x27401d91, 0x7400d180, 0x480d1000, 0x14011033, 0x05900064, 0x41063640,
+0xd0034400, 0x0035400c, 0x036400d9, 0x0c400cd0, 0x00000220, 0x00000000,
+0x0037a800, 0x4c6c019f, 0x22900db1, 0x6c40d300, 0xc00d3000, 0x00930027,
+0x21b83c2d, 0x1300c0c1, 0xb003cd02, 0x0030c00d, 0x034c00db, 0x08c00db0,
+0x00000e20, 0x00000000, 0x003d8087, 0x07dc15ff, 0x6cc40a70, 0xdc00ff02,
+0xc00fe001, 0x003f002f, 0x0b7000dc, 0x7f080dc8, 0x70033c09, 0x003fc00d,
+0x03d800f7, 0x1fc10f72, 0x00000600, 0x00000000, 0x00350802, 0x405cc093,
+0x25c08d70, 0x5c00d300, 0xd00d3000, 0x001b2034, 0x3130a04c, 0xbb008ec0,
+0xb0034d02, 0x0034d00d, 0x031c00cf, 0x08d00d70, 0x00000420, 0x00000000,
+0x0874a013, 0x03444791, 0x24481d10, 0x0400f100, 0x400f1003, 0x301100b4,
+0x04100044, 0x5d003440, 0x1083c402, 0x003eca0f, 0x03c400fd, 0x4c402f10,
+0x00000200, 0x00000000, 0x11e2a003, 0x045403d1, 0x21400cd1, 0x1400d140,
+0x400c1101, 0x000d04b0, 0x00904005, 0x8d800240, 0x90030418, 0x2030400c,
+0x031400cd, 0x1c400c50, 0x00000a00, 0x00000000, 0x46688000, 0x548401f1,
+0x6940bc90, 0x8401e900, 0x401e1004, 0x01212368, 0xb29404c4, 0xad0a7864,
+0x12078401, 0x007a401e, 0x078429ed, 0x10501e10, 0x00000200, 0x00000000,
+0x00201016, 0x001c0a83, 0x25c48cf2, 0x5c08d300, 0xc00d3403, 0x080f0120,
+0x09b00005, 0xdf0202c0, 0xb0130c0e, 0x0030c04c, 0x035c00df, 0x48c00d70,
+0x00000040, 0x00000000, 0x4835b200, 0x117c60cd, 0x26c2ad60, 0x7c30d700,
+0xc08df200, 0x001f4137, 0x0d70223c, 0xdf023780, 0xf0037c28, 0x0037c00d,
+0x237c60df, 0x0bc18dd0, 0x00000660, 0x00000000, 0x0077a015, 0x007400d3,
+0x34d02c21, 0x7c00df00, 0xc00db000, 0x80134023, 0x013000fc, 0x33007ec2,
+0xf0037c00, 0x033484cd, 0x334d1cd1, 0x54c00df2, 0x00000e00, 0x00000000,
+0x00298810, 0x00f480e1, 0x38400e10, 0xb424ed00, 0x4c4e1001, 0x0061002b,
+0x025000b4, 0xa1003d00, 0xd083b400, 0x043c42cf, 0x539400e5, 0x48405ed0,
+0x00000620, 0x00000000, 0x00710083, 0x04b401a1, 0x78401f10, 0xf041ed00,
+0x449e9904, 0x0121047f, 0x131005b4, 0xe1004840, 0xd007b401, 0x0138401e,
+0x078485c1, 0x0c501ed0, 0x00000400, 0x00000000, 0x40732812, 0x813400c1,
+0x34420c10, 0x7400cd02, 0x400c103f, 0x21010073, 0x0c100634, 0xc101f040,
+0xd0033407, 0x0030420c, 0x031400c5, 0x48400cd0, 0x00000c20, 0x00000000,
+0x045da816, 0x01fc1171, 0x54c00634, 0xfc007f00, 0xc005b009, 0x9373201f,
+0x273485fc, 0x7341dcc0, 0xf0817c07, 0x0014d005, 0x014c0053, 0x5cc005f0,
+0x00000620, 0x00000000, 0x00070012, 0x007c921f, 0x07c021f2, 0x7c001f00,
+0xc001f000, 0x011f0007, 0x11f0287c, 0x0f0005d0, 0xf1007c02, 0x0007c000,
+0x003e001f, 0x4bc001f0, 0x00000c00, 0x00000000, 0x02260810, 0x067c009f,
+0x24c40920, 0x7c009340, 0xc8093002, 0x009b0027, 0x1830027c, 0x9f0026c0,
+0xf2024c01, 0x0020c009, 0x024c0093, 0x40d09872, 0x00000c20, 0x00000000,
+0x01a62000, 0x2634009d, 0x24420910, 0x74009b08, 0x40091002, 0x80910027,
+0xb9b06e34, 0x9d082442, 0xd0024451, 0x08244009, 0x82440091, 0x04403910,
+0x00000800, 0x00000000, 0x00248018, 0x0274189d, 0x24401951, 0x74009100,
+0x40091002, 0x80990063, 0x09100274, 0x9d002760, 0xd0024404, 0x40245409,
+0x02440081, 0x60400950, 0x00000200, 0x00000000, 0x02202010, 0x2676088d,
+0x20400850, 0x34088102, 0x44881022, 0x08812263, 0x98902234, 0x8d002048,
+0xd0020548, 0x01204048, 0x32040481, 0x40408812, 0x00000080, 0x00000000,
+0x0586b01c, 0x087c821f, 0x84d14574, 0x7c161100, 0xc1613458, 0x221b0587,
+0x6134587c, 0x1f3787c1, 0xf2784c36, 0x22c4c8b1, 0x0c4d0b13, 0x74c16470,
+0x00000ac0, 0x00000000, 0x012fb839, 0x12fc04bf, 0x2fc00bb0, 0xbc049f01,
+0x8849f113, 0x84bf412f, 0x4a7012bc, 0xbf106fc0, 0xf0867c24, 0x0267c099,
+0x327c099f, 0x67c049f0, 0x00000e60, 0x00000000, 0x01afa018, 0x02c402b3,
+0xa4c04b20, 0x0c269348, 0x40693012, 0x02b30227, 0x2be0123c, 0xb111a7c0,
+0xf1367c04, 0x0023c009, 0x4a4c1493, 0x60c06a30, 0x00000e00, 0x00000000,
+0x0987089c, 0x00440451, 0x0460a112, 0x44261109, 0x40611058, 0x00114283,
+0x24710e64, 0x11018700, 0xd0207414, 0x038748a1, 0x18540601, 0x70404110,
+0x00000c20, 0x00000000, 0x40a7a010, 0x42240099, 0x22520990, 0x25029100,
+0x4028100a, 0x80811127, 0x68d02234, 0x81032340, 0xd0123402, 0x04234148,
+0x12241081, 0x40406890, 0x00000e80, 0x00000000, 0x0935a818, 0x02648899,
+0x26400994, 0x64009100, 0x40091002, 0x20910827, 0x09512864, 0x91562240,
+0xd2027494, 0x08274009, 0x0274a091, 0x62400990, 0x00000620, 0x00000000,
+0x0027a801, 0x866d039b, 0x264019b1, 0x6c009300, 0xc0093402, 0x18930067,
+0x09f0007c, 0x9300a7c2, 0xf0027c00, 0x4027c809, 0x026c0093, 0x14d009b4,
+0x00000e20, 0x00000000, 0x10658014, 0x0a5d0097, 0x25c44970, 0x1c009f10,
+0xc009f102, 0x009f0237, 0x39f0056c, 0x9f0067c0, 0xf2027c20, 0x2023c009,
+0x021c009f, 0x51d00870, 0x00000600, 0x00000000, 0x04050814, 0x107c821f,
+0x06c40131, 0x7c001f00, 0xd0013008, 0x02130404, 0x6130406c, 0x134084c0,
+0x60007c2a, 0x0004c001, 0x004c0003, 0x50c00130, 0x00000420, 0x00000000,
+0x0498a014, 0x01f4236d, 0x14500610, 0xf6004d00, 0x44051401, 0x00512090,
+0x07101d44, 0x71001ec0, 0x10017400, 0x401c4005, 0x816c2051, 0x504207b0,
+0x00000200, 0x00000000, 0x00b2a014, 0x03749bcd, 0x34400c11, 0x3400cd20,
+0x400c9003, 0x00c100f2, 0x1c140324, 0xc1003040, 0x50033407, 0x0030400c,
+0x030400c1, 0x50440492, 0x00000a00, 0x00000000, 0x00288005, 0x02f400ed,
+0x38410f10, 0xb404ed11, 0x401c9203, 0x01b100ba, 0x3e102784, 0xe1013040,
+0x10073400, 0x0138601e, 0x032501e1, 0x14400e90, 0x00000200, 0x00000000,
+0x00781015, 0x07bc81ef, 0x78c41634, 0xb403ef00, 0xc01eb017, 0x01e3404a,
+0x1e3027ac, 0x21027850, 0x7017bc01, 0x00f8c15c, 0x1f8c02e3, 0x54c09ab0,
+0x00000040, 0x00000000, 0x1005b810, 0x003c001f, 0x35c000f1, 0x7c00df02,
+0xc88d5023, 0x028e0885, 0x0ff01b7c, 0x3f0b37c8, 0xf0237c00, 0x01b7d0ed,
+0x075c14df, 0x43d069f0, 0x00000660, 0x00000000, 0x406fa202, 0x37cc0973,
+0x7f401f21, 0xc801f302, 0xc01ff007, 0x03f300ec, 0x1b7027cc, 0xf3207cc0,
+0x100fcc21, 0x40fcc0df, 0x07cc01f3, 0x00c017f0, 0x00000e00, 0x00000000,
+0x000d8815, 0xb0848aa1, 0x3f444e10, 0x9400e000, 0x400ed003, 0x84a10128,
+0x07507384, 0xe1013941, 0x10038400, 0x0138488e, 0x039400f5, 0x54408ed0,
+0x00000620, 0x00000000, 0x00390018, 0x33c60861, 0x3a41061a, 0x8400e150,
+0x400ed003, 0xc1e0441a, 0x0b400384, 0x61003840, 0x10038410, 0x9038444e,
+0x038400e1, 0x00501ad0, 0x00000400, 0x00000000, 0x00032806, 0x04050101,
+0x33401410, 0x0400c100, 0x000cd007, 0x12910012, 0x38100b44, 0x01427140,
+0xd0034413, 0x0830400c, 0x031500c4, 0x104008c0, 0x00000c20, 0x00000000,
+0x1875a81d, 0x4a448591, 0x3ec01d05, 0xcd00f300, 0xd20ff01f, 0x93934016,
+0x15700f4d, 0xd300bcc2, 0x3403cd03, 0x003cd00f, 0x03cc00f3, 0x54c001d0,
+0x00000620, 0x00000000, 0x00670001, 0x027c229f, 0x37c42df1, 0x7ca0df00,
+0xc00df003, 0x00df0015, 0x2ff0837c, 0xff0033c1, 0x30037c02, 0x2033c20c,
+0x032c00df, 0x07c009f0, 0x00000c00, 0x00000000, 0x103f0801, 0x43cc187f,
+0x3cd40330, 0xbc00df00, 0xc00c3043, 0x08b30024, 0x2730434c, 0x93043fc0,
+0x3003f801, 0x003cc80d, 0x03cc00f3, 0x00c08f30, 0x00000c22, 0x00000000,
+0x00e62081, 0x0404030d, 0x34409812, 0x7420dda0, 0x400d1003, 0x00d104a4,
+0x65b0e344, 0x11003742, 0x10837405, 0x0034400d, 0x036c00d1, 0x04400d10,
+0x00000802, 0x00000000, 0x0074a000, 0x064420dd, 0x34422d10, 0x7480dd00,
+0x400d5203, 0x00910800, 0x01100344, 0x11003740, 0x10036408, 0x1034400d,
+0x8344a0c1, 0x04400010, 0x00000200, 0x00000000, 0x00202010, 0x0044009d,
+0x30400c10, 0x3480cd00, 0x400c5103, 0x00c10820, 0x00900341, 0xc1483340,
+0x12033480, 0x0030400c, 0x032480c1, 0x40500810, 0x00000080, 0x00000000,
+0x0836b000, 0x034d004f, 0x34c00534, 0x7c80dd00, 0xd00d7403, 0x00a34034,
+0x0130034d, 0x13003f40, 0x3403ac00, 0x4038d00f, 0x034c00f3, 0x00c00e34,
+0x00000ac0, 0x00000000, 0x000fb804, 0x80bc003f, 0x3fc20fd8, 0xfc20ff00,
+0xc20fb003, 0x00ff083f, 0x03f083fc, 0x3f003bc2, 0xe003fc00, 0x403fc00f,
+0x03fc00ff, 0x17c00ff0, 0x00000e60, 0x00000000, 0x000ba003, 0x98cc02bf,
+0x3cc20ff0, 0xcc88bf20, 0xc00f3032, 0x00f7103c, 0x033003fc, 0xfb203dc0,
+0xf002ccc0, 0x012fc00f, 0x03cc04b3, 0x0cc4cbf0, 0x00000e00, 0x00000000,
+0x08350801, 0x004482ed, 0x36c825c0, 0x54469d10, 0x400d5033, 0x40c10039,
+0x01110274, 0xe9003048, 0xd0024480, 0x02974a0d, 0x01444a91, 0x0440cbd0,
+0x00000c20, 0x00000000, 0x00332011, 0x1811068d, 0x21482c58, 0x16868d20,
+0x400c1002, 0x80c58832, 0x01100374, 0xc9003140, 0xd0023400, 0x0033400c,
+0x03070081, 0x444008d0, 0x00000e88, 0x00000000, 0x00b5a803, 0x085440dd,
+0x36401dd0, 0x16018d00, 0x400d5046, 0x00d11037, 0x0d160274, 0xd9003400,
+0xd2036440, 0x0037440d, 0x014620d0, 0x0c4089d0, 0x00000620, 0x00000000,
+0x0057a800, 0x045c009f, 0x74c01c70, 0x4c879f00, 0xc00f310f, 0xa0d70036,
+0xb130007c, 0xdb0035c0, 0xe0227d00, 0x1033c00f, 0x014c0853, 0x08d01df1,
+0x00000e20, 0x00000000, 0x00fd8087, 0x15e404ee, 0x7fc40ff0, 0xf8009e21,
+0x800ee003, 0x02ff003d, 0x0ff203f8, 0xff10bf44, 0xf002dc40, 0x401fc00f,
+0x17fc00ff, 0x1fc01bf0, 0x00000600, 0x00000000, 0x00350802, 0x014c00db,
+0x14c10df1, 0x4c021f01, 0xc04d700a, 0x40d34037, 0x61f0024c, 0xd32034c8,
+0xf0824c04, 0x20b7c00d, 0x034d00c3, 0x08d00cf0, 0x00000420, 0x00000000,
+0x23b4a013, 0x2dc00091, 0x34501dc0, 0x44019d00, 0x423f1082, 0x4491007b,
+0x3cd00304, 0xf00aa440, 0xd0034400, 0x0037400f, 0x034401d1, 0x4c420dd0,
+0x00000200, 0x00000000, 0x0032a007, 0x22048089, 0xb24008d0, 0x04418d08,
+0x443c1041, 0x13cd0033, 0x00d04b04, 0xd0003148, 0xd0830402, 0x0023400c,
+0x0224488d, 0x1e4008d0, 0x00000a00, 0x00000000, 0x407c8006, 0x058409e9,
+0x7a4097d1, 0xe501ad00, 0x411e1127, 0x09ed067b, 0x12d00680, 0xe1027900,
+0xd0068419, 0x6273401e, 0x06a4098d, 0x12409ad0, 0x00000208, 0x00000000,
+0x02301012, 0x010c00ca, 0x32c188f0, 0x0c3c8f00, 0xc0cc3420, 0x00cf2233,
+0x0df0030c, 0xc34231d1, 0xf0030d00, 0x02b3c48c, 0x222c088f, 0x4ac289ea,
+0x00000040, 0x00000000, 0xa03db802, 0x43fd00b7, 0x35408ec0, 0x9e089f12,
+0xc28db1a2, 0x20f30237, 0x0ff120f1, 0xff023ec0, 0xf103fc00, 0x023fc00f,
+0xa2dc68f3, 0x09c08bf0, 0x00000660, 0x00000000, 0x0037a015, 0x024c009f,
+0xb4c81bf0, 0x5c009301, 0xc00d3403, 0x20d36437, 0x0d30024c, 0xd30130d0,
+0xf0034c03, 0x0037c00f, 0x044c0013, 0x54c04df2, 0x00000e00, 0x00000000,
+0x00398812, 0x118488ed, 0x3ac40ed1, 0xb480e584, 0x486eb003, 0x00e1003b,
+0x0e1083c4, 0xe1043840, 0xd002840c, 0x0033405e, 0x03840085, 0x48450ed0,
+0x00000620, 0x00000000, 0x00790083, 0x05a421ad, 0xda4018d0, 0xb401a100,
+0x405e1806, 0x11f1027b, 0x1e100684, 0xe1007e44, 0xd0078408, 0x007b429e,
+0x02a403a1, 0x0c401cd1, 0x00000400, 0x00000000, 0x00730812, 0x074421cd,
+0x32406cd2, 0x74028524, 0x480c900a, 0x00c90033, 0x1c144504, 0xc1027240,
+0xd8030520, 0x0073400c, 0x472503c5, 0x48408cd0, 0x00000c20, 0x00000000,
+0x015da817, 0x05cc015f, 0x96d007e2, 0xfc067300, 0xc0073411, 0x0172001f,
+0x77340dcc, 0x534016c0, 0xf0014c00, 0x015fc005, 0x1de58373, 0x5cd015f0,
+0x00000620, 0x00000000, 0x00870012, 0x287d081f, 0x07c001e0, 0x78041f00,
+0xc021f810, 0x00170087, 0x31f0207d, 0x1f0005c0, 0xf0007c00, 0x5003c001,
+0x005c040f, 0x4bc001f0, 0x00000c00, 0x00000000, 0x00a70810, 0x164c009f,
+0x37c01930, 0x4c499b08, 0xc8493002, 0x009b0827, 0x3930064c, 0x8300b4c0,
+0xf0024c01, 0x2024d009, 0x024c0193, 0x40c02930, 0x00000c20, 0x00000000,
+0x01262001, 0x164c009d, 0x23403914, 0x6c839100, 0x40495002, 0x009108a7,
+0x09100644, 0x914026c8, 0x70024083, 0x40244008, 0x024c0a91, 0x04502910,
+0x00000800, 0x00000000, 0x0024a018, 0x02440085, 0x27498910, 0x44828100,
+0x60091002, 0x00814023, 0x0c102305, 0x91002050, 0x50024414, 0x40244009,
+0x03060091, 0x60410810, 0x00000200, 0x00000000, 0x00202010, 0xd204148d,
+0x23414818, 0x24148140, 0x60085552, 0x08810223, 0x8c142204, 0x81022060,
+0x500a0408, 0x02204028, 0x0a270181, 0x40408810, 0x00000080, 0x00000000,
+0x2006b01d, 0x104c4407, 0x17c84130, 0x06041340, 0xc1413110, 0x02110093,
+0x2032084c, 0x03108440, 0x71004c02, 0x1584c141, 0x004c9413, 0x74c16130,
+0x00000ac0, 0x00000000, 0x082f9819, 0x52d914bf, 0x33c60bf0, 0xfc14bf20,
+0xc009f452, 0x04a701a7, 0x4ff012fc, 0x9f0127c0, 0x7002f806, 0x012fc409,
+0x03dc40bf, 0x67c04bf0, 0x00000e60, 0x00000000, 0x002f8019, 0x1acc0c93,
+0x25c04b31, 0xcc069300, 0xd059300a, 0x029301ac, 0x29300a6c, 0x9300a4c0,
+0xf0020c80, 0x0324c018, 0x0a4c00b3, 0x60c0cb30, 0x00000e00, 0x00000000,
+0x0007089c, 0xa8400e11, 0x0452a110, 0x044a0120, 0x40011008, 0x04110384,
+0x01100044, 0x31000440, 0xd1104416, 0x43844061, 0x106d0a15, 0x7040e110,
+0x00000c20, 0x00000000, 0x0067a010, 0x12144085, 0x25401910, 0x24219580,
+0x4029101a, 0x04a50127, 0x4a101285, 0xa1012840, 0xd0422422, 0x20204128,
+0x12644089, 0x40400810, 0x00000e80, 0x00000000, 0x6065a818, 0x0a540481,
+0x24400918, 0x44209551, 0x40090002, 0x00a10026, 0x0b100a84, 0xb1002c40,
+0xd0066400, 0x04245409, 0x0264009d, 0x60404810, 0x00000620, 0x00000000,
+0x00e7a805, 0x0a5d0197, 0xe5802934, 0x6d009720, 0xc0092402, 0x01970027,
+0x2934026c, 0x93402490, 0xf0026c00, 0x4024c809, 0x0a2c069b, 0x14d01934,
+0x00000e20, 0x00000000, 0x00258214, 0x666c209f, 0x37c009f1, 0x3c09db00,
+0xc10df026, 0x429f4025, 0x59f0027c, 0x9f0e67c0, 0xf0825c00, 0x0227c008,
+0x027c0997, 0x53c009f0, 0x00000600, 0x00000000, 0x24050814, 0x080c001f,
+0xc4c00118, 0x4c881f00, 0xc0013404, 0x10130004, 0x0130004c, 0x0f0004d0,
+0x30007c04, 0x4000c001, 0x007c0303, 0x50c101f0, 0x00000420, 0x00000000,
+0x09d88214, 0x81c4005d, 0x14505630, 0xec415c00, 0x4004f015, 0x055b00d0,
+0x15140545, 0x5d209440, 0x50017402, 0x401c4007, 0x01740671, 0x505077d0,
+0x00000200, 0x00000000, 0x00b2a014, 0x0f0000cd, 0x37604c98, 0x0441dd00,
+0x50205007, 0x03c106f0, 0x0d103704, 0xcd02f740, 0x10033400, 0x0030500c,
+0x033401c1, 0x50400cd0, 0x00000a00, 0x00000000, 0x08388005, 0x080404ed,
+0x3b400c10, 0xa400ed00, 0x4103d003, 0x00e9003c, 0x0e100384, 0xed001b41,
+0x4007f401, 0x0038424e, 0x13b480e1, 0x14400cd0, 0x00000200, 0x00000000,
+0x00781015, 0x048d03fd, 0x7bc01e94, 0x8c116f10, 0xc0127007, 0x01f3007c,
+0x1f3106cc, 0x2f007bc0, 0x3047bc90, 0x007cc13e, 0x1fbc0123, 0x54c01ef0,
+0x00000040, 0x00000000, 0x0015b010, 0x837c16df, 0xb4d80970, 0xfc205f01,
+0xc068f403, 0x00df0037, 0x0df0027c, 0x1f0014c0, 0xb0137404, 0x0237c00d,
+0x0b7c205f, 0x43c00df0, 0x00000660, 0x00000000, 0x1a7fa002, 0x04cc41ff,
+0xfcc01730, 0xfc01f302, 0xc0333005, 0x01e7006f, 0x1b3007cc, 0xf3426fc0,
+0x7243fc01, 0x207cc41f, 0x0fcc817b, 0x03c01f30, 0x00000e00, 0x00000000,
+0x12398815, 0x1b8404ed, 0x3ac00e10, 0xf482a102, 0x48221003, 0x50e1003b,
+0x0a104384, 0xe1000f48, 0xb023f400, 0x403ac00f, 0x03cc0061, 0x57400eb0,
+0x00000620, 0x00000000, 0x2a190008, 0x038490cd, 0xba400e18, 0xb4002510,
+0x40021001, 0x00f50223, 0x0a1402c5, 0x21142b40, 0x5023b400, 0x0038408e,
+0x03a40001, 0x03400e10, 0x00000400, 0x00000000, 0x04032816, 0x0c0400cd,
+0x32490c10, 0x74010500, 0x4000100b, 0x00d10033, 0x2c120204, 0x91200342,
+0xc0033400, 0x0032400c, 0x0b042001, 0x13409d90, 0x00000c20, 0x00000000,
+0x0075a805, 0x034d01ff, 0x32c00c34, 0x7c611740, 0xc601300a, 0x00170017,
+0x1430014c, 0xd31037c9, 0x7003f800, 0x003cc20f, 0x1fad0513, 0x57c01d30,
+0x00000620, 0x00000000, 0x02b70001, 0xb97c80df, 0x77c01df0, 0xfc081a00,
+0xc001f022, 0x021f0017, 0x45f0017c, 0xdf0097c0, 0x22077c00, 0x0477c00d,
+0x437c105f, 0x07c00df0, 0x00000c00, 0x00000000, 0x003f0801, 0x07cc00f3,
+0x3cc80db0, 0xfc143300, 0xc0833042, 0x283b0018, 0x073040cc, 0x3f027cc0,
+0xb003cc02, 0x2038c00f, 0x03cd0033, 0x00c09f30, 0x00000c22, 0x00000000,
+0x00122081, 0x0d0400d1, 0x34500d10, 0x74031100, 0x4028f002, 0x02110094,
+0x2d104844, 0x5d001440, 0x10034481, 0x4035400d, 0x03440641, 0x04402d10,
+0x00000802, 0x00000000, 0x0c34a001, 0x224500c1, 0x34608593, 0x76005110,
+0x40011005, 0x10190084, 0x21101104, 0xdd142540, 0x90030400, 0x0034400c,
+0x03542119, 0x04610d10, 0x00000200, 0x00000000, 0x20102210, 0x004400c1,
+0x54620d90, 0x34000100, 0x4800d203, 0x00c12010, 0x01120305, 0xcd002140,
+0x91030440, 0x0031480c, 0x03440001, 0x40400c10, 0x00000080, 0x00000000,
+0x0016b001, 0x020c80f1, 0x34c80db1, 0x7c001340, 0xd0013201, 0x001b0024,
+0x0134014d, 0x1f0035c4, 0xb103cd00, 0x0034c00f, 0x03dc0013, 0x00d00132,
+0x00000ac0, 0x00000000, 0x002fb805, 0x00fc00ff, 0x3bd00f70, 0xfc003f00,
+0xc00ff483, 0x20ff103f, 0x0ff083bc, 0xff003ed4, 0x7183fc00, 0x403bc40f,
+0x03fc803f, 0x17c003f0, 0x00000e60, 0x00000000, 0x8080a300, 0x0839020e,
+0x83b820ec, 0x3b038ec0, 0xb020ec08, 0x820e80e3, 0x20ec083a, 0x0ec083a0,
+0xec0a3b02, 0xc083a828, 0x083b020e, 0x03b020ec, 0x0000008c, 0x00000000,
+0x8022a200, 0x023a808e, 0x23b808ea, 0x2a808ea0, 0xa808ea82, 0x808e8023,
+0x08ea023a, 0x8ea023a8, 0xea023a80, 0xa0232808, 0x023a808e, 0x03a808ea,
+0x00000a88, 0x00000000, 0x80402100, 0x04120104, 0x41201048, 0x12018480,
+0x20104804, 0x01048061, 0x10480412, 0x04804120, 0x48041201, 0x80410018,
+0x04120104, 0x01201048, 0x0000020c, 0x00000000, 0x80008100, 0x001a0006,
+0x01a00068, 0x1a100680, 0xa0006800, 0x10068401, 0x0068001a, 0x060001a9,
+0x68461a00, 0x80018900, 0x00180006, 0x01a00068, 0x00000004, 0x00000000,
+0xa012a300, 0x013a804e, 0x13a004e2, 0x3a884e20, 0xa804ea01, 0x004ea013,
+0x04e2013a, 0x4ea013a8, 0xea293a80, 0xa013a014, 0x013a804e, 0x03a804ea,
+0x00000a88, 0x00000000, 0x0002a100, 0x00180006, 0x01800060, 0x18080600,
+0x80006000, 0x00060201, 0x80602018, 0x06020180, 0x60a01800, 0x00018080,
+0x00180006, 0x01800060, 0x0000008c, 0x00000000, 0x2012a300, 0x01108044,
+0x11000442, 0x10804420, 0x08044201, 0x00042011, 0x00420110, 0x44201108,
+0x42011080, 0x20110004, 0x01108044, 0x01080442, 0x0000008c, 0x00000000,
+0xa052a300, 0x050a8142, 0x50a0142a, 0x0a8342a0, 0xa8142a05, 0x8102a050,
+0x102a050a, 0x42a050a0, 0x2a070881, 0xa050a014, 0x05088142, 0x00a8142a,
+0x00000a8c, 0x00000000, 0x80300100, 0x032a00ca, 0x32a00ca8, 0x2200ea80,
+0xa00ca803, 0x00ca803a, 0x0ea80baa, 0xca802aa0, 0xa803aa00, 0x8032a00e,
+0x032a00ca, 0x02a00ca8, 0x00000804, 0x00000000, 0x28000100, 0x00080002,
+0x00820020, 0x20000200, 0x80002000, 0x00422000, 0x04200008, 0x02000082,
+0x20020800, 0x00008800, 0x00080002, 0x80800020, 0x00000004, 0x00000000,
+0x0006a200, 0x00410010, 0x04100104, 0x61101040, 0x10010400, 0x10100404,
+0x01040841, 0x10401411, 0x04404100, 0x40041101, 0x00410010, 0x80100104,
+0x00000a8c, 0x00000000, 0xa002a300, 0x001a8006, 0x01a0006a, 0x1a8026a0,
+0xa8006a00, 0x4006a009, 0x026a009b, 0x06a8099a, 0x6a009a80, 0xa001a802,
+0x001a8006, 0x01a8006a, 0x0000008c, 0x00000000, 0x8002a300, 0x001b0006,
+0x01b0006c, 0x1b0006c0, 0xb0006c00, 0x0046c001, 0x046c001a, 0x06c001a0,
+0x6c001b00, 0xc001b000, 0x001b0006, 0x01b0006e, 0x0000008c, 0x00000000,
+0x0042a300, 0x0430810c, 0x430810c2, 0x30910c20, 0x0810c204, 0x810c2043,
+0x10c20430, 0x0c204308, 0xc2443081, 0x20430810, 0x0430810c, 0x030810c2,
+0x00000a8c, 0x00000000, 0x20000100, 0x0030000c, 0x030000c0, 0x30080c00,
+0x0000c000, 0x000c0203, 0x80c02030, 0x0c020300, 0xc0203000, 0x00030080,
+0x0030000c, 0x030000c0, 0x00000004, 0x00000000, 0x80400100, 0x0432010c,
+0x432010c8, 0x32010c80, 0x2010c804, 0x830c8043, 0x30c80432, 0x0c804328,
+0xc8043201, 0x80432010, 0x0432010c, 0x032010ca, 0x00000204, 0x00000000,
+0xa042a200, 0x041a8106, 0x41a8106a, 0x1a8106a0, 0xa8106a04, 0x8306a041,
+0x306a041a, 0x06a04188, 0x6a041a81, 0xa041a810, 0x041a8106, 0x01a81060,
+0x00000a88, 0x00000000, 0x0042a300, 0x04100104, 0x41001040, 0x10210400,
+0x00104004, 0x01040041, 0x10400430, 0x04004300, 0x40041001, 0x00410010,
+0x04100104, 0x01001040, 0x00000084, 0x00000000, 0x2042a200, 0x04188106,
+0x41881062, 0x18812620, 0x88106204, 0x81062041, 0x10620430, 0x06204308,
+0x62049881, 0x20418810, 0x04188106, 0x01881060, 0x00000088, 0x00000000,
+0x2006a300, 0x0068801a, 0x06a801aa, 0x6a801aa0, 0xa801a200, 0x001aa006,
+0x01aa0062, 0x1aa00620, 0xaa006a80, 0xa006a801, 0x006a801a, 0x02a801a0,
+0x00000a88, 0x00000000, 0x80600100, 0x060a0182, 0x60a01828, 0x08018280,
+0xa0182806, 0x01828060, 0x1828060a, 0x82006080, 0x20060801, 0x80608018,
+0x06080182, 0x00a01828, 0x00000004, 0x00000000, 0x80400000, 0x04020100,
+0x40221008, 0x02012080, 0x20100804, 0x01008040, 0x10080402, 0x00804020,
+0x08048201, 0x80402210, 0x04020100, 0x00201008, 0x00000004, 0x00000000,
+0x8062a300, 0x062b018a, 0x62b018ac, 0x2b098ac0, 0xb018ac06, 0x098ac262,
+0x98ac062b, 0x8ac062b0, 0xac262b01, 0xc062b098, 0x062b018a, 0x02b018ac,
+0x00000a8c, 0x00000000, 0xa062a200, 0x063a818e, 0x63a818ea, 0x3a918ea0,
+0xa818ea06, 0x818ea063, 0x18ea063b, 0x8e8063b8, 0xea463a81, 0xa0638818,
+0x063a818e, 0x03a818ea, 0x00000088, 0x00000000, 0xc062a200, 0x063b018e,
+0x63b018e4, 0x39018ec0, 0xb0186c06, 0x018ec063, 0x18ec063a, 0x8ec063a8,
+0xec063b81, 0xc063b018, 0x063b018e, 0x03b018e4, 0x00000088, 0x00000000,
+0xa062a200, 0x063a818e, 0x63a818ea, 0x3a898ea0, 0xa818ca06, 0x818ea263,
+0x98eaa630, 0x8ea26308, 0xea263b81, 0xa063a898, 0x063a818e, 0x03a818ea,
+0x00000a88, 0x00000000, 0x80400000, 0x04120104, 0x41201048, 0x12010480,
+0x20104804, 0x01048041, 0x1048043a, 0x048043a0, 0x48041201, 0x80412010,
+0x04120104, 0x01201048, 0x00000000, 0x00000000, 0x80600000, 0x061a0186,
+0x61a01868, 0x1a018680, 0xa0186806, 0x81860061, 0x18680618, 0x860061a0,
+0x68061a01, 0x8061a018, 0x061a0186, 0x01a01868, 0x00000000, 0x00000000,
+0xa002a200, 0x003a800e, 0x038800ea, 0x3a800ea0, 0x8800e200, 0x800ca003,
+0x00ca003a, 0x0ea003a8, 0xea003a00, 0xa0032800, 0x003a800e, 0x03a800e2,
+0x00000a88, 0x00000000, 0x0042a200, 0x04180106, 0x41801060, 0x18010600,
+0x80106004, 0x010400c1, 0x10400418, 0x06004180, 0x60041801, 0x00410010,
+0x04180106, 0x01801060, 0x00000088, 0x00000000, 0x2042a200, 0x04108104,
+0x41081042, 0x10810420, 0x08104204, 0x81062041, 0x10620410, 0x04204108,
+0x42041001, 0x20418810, 0x04108104, 0x01081042, 0x00000088, 0x00000000,
+0x2042a200, 0x040a8102, 0x4088102a, 0x088102a0, 0xa8102204, 0x010a2040,
+0x10aa0c0a, 0x02a040a8, 0x2a040a01, 0xa042a830, 0x040a8102, 0x00a8102a,
+0x00000a88, 0x00000000, 0x80c00000, 0x0c2a030a, 0xc2a030a8, 0x2a010a80,
+0xa030a80c, 0x030a80c2, 0x30a80c2a, 0x0a80c2a0, 0xa80c2a03, 0x80c2a030,
+0x0c2a030a, 0x02a030a8, 0x00000000, 0x00000000, 0x00120000, 0x01080042,
+0x10800420, 0x08004200, 0x80042001, 0x00420000, 0x04208008, 0x42001080,
+0x20010800, 0x00108000, 0x01080042, 0x00800420, 0x00000000, 0x00000000,
+0x4042a200, 0x04010100, 0x40101004, 0x01010040, 0x10100404, 0x01004050,
+0x10040501, 0x00404010, 0x04040101, 0x40401014, 0x04010100, 0x00101004,
+0x00000a88, 0x00000000, 0xa000a200, 0x001a8006, 0x01a8006a, 0x1a0006a0,
+0xa0006a00, 0x8006a001, 0x0062001b, 0x06a001b8, 0x6a001a80, 0xa001a800,
+0x001a8006, 0x01a8006a, 0x00000088, 0x00000000, 0xc002a300, 0x001b0006,
+0x01b0006c, 0x1b8006c0, 0xb0006c00, 0x8006c001, 0x006c003a, 0x06c003a0,
+0x6c001b00, 0xc001b000, 0x00130006, 0x01b0006c, 0x00000000, 0x00000000,
+0x20000000, 0x0030800c, 0x030800c2, 0x30800c20, 0x0800c200, 0x800c2003,
+0x00c20018, 0x0c200188, 0xc2003080, 0x20030800, 0x0030800c, 0x030800c2,
+0x00000000, 0x00000000, 0x00000000, 0x0030000c, 0x030000c0, 0x30002c00,
+0x0000c000, 0x002c000b, 0x0ac00010, 0x0c002100, 0xc002b000, 0x00030002,
+0x0010000c, 0x030000c0, 0x00000000, 0x00000000, 0x00a00000, 0x0a32028c,
+0xa32028c8, 0x32808c80, 0x2028c80a, 0x028c80a3, 0x38c80a32, 0x8c80a328,
+0xc80a3202, 0x80a32028, 0x0a32028c, 0x032028c8, 0x00000000, 0x00000000,
+0xa0c40000, 0x0c588316, 0xc5a8316a, 0x5a8316a0, 0xa8316a0c, 0x8316a0c5,
+0x316a0c5a, 0x16a0c5a8, 0x6a0c5a83, 0xa0c5a831, 0x0c5a8316, 0x01a8316a,
+0x00000000, 0x00000000, 0x00000000, 0x00100004, 0x01000040, 0x10002400,
+0x00004000, 0x00240019, 0x0a400110, 0x04002100, 0x40029000, 0x00010006,
+0x00100004, 0x01000040, 0x00000000, 0x00000000, 0x22100000, 0x21188846,
+0x11888462, 0x18804622, 0x88846221, 0x88462201, 0x04622018, 0x46201188,
+0x62011888, 0x22118880, 0x21188846, 0x01888462, 0x00000000, 0x00000000,
+0xa2000000, 0x2028880a, 0x028880a2, 0x28080aa2, 0xa880aa20, 0x880aa202,
+0x80aa202a, 0x0aa222a0, 0xaa022888, 0x2202a880, 0x202a880a, 0x02a880aa,
+0x00000000, 0x00000000, 0x84100000, 0x410a1042, 0x10a10428, 0x0a184284,
+0xa1042041, 0x104a8010, 0x04a8410a, 0x42841081, 0x20010a10, 0x8412a004,
+0x410a1042, 0x00a10428, 0x00000000, 0x00000000, 0x80500000, 0x05020140,
+0x50201408, 0x02014080, 0x20140805, 0x01400050, 0x14000502, 0x40805020,
+0x08050201, 0x80500014, 0x05020140, 0x00201408, 0x00000000, 0x00000000,
+0xc0300000, 0x032b00ca, 0x32b00cac, 0x2b00cac0, 0xb00cac03, 0x00c84032,
+0x0c84032b, 0xcac032b0, 0xac032b00, 0xc032100c, 0x032b00ca, 0x02b00cac,
+0x00000000, 0x00000000, 0xa0100000, 0x013a804e, 0x13a004ea, 0x3a804ea0,
+0xa804ea01, 0x804ea013, 0x04ea013b, 0x4ea013b8, 0xea013a80, 0xa013a804,
+0x013a804e, 0x03a804ea, 0x00000000, 0x00000000, 0x18c40000, 0x8c486312,
+0xc4863121, 0x48030218, 0x8631218c, 0x231208c0, 0x30218c08, 0x1218c082,
+0x200c0863, 0x18c48230, 0x8c486312, 0x00863121, 0x00000000, 0x00000000,
+0xfffc0000, 0xffcbfff2, 0xfcbfff2f, 0xcbfff2ff, 0xbfff2fff, 0xfff2fffc,
+0xff2fffcb, 0xf2fffcbf, 0x2fffcbff, 0xfffcbfff, 0xffcbfff2, 0x00bfff2f,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xdb340000, 0xb3436cd0,
+0x3436cd0d, 0x4bedf0db, 0x36cd0db3, 0x6cd2fb34, 0xdf0db343, 0xd0db7c36,
+0x2fffc36c, 0xdb34becd, 0xb3436cd0, 0x0036cd0d, 0x00000000, 0x00000000,
+0x3ccc0000, 0xccc8f332, 0xcc8f3323, 0xcbf3f23c, 0x8f3323cc, 0xf332fccc,
+0x3f23ccc8, 0x323cfc8f, 0x2fffc8f3, 0x3cccbf33, 0xccc8f332, 0x008f3323,
+0x00000000, 0x00000000, 0x7edc0000, 0xedc9fb72, 0xdc9fb727, 0xc9e3727e,
+0x9fb727ed, 0x7b727ec4, 0xb727ec48, 0x727edc87, 0x27edc9fb, 0x7edc9fb1,
+0xedc9fb72, 0x009fb727, 0x00000000, 0x00000000, 0x40800000, 0x0839020e,
+0xa39020e4, 0x39020e60, 0x9028e408, 0x020e40a3, 0x20e60839, 0x0e408380,
+0xe4083902, 0x60839028, 0x0833020e, 0x038020e4, 0x00000000, 0x00000000,
+0xa0200000, 0x023aa08e, 0x63a808ea, 0x3a808ea0, 0xa808ea02, 0x808ea063,
+0x08ea023a, 0x8ea023a0, 0xea823a80, 0xa023a808, 0x0232808e, 0x03a808ea,
+0x00000000, 0x00000000, 0x80400000, 0x00120104, 0x61201048, 0x12010480,
+0x20104804, 0x01048041, 0x10480412, 0x44804120, 0x48041201, 0x80412018,
+0x04120104, 0x01201048, 0x00000000, 0x00000000, 0x00000000, 0x44180006,
+0x01800060, 0x18100604, 0x81086000, 0x10060421, 0x00620018, 0x06000180,
+0x60001800, 0x20018110, 0x80180006, 0x01890060, 0x00000000, 0x00000000,
+0x22100000, 0x0138884e, 0x138804e2, 0x38804e00, 0x8814e201, 0x804e2013,
+0x04e00138, 0x0e201388, 0xe2213880, 0x00138804, 0x2938804e, 0x038884e2,
+0x00000000, 0x00000000, 0x00000000, 0x00180086, 0x01800060, 0x18080600,
+0x80006080, 0x00060201, 0x80600018, 0x06020180, 0x60001800, 0x00018080,
+0x00180806, 0x01800060, 0x00000000, 0x00000000, 0x20300000, 0x01908044,
+0x19080442, 0x10806400, 0x08064201, 0x80642019, 0x04400110, 0x44201108,
+0x42011080, 0x00110806, 0x03108044, 0x01080242, 0x00000000, 0x00000000,
+0x20540000, 0x054881d2, 0x54881522, 0x48815220, 0x88152205, 0x81522054,
+0x15200548, 0x52205488, 0x220d4881, 0x00548815, 0x05488152, 0x00801922,
+0x00000000, 0x00000000, 0x00300310, 0x032800ca, 0x32800ca0, 0x2800ca00,
+0x800ca003, 0x00ca00b2, 0x0ca00328, 0xca003280, 0x80032800, 0x0032800c,
+0x032800ca, 0x02800ca0, 0x00000000, 0x00000000, 0x00600310, 0x00880082,
+0x08800020, 0x08002200, 0x80022000, 0x00220008, 0x00200008, 0x02000080,
+0x80000800, 0x00008002, 0x02080002, 0x01801620, 0x0000000c, 0x00000000,
+0x40020310, 0x40010000, 0x00100004, 0x01100044, 0x11000400, 0x10004480,
+0x00040001, 0x00400000, 0x84000100, 0x40001100, 0x00010000, 0x00110004,
+0x0000000c, 0x00000000, 0x20020310, 0x00188006, 0x018a0062, 0x18800600,
+0x88006200, 0x80062001, 0x00610018, 0x06200198, 0x628018a0, 0x20018800,
+0x00188006, 0x01980060, 0x0000000c, 0x00000000, 0x40028008, 0x00190006,
+0x01900064, 0x19800600, 0x98006400, 0x00064001, 0x00640019, 0x06400190,
+0x60001900, 0x40019000, 0x00130006, 0x41800464, 0x00000000, 0x00000000,
+0x2442a202, 0x0430910c, 0x430810c2, 0x30810c00, 0x0810c204, 0x810c2043,
+0x10c20430, 0x0c204308, 0xc0443081, 0x20430810, 0x4430810c, 0x030910c2,
+0x00000a88, 0x00000000, 0x00000002, 0x0030000c, 0x030000c0, 0x30080c00,
+0x0000c000, 0x000c0203, 0x80c00030, 0x0c020300, 0xc0003000, 0x00030080,
+0x0010080c, 0x030000c0, 0x00000000, 0x00000000, 0x00400002, 0x0430210c,
+0x430010c0, 0x30810c00, 0x0010c004, 0x010c0043, 0x10c00430, 0x0c004300,
+0xc0043001, 0x00430010, 0x0430010c, 0x030830c0, 0x00000000, 0x00000000,
+0x2042a202, 0x04188106, 0x41881062, 0x18010620, 0x80106204, 0x81062041,
+0x10620418, 0x06204188, 0x62041881, 0x20418810, 0x04188106, 0x01883062,
+0x00000a88, 0x00000000, 0x00428002, 0x04100104, 0x41001040, 0x10010400,
+0x00104004, 0x01040041, 0x10400410, 0x04004100, 0x40041001, 0x00410010,
+0x04100104, 0x03001040, 0x00000000, 0x00000000, 0x2040800a, 0x04188106,
+0x41881062, 0x18010620, 0x80106204, 0x81062041, 0x10620418, 0x06204188,
+0x62041881, 0x20418810, 0x04188106, 0x03081062, 0x00000200, 0x00000000,
+0x2002a202, 0x0028800a, 0x028800a2, 0x28000a20, 0x8000a200, 0x800a2002,
+0x00a20028, 0x0a200288, 0xa2002880, 0x20028800, 0x0028800a, 0x420000a2,
+0x00000a88, 0x00000000, 0x00602012, 0x06080182, 0x60801820, 0x08018200,
+0x88182006, 0x01820060, 0x18200608, 0x82006080, 0x20060801, 0x00608018,
+0x06080182, 0x00801820, 0x00000008, 0x00000000, 0x80400012, 0x84020100,
+0x40201008, 0x02010080, 0x20100804, 0x01008040, 0x10080402, 0x00804020,
+0x08040201, 0x80402010, 0x04022100, 0x00201008, 0x00000000, 0x00000000,
+0xc062a202, 0x262b018a, 0x62b018ac, 0x2b098a82, 0xb098ac06, 0x098ac262,
+0x188c062b, 0x8ac062b0, 0xa8062b01, 0xc062b098, 0x062b018a, 0x02b098ac,
+0x00000a88, 0x00000000, 0x24628000, 0x0638118e, 0x638818e2, 0x38818e70,
+0x8818e286, 0x818e2063, 0x18ca0638, 0x8e206388, 0xe6463881, 0x20638818,
+0x4638818e, 0x039918e2, 0x00000000, 0x00000000, 0x40628002, 0x0639018e,
+0x639018e4, 0x3b818e40, 0x9018e406, 0x018e6063, 0x18e40639, 0x8e406398,
+0xe4063901, 0x40639018, 0x0639818e, 0x038018e4, 0x00000000, 0x00000000,
+0xa062a20a, 0x063a818e, 0x63a818ea, 0x13898ea0, 0xa818ea06, 0x818ea263,
+0x98ea063a, 0x8ea263a8, 0xea063a81, 0xa063a898, 0x063a898e, 0x430818ea,
+0x00000a88, 0x00000000, 0x80480002, 0x04120124, 0x41201048, 0x12010480,
+0x20104804, 0x01048041, 0x10480412, 0x04804120, 0x48049201, 0x80412010,
+0x04920104, 0x03a01248, 0x00000200, 0x00000000, 0x00608002, 0x06180186,
+0x61801860, 0x18018600, 0x80186006, 0x01862061, 0x18600618, 0x86006180,
+0x60061801, 0x00618018, 0x06188186, 0x01881860, 0x00000080, 0x00000000,
+0x20068200, 0x0078801e, 0x0788014a, 0x78001e20, 0x8801e200, 0x801c0007,
+0x01e20078, 0x1e200700, 0xe2007880, 0x20078801, 0x0078001e, 0x038801e2,
+0x00000a08, 0x00000000, 0x00488002, 0x04180126, 0x41801060, 0x18010600,
+0x80106004, 0x01040041, 0x10600418, 0x06004100, 0x60049801, 0x00418010,
+0x04980106, 0x01801260, 0x00000000, 0x00000000, 0x20428002, 0x04108104,
+0x41081042, 0x10010420, 0x08104204, 0x81060041, 0x10420410, 0x04204180,
+0x42041081, 0x20410810, 0x04100104, 0x01081042, 0x00000000, 0x00000000,
+0x2042a202, 0x04088102, 0x40881022, 0x08010220, 0x88102204, 0x810a00c0,
+0x30220408, 0x02204288, 0x22040881, 0x20408810, 0x04080102, 0x00801022,
+0x00000a88, 0x00000000, 0x00c00002, 0x0c28030a, 0xc28030a0, 0x28030a00,
+0x8030a00c, 0x030a00c2, 0x30a00c28, 0x0a00c280, 0xa0042803, 0x00c28030,
+0x0c28030a, 0x028030a0, 0x00000000, 0x00000000, 0x00100202, 0x01080042,
+0x10800420, 0x08204200, 0x80042001, 0x00420000, 0x00200108, 0x42001080,
+0x60010800, 0x00108004, 0x01080042, 0x00800420, 0x00000000, 0x00000000,
+0x4042a202, 0x04010100, 0x40101004, 0x01010040, 0x10100404, 0x01004050,
+0x14040401, 0x00404010, 0x04040101, 0x40401010, 0x04010100, 0x00101004,
+0x00000a88, 0x00000000, 0x20028202, 0x00188006, 0x01880060, 0x18000620,
+0x88006200, 0x80062001, 0x00620018, 0x06200180, 0x62001880, 0x20018800,
+0x00188006, 0x01980062, 0x00000000, 0x00000000, 0x48028002, 0x00190006,
+0x01900066, 0x19002640, 0x90006400, 0x00060009, 0x02640019, 0x06400998,
+0x64001900, 0x40019002, 0x00198026, 0x03800064, 0x00000000, 0x00000000,
+0x2006a202, 0x0070801c, 0x070801c2, 0x70801c20, 0x0801c200, 0x801c0807,
+0x01c20070, 0x1c200708, 0xc2007080, 0x20070801, 0x0070801c, 0x018801c2,
+0x00000a88, 0x00000000, 0x0080000a, 0x0830020c, 0x830020c0, 0x30020c00,
+0x0020c008, 0x020c0083, 0x20c00830, 0x0c00a300, 0xc0083002, 0x00830038,
+0x0830028c, 0x010020c0, 0x00000000, 0x00000000, 0x00a0a002, 0x0a30028c,
+0xa30028c2, 0x3002ac00, 0x0028c00a, 0x028c00ab, 0x2ac00a30, 0x8c00ab00,
+0xc0023002, 0x00a3002a, 0x0a3082ac, 0x430828c0, 0x00000000, 0x00000000,
+0x20c2a202, 0x0c188306, 0xc1883060, 0x18830620, 0x8830620c, 0x830620c1,
+0x30620c18, 0x0620e180, 0x620c1883, 0x20c18830, 0x0c180386, 0x01883062,
+0x00000a88, 0x00000000, 0x00028002, 0x00100004, 0x01000040, 0x10008400,
+0x02004000, 0x00040011, 0x04400010, 0x04000100, 0x40001000, 0x00010008,
+0x00100004, 0x01000040, 0x00000000, 0x00000000, 0x2210a002, 0x21188846,
+0x11888460, 0x1880c622, 0x88846221, 0x88462201, 0x80622118, 0x46201180,
+0x62211888, 0x22118804, 0x211800c6, 0x01888462, 0x00000000, 0x00000000,
+0x2002a202, 0xa028800a, 0x028880a0, 0x28880a2a, 0x8880a220, 0x880a2202,
+0x80a22028, 0x0a228288, 0xa2a02888, 0x22028880, 0x0028080a, 0x028000a2,
+0x00000a88, 0x00000000, 0x04120002, 0x01081042, 0x10810420, 0x08004200,
+0x80042040, 0x004a0010, 0x04204108, 0x42041281, 0x20410810, 0x04108004,
+0x41081042, 0x00810420, 0x00000000, 0x00000000, 0x80508200, 0x05020140,
+0x50201408, 0x02014080, 0x20140805, 0x01400050, 0x14080502, 0x40805020,
+0x08050201, 0x80502014, 0x05020140, 0x00201408, 0x00000000, 0x00000000,
+0xc0b2a202, 0x0b2b02ca, 0xb2b02cac, 0x2b02cac0, 0xb02cac0b, 0x02c800b2,
+0x2cac0b2b, 0xcac0b290, 0xac0b2b02, 0xc0b2b02c, 0x0b2302ca, 0x02b02cac,
+0x00000a88, 0x00000000, 0x20120002, 0x0138804e, 0x138800e2, 0x38404e20,
+0x8804e200, 0x804e6013, 0x04e20138, 0x0e2013a0, 0xe2003880, 0x20138804,
+0x0132804e, 0x039804e2, 0x00000000, 0x00000000, 0x10c40000, 0x8c484312,
+0xc4863120, 0x48230208, 0x8231218c, 0x231208c0, 0x30218c48, 0x1218c086,
+0x210c4863, 0x18c48230, 0x0c486302, 0x00803121, 0x00000000, 0x00000000,
+0xfffc0000, 0xffcbfff2, 0xfcbfff2f, 0xcbfff2ff, 0xbfff2fff, 0xfff2fffc,
+0xff2fffcb, 0xf2fffcbf, 0x2fffcbff, 0xfffcbfff, 0xffcbfff2, 0x00bfff2f,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xdfb40000, 0xb3437ed0,
+0x3436cd2f, 0x4bedf2fb, 0xbecd0db3, 0xecd2fb34, 0xcd0db34b, 0xd0db7c36,
+0x0db3436c, 0xdb34bedf, 0xfb436df0, 0x0037ed0d, 0x00000000, 0x00000000,
+0x3fcc0000, 0xccc8ff32, 0xcc8f332f, 0xcbf3f2fc, 0xbf3323cc, 0xf332fccc,
+0x3323cccb, 0x323cfc8f, 0x23ccc8f3, 0x3cccbf3f, 0xfcc8f3f2, 0x008ff323,
+0x00000000, 0x00000000, 0x7edc0000, 0xedc9fb72, 0xdc9fb727, 0xc9fb727e,
+0x9fb727ed, 0xfb727ec4, 0xb127edc9, 0x727edc9f, 0x278dc9fb, 0x7edc9fb7,
+0xedc9fb72, 0x0087b727, 0x00000000, 0x00000000, 0x65000000, 0x10508c20,
+0x422ac04a, 0x00843021, 0x08504a14, 0x84202140, 0x50821010, 0x00214018,
+0x02100185, 0x61423850, 0x14508120, 0x00085002, 0x00000000, 0x00000000,
+0xa0024000, 0x00618818, 0x0108208e, 0x00800820, 0x08008220, 0x80482011,
+0x04420162, 0x58201228, 0x02012280, 0xa0100804, 0x05308848, 0x00080682,
+0x00000920, 0x00000000, 0xe3000000, 0x20128c24, 0x032ac04a, 0x908d1423,
+0x08c64a10, 0x8d342302, 0x42422011, 0x24230118, 0x4234518c, 0x21010842,
+0x30708c34, 0x00084042, 0x00000000, 0x00000000, 0xe0100800, 0x21128060,
+0x1f28040e, 0x90814420, 0x08040a01, 0x8140201c, 0x06c22150, 0x64201d18,
+0x4205c180, 0x601e3806, 0x01b08004, 0x00080642, 0x00000000, 0x00000000,
+0x01004000, 0x14202c40, 0x00200008, 0x40080401, 0x0040c400, 0x04080100,
+0x40001100, 0x40010100, 0x40110004, 0x01113044, 0x15000444, 0x01004400,
+0x00000900, 0x00000000, 0x40400010, 0x40032900, 0x423010c4, 0x02010000,
+0x00104804, 0x01048040, 0x10800400, 0x00804000, 0x80040001, 0x00430010,
+0x00000108, 0x00001000, 0x00000000, 0x00000000, 0x83100010, 0x19920d44,
+0x112014c8, 0x010c6403, 0x0005c421, 0x0c784318, 0x44401580, 0x40031100,
+0x4031800c, 0x01130046, 0x21d00c64, 0x41004640, 0x00000000, 0x00000000,
+0x80100000, 0x41830044, 0x18300480, 0x41004400, 0x0005c021, 0x00480014,
+0x06000140, 0x60401800, 0x40010000, 0x00183004, 0x21100060, 0x41000440,
+0x00000000, 0x00000000, 0x21102010, 0x1501854c, 0x50085442, 0xa0854021,
+0x08540615, 0x85402151, 0x54021511, 0x40615008, 0x4215d085, 0x61510854,
+0x25238540, 0x40085482, 0x00000080, 0x00000000, 0xa0100010, 0x2183a05c,
+0x1b2a048a, 0x92807420, 0x0806ca01, 0x80402015, 0x040201f2, 0x60a01008,
+0x82010080, 0xa0130805, 0x0130804c, 0x020805c2, 0x00000000, 0x00000000,
+0x62400010, 0x5043881c, 0x09184042, 0x118c2021, 0x2840c210, 0x84242103,
+0x41421011, 0x20610908, 0x42101084, 0x61090842, 0x00708424, 0x410842c2,
+0x00000000, 0x00000000, 0xe2040800, 0x00b28004, 0x0a180246, 0xb1800820,
+0x28034e00, 0x80042001, 0x03420030, 0x2ca00908, 0x8e003388, 0x200b0802,
+0x00938008, 0x433800ce, 0x00000020, 0x00000000, 0xa1000010, 0x5802a000,
+0x0918408e, 0x63841821, 0x08400e10, 0x84206108, 0x40821010, 0x00210e08,
+0x04108084, 0x210f0840, 0x10608418, 0x4008408e, 0x00000000, 0x00000000,
+0x80440000, 0x24e02100, 0x4430108e, 0x90810c00, 0x00104204, 0x01188042,
+0x10400490, 0x00004300, 0x0a042201, 0x00410010, 0x0410012c, 0x0000128a,
+0x00000000, 0x00000000, 0xc1400000, 0x10120410, 0x0132834a, 0x30801401,
+0x0040c210, 0x04044101, 0x40801010, 0x10010300, 0x46101008, 0x81030043,
+0x30700404, 0x00004246, 0x00000000, 0x00000000, 0x80030800, 0x00122010,
+0x0130018c, 0x10000800, 0x00024000, 0x00044009, 0x02000070, 0x20000300,
+0x42009100, 0x80030002, 0x00300008, 0x000002c8, 0x00000420, 0x00000000,
+0x0808000c, 0x04020002, 0x0b000800, 0x02080200, 0x00000104, 0x0801000b,
+0x00010000, 0x00040b00, 0x01000008, 0x000b0000, 0x00000800, 0x33000001,
+0x00000000, 0x00000000, 0x0308040c, 0x00000101, 0x09080808, 0x0001010b,
+0x08000800, 0x05010b09, 0x000a0000, 0x01030908, 0x0a000005, 0x03090800,
+0x00000503, 0x3108000a, 0x00000010, 0x00000000, 0xced7e000, 0xf8014f19,
+0x9a481a7f, 0x02000201, 0x00080194, 0x00030000, 0x0c000c03, 0x03000000,
+0x000c0300, 0x9800000c, 0x0c020000, 0x00000c00, 0x00000f80, 0x00000000,
+0x0da00000, 0x280303b1, 0x01402208, 0x00000100, 0x02000000, 0x00000000,
+0x08000800, 0x00000000, 0x00000100, 0x00000088, 0x00010000, 0x00000000,
+0x00000000, 0x00000000, 0x82280000, 0x11118713, 0x01414081, 0x44000000,
+0x00000100, 0x00000000, 0x00030044, 0x00000002, 0x01004400, 0x00000000,
+0x00440000, 0x00020002, 0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff,
+0xf4000000, 0x03ffffff, 0x00000000, 0xfffffffc, 0x00000001, 0xfbfffc00,
+0x000000ff, 0xfffc0000, 0x0000fffe, 0x00000000, 0x00000000, 0x00000000,
+0xfffc0000, 0x0003ffff, 0xf4000000, 0x03efffff, 0x00000000, 0xfef7fbfc,
+0x00000003, 0xfffffc00, 0x000001fe, 0xfffc0000, 0x0003fdff, 0x00000000,
+0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff, 0xf8000000, 0x03fbfffb,
+0x00000000, 0xfbfffffc, 0x00000003, 0xfffffc00, 0x000003f3, 0xf7fc0000,
+0x0003f3ff, 0x00000000, 0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff,
+0xfc000000, 0x03bfdfef, 0x00000000, 0xefe7fffc, 0x00000003, 0xf7fffc00,
+0x000003df, 0xfffc0000, 0x0003fcf7, 0x00000000, 0x00000000, 0x00000000,
+0xfffc0000, 0x0003ffff, 0xfc000000, 0x03ffffbf, 0x00000000, 0xfffdfffc,
+0x00000003, 0xfffffc00, 0x000003ff, 0xfffc0000, 0x00037fff, 0x00000000,
+0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff, 0xfc000000, 0x03ffffff,
+0x00000000, 0xfffffffc, 0x00000003, 0xfffffc00, 0x000003ff, 0xfffc0000,
+0x00037fff, 0x00000000, 0x00000000, 0x00000000, 0x62000000, 0x14308420,
+0x4138800e, 0x238c3021, 0x08104234, 0x8534e341, 0xd182b410, 0x10214408,
+0x0614808d, 0x20440850, 0x14530518, 0x00089002, 0x00000000, 0x00000000,
+0xe2000000, 0x00a28000, 0x0038000a, 0xb3805020, 0x18028200, 0x80542012,
+0x04420020, 0x40200208, 0x0a01a080, 0x22000802, 0x01708004, 0x00080202,
+0x00000000, 0x00000000, 0xa1100000, 0x11538464, 0x1928544e, 0x308d4421,
+0x28c44211, 0x84402319, 0x44823010, 0x00210108, 0x4631508c, 0x230008c0,
+0x10108400, 0x00080002, 0x00000000, 0x00000000, 0x60100000, 0x01a08164,
+0x1928144a, 0x33884422, 0x08044201, 0x8844e019, 0x06820140, 0x40201908,
+0x460110a0, 0x20180806, 0x01808040, 0x00080602, 0x00000000, 0x00000000,
+0x02000000, 0x10100428, 0x01008040, 0x500c0401, 0x00c04030, 0x04000310,
+0x80003041, 0x50010100, 0x0811010c, 0x41112044, 0x11100454, 0x00004400,
+0x00000000, 0x00000000, 0x82400010, 0x04230104, 0x4210904c, 0x01010840,
+0x00108004, 0x01048040, 0x90000402, 0x00004200, 0x00040201, 0x80421010,
+0x04000108, 0x40001000, 0x00000000, 0x00000000, 0x41500010, 0x2112014c,
+0x11209444, 0x920d7481, 0x20c74011, 0x06704318, 0x47003181, 0x70011900,
+0x4821800c, 0x431122c7, 0x11900474, 0x4100c700, 0x00000000, 0x00000000,
+0x00100010, 0x21830044, 0x1020844c, 0x12085002, 0x20040001, 0x08580010,
+0x04000180, 0x50001000, 0x40210000, 0x00102004, 0x01000054, 0x41000400,
+0x00000000, 0x00000000, 0x20100010, 0x11028448, 0x5608440a, 0x028c4c21,
+0x08d44631, 0x8444e153, 0x55023520, 0x44235238, 0x0e55d084, 0x21580855,
+0x15e38d48, 0x41085502, 0x00000000, 0x00000000, 0x62100010, 0x05018174,
+0x1d28144e, 0x72816c00, 0x0804ca21, 0x80642017, 0x04420112, 0x6c201708,
+0x4201a081, 0x20180884, 0x01a08064, 0x42080602, 0x00000000, 0x00000000,
+0xa1000010, 0x24828510, 0x0118508a, 0x500d0c23, 0x0ac24230, 0x8d082307,
+0xc0021071, 0x0c230b08, 0xc030108d, 0x21080a40, 0x10100000, 0x41084002,
+0x00000000, 0x00000000, 0xe0480810, 0x20b3812c, 0x0b08128e, 0xa08808c0,
+0x38008600, 0x8104e00a, 0x00820010, 0x10e00038, 0xc2003380, 0xe0033800,
+0x0000a014, 0x423800ce, 0x00000020, 0x00000000, 0x22000010, 0x14028024,
+0x04380006, 0x118d1c21, 0x08c00630, 0x84002102, 0x42023072, 0x00230508,
+0x02108185, 0x61040842, 0x10008c10, 0x40084242, 0x00000000, 0x00000000,
+0xc2400000, 0x00210000, 0x4a20008c, 0x73802c00, 0x12120820, 0x81300041,
+0x10000402, 0x1000c900, 0x000c0200, 0x80481080, 0x04020104, 0x00001180,
+0x00000000, 0x00000000, 0x81440000, 0x14520424, 0x0920434c, 0x508c0c03,
+0x20c04430, 0x8c040305, 0xc24010c0, 0x00030300, 0x4030000c, 0x01012042,
+0x10410c00, 0x00004240, 0x00000000, 0x00000000, 0x40050800, 0x04900114,
+0x01200244, 0x13890800, 0x00014004, 0x00040007, 0x01400032, 0x00000300,
+0x40008000, 0x40010011, 0x00810008, 0x00000000, 0x00000420, 0x00000000,
+0x08080000, 0x00000802, 0x0b000401, 0x00000000, 0x00000000, 0x0800000b,
+0x00010000, 0x00000b00, 0x01000008, 0x000b0000, 0x00000800, 0x03000001,
+0x00000000, 0x00000000, 0x03083c3c, 0x00000501, 0x0908080a, 0x00050303,
+0x08000a00, 0x05030309, 0x000a0000, 0x010f0908, 0x0a000005, 0x0b090800,
+0x00000503, 0xf108000a, 0x000000f0, 0x00000000, 0x7b1c0000, 0xdc00fb8d,
+0x01f35c9c, 0x03980300, 0x01900000, 0x00030000, 0x0c000403, 0x03000000,
+0x00000300, 0x00000000, 0x0c030001, 0x00000c00, 0x00000000, 0x00000000,
+0x82e80000, 0x5002a165, 0x0030cc35, 0x01000000, 0x00800008, 0x00010000,
+0x08000001, 0x01000000, 0x02080100, 0x00000008, 0x08010001, 0x00008800,
+0x00000000, 0x00000000, 0x24180000, 0x15101b22, 0x01142921, 0x44000000,
+0x00000100, 0x00000000, 0x00010044, 0x00000001, 0x00004400, 0x00000200,
+0x00440000, 0x00000001, 0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff,
+0x78000000, 0x03ef7be7, 0x00000000, 0x7ffffff8, 0x00000003, 0x677e7c00,
+0x0000026f, 0x6bfc0000, 0x0002fff5, 0x00000000, 0x00000000, 0x00000000,
+0xfffc0000, 0x0003ffff, 0x78000000, 0x03eb7fef, 0x00000000, 0xe7e66e7c,
+0x00000003, 0x777ffc00, 0x000003fd, 0x5cfc0000, 0x0003fefe, 0x00000000,
+0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff, 0xf8000000, 0x03fbfbf7,
+0x00000000, 0xf3f1f9f4, 0x00000003, 0xfdf3f800, 0x000003f2, 0xfdf80000,
+0x0003fefd, 0x00000000, 0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff,
+0xfc000000, 0x035fffff, 0x00000000, 0xfffffffc, 0x00000003, 0xfffffc00,
+0x000003ff, 0xfffc0000, 0x0000fff7, 0x00000000, 0x00000000, 0x00000000,
+0xfffc0000, 0x0003ffff, 0x9c000000, 0x03bfffdf, 0x00000000, 0xfffffffc,
+0x00000001, 0xffbffc00, 0x000003ff, 0xfffc0000, 0x0003ffff, 0x00000000,
+0x00000000, 0x00000000, 0xfffc0000, 0x0003ffff, 0xfc000000, 0x03bfffff,
+0x00000000, 0xffffbffc, 0x00000003, 0xfffffc00, 0x000003ff, 0xfffc0000,
+0x0003ffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x8004000c, 0x00000040, 0x71c2000c, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x8004000c, 0x00004040, 0x01c2000c, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x8000000c, 0x18c80000, 0x8001000c, 0xc0000000, 0x7002000c, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+0x00000000, 0x8001000c, 0xa0000000, 0x8005000c, 0x00000000, 0x8000000c,
+0xe9d60000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+};
diff -Nru a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
--- a/sound/pci/rme9652/rme9652.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/rme9652/rme9652.c	Thu Jun 20 15:54:01 2002
@@ -303,11 +303,11 @@
 	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
 };
 
-#define RME9652_PREALLOCATE_MEMORY	/* via module snd-rme9652_mem */
+#define RME9652_PREALLOCATE_MEMORY	/* via module snd-hammerfall-mem */
 
 #ifdef RME9652_PREALLOCATE_MEMORY
-extern void *snd_rme9652_get_buffer(int card, dma_addr_t *dmaaddr);
-extern void snd_rme9652_free_buffer(int card, void *ptr);
+extern void *snd_hammerfall_get_buffer(struct pci_dev *, dma_addr_t *dmaaddr);
+extern void snd_hammerfall_free_buffer(struct pci_dev *, void *ptr);
 #endif
 
 static struct pci_device_id snd_rme9652_ids[] __devinitdata = {
@@ -479,6 +479,10 @@
 	int reject_if_open = 0;
 	int xrate;
 
+	if (!snd_rme9652_use_is_exclusive (rme9652)) {
+		return -EBUSY;
+	}
+
 	/* Changing from a "single speed" to a "double speed" rate is
 	   not allowed if any substreams are open. This is because
 	   such a change causes a shift in the location of 
@@ -522,8 +526,7 @@
 		return -EINVAL;
 	}
 
-	if (reject_if_open &&
-	    (rme9652->capture_pid >= 0 || rme9652->playback_pid >= 0)) {
+	if (reject_if_open && (rme9652->capture_pid >= 0 || rme9652->playback_pid >= 0)) {
 		spin_unlock_irq(&rme9652->lock);
 		return -EBUSY;
 	}
@@ -531,7 +534,6 @@
 	if ((restart = rme9652->running)) {
 		rme9652_stop(rme9652);
 	}
-
 	rme9652->control_register &= ~(RME9652_freq | RME9652_DS);
 	rme9652->control_register |= rate;
 	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
@@ -1823,7 +1825,7 @@
 				   rme9652->capture_buffer_unaligned,
 				   rme9652->capture_buffer_addr);
 #else
-		snd_rme9652_free_buffer(rme9652->dev, rme9652->capture_buffer_unaligned);
+		snd_hammerfall_free_buffer(rme9652->pci, rme9652->capture_buffer_unaligned);
 #endif
 	}
 
@@ -1834,7 +1836,7 @@
 				   rme9652->playback_buffer_unaligned,
 				   rme9652->playback_buffer_addr);
 #else
-		snd_rme9652_free_buffer(rme9652->dev, rme9652->playback_buffer_unaligned);
+		snd_hammerfall_free_buffer(rme9652->pci, rme9652->playback_buffer_unaligned);
 #endif
 	}
 }
@@ -1867,21 +1869,21 @@
 	cb = snd_malloc_pci_pages(rme9652->pci, RME9652_DMA_AREA_BYTES, &cb_addr);
 	pb = snd_malloc_pci_pages(rme9652->pci, RME9652_DMA_AREA_BYTES, &pb_addr);
 #else
-	cb = snd_rme9652_get_buffer(rme9652->dev, &cb_addr);
-	pb = snd_rme9652_get_buffer(rme9652->dev, &pb_addr);
+	cb = snd_hammerfall_get_buffer(rme9652->pci, &cb_addr);
+	pb = snd_hammerfall_get_buffer(rme9652->pci, &pb_addr);
 #endif
 
 	if (cb == 0 || pb == 0) {
 		if (cb) {
 #ifdef RME9652_PREALLOCATE_MEMORY
-			snd_rme9652_free_buffer(rme9652->dev, cb);
+			snd_hammerfall_free_buffer(rme9652->pci, cb);
 #else
 			snd_free_pci_pages(rme9652->pci, RME9652_DMA_AREA_BYTES, cb, cb_addr);
 #endif
 		}
 		if (pb) {
 #ifdef RME9652_PREALLOCATE_MEMORY
-			snd_rme9652_free_buffer(rme9652->dev, pb);
+			snd_hammerfall_free_buffer(rme9652->pci, pb);
 #else
 			snd_free_pci_pages(rme9652->pci, RME9652_DMA_AREA_BYTES, pb, pb_addr);
 #endif
@@ -2232,6 +2234,9 @@
 			    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 				rme9652_silence_playback(rme9652);
 		}
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) 
+			rme9652_silence_playback(rme9652);
 	}
  _ok:
 	snd_pcm_trigger_done(substream, substream);
@@ -2544,6 +2549,20 @@
 	rme9652->irq = -1;
 	rme9652->card = card;
 
+	pci_read_config_word(rme9652->pci, PCI_CLASS_REVISION, &rev);
+
+	switch (rev & 0xff) {
+	case 3:
+	case 4:
+	case 8:
+	case 9:
+		break;
+
+	default:
+		/* who knows? */
+		return -ENODEV;
+	}
+
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 
@@ -2555,18 +2574,17 @@
 		return -EBUSY;
 	}
 
-	if (request_irq(pci->irq, snd_rme9652_interrupt, SA_INTERRUPT|SA_SHIRQ, "rme9652", (void *)rme9652)) {
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
-		return -EBUSY;
-	}
-	rme9652->irq = pci->irq;
-
 	rme9652->iobase = (unsigned long) ioremap_nocache(rme9652->port, RME9652_IO_EXTENT);
 	if (rme9652->iobase == 0) {
 		snd_printk("unable to remap region 0x%lx-0x%lx\n", rme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);
 		return -EBUSY;
 	}
 	
+	if (request_irq(pci->irq, snd_rme9652_interrupt, SA_INTERRUPT|SA_SHIRQ, "rme9652", (void *)rme9652)) {
+		snd_printk("unable to request IRQ %d\n", pci->irq);
+		return -EBUSY;
+	}
+	rme9652->irq = pci->irq;
 	rme9652->precise_ptr = precise_ptr;
 
 	/* Determine the h/w rev level of the card. This seems like
@@ -2588,9 +2606,7 @@
 	   relevant.  
 	*/
 
-	pci_read_config_word(rme9652->pci, PCI_CLASS_REVISION, &rev);
-	strcpy(card->driver, "RME9652");
-	switch (rev & 0xff) {
+	switch (rev) {
 	case 8: /* original eprom */
 		strcpy(card->driver, "RME9636");
 		if (rme9652->hw_rev == 15) {
@@ -2606,11 +2622,12 @@
 		rme9652->ss_channels = RME9636_NCHANNELS;
 		break;
 	case 4: /* W52_G EPROM */
+		strcpy(card->driver, "RME9652");
 		rme9652->card_name = "RME Digi9652 (Rev G)";
 		rme9652->ss_channels = RME9652_NCHANNELS;
 		break;
-	default:
 	case 3: /* original eprom */
+		strcpy(card->driver, "RME9652");
 		if (rme9652->hw_rev == 15) {
 			rme9652->card_name = "RME Digi9652 (Rev 1.5)";
 		} else {
diff -Nru a/sound/pci/rme9652/rme9652_mem.c b/sound/pci/rme9652/rme9652_mem.c
--- a/sound/pci/rme9652/rme9652_mem.c	Thu Jun 20 15:54:00 2002
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,278 +0,0 @@
-/* 
-    ALSA memory allocation module for the RME Digi9652
-  
- 	Copyright(c) 1999 IEM - Winfried Ritsch
-        Copyright (C) 1999 Paul Barton-Davis 
-
-    This module is only needed if you compiled the rme9652 driver with
-    the PREALLOCATE_MEMORY option. It allocates the memory need to
-    run the board and holds it until the module is unloaded. Because
-    we need 2 contiguous 1.6MB regions for the board, it can be
-    a problem getting them once the system memory has become fairly
-    fragmented. 
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-
-    $Id$
-
-
-    Tue Oct 17 2000  Jaroslav Kysela <perex@suse.cz>
-    	* space is allocated only for physical devices
-        * added support for 2.4 kernels (pci_alloc_consistent)
-    
-*/
-
-#include <linux/config.h>
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <sound/initval.h>
-
-#define RME9652_CARDS			8
-#define RME9652_CHANNEL_BUFFER_SAMPLES  (16*1024)
-#define RME9652_CHANNEL_BUFFER_BYTES    (4*RME9652_CHANNEL_BUFFER_SAMPLES)
-
-/* export */
-
-static int snd_enable[8] = {1,1,1,1,1,1,1,1};
-MODULE_PARM(snd_enable, "1-" __MODULE_STRING(RME9652_CARDS) "i");
-MODULE_PARM_DESC(snd_enable, "Enable cards to allocate buffers for.");
-
-MODULE_AUTHOR("Winfried Ritsch, Paul Barton-Davis <pbd@op.net>");
-MODULE_DESCRIPTION("Memory allocator for RME Hammerfall");
-MODULE_CLASSES("{sound}");
-MODULE_LICENSE("GPL");
-
-/* Since we don't know at this point if we're allocating memory for a
-   Hammerfall or a Hammerfall/Light, assume the worst and allocate
-   space for the maximum number of channels.
-		   
-   See note in rme9652.h about why we allocate for an extra channel.  
-*/
-
-#define TOTAL_SIZE (26+1)*(RME9652_CHANNEL_BUFFER_BYTES)
-#define NBUFS   2*RME9652_CARDS
-
-#define RME9652_BUF_ALLOCATED 0x1
-#define RME9652_BUF_USED      0x2
-
-typedef struct rme9652_buf_stru rme9652_buf_t;
-
-struct rme9652_buf_stru {
-	struct pci_dev *pci;
-	void *buf;
-	dma_addr_t addr;
-	char flags;
-};
-
-static rme9652_buf_t rme9652_buffers[NBUFS];
-
-/* These are here so that we have absolutely no dependencies on any
-   other modules. Dependencies can (1) cause us to lose in the rush
-   for 2x 1.6MB chunks of contiguous memory and (2) make driver
-   debugging difficult because unloading and reloading the snd module
-   causes us to have to do the same for this one. Since on 2.2
-   kernels, and before, we can rarely if ever allocate memory after
-   starting things running, this would be bad.
-*/
-
-/* remove hack for pci_alloc_consistent to avoid dependecy on snd module */
-#ifdef HACK_PCI_ALLOC_CONSISTENT
-#undef pci_alloc_consistent
-#endif
-
-static void *rme9652_malloc_pages(struct pci_dev *pci,
-				  unsigned long size,
-				  dma_addr_t *dmaaddr)
-{
-	void *res;
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 3, 0)
-	res = (void *) pci_alloc_consistent(pci, size, dmaaddr);
-#else
-	int pg;
-	for (pg = 0; PAGE_SIZE * (1 << pg) < size; pg++);
-	res = (void *)__get_free_pages(GFP_KERNEL, pg);
-	if (res != NULL)
-		*dmaaddr = virt_to_bus(res);
-#endif
-	if (res != NULL) {
-		struct page *page = virt_to_page(res);
-		struct page *last_page = page + (size + PAGE_SIZE - 1) / PAGE_SIZE;
-		while (page < last_page)
-			set_bit(PG_reserved, &(page++)->flags);
-	}
-	return res;
-}
-
-static void rme9652_free_pages(struct pci_dev *pci, unsigned long size,
-			       void *ptr, dma_addr_t dmaaddr)
-{
-	struct page *page, *last_page;
-
-	if (ptr == NULL)
-		return;
-	page = virt_to_page(ptr);
-	last_page = virt_to_page(ptr) + (size + PAGE_SIZE - 1) / PAGE_SIZE;
-	while (page < last_page)
-		clear_bit(PG_reserved, &(page++)->flags);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 3, 0)
-	pci_free_consistent(pci, size, ptr, dmaaddr);
-#else
-	{
-		int pg;
-		for (pg = 0; PAGE_SIZE * (1 << pg) < size; pg++);
-		if (bus_to_virt(dmaaddr) != ptr) {
-			printk(KERN_ERR "rme9652_free_pages: dmaaddr != ptr\n");
-			return;
-		}
-		free_pages((unsigned long)ptr, pg);
-	}
-#endif
-}
-
-void *snd_rme9652_get_buffer (int card, dma_addr_t *dmaaddr)
-
-{
-	int i;
-	rme9652_buf_t *rbuf;
-
-	if (card < 0 || card >= RME9652_CARDS) {
-		printk(KERN_ERR "snd_rme9652_get_buffer: card %d is out of range", card);
-		return NULL;
-	}
-	for (i = card * 2; i < card * 2 + 2; i++) {
-		rbuf = &rme9652_buffers[i];
-		if (rbuf->flags == RME9652_BUF_ALLOCATED) {
-			rbuf->flags |= RME9652_BUF_USED;
-			MOD_INC_USE_COUNT;
-			*dmaaddr = rbuf->addr;
-			return rbuf->buf;
-		}
-	}
-
-	return NULL;
-}
-
-void snd_rme9652_free_buffer (int card, void *addr)
-
-{
-	int i;
-	rme9652_buf_t *rbuf;
-
-	if (card < 0 || card >= RME9652_CARDS) {
-		printk(KERN_ERR "snd_rme9652_get_buffer: card %d is out of range", card);
-		return;
-	}
-	for (i = card * 2; i < card * 2 + 2; i++) {
-		rbuf = &rme9652_buffers[i];
-		if (rbuf->buf == addr) {
-			MOD_DEC_USE_COUNT;
-			rbuf->flags &= ~RME9652_BUF_USED;
-			return;
-		}
-	}
-
-	printk ("RME9652 memory allocator: unknown buffer address passed to free buffer");
-}
-
-static void __exit rme9652_free_buffers (void)
-
-{
-	int i;
-	rme9652_buf_t *rbuf;
-
-	for (i = 0; i < NBUFS; i++) {
-
-		/* We rely on general module code to prevent
-		   us from being unloaded with buffers in use.
-
-		   However, not quite. Do not release memory
-		   if it is still marked as in use. This might
-		   be unnecessary.
-		*/
-
-		rbuf = &rme9652_buffers[i];
-
-		if (rbuf->flags == RME9652_BUF_ALLOCATED) {
-			rme9652_free_pages (rbuf->pci, TOTAL_SIZE, rbuf->buf, rbuf->addr);
-			rbuf->buf = NULL;
-			rbuf->flags = 0;
-		}
-	}
-}				 
-
-static int __init alsa_rme9652_mem_init(void)
-{
-	int i;
-	struct pci_dev *pci;
-	rme9652_buf_t *rbuf;
-
-	/* make sure our buffer records are clean */
-
-	for (i = 0; i < NBUFS; i++) {
-		rbuf = &rme9652_buffers[i];
-		rbuf->pci = NULL;
-		rbuf->buf = NULL;
-		rbuf->flags = 0;
-	}
-
-	/* ensure sane values for the number of buffers */
-
-	/* Remember: 2 buffers per card, one for capture, one for
-	   playback.
-	*/
-	
-	i = 0;	/* card number */
-	rbuf = rme9652_buffers;
-	pci_for_each_dev(pci) {
-		int k;
-		if (pci->vendor != 0x10ee || pci->device != 0x3fc4)
-			continue;
-
-		if (!snd_enable[i])
-			continue;
-
-		for (k = 0; k < 2; ++k) {
-			rbuf->buf = rme9652_malloc_pages(pci, TOTAL_SIZE, &rbuf->addr);
-			if (rbuf->buf == NULL) {
-				rme9652_free_buffers();
-				printk(KERN_ERR "RME9652 memory allocator: no memory available for card %d buffer %d\n", i, k + 1);
-				return -ENOMEM;
-			}
-			rbuf->flags = RME9652_BUF_ALLOCATED;
-			rbuf++;
-		}
-		i++;
-	}
-
-	if (i == 0)
-		printk(KERN_ERR "RME9652 memory allocator: no RME9652 card found...\n");
-	
-	return 0;
-}
-
-static void __exit alsa_rme9652_mem_exit(void)
-{
-	rme9652_free_buffers();
-}
-
-module_init(alsa_rme9652_mem_init)
-module_exit(alsa_rme9652_mem_exit)
-
-EXPORT_SYMBOL(snd_rme9652_get_buffer);
-EXPORT_SYMBOL(snd_rme9652_free_buffer);
diff -Nru a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
--- a/sound/pci/trident/trident_main.c	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/trident/trident_main.c	Thu Jun 20 15:54:00 2002
@@ -3236,7 +3236,7 @@
 		}
 		memset(trident->tlb.silent_page, 0, SNDRV_TRIDENT_PAGE_SIZE);
 		for (i = 0; i < SNDRV_TRIDENT_MAX_PAGES; i++) {
-			trident->tlb.entries[i] = trident->tlb.silent_page_dmaaddr & ~(SNDRV_TRIDENT_PAGE_SIZE-1);
+			trident->tlb.entries[i] = cpu_to_le32(trident->tlb.silent_page_dmaaddr & ~(SNDRV_TRIDENT_PAGE_SIZE-1));
 			trident->tlb.shadow_entries[i] = (unsigned long)trident->tlb.silent_page;
 		}
 
diff -Nru a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
--- a/sound/pci/trident/trident_memory.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/trident/trident_memory.c	Thu Jun 20 15:54:01 2002
@@ -34,12 +34,12 @@
  * aligned pages in others
  */
 #define __set_tlb_bus(trident,page,ptr,addr) \
-	do { (trident)->tlb.entries[page] = (addr) & ~(SNDRV_TRIDENT_PAGE_SIZE-1); \
+	do { (trident)->tlb.entries[page] = cpu_to_le32((addr) & ~(SNDRV_TRIDENT_PAGE_SIZE-1)); \
 	     (trident)->tlb.shadow_entries[page] = (ptr); } while (0)
 #define __tlb_to_ptr(trident,page) \
 	(void*)((trident)->tlb.shadow_entries[page])
 #define __tlb_to_addr(trident,page) \
-	(dma_addr_t)((trident->tlb.entries[page]) & ~(SNDRV_TRIDENT_PAGE_SIZE - 1))
+	(dma_addr_t)le32_to_cpu((trident->tlb.entries[page]) & ~(SNDRV_TRIDENT_PAGE_SIZE - 1))
 
 #if PAGE_SIZE == 4096
 /* page size == SNDRV_TRIDENT_PAGE_SIZE */
diff -Nru a/sound/pci/via8233.c b/sound/pci/via8233.c
--- a/sound/pci/via8233.c	Thu Jun 20 15:54:00 2002
+++ b/sound/pci/via8233.c	Thu Jun 20 15:54:00 2002
@@ -59,6 +59,7 @@
 MODULE_PARM_DESC(snd_ac97_clock, "AC'97 codec clock (default 48000Hz).");
 MODULE_PARM_SYNTAX(snd_ac97_clock, SNDRV_ENABLED ",default:48000");
 
+
 /*
  *  Direct registers
  */
@@ -67,6 +68,13 @@
 #define PCI_DEVICE_ID_VIA_8233_5	0x3059
 #endif
 
+/* revision numbers */
+#define VIA_REV_PRE_8233	0x10	/* not in market */
+#define VIA_REV_8233C		0x20	/* 2 rec, 4 pb, 1 multi-pb */
+#define VIA_REV_8233		0x30	/* 2 rec, 4 pb, 1 multi-pb, spdif */
+#define VIA_REV_8233A		0x40	/* 1 rec, 1 multi-pb, spdf */
+#define VIA_REV_8235		0x50	/* 2 rec, 4 pb, 1 multi-pb, spdif */
+
 #define VIAREG(via, x) ((via)->port + VIA_REG_##x)
 
 /* offsets */
@@ -87,23 +95,39 @@
 #define   VIA_REG_CTRL_INT (VIA_REG_CTRL_INT_FLAG | VIA_REG_CTRL_INT_EOL | VIA_REG_CTRL_AUTOSTART)
 #define VIA_REG_OFFSET_TABLE_PTR	0x04	/* dword - channel table pointer */
 #define VIA_REG_OFFSET_CURR_PTR		0x04	/* dword - channel current pointer */
-#define VIA_REG_OFFSET_TYPE		0x08	/* long - stop index, channel type, sample rate */
+#define VIA_REG_OFFSET_STOP_IDX		0x08	/* dword - stop index, channel type, sample rate */
 #define   VIA_REG_TYPE_16BIT		0x00200000	/* RW */
 #define   VIA_REG_TYPE_STEREO		0x00100000	/* RW */
 #define VIA_REG_OFFSET_CURR_COUNT	0x0c	/* dword - channel current count (24 bit) */
 #define VIA_REG_OFFSET_CURR_INDEX	0x0f	/* byte - channel current index */
 
 #define VIA_NUM_OF_DMA_CHANNELS	2
-/* playback block */
+
+/* playback block (VT8233/8233C) - channels 0-3 (0-0x3f) */
 #define VIA_REG_PLAYBACK_STATUS		0x00	/* byte - channel status */
 #define VIA_REG_PLAYBACK_CONTROL	0x01	/* byte - channel control */
 #define VIA_REG_PLAYBACK_VOLUME_L	0x02	/* byte */
 #define VIA_REG_PLAYBACK_VOLUME_R	0x03	/* byte */
 #define VIA_REG_PLAYBACK_TABLE_PTR	0x04	/* dword - channel table pointer */
 #define VIA_REG_PLAYBACK_CURR_PTR	0x04	/* dword - channel current pointer */
-#define VIA_REG_PLAYBACK_TYPE		0x08    /* long - stop index, channel type, sample rate */ /* byte - channel type */
+#define VIA_REG_PLAYBACK_STOP_IDX	0x08    /* dword - stop index, channel type, sample rate */
 #define VIA_REG_PLAYBACK_CURR_COUNT	0x0c	/* dword - channel current count (24 bit) */
 #define VIA_REG_PLAYBACK_CURR_INDEX	0x0f	/* byte - channel current index */
+
+/* multi-channel playback */
+#define VIA_REG_MULTPLAY_STATUS		0x40	/* byte - channel status */
+#define VIA_REG_MULTPLAY_CONTROL	0x41	/* byte - channel control */
+#define VIA_REG_MULTPLAY_FORMAT		0x42	/* byte - format and channels */
+#define   VIA_REG_MULTPLAY_FMT_8BIT	0x00
+#define   VIA_REG_MULTPLAY_FMT_16BIT	0x80
+#define   VIA_REG_MULTPLAY_FMT_CH_MASK	0x70	/* # channels << 4 (valid = 1,2,4,6) */
+#define VIA_REG_MULTPLAY_SCRATCH	0x43	/* byte - nop */
+#define VIA_REG_MULTPLAY_TABLE_PTR	0x44	/* dword - channel table pointer */
+#define VIA_REG_MULTPLAY_CURR_PTR	0x44	/* dword - channel current pointer */
+#define VIA_REG_MULTPLAY_STOP_IDX	0x48    /* dword - stop index, slots */
+#define VIA_REG_MULTPLAY_CURR_COUNT	0x4c	/* dword - channel current count (24 bit) */
+#define VIA_REG_MULTIPLAY_CURR_INDEX	0x4f	/* byte - channel current index */
+
 /* capture block */
 #define VIA_REG_CAPTURE_STATUS		0x60	/* byte - channel status */
 #define VIA_REG_CAPTURE_CONTROL		0x61	/* byte - channel control */
@@ -112,9 +136,10 @@
 #define VIA_REG_CAPTURE_CHANNEL		0x63	/* byte - input select */
 #define   VIA_REG_CAPTURE_CHANNEL_MIC	0x4
 #define   VIA_REG_CAPTURE_CHANNEL_LINE	0
+#define   VIA_REG_CAPTURE_SELECT_CODEC	0x03	/* recording source codec (0 = primary) */
 #define VIA_REG_CAPTURE_TABLE_PTR	0x64	/* dword - channel table pointer */
 #define VIA_REG_CAPTURE_CURR_PTR	0x64	/* dword - channel current pointer */
-#define VIA_REG_CAPTURE_TYPE		0x68	/* byte - channel type */
+#define VIA_REG_CAPTURE_STOP_IDX	0x68	/* dword - stop index */
 #define VIA_REG_CAPTURE_CURR_COUNT	0x6c	/* dword - channel current count (24 bit) */
 #define VIA_REG_CAPTURE_CURR_INDEX	0x6f	/* byte - channel current index */
 /* AC'97 */
@@ -272,7 +297,7 @@
 			port,
 			inb(port + VIA_REG_OFFSET_STATUS),
 			inb(port + VIA_REG_OFFSET_CONTROL),
-			inl(port + VIA_REG_OFFSET_TYPE),
+			inl(port + VIA_REG_OFFSET_STOP_IDX),
 			inl(port + VIA_REG_OFFSET_CURR_PTR),
 			inl(port + VIA_REG_OFFSET_CURR_COUNT));
 }
@@ -332,10 +357,27 @@
 
 	snd_via8233_channel_reset(chip, viadev);
 	outl(viadev->table_addr, port + VIA_REG_OFFSET_TABLE_PTR);
-	outl((runtime->format == SNDRV_PCM_FORMAT_S16_LE ? VIA_REG_TYPE_16BIT : 0) |
-	     (runtime->channels > 1 ? VIA_REG_TYPE_STEREO : 0) |
-			0xff000000,    /* STOP index is never reached */
-			port + VIA_REG_OFFSET_TYPE);
+	if (viadev->reg_offset == VIA_REG_MULTPLAY_STATUS) {
+		unsigned int slots;
+		int fmt = (runtime->format == SNDRV_PCM_FORMAT_S16_LE) ? VIA_REG_MULTPLAY_FMT_16BIT : VIA_REG_MULTPLAY_FMT_8BIT;
+		fmt |= runtime->channels << 4;
+		outb(fmt, chip->port + VIA_REG_MULTPLAY_FORMAT);
+		/* set sample number to slot 3, 4, 7, 8, 6, 9 */
+		switch (runtime->channels) {
+		case 1: slots = (1<<0); break;
+		case 2: slots = (1<<0) | (2<<4); break;
+		case 4: slots = (1<<0) | (2<<4) | (3<<8) | (4<<12);
+		case 6: slots = (1<<0) | (2<<4) | (5<<8) | (6<<12) | (3<<16) | (4<<20); break;
+		default: slots = 0;
+		}
+		/* STOP index is never reached */
+		outl(0xff000000 | slots, chip->port + VIA_REG_MULTPLAY_STOP_IDX);
+	} else {
+		outl((runtime->format == SNDRV_PCM_FORMAT_S16_LE ? VIA_REG_TYPE_16BIT : 0) |
+		     (runtime->channels > 1 ? VIA_REG_TYPE_STEREO : 0) |
+		     0xff000000,    /* STOP index is never reached */
+		     port + VIA_REG_OFFSET_STOP_IDX);
+	}
 
 	if (viadev->size == viadev->fragsize) {
 		table[0] = cpu_to_le32(viadev->physbuf);
@@ -373,9 +415,9 @@
 {
 	via8233_t *chip = snd_magic_cast(via8233_t, dev_id, return);
 
-	if (inb(VIAREG(chip, PLAYBACK_STATUS)) & (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG))
+	if (inb(chip->port + chip->playback.reg_offset) & (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG))
 		snd_via8233_update(chip, &chip->playback);
-	if (inb(VIAREG(chip, CAPTURE_STATUS)) & (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG))
+	if (inb(chip->port + chip->capture.reg_offset) & (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG))
 		snd_via8233_update(chip, &chip->capture);
 }
 
@@ -413,15 +455,17 @@
 {
 	via8233_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
-	unsigned long tmp;
 
 	snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);
 	snd_via8233_setup_periods(chip, &chip->playback, substream);
-	/* I don't understand this stuff but its from the documentation and this way it works */
-	outb(0 , VIAREG(chip, PLAYBACK_VOLUME_L));
-	outb(0 , VIAREG(chip, PLAYBACK_VOLUME_R));
-	tmp = inl(VIAREG(chip, PLAYBACK_TYPE)) & ~0xfffff;
-	outl(tmp | (0xffff * runtime->rate)/(48000/16), VIAREG(chip, PLAYBACK_TYPE));
+	if (chip->playback.reg_offset != VIA_REG_MULTPLAY_STATUS) {
+		unsigned int tmp;
+		/* I don't understand this stuff but its from the documentation and this way it works */
+		outb(0 , VIAREG(chip, PLAYBACK_VOLUME_L));
+		outb(0 , VIAREG(chip, PLAYBACK_VOLUME_R));
+		tmp = inl(VIAREG(chip, PLAYBACK_STOP_IDX)) & ~0xfffff;
+		outl(tmp | (0xffff * runtime->rate)/(48000/16), VIAREG(chip, PLAYBACK_STOP_IDX));
+	}
 	return 0;
 }
 
@@ -474,7 +518,7 @@
 	rate_min:		8000,
 	rate_max:		48000,
 	channels_min:		1,
-	channels_max:		2,
+	channels_max:		6,
 	buffer_bytes_max:	128 * 1024,
 	period_bytes_min:	32,
 	period_bytes_max:	128 * 1024,
@@ -502,6 +546,18 @@
 	fifo_size:		0,
 };
 
+static unsigned int channels[] = {
+	1, 2, 4, 6
+};
+
+#define CHANNELS sizeof(channels) / sizeof(channels[0])
+
+static snd_pcm_hw_constraint_list_t hw_constraints_channels = {
+	count: CHANNELS,
+	list: channels,
+	mask: 0,
+};
+
 static int snd_via8233_playback_open(snd_pcm_substream_t * substream)
 {
 	via8233_t *chip = snd_pcm_substream_chip(substream);
@@ -515,6 +571,7 @@
 		runtime->hw.rate_min = 48000;
 	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
 		return err;
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels);
 	return 0;
 }
 
@@ -763,7 +820,14 @@
 	synchronize_irq();
 
 	/* initialize offsets */
-	chip->playback.reg_offset = VIA_REG_PLAYBACK_STATUS;
+#if 0
+	chip->playback.reg_offset = VIA_REG_PLAYBACK_STATUS; /* this doesn't work on VIA8233A */
+#endif
+	/* we use multi-channel playback mode, since this mode is supported
+	 * by all VIA8233 models (and obviously suitable for our purpose).
+	 */
+	chip->playback.reg_offset = VIA_REG_MULTPLAY_STATUS;
+
 	chip->capture.reg_offset = VIA_REG_CAPTURE_STATUS;
 
 	/* allocate buffer descriptor lists */
diff -Nru a/sound/pci/ymfpci/ymfpci_main.c b/sound/pci/ymfpci/ymfpci_main.c
--- a/sound/pci/ymfpci/ymfpci_main.c	Thu Jun 20 15:54:01 2002
+++ b/sound/pci/ymfpci/ymfpci_main.c	Thu Jun 20 15:54:01 2002
@@ -453,7 +453,8 @@
 
 static void snd_ymfpci_pcm_init_voice(ymfpci_voice_t *voice, int stereo,
 				      int rate, int w_16, unsigned long addr,
-				      unsigned int end, int eff2)
+				      unsigned int end,
+				      int output_front, int output_rear)
 {
 	u32 format;
 	u32 delta = snd_ymfpci_calc_delta(rate);
@@ -499,19 +500,20 @@
 		bank->eff3_gain_end = 0;
 
 		if (!stereo) {
-			if (!eff2) {
+			if (output_front) {
 				bank->left_gain = 
 				bank->right_gain =
 				bank->left_gain_end =
 				bank->right_gain_end = cpu_to_le32(0x40000000);
-			} else {
+			}
+			if (output_rear) {
 				bank->eff2_gain =
 				bank->eff2_gain_end =
 				bank->eff3_gain =
 				bank->eff3_gain_end = cpu_to_le32(0x40000000);
 			}
 		} else {
-			if (!eff2) {
+			if (output_front) {
 				if ((voice->number & 1) == 0) {
 					bank->left_gain =
 					bank->left_gain_end = cpu_to_le32(0x40000000);
@@ -520,7 +522,8 @@
 					bank->right_gain =
 					bank->right_gain_end = cpu_to_le32(0x40000000);
 				}
-			} else {
+			}
+			if (output_rear) {
 				if ((voice->number & 1) == 0) {
 					bank->eff3_gain =
 					bank->eff3_gain_end = cpu_to_le32(0x40000000);
@@ -534,13 +537,11 @@
 	}
 }
 
-static int snd_ymfpci_ac3_init(ymfpci_t *chip)
+static int __devinit snd_ymfpci_ac3_init(ymfpci_t *chip)
 {
 	unsigned char *ptr;
 	dma_addr_t ptr_addr;
 
-	if (chip->ac3_tmp_base != NULL)
-		return -EBUSY;
 	if ((ptr = snd_malloc_pci_pages(chip->pci, 4096, &ptr_addr)) == NULL)
 		return -ENOMEM;
 
@@ -568,7 +569,7 @@
 	snd_ymfpci_writel(chip, YDSXGR_MAPOFEFFECT,
 			  snd_ymfpci_readl(chip, YDSXGR_MAPOFEFFECT) & ~(3 << 3));
 	spin_unlock_irq(&chip->reg_lock);
-	snd_ymfpci_irq_wait(chip);
+	// snd_ymfpci_irq_wait(chip);
 	if (chip->ac3_tmp_base) {
 		snd_free_pci_pages(chip->pci, 4096, chip->ac3_tmp_base, chip->ac3_tmp_base_addr);
 		chip->ac3_tmp_base = NULL;
@@ -579,7 +580,6 @@
 static int snd_ymfpci_playback_hw_params(snd_pcm_substream_t * substream,
 					 snd_pcm_hw_params_t * hw_params)
 {
-	ymfpci_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	ymfpci_pcm_t *ypcm = snd_magic_cast(ymfpci_pcm_t, runtime->private_data, return -ENXIO);
 	int err;
@@ -588,9 +588,6 @@
 		return err;
 	if ((err = snd_ymfpci_pcm_voice_alloc(ypcm, params_channels(hw_params))) < 0)
 		return err;
-	if (ypcm->spdif || ypcm->mode4ch)
-		if ((err = snd_ymfpci_ac3_init(chip)) < 0)
-			return err;
 	return 0;
 }
 
@@ -600,7 +597,6 @@
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	ymfpci_pcm_t *ypcm;
 	
-	
 	if (runtime->private_data == NULL)
 		return 0;
 	ypcm = snd_magic_cast(ymfpci_pcm_t, runtime->private_data, return -ENXIO);
@@ -616,8 +612,6 @@
 		snd_ymfpci_voice_free(chip, ypcm->voices[0]);
 		ypcm->voices[0] = NULL;
 	}
-	if (ypcm->spdif || ypcm->mode4ch)
-		snd_ymfpci_ac3_done(chip);
 	return 0;
 }
 
@@ -639,7 +633,8 @@
 					  snd_pcm_format_width(runtime->format) == 16,
 					  runtime->dma_addr,
 					  ypcm->buffer_size,
-					  ypcm->spdif || ypcm->mode4ch);
+					  ypcm->output_front,
+					  ypcm->output_rear);
 	return 0;
 }
 
@@ -842,7 +837,7 @@
 		snd_magic_kfree(ypcm);
 }
 
-static int snd_ymfpci_playback_open(snd_pcm_substream_t * substream)
+static int snd_ymfpci_playback_open_1(snd_pcm_substream_t * substream)
 {
 	ymfpci_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -862,6 +857,53 @@
 	return 0;
 }
 
+/* call with spinlock held */
+static void ymfpci_open_extension(ymfpci_t *chip)
+{
+	if (! chip->rear_opened) {
+		if (! chip->spdif_opened) /* set AC3 */
+			snd_ymfpci_writel(chip, YDSXGR_MODE,
+					  snd_ymfpci_readl(chip, YDSXGR_MODE) | (1 << 30));
+		/* enable second codec (4CHEN) */
+		snd_ymfpci_writew(chip, YDSXGR_SECCONFIG,
+				  (snd_ymfpci_readw(chip, YDSXGR_SECCONFIG) & ~0x0330) | 0x0010);
+	}
+}
+
+/* call with spinlock held */
+static void ymfpci_close_extension(ymfpci_t *chip)
+{
+	if (! chip->rear_opened) {
+		if (! chip->spdif_opened)
+			snd_ymfpci_writel(chip, YDSXGR_MODE,
+					  snd_ymfpci_readl(chip, YDSXGR_MODE) & ~(1 << 30));
+		snd_ymfpci_writew(chip, YDSXGR_SECCONFIG,
+				  (snd_ymfpci_readw(chip, YDSXGR_SECCONFIG) & ~0x0330) & ~0x0010);
+	}
+}
+
+static int snd_ymfpci_playback_open(snd_pcm_substream_t * substream)
+{
+	ymfpci_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	ymfpci_pcm_t *ypcm;
+	unsigned long flags;
+	int err;
+	
+	if ((err = snd_ymfpci_playback_open_1(substream)) < 0)
+		return err;
+	ypcm = snd_magic_cast(ymfpci_pcm_t, runtime->private_data, return 0);
+	ypcm->output_front = 1;
+	ypcm->output_rear = chip->mode_dup4ch ? 1 : 0;
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	if (ypcm->output_rear) {
+		ymfpci_open_extension(chip);
+		chip->rear_opened++;
+	}
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return 0;
+}
+
 static int snd_ymfpci_playback_spdif_open(snd_pcm_substream_t * substream)
 {
 	ymfpci_t *chip = snd_pcm_substream_chip(substream);
@@ -870,25 +912,23 @@
 	unsigned long flags;
 	int err;
 	
-	if ((err = snd_ymfpci_playback_open(substream)) < 0)
+	if ((err = snd_ymfpci_playback_open_1(substream)) < 0)
 		return err;
 	ypcm = snd_magic_cast(ymfpci_pcm_t, runtime->private_data, return 0);
-	ypcm->spdif = 1;
+	ypcm->output_front = 0;
+	ypcm->output_rear = 1;
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL,
 			  snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) | 2);
-	snd_ymfpci_writel(chip, YDSXGR_MODE,
-			  snd_ymfpci_readl(chip, YDSXGR_MODE) | (1 << 30));
+	ymfpci_open_extension(chip);
 	chip->spdif_pcm_bits = chip->spdif_bits;
 	snd_ymfpci_writel(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_pcm_bits);
+	chip->spdif_opened++;
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 
 	chip->spdif_pcm_ctl->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
 	snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |
 		       SNDRV_CTL_EVENT_MASK_INFO, &chip->spdif_pcm_ctl->id);
-
-	/* FIXME? True value is 256/48 = 5.33333 ms */
-	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME, 5333, UINT_MAX);
 	return 0;
 }
 
@@ -900,19 +940,15 @@
 	unsigned long flags;
 	int err;
 	
-	if ((err = snd_ymfpci_playback_open(substream)) < 0)
+	if ((err = snd_ymfpci_playback_open_1(substream)) < 0)
 		return err;
 	ypcm = snd_magic_cast(ymfpci_pcm_t, runtime->private_data, return 0);
-	ypcm->mode4ch = 1;
+	ypcm->output_front = 0;
+	ypcm->output_rear = 1;
 	spin_lock_irqsave(&chip->reg_lock, flags);
-	snd_ymfpci_writew(chip, YDSXGR_SECCONFIG,
-			  (snd_ymfpci_readw(chip, YDSXGR_SECCONFIG) & ~0x0030) | 0x0010);
-	snd_ymfpci_writel(chip, YDSXGR_MODE,
-			  snd_ymfpci_readl(chip, YDSXGR_MODE) | (1 << 30));
+	ymfpci_open_extension(chip);
+	chip->rear_opened++;
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
-
-	/* FIXME? True value is 256/48 = 5.33333 ms */
-	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME, 5333, UINT_MAX);
 	return 0;
 }
 
@@ -950,19 +986,34 @@
 	return snd_ymfpci_capture_open(substream, 1);
 }
 
-static int snd_ymfpci_playback_close(snd_pcm_substream_t * substream)
+static int snd_ymfpci_playback_close_1(snd_pcm_substream_t * substream)
 {
 	return 0;
 }
 
+static int snd_ymfpci_playback_close(snd_pcm_substream_t * substream)
+{
+	ymfpci_t *chip = snd_pcm_substream_chip(substream);
+	ymfpci_pcm_t *ypcm = snd_magic_cast(ymfpci_pcm_t, substream->runtime->private_data, return -ENXIO);
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	if (ypcm->output_rear && chip->rear_opened > 0) {
+		chip->rear_opened--;
+		ymfpci_close_extension(chip);
+	}
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return snd_ymfpci_playback_close_1(substream);
+}
+
 static int snd_ymfpci_playback_spdif_close(snd_pcm_substream_t * substream)
 {
 	ymfpci_t *chip = snd_pcm_substream_chip(substream);
 	unsigned long flags;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
-	snd_ymfpci_writel(chip, YDSXGR_MODE,
-			  snd_ymfpci_readl(chip, YDSXGR_MODE) & ~(1 << 30));
+	chip->spdif_opened = 0;
+	ymfpci_close_extension(chip);
 	snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL,
 			  snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) & ~2);
 	snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);
@@ -970,7 +1021,7 @@
 	chip->spdif_pcm_ctl->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
 	snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |
 		       SNDRV_CTL_EVENT_MASK_INFO, &chip->spdif_pcm_ctl->id);
-	return snd_ymfpci_playback_close(substream);
+	return snd_ymfpci_playback_close_1(substream);
 }
 
 static int snd_ymfpci_playback_4ch_close(snd_pcm_substream_t * substream)
@@ -979,12 +1030,12 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
-	snd_ymfpci_writel(chip, YDSXGR_MODE,
-			  snd_ymfpci_readl(chip, YDSXGR_MODE) & ~(1 << 30));
-	snd_ymfpci_writew(chip, YDSXGR_SECCONFIG,
-			  (snd_ymfpci_readw(chip, YDSXGR_SECCONFIG) & ~0x0330) | 0x0010);
+	if (chip->rear_opened > 0) {
+		chip->rear_opened--;
+		ymfpci_close_extension(chip);
+	}
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
-	return snd_ymfpci_playback_close(substream);
+	return snd_ymfpci_playback_close_1(substream);
 }
 
 static int snd_ymfpci_capture_close(snd_pcm_substream_t * substream)
@@ -1446,6 +1497,36 @@
 	return change;
 }
 
+/*
+ * 4ch duplication
+ */
+static int snd_ymfpci_info_dup4ch(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_ymfpci_get_dup4ch(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ymfpci_t *chip = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer.value[0] = chip->mode_dup4ch;
+	return 0;
+}
+
+static int snd_ymfpci_put_dup4ch(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ymfpci_t *chip = snd_kcontrol_chip(kcontrol);
+	int change;
+	change = (ucontrol->value.integer.value[0] != chip->mode_dup4ch);
+	if (change)
+		chip->mode_dup4ch = !!ucontrol->value.integer.value[0];
+	return change;
+}
+
+
 #define YMFPCI_CONTROLS (sizeof(snd_ymfpci_controls)/sizeof(snd_kcontrol_new_t))
 
 static snd_kcontrol_new_t snd_ymfpci_controls[] __devinitdata = {
@@ -1462,7 +1543,14 @@
 YMFPCI_DOUBLE(SNDRV_CTL_NAME_IEC958("AC97 ",PLAYBACK,VOLUME), 1, YDSXGR_SPDIFOUTVOL),
 YMFPCI_DOUBLE(SNDRV_CTL_NAME_IEC958("",CAPTURE,VOLUME), 1, YDSXGR_SPDIFLOOPVOL),
 YMFPCI_SINGLE(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH), 0, YDSXGR_SPDIFOUTCTRL),
-YMFPCI_SINGLE(SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH), 0, YDSXGR_SPDIFINCTRL)
+YMFPCI_SINGLE(SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH), 0, YDSXGR_SPDIFINCTRL),
+{
+	iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	name: "4ch Duplication",
+	info: snd_ymfpci_info_dup4ch,
+	get: snd_ymfpci_get_dup4ch,
+	put: snd_ymfpci_put_dup4ch,
+},
 };
 
 
@@ -1952,12 +2040,19 @@
 		snd_ymfpci_writew(chip, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);
 	}
 
+	snd_ymfpci_ac3_done(chip);
+
 	/* Set PCI device to D3 state */
-	// pci_set_power_state(chip->pci, 3);
+#if 0
+	/* FIXME: temporarily disabled, otherwise we cannot fire up
+	 * the chip again unless reboot.  ACPI bug?
+	 */
+	pci_set_power_state(chip->pci, 3);
+#endif
 
 #ifdef CONFIG_PM
 	if (chip->saved_regs)
-		kfree(chip->saved_regs);
+		vfree(chip->saved_regs);
 #endif
 	if (chip->reg_area_virt)
 		iounmap((void *)chip->reg_area_virt);
@@ -2150,8 +2245,11 @@
 		return -EIO;
 	}
 
+	if ((err = snd_ymfpci_ac3_init(chip)) < 0)
+		return err;
+
 #ifdef CONFIG_PM
-	chip->saved_regs = kmalloc(YDSXGR_NUM_SAVED_REGS * sizeof(u32), GFP_KERNEL);
+	chip->saved_regs = vmalloc(YDSXGR_NUM_SAVED_REGS * sizeof(u32));
 	if (chip->saved_regs == NULL) {
 		snd_ymfpci_free(chip);
 		return -ENOMEM;
diff -Nru a/sound/ppc/awacs.c b/sound/ppc/awacs.c
--- a/sound/ppc/awacs.c	Thu Jun 20 15:54:01 2002
+++ b/sound/ppc/awacs.c	Thu Jun 20 15:54:01 2002
@@ -23,6 +23,7 @@
 #define __NO_VERSION__
 #include <sound/driver.h>
 #include <asm/io.h>
+#include <asm/nvram.h>
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <sound/core.h>
@@ -31,6 +32,26 @@
 #define chip_t pmac_t
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) || defined(CONFIG_ADB_CUDA)
+#define PMAC_AMP_AVAIL
+#endif
+
+#ifdef PMAC_AMP_AVAIL
+typedef struct awacs_amp {
+	unsigned char amp_master;
+	unsigned char amp_vol[2][2];
+	unsigned char amp_tone[2];
+} awacs_amp_t;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+#define CHECK_CUDA_AMP() (adb_hardware == ADB_VIACUDA)
+#else
+#define CHECK_CUDA_AMP() (sys_ctrler == SYS_CTRLER_CUDA)
+#endif
+
+#endif /* PMAC_AMP_AVAIL */
+
+
 /*
  * write AWACS register
  */
@@ -39,9 +60,6 @@
 {
 	long timeout = 5000000;
 
-	if (chip->model <= PMAC_SCREAMER)
-		return;
-
 	while (in_le32(&chip->awacs->codec_ctrl) & MASK_NEWECMD) {
 		if (! --timeout) {
 			snd_printd("snd_pmac_awacs_write timeout\n");
@@ -65,9 +83,12 @@
 }
 
 #ifdef CONFIG_PMAC_PBOOK
-static void
-screamer_recalibrate(pmac_t *chip)
+/* Recalibrate chip */
+static void screamer_recalibrate(pmac_t *chip)
 {
+	if (chip->model != PMAC_SCREAMER)
+		return;
+
 	/* Sorry for the horrible delays... I hope to get that improved
 	 * by making the whole PM process asynchronous in a future version
 	 */
@@ -77,6 +98,9 @@
 	mdelay(1000);
 	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
 }
+
+#else
+#define screamer_recalibrate(chip) /* NOP */
 #endif
 
 
@@ -91,43 +115,6 @@
 }
 
 
-#ifdef PMAC_AMP_AVAIL
-/* Turn on sound output, needed on G3 desktop powermacs */
-/* vol = 0 - 31, stereo */
-static void
-snd_pmac_awacs_enable_amp(pmac_t *chip, int lvol, int rvol)
-{
-	struct adb_request req;
-
-	if (! chip->amp_only)
-		return;
-
-	/* turn on headphones */
-	cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,
-		     0x8a, 4, 0);
-	while (!req.complete) cuda_poll();
-	cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,
-		     0x8a, 6, 0);
-	while (!req.complete) cuda_poll();
-
-	/* turn on speaker */
-	cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,
-		     0x8a, 3, lvol & 0xff);
-	while (!req.complete) cuda_poll();
-	cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,
-		     0x8a, 5, rvol & 0xff);
-	while (!req.complete) cuda_poll();
-
-	cuda_request(&req, NULL, 5, CUDA_PACKET,
-		     CUDA_GET_SET_IIC, 0x8a, 1, 0x29);
-	while (!req.complete) cuda_poll();
-
-	/* update */
-	chip->amp_vol[0] = lvol;
-	chip->amp_vol[1] = rvol;
-}
-#endif
-
 /*
  * AWACS volume callbacks
  */
@@ -146,13 +133,13 @@
 static int snd_pmac_awacs_get_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	int n = kcontrol->private_value & 0xff;
+	int reg = kcontrol->private_value & 0xff;
 	int lshift = (kcontrol->private_value >> 8) & 0xff;
 	unsigned long flags;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
-	ucontrol->value.integer.value[0] = 0x0f - ((chip->awacs_reg[n] >> lshift) & 0xf);
-	ucontrol->value.integer.value[1] = 0x0f - (chip->awacs_reg[n] & 0xf);
+	ucontrol->value.integer.value[0] = 0x0f - ((chip->awacs_reg[reg] >> lshift) & 0xf);
+	ucontrol->value.integer.value[1] = 0x0f - (chip->awacs_reg[reg] & 0xf);
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 	return 0;
 }
@@ -160,19 +147,20 @@
 static int snd_pmac_awacs_put_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	int n = kcontrol->private_value & 0xff;
+	int reg = kcontrol->private_value & 0xff;
 	int lshift = (kcontrol->private_value >> 8) & 0xff;
-	int rn, oldval;
+	int val, oldval;
 	unsigned long flags;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
-	oldval = chip->awacs_reg[n];
-	rn = oldval & ~(0xf | (0xf << lshift));
-	rn |= ((0x0f - (ucontrol->value.integer.value[0] & 0xf)) << lshift);
-	rn |= 0x0f - (ucontrol->value.integer.value[1] & 0xf);
-	snd_pmac_awacs_write_reg(chip, n, rn);
+	oldval = chip->awacs_reg[reg];
+	val = oldval & ~(0xf | (0xf << lshift));
+	val |= ((0x0f - (ucontrol->value.integer.value[0] & 0xf)) << lshift);
+	val |= 0x0f - (ucontrol->value.integer.value[1] & 0xf);
+	if (oldval != val)
+		snd_pmac_awacs_write_reg(chip, reg, val);
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
-	return oldval != rn;
+	return oldval != reg;
 }
 
 
@@ -181,60 +169,127 @@
   info: snd_pmac_awacs_info_volume, \
   get: snd_pmac_awacs_get_volume, \
   put: snd_pmac_awacs_put_volume, \
-  private_value: (xreg) | (xshift << 8) }
+  private_value: (xreg) | ((xshift) << 8) }
 
 /*
  * mute master/ogain for AWACS: mono
  */
-static int snd_pmac_awacs_info_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
- 
 static int snd_pmac_awacs_get_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	int mask = kcontrol->private_value & 0xff;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int invert = (kcontrol->private_value >> 16) & 1;
+	int val;
 	unsigned long flags;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
-	ucontrol->value.integer.value[0] = (chip->awacs_reg[1] & mask) ? 0 : 1;
+	val = (chip->awacs_reg[reg] >> shift) & 1;
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	if (invert)
+		val = 1 - val;
+	ucontrol->value.integer.value[0] = val;
 	return 0;
 }
 
 static int snd_pmac_awacs_put_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	int mask = kcontrol->private_value & 0xff;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int invert = (kcontrol->private_value >> 16) & 1;
+	int mask = 1 << shift;
 	int val, changed;
 	unsigned long flags;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
-	val = chip->awacs_reg[1] & ~mask;
-	if (! ucontrol->value.integer.value[0])
+	val = chip->awacs_reg[reg] & ~mask;
+	if (ucontrol->value.integer.value[0] != invert)
 		val |= mask;
-	snd_pmac_awacs_write_reg(chip, 1, val);
-	changed = chip->awacs_reg[1] != val;
+	changed = chip->awacs_reg[reg] != val;
+	if (changed)
+		snd_pmac_awacs_write_reg(chip, reg, val);
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 	return changed;
 }
 
-#define AWACS_SWITCH(xname, xreg, xmask) \
+#define AWACS_SWITCH(xname, xreg, xshift, xinvert) \
 { iface: SNDRV_CTL_ELEM_IFACE_MIXER, name: xname, index: 0, \
-  info: snd_pmac_awacs_info_switch, \
+  info: snd_pmac_boolean_mono_info, \
   get: snd_pmac_awacs_get_switch, \
   put: snd_pmac_awacs_put_switch, \
-  private_value: (xreg) | ((xmask) << 8) }
+  private_value: (xreg) | ((xshift) << 8) | ((xinvert) << 16) }
 
 
 #ifdef PMAC_AMP_AVAIL
 /*
- * Master volume for awacs revision 3
+ * controls for perch/whisper extension cards, e.g. G3 desktop
+ *
+ * TDA7433 connected via i2c address 0x45 (= 0x8a),
+ * accessed through cuda
+ */
+static void awacs_set_cuda(int reg, int val)
+{
+	struct adb_request req;
+	cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC, 0x8a, reg, val);
+	while (! req.complete)
+		cuda_poll();
+}
+
+/*
+ * level = 0 - 14, 7 = 0 dB
+ */
+static void awacs_amp_set_tone(awacs_amp_t *amp, int bass, int treble)
+{
+	amp->amp_tone[0] = bass;
+	amp->amp_tone[1] = treble;
+	if (bass > 7)
+		bass = (14 - bass) + 8;
+	if (treble > 7)
+		treble = (14 - treble) + 8;
+	awacs_set_cuda(2, (bass << 4) | treble);
+}
+
+/*
+ * vol = 0 - 31 (attenuation), 32 = mute bit, stereo
+ */
+static int awacs_amp_set_vol(awacs_amp_t *amp, int index, int lvol, int rvol, int do_check)
+{
+	if (do_check && amp->amp_vol[index][0] == lvol &&
+	    amp->amp_vol[index][1] == rvol)
+		return 0;
+	awacs_set_cuda(3 + index, lvol);
+	awacs_set_cuda(5 + index, rvol);
+	amp->amp_vol[index][0] = lvol;
+	amp->amp_vol[index][1] = rvol;
+	return 1;
+}
+
+/*
+ * 0 = -79 dB, 79 = 0 dB, 99 = +20 dB
+ */
+static void awacs_amp_set_master(awacs_amp_t *amp, int vol)
+{
+	amp->amp_master = vol;
+	if (vol <= 79)
+		vol = 32 + (79 - vol);
+	else
+		vol = 32 - (vol - 79);
+	awacs_set_cuda(1, vol);
+}
+
+static void awacs_amp_free(pmac_t *chip)
+{
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return);
+	kfree(amp);
+	chip->mixer_data = NULL;
+	chip->mixer_free = NULL;
+}
+
+
+/*
+ * mixer controls
  */
 static int snd_pmac_awacs_info_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
 {
@@ -248,57 +303,273 @@
 static int snd_pmac_awacs_get_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	ucontrol->value.integer.value[0] = chip->amp_vol[0];
-	ucontrol->value.integer.value[1] = chip->amp_vol[1];
+	int index = kcontrol->private_value;
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+	ucontrol->value.integer.value[0] = 31 - (amp->amp_vol[index][0] & 31);
+	ucontrol->value.integer.value[1] = 31 - (amp->amp_vol[index][1] & 31);
 	return 0;
 }
 
 static int snd_pmac_awacs_put_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	int changed = ucontrol->value.integer.value[0] != chip->amp_vol[0] ||
-		ucontrol->value.integer.value[1] != chip->amp_vol[1];
-	snd_pmac_awacs_enable_amp(chip,
-				  ucontrol->value.integer.value[0],
-				  ucontrol->value.integer.value[1]);
-	return changed;
+	int index = kcontrol->private_value;
+	int vol[2];
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+
+	vol[0] = (31 - (ucontrol->value.integer.value[0] & 31)) | (amp->amp_vol[index][0] & 32);
+	vol[1] = (31 - (ucontrol->value.integer.value[1] & 31)) | (amp->amp_vol[index][1] & 32);
+	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
 }
+
+static int snd_pmac_awacs_get_switch_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+	ucontrol->value.integer.value[0] = (amp->amp_vol[index][0] & 32) ? 0 : 1;
+	ucontrol->value.integer.value[1] = (amp->amp_vol[index][1] & 32) ? 0 : 1;
+	return 0;
+}
+
+static int snd_pmac_awacs_put_switch_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	int vol[2];
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+
+	vol[0] = (ucontrol->value.integer.value[0] ? 0 : 32) | (amp->amp_vol[index][0] & 31);
+	vol[1] = (ucontrol->value.integer.value[1] ? 0 : 32) | (amp->amp_vol[index][1] & 31);
+	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
+}
+
+static int snd_pmac_awacs_info_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 14;
+	return 0;
+}
+ 
+static int snd_pmac_awacs_get_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+	ucontrol->value.integer.value[0] = amp->amp_tone[index];
+	return 0;
+}
+
+static int snd_pmac_awacs_put_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+	if (ucontrol->value.integer.value[0] != amp->amp_tone[index]) {
+		amp->amp_tone[index] = ucontrol->value.integer.value[0];
+		awacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);
+		return 1;
+	}
+	return 0;
+}
+
+static int snd_pmac_awacs_info_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 99;
+	return 0;
+}
+ 
+static int snd_pmac_awacs_get_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	ucontrol->value.integer.value[0] = amp->amp_master;
+	return 0;
+}
+
+static int snd_pmac_awacs_put_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	if (ucontrol->value.integer.value[0] != amp->amp_master) {
+		amp->amp_master = ucontrol->value.integer.value[0];
+		awacs_amp_set_master(amp, amp->amp_master);
+		return 1;
+	}
+	return 0;
+}
+
+#define AMP_CH_SPK	0
+#define AMP_CH_HD	1
+
+static snd_kcontrol_new_t snd_pmac_awacs_amp_vol[] __initdata = {
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "PC Speaker Playback Volume",
+	  info: snd_pmac_awacs_info_volume_amp,
+	  get: snd_pmac_awacs_get_volume_amp,
+	  put: snd_pmac_awacs_put_volume_amp,
+	  private_value: AMP_CH_SPK,
+	},
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "Headphone Playback Volume",
+	  info: snd_pmac_awacs_info_volume_amp,
+	  get: snd_pmac_awacs_get_volume_amp,
+	  put: snd_pmac_awacs_put_volume_amp,
+	  private_value: AMP_CH_HD,
+	},
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "Tone Control - Bass",
+	  info: snd_pmac_awacs_info_tone_amp,
+	  get: snd_pmac_awacs_get_tone_amp,
+	  put: snd_pmac_awacs_put_tone_amp,
+	  private_value: 0,
+	},
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "Tone Control - Treble",
+	  info: snd_pmac_awacs_info_tone_amp,
+	  get: snd_pmac_awacs_get_tone_amp,
+	  put: snd_pmac_awacs_put_tone_amp,
+	  private_value: 1,
+	},
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "Amp Master Playback Volume",
+	  info: snd_pmac_awacs_info_master_amp,
+	  get: snd_pmac_awacs_get_master_amp,
+	  put: snd_pmac_awacs_put_master_amp,
+	},
+};
+
+static snd_kcontrol_new_t snd_pmac_awacs_amp_hp_sw __initdata = {
+	iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	name: "Headphone Playback Switch",
+	info: snd_pmac_boolean_stereo_info,
+	get: snd_pmac_awacs_get_switch_amp,
+	put: snd_pmac_awacs_put_switch_amp,
+	private_value: AMP_CH_HD,
+};
+
+static snd_kcontrol_new_t snd_pmac_awacs_amp_spk_sw __initdata = {
+	iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	name: "PC Speaker Playback Switch",
+	info: snd_pmac_boolean_stereo_info,
+	get: snd_pmac_awacs_get_switch_amp,
+	put: snd_pmac_awacs_put_switch_amp,
+	private_value: AMP_CH_SPK,
+};
+
 #endif /* PMAC_AMP_AVAIL */
 
 
 /*
+ * mic boost for screamer
+ */
+static int snd_pmac_screamer_mic_boost_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 2;
+	return 0;
+}
+
+static int snd_pmac_screamer_mic_boost_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	if (chip->awacs_reg[6] & MASK_MIC_BOOST)
+		val = 2;
+	else if (chip->awacs_reg[0] & MASK_GAINLINE)
+		val = 1;
+	else
+		val = 0;
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	ucontrol->value.integer.value[0] = val;
+	return 0;
+}
+
+static int snd_pmac_screamer_mic_boost_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+	int val0, val6;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	val0 = chip->awacs_reg[0] & ~MASK_GAINLINE;
+	val6 = chip->awacs_reg[6] & ~MASK_MIC_BOOST;
+	if (ucontrol->value.integer.value[0] > 0) {
+		val0 |= MASK_GAINLINE;
+		if (ucontrol->value.integer.value[0] > 1)
+			val6 |= MASK_MIC_BOOST;
+	}
+	if (val0 != chip->awacs_reg[0]) {
+		snd_pmac_awacs_write_reg(chip, 0, val0);
+		changed = 1;
+	}
+	if (val6 != chip->awacs_reg[6]) {
+		snd_pmac_awacs_write_reg(chip, 6, val6);
+		changed = 1;
+	}
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return changed;
+}
+
+/*
  * lists of mixer elements
  */
-static snd_kcontrol_new_t snd_pmac_awacs_mixers1[] = {
+static snd_kcontrol_new_t snd_pmac_awacs_mixers[] __initdata = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6),
-	AWACS_SWITCH("Master Playback Switch", 1, MASK_AMUTE),
-	AWACS_SWITCH("Master Capture Switch", 1, MASK_LOOPTHRU),
-};
-
-static snd_kcontrol_new_t snd_pmac_awacs_mixers2[] = {
+	AWACS_SWITCH("Master Capture Switch", 1, SHIFT_LOOPTHRU, 0),
 	AWACS_VOLUME("Capture Volume", 0, 4),
-	AWACS_SWITCH("Line Capture Switch", 0, MASK_MUX_AUDIN),
-	AWACS_SWITCH("CD Capture Switch", 0, MASK_MUX_CD),
-	AWACS_SWITCH("Mic Capture Switch", 0, MASK_MUX_MIC),
-	AWACS_SWITCH("Mic Boost", 0, MASK_GAINLINE),
+	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_LINE, 0),
+	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
+	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static snd_kcontrol_new_t snd_pmac_awacs_speaker_mixers[] = {
-	AWACS_VOLUME("PC Speaker Playback Volume", 4, 6),
-	AWACS_SWITCH("PC Speaker Playback Switch", 1, MASK_CMUTE),
+static snd_kcontrol_new_t snd_pmac_awacs_master_sw __initdata =
+AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
+
+static snd_kcontrol_new_t snd_pmac_awacs_mic_boost[] __initdata = {
+	AWACS_SWITCH("Mic Boost", 0, SHIFT_GAINLINE, 0),
 };
 
-#ifdef PMAC_AMP_AVAIL
-static snd_kcontrol_new_t snd_pmac_awacs_amp_mixers[] = {
-	{
-		iface: SNDRV_CTL_ELEM_IFACE_MIXER,
-		name: "PC Speaker Playback Volume", index: 0, 
-		info: snd_pmac_awacs_info_volume_amp, \
-		get: snd_pmac_awacs_get_volume_amp,
-		put: snd_pmac_awacs_put_volume_amp,
+static snd_kcontrol_new_t snd_pmac_screamer_mic_boost[] __initdata = {
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "Mic Boost",
+	  info: snd_pmac_screamer_mic_boost_info,
+	  get: snd_pmac_screamer_mic_boost_get,
+	  put: snd_pmac_screamer_mic_boost_put,
 	},
 };
-#endif
+
+static snd_kcontrol_new_t snd_pmac_awacs_speaker_vol[] __initdata = {
+	AWACS_VOLUME("PC Speaker Playback Volume", 4, 6),
+};
+static snd_kcontrol_new_t snd_pmac_awacs_speaker_sw __initdata =
+AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
+
 
 #define num_controls(ary) (sizeof(ary) / sizeof(snd_kcontrol_new_t))
 
@@ -316,22 +587,108 @@
 	return 0;
 }
 
+
+/*
+ * restore all registers
+ */
+static void awacs_restore_all_regs(pmac_t *chip)
+{
+	snd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);
+	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
+	snd_pmac_awacs_write_noreg(chip, 2, chip->awacs_reg[2]);
+	snd_pmac_awacs_write_noreg(chip, 4, chip->awacs_reg[4]);
+	if (chip->model == PMAC_SCREAMER) {
+		snd_pmac_awacs_write_noreg(chip, 5, chip->awacs_reg[5]);
+		mdelay(100);
+		snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
+		mdelay(2);
+		snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
+		snd_pmac_awacs_write_noreg(chip, 7, chip->awacs_reg[7]);
+		snd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);
+	}
+}
+
 #ifdef CONFIG_PMAC_PBOOK
 static void snd_pmac_awacs_resume(pmac_t *chip)
 {
-	snd_pmac_awacs_write_reg(chip, 0, chip->awacs_reg[0]);
-	snd_pmac_awacs_write_reg(chip, 1, chip->awacs_reg[1]);
-	snd_pmac_awacs_write_reg(chip, 2, chip->awacs_reg[2]);
-	snd_pmac_awacs_write_reg(chip, 4, chip->awacs_reg[4]);
-	if (chip->model == PMAC_SCREAMER) {
-		snd_pmac_awacs_write_reg(chip, 5, chip->awacs_reg[5]);
-		snd_pmac_awacs_write_reg(chip, 6, chip->awacs_reg[6]);
-		snd_pmac_awacs_write_reg(chip, 7, chip->awacs_reg[7]);
-		screamer_recalibrate(chip);
+	awacs_restore_all_regs(chip);
+	screamer_recalibrate(chip);
+#ifdef PMAC_AMP_AVAIL
+	if (chip->mixer_data) {
+		awacs_amp_t *amp = chip->mixer_data;
+		awacs_amp_set_vol(amp, 0, amp->amp_vol[0][0], amp->amp_vol[0][1], 0);
+		awacs_amp_set_vol(amp, 1, amp->amp_vol[1][0], amp->amp_vol[1][1], 0);
+		awacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);
+		awacs_amp_set_master(amp, amp->amp_master);
 	}
+#endif
 }
 #endif /* CONFIG_PMAC_PBOOK */
 
+#ifdef PMAC_SUPPORT_AUTOMUTE
+/*
+ * auto-mute stuffs
+ */
+static int snd_pmac_awacs_detect_headphone(pmac_t *chip)
+{
+	return (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;
+}
+
+#ifdef PMAC_AMP_AVAIL
+static int toggle_amp_mute(awacs_amp_t *amp, int index, int mute)
+{
+	int vol[2];
+	vol[0] = amp->amp_vol[index][0] & 31;
+	vol[1] = amp->amp_vol[index][1] & 31;
+	if (mute) {
+		vol[0] |= 32;
+		vol[1] |= 32;
+	}
+	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
+}
+#endif
+
+static void snd_pmac_awacs_update_automute(pmac_t *chip, int do_notify)
+{
+	if (chip->auto_mute) {
+#ifdef PMAC_AMP_AVAIL
+		if (chip->mixer_data) {
+			awacs_amp_t *amp = chip->mixer_data;
+			int changed;
+			if (snd_pmac_awacs_detect_headphone(chip)) {
+				changed = toggle_amp_mute(amp, AMP_CH_HD, 0);
+				changed |= toggle_amp_mute(amp, AMP_CH_SPK, 1);
+			} else {
+				changed = toggle_amp_mute(amp, AMP_CH_HD, 1);
+				changed |= toggle_amp_mute(amp, AMP_CH_SPK, 0);
+			}
+			if (do_notify && ! changed)
+				return;
+		} else
+#endif
+		{
+			int reg = chip->awacs_reg[1] | (MASK_HDMUTE|MASK_SPKMUTE);
+			if (snd_pmac_awacs_detect_headphone(chip))
+				reg &= ~MASK_HDMUTE;
+			else
+				reg &= ~MASK_SPKMUTE;
+			if (do_notify && reg == chip->awacs_reg[1])
+				return;
+			snd_pmac_awacs_write_reg(chip, 1, reg);
+		}
+		if (do_notify) {
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->master_sw_ctl->id);
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->speaker_sw_ctl->id);
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->hp_detect_ctl->id);
+		}
+	}
+}
+#endif /* PMAC_SUPPORT_AUTOMUTE */
+
+
 /*
  * initialize chip
  */
@@ -340,47 +697,72 @@
 {
 	int err, vol;
 
-	snd_pmac_awacs_write_reg(chip, 0, MASK_MUX_CD);
+	/* looks like MASK_GAINLINE triggers something, so we set here
+	 * as start-up
+	 */
+	chip->awacs_reg[0] = MASK_MUX_CD | 0xff | MASK_GAINLINE;
+	chip->awacs_reg[1] = MASK_CMUTE | MASK_AMUTE;
 	/* FIXME: Only machines with external SRS module need MASK_PAROUT */
-	chip->awacs_reg[1] = MASK_LOOPTHRU;
 	if (chip->has_iic || chip->device_id == 0x5 ||
 	    /*chip->_device_id == 0x8 || */
 	    chip->device_id == 0xb)
 		chip->awacs_reg[1] |= MASK_PAROUT;
-	snd_pmac_awacs_write_reg(chip, 1, chip->awacs_reg[1]);
 	/* get default volume from nvram */
-	vol = (~nvram_read_byte(0x1308) & 7) << 1;
-	snd_pmac_awacs_write_reg(chip, 2, vol + (vol << 6));
-	snd_pmac_awacs_write_reg(chip, 4, vol + (vol << 6));
+	// vol = (~nvram_read_byte(0x1308) & 7) << 1;
+	// vol = ((pmac_xpram_read( 8 ) & 7 ) << 1 );
+	vol = 0x0f; /* no, on alsa, muted as default */
+	vol = vol + (vol << 6);
+	chip->awacs_reg[2] = vol;
+	chip->awacs_reg[4] = vol;
 	if (chip->model == PMAC_SCREAMER) {
-		snd_pmac_awacs_write_reg(chip, 5, 0);
-		snd_pmac_awacs_write_reg(chip, 6, 0);
-		snd_pmac_awacs_write_reg(chip, 7, 0);
+		chip->awacs_reg[5] = vol; /* FIXME: screamer has loopthru vol control */
+		chip->awacs_reg[6] = MASK_MIC_BOOST; /* FIXME: maybe should be vol << 3 for PCMCIA speaker */
+		chip->awacs_reg[7] = 0;
 	}
 
-#ifdef CONFIG_PMAC_PBOOK
-	/* Recalibrate chip */
-	if (chip->model == PMAC_SCREAMER)
-		screamer_recalibrate(chip);
-#endif
+	awacs_restore_all_regs(chip);
+	screamer_recalibrate(chip);
 
-	if (chip->model <= PMAC_SCREAMER && chip->revision == 0) {
-		chip->revision =
-			(in_le32(&chip->awacs->codec_stat) >> 12) & 0xf;
-		if (chip->revision == 3) {
+	chip->revision = (in_le32(&chip->awacs->codec_stat) >> 12) & 0xf;
 #ifdef PMAC_AMP_AVAIL
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-			if (adb_hardware == ADB_VIACUDA)
-				chip->amp_only = 1;
-#elif defined(CONFIG_ADB_CUDA)
-			if (sys_ctrler == SYS_CTRLER_CUDA)
-				chip->amp_only = 1;
-#endif
-			if (chip->amp_only) {
-				/*chip->amp_vol[0] = chip->amp_vol[1] = 31;*/
-				snd_pmac_awacs_enable_amp(chip, chip->amp_vol[0], chip->amp_vol[1]);
-			}
+	if (chip->revision == 3 && chip->has_iic && CHECK_CUDA_AMP()) {
+		awacs_amp_t *amp = kmalloc(sizeof(*amp), GFP_KERNEL);
+		if (! amp)
+			return -ENOMEM;
+		chip->mixer_data = amp;
+		memset(amp, 0, sizeof(*amp));
+		chip->mixer_free = awacs_amp_free;
+		awacs_amp_set_vol(amp, 0, 63, 63, 0); /* mute and zero vol */
+		awacs_amp_set_vol(amp, 1, 63, 63, 0);
+		awacs_amp_set_tone(amp, 7, 7); /* 0 dB */
+		awacs_amp_set_master(amp, 79); /* 0 dB */
+	}
 #endif /* PMAC_AMP_AVAIL */
+
+	if (chip->hp_stat_mask == 0) {
+		/* set headphone-jack detection bit */
+		switch (chip->model) {
+		case PMAC_AWACS:
+			chip->hp_stat_mask = 0x04;
+			break;
+		case PMAC_SCREAMER:
+			switch (chip->device_id) {
+			case 0x08:
+				/* 1 = side jack, 2 = front jack */
+				chip->hp_stat_mask = 0x03;
+				break;
+			case 0x00:
+			case 0x05:
+				chip->hp_stat_mask = 0x04;
+				break;
+			default:
+				chip->hp_stat_mask = 0x08;
+				break;
+			}
+			break;
+		default:
+			snd_BUG();
+			break;
 		}
 	}
 
@@ -389,25 +771,51 @@
 	 */
 	strcpy(chip->card->mixername, "PowerMac AWACS");
 
-	if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_mixers1),
-				snd_pmac_awacs_mixers1)) < 0)
+	if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_mixers),
+				snd_pmac_awacs_mixers)) < 0)
+		return err;
+	chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_master_sw, chip);
+	if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
 		return err;
 #ifdef PMAC_AMP_AVAIL
-	if (chip->amp_only) {
-		if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_amp_mixers),
-					snd_pmac_awacs_amp_mixers)) < 0)
+	if (chip->mixer_data) {
+		/* use amplifier.  the signal is connected from route A
+		 * to the amp.  the amp has its headphone and speaker
+		 * volumes and mute switches, so we use them instead of
+		 * screamer registers.
+		 * in this case, it seems the route C is not used.
+		 */
+		if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_amp_vol),
+					snd_pmac_awacs_amp_vol)) < 0)
 			return err;
-	} else {
+		/* overwrite */
+		chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_hp_sw, chip);
+		if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
+			return err;
+		chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_spk_sw, chip);
+		if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
+			return err;
+	} else
 #endif /* PMAC_AMP_AVAIL */
-		if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_speaker_mixers),
-					snd_pmac_awacs_speaker_mixers)) < 0)
+	{
+		/* route A = headphone, route C = speaker */
+		if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_speaker_vol),
+					snd_pmac_awacs_speaker_vol)) < 0)
+			return err;
+		chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_speaker_sw, chip);
+		if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
+			return err;
+	}
+
+	if (chip->model == PMAC_SCREAMER) {
+		if ((err = build_mixers(chip, num_controls(snd_pmac_screamer_mic_boost),
+					snd_pmac_screamer_mic_boost)) < 0)
+			return err;
+	} else {
+		if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_mic_boost),
+					snd_pmac_awacs_mic_boost)) < 0)
 			return err;
-#ifdef PMAC_AMP_AVAIL
 	}
-#endif /* PMAC_AMP_AVAIL */
-	if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_mixers2),
-				snd_pmac_awacs_mixers2)) < 0)
-		return err;
 
 	/*
 	 * set lowlevel callbacks
@@ -415,6 +823,13 @@
 	chip->set_format = snd_pmac_awacs_set_format;
 #ifdef CONFIG_PMAC_PBOOK
 	chip->resume = snd_pmac_awacs_resume;
+#endif
+#ifdef PMAC_SUPPORT_AUTOMUTE
+	if ((err = snd_pmac_add_automute(chip)) < 0)
+		return err;
+	chip->detect_headphone = snd_pmac_awacs_detect_headphone;
+	chip->update_automute = snd_pmac_awacs_update_automute;
+	snd_pmac_awacs_update_automute(chip, 0); /* update the status only */
 #endif
 
 	return 0;
diff -Nru a/sound/ppc/awacs.h b/sound/ppc/awacs.h
--- a/sound/ppc/awacs.h	Thu Jun 20 15:54:01 2002
+++ b/sound/ppc/awacs.h	Thu Jun 20 15:54:01 2002
@@ -89,11 +89,14 @@
 #define MASK_GAINLEFT	(0xf << 4)	/* Gain Left Mask */
 #define MASK_GAINLINE	(0x1 << 8)	/* Disable Mic preamp */
 #define MASK_GAINMIC	(0x0 << 8)	/* Enable Mic preamp */
-
 #define MASK_MUX_CD	(0x1 << 9)	/* Select CD in MUX */
 #define MASK_MUX_MIC	(0x1 << 10)	/* Select Mic in MUX */
 #define MASK_MUX_AUDIN	(0x1 << 11)	/* Select Audio In in MUX */
 #define MASK_MUX_LINE	MASK_MUX_AUDIN
+#define SHIFT_GAINLINE	8
+#define SHIFT_MUX_CD	9
+#define SHIFT_MUX_MIC	10
+#define SHIFT_MUX_LINE	11
 
 #define GAINRIGHT(x)	((x) & MASK_GAINRIGHT)
 #define GAINLEFT(x)	(((x) << 4) & MASK_GAINLEFT)
@@ -104,11 +107,14 @@
 #define MASK_RECALIBRATE (0x1 << 2)	/* Recalibrate */
 #define MASK_SAMPLERATE	(0x7 << 3)	/* Sample Rate: */
 #define MASK_LOOPTHRU	(0x1 << 6)	/* Loopthrough Enable */
+#define SHIFT_LOOPTHRU	6
 #define MASK_CMUTE	(0x1 << 7)	/* Output C (Speaker) Mute when 1 */
 #define MASK_SPKMUTE	MASK_CMUTE
+#define SHIFT_SPKMUTE	7
 #define MASK_ADDR1RES2	(0x1 << 8)	/* Reserved */
 #define MASK_AMUTE	(0x1 << 9)	/* Output A (Headphone) Mute when 1 */
 #define MASK_HDMUTE	MASK_AMUTE
+#define SHIFT_HDMUTE	9
 #define MASK_PAROUT	(0x3 << 10)	/* Parallel Out (???) */
 
 #define SAMPLERATE_48000	(0x0 << 3)	/* 48 or 44.1 kHz */
@@ -131,6 +137,10 @@
 
 #define VOLRIGHT(x)	(((~(x)) & MASK_OUTVOLRIGHT))
 #define VOLLEFT(x)	(((~(x)) << 6) & MASK_OUTVOLLEFT)
+
+/* address 6 */
+#define MASK_MIC_BOOST  (0x4)           /* screamer mic boost */
+#define SHIFT_MIC_BOOST	2
 
 /* Audio Codec Status Reg Bit Masks */
 /* ----- ----- ------ --- --- ----- */
diff -Nru a/sound/ppc/burgundy.c b/sound/ppc/burgundy.c
--- a/sound/ppc/burgundy.c	Thu Jun 20 15:54:00 2002
+++ b/sound/ppc/burgundy.c	Thu Jun 20 15:54:00 2002
@@ -301,7 +301,7 @@
   put: snd_pmac_burgundy_put_volume_out,\
   private_value: (ADDR2BASE(addr) | ((stereo) << 24)) }
 
-static snd_kcontrol_new_t snd_pmac_burgundy_mixers[] = {
+static snd_kcontrol_new_t snd_pmac_burgundy_mixers[] __initdata = {
 	BURGUNDY_VOLUME("Master Playback Volume", 0, MASK_ADDR_BURGUNDY_MASTER_VOLUME, 8),
 	BURGUNDY_VOLUME("Line Playback Volume", 0, MASK_ADDR_BURGUNDY_VOLLINE, 16),
 	BURGUNDY_VOLUME("CD Playback Volume", 0, MASK_ADDR_BURGUNDY_VOLCD, 16),
@@ -309,13 +309,50 @@
 	BURGUNDY_OUTPUT_VOLUME("PC Speaker Playback Volume", 0, MASK_ADDR_BURGUNDY_ATTENHP, 0),
 	/*BURGUNDY_OUTPUT_VOLUME("PCM Playback Volume", 0, MASK_ADDR_BURGUNDY_ATTENLINEOUT, 1),*/
 	BURGUNDY_OUTPUT_VOLUME("Headphone Playback Volume", 0, MASK_ADDR_BURGUNDY_ATTENSPEAKER, 1),
-	BURGUNDY_OUTPUT_SWITCH("PC Speaker Playback Switch", 0, BURGUNDY_OUTPUT_INTERN, 0, 0),
-	BURGUNDY_OUTPUT_SWITCH("Headphone Playback Switch", 0, BURGUNDY_OUTPUT_LEFT, BURGUNDY_OUTPUT_RIGHT, 1),
 };	
+static snd_kcontrol_new_t snd_pmac_burgundy_master_sw __initdata = 
+BURGUNDY_OUTPUT_SWITCH("Headphone Playback Switch", 0, BURGUNDY_OUTPUT_LEFT, BURGUNDY_OUTPUT_RIGHT, 1);
+static snd_kcontrol_new_t snd_pmac_burgundy_speaker_sw __initdata = 
+BURGUNDY_OUTPUT_SWITCH("PC Speaker Playback Switch", 0, BURGUNDY_OUTPUT_INTERN, 0, 0);
 
 #define num_controls(ary) (sizeof(ary) / sizeof(snd_kcontrol_new_t))
 
 
+#ifdef PMAC_SUPPORT_AUTOMUTE
+/*
+ * auto-mute stuffs
+ */
+static int snd_pmac_burgundy_detect_headphone(pmac_t *chip)
+{
+	return (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;
+}
+
+static void snd_pmac_burgundy_update_automute(pmac_t *chip, int do_notify)
+{
+	if (chip->auto_mute) {
+		int reg, oreg;
+		reg = oreg = snd_pmac_burgundy_rcb(chip, MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES);
+		reg &= ~(BURGUNDY_OUTPUT_LEFT | BURGUNDY_OUTPUT_RIGHT | BURGUNDY_OUTPUT_INTERN);
+		if (snd_pmac_burgundy_detect_headphone(chip))
+			reg |= BURGUNDY_OUTPUT_LEFT | BURGUNDY_OUTPUT_RIGHT;
+		else
+			reg |= BURGUNDY_OUTPUT_INTERN;
+		if (do_notify && reg == oreg)
+			return;
+		snd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES, reg);
+		if (do_notify) {
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->master_sw_ctl->id);
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->speaker_sw_ctl->id);
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->hp_detect_ctl->id);
+		}
+	}
+}
+#endif /* PMAC_SUPPORT_AUTOMUTE */
+
+
 /*
  * initialize burgundy
  */
@@ -365,6 +402,10 @@
 	snd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_VOLMIC,
 			   DEF_BURGUNDY_VOLMIC);
 
+	if (chip->hp_stat_mask == 0)
+		/* set headphone-jack detection bit */
+		chip->hp_stat_mask = 0x04;
+
 	/*
 	 * build burgundy mixers
 	 */
@@ -374,5 +415,20 @@
 		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_pmac_burgundy_mixers[i], chip))) < 0)
 			return err;
 	}
+	chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_burgundy_master_sw, chip);
+	if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
+		return err;
+	chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_burgundy_speaker_sw, chip);
+	if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
+		return err;
+#ifdef PMAC_SUPPORT_AUTOMUTE
+	if ((err = snd_pmac_add_automute(chip)) < 0)
+		return err;
+
+	chip->detect_headphone = snd_pmac_burgundy_detect_headphone;
+	chip->update_automute = snd_pmac_burgundy_update_automute;
+	snd_pmac_burgundy_update_automute(chip, 0); /* update the status only */
+#endif
+
 	return 0;
 }
diff -Nru a/sound/ppc/daca.c b/sound/ppc/daca.c
--- a/sound/ppc/daca.c	Thu Jun 20 15:54:00 2002
+++ b/sound/ppc/daca.c	Thu Jun 20 15:54:00 2002
@@ -22,6 +22,9 @@
 #define __NO_VERSION__
 #include <sound/driver.h>
 #include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/kmod.h>
 #include <sound/core.h>
 #include "pmac.h"
 
@@ -50,7 +53,7 @@
 /*
  * initialize / detect DACA
  */
-static int daca_init_client(pmac_t *chip, pmac_keywest_t *i2c)
+static int daca_init_client(pmac_keywest_t *i2c)
 {
 	unsigned short wdata = 0x00;
 	/* SR: no swap, 1bit delay, 32-48kHz */
@@ -68,7 +71,7 @@
 {
 	unsigned char data[2];
   
-	if (! mix->i2c.base)
+	if (! mix->i2c.client)
 		return -ENODEV;
   
 	if (mix->right_vol > DACA_VOL_MAX)
@@ -245,6 +248,10 @@
 	int i, err;
 	pmac_daca_t *mix;
 
+#ifdef CONFIG_KMOD
+	request_module("i2c-keywest");
+#endif /* CONFIG_KMOD */	
+
 	mix = kmalloc(sizeof(*mix), GFP_KERNEL);
 	if (! mix)
 		return -ENOMEM;
@@ -253,7 +260,10 @@
 	chip->mixer_free = daca_cleanup;
 	mix->amp_on = 1; /* default on */
 
-	if ((err = snd_pmac_keywest_find(chip, &mix->i2c, DACA_I2C_ADDR, daca_init_client)) < 0)
+	mix->i2c.addr = DACA_I2C_ADDR;
+	mix->i2c.init_client = daca_init_client;
+	mix->i2c.name = "DACA";
+	if ((err = snd_pmac_keywest_init(&mix->i2c)) < 0)
 		return err;
 
 	/*
diff -Nru a/sound/ppc/keywest.c b/sound/ppc/keywest.c
--- a/sound/ppc/keywest.c	Thu Jun 20 15:54:01 2002
+++ b/sound/ppc/keywest.c	Thu Jun 20 15:54:01 2002
@@ -1,12 +1,8 @@
 /*
- * Keywest i2c code
+ * common keywest i2c layer
  *
  * Copyright (c) by Takashi Iwai <tiwai@suse.de>
  *
- *
- * based on i2c-keywest.c from lm_sensors.
- *    Copyright (c) 2000 Philip Edelbrock <phil@stimpy.netroedge.com>
- *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
  *   the Free Software Foundation; either version 2 of the License, or
@@ -26,203 +22,108 @@
 #define __NO_VERSION__
 #include <sound/driver.h>
 #include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
 #include <sound/core.h>
 #include "pmac.h"
 
-/* The Tumbler audio equalizer can be really slow sometimes */
-#define KW_POLL_SANITY 10000
-
-/* address indices */
-#define KW_ADDR_MODE	0
-#define KW_ADDR_CONTROL	1
-#define KW_ADDR_STATUS	2
-#define KW_ADDR_ISR	3
-#define KW_ADDR_IER	4
-#define KW_ADDR_ADDR	5
-#define KW_ADDR_SUBADDR	6
-#define KW_ADDR_DATA	7
-
-#define KW_I2C_ADDR(i2c,type)	((i2c)->base + (type) * (i2c)->steps)
-
-/* keywest needs a small delay to defuddle itself after changing a setting */
-inline static void keywest_writeb_wait(pmac_keywest_t *i2c, int addr, int value)
-{
-	writeb(value, KW_I2C_ADDR(i2c, addr));
-	udelay(10);
-}
+/*
+ * we have to keep a static variable here since i2c attach_adapter
+ * callback cannot pass a private data.
+ */
+static pmac_keywest_t *keywest_ctx;
 
-inline static void keywest_writeb(pmac_keywest_t *i2c, int addr, int value)
-{
-	writeb(value, KW_I2C_ADDR(i2c, addr));
-}
 
-inline unsigned char keywest_readb(pmac_keywest_t *i2c, int addr)
-{
-	return readb(KW_I2C_ADDR(i2c, addr));
-}
+#define I2C_DRIVERID_KEYWEST	0xFEBA
 
-static int keywest_poll_interrupt(pmac_keywest_t *i2c)
-{
-	int i, res;
-	for (i = 0; i < KW_POLL_SANITY; i++) {
-		udelay(100);
-		res = keywest_readb(i2c, KW_ADDR_ISR) & 0x0f;
-		if (res > 0)
-			return res;
-	}
+static int keywest_attach_adapter(struct i2c_adapter *adapter);
+static int keywest_detach_client(struct i2c_client *client);
 
-	//snd_printd("Sanity check failed!  Expected interrupt never happened.\n");
-	return -ENODEV;
-}
+struct i2c_driver keywest_driver = {  
+	name: "PMac Keywest Audio",
+	id: I2C_DRIVERID_KEYWEST,
+	flags: I2C_DF_NOTIFY,
+	attach_adapter: &keywest_attach_adapter,
+	detach_client: &keywest_detach_client,
+};
 
 
-static void keywest_reset(pmac_keywest_t *i2c)
+static int keywest_attach_adapter(struct i2c_adapter *adapter)
 {
-	int interrupt_state;
+	int err;
+	struct i2c_client *new_client;
 
-	/* Clear all past interrupts */
-	interrupt_state = keywest_readb(i2c, KW_ADDR_ISR) & 0x0f;
-	if (interrupt_state > 0)
-		keywest_writeb_wait(i2c, KW_ADDR_ISR, interrupt_state);
-}
-
-static int keywest_start(pmac_keywest_t *i2c, unsigned char cmd, int is_read)
-{
-	int interrupt_state;
-	int ack;
+	if (! keywest_ctx)
+		return -EINVAL;
 
-	keywest_reset(i2c);
+	if (strncmp(adapter->name, "mac-io", 6))
+		return 0;
 
-	/* Set up address and r/w bit */
-	keywest_writeb_wait(i2c, KW_ADDR_ADDR, (i2c->addr << 1) | (is_read ? 1 : 0));
+	new_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (! new_client)
+		return -ENOMEM;
 
-	/* Set up 'sub address' which I'm guessing is the command field? */
-	keywest_writeb_wait(i2c, KW_ADDR_SUBADDR, cmd);
-	
-	/* Start sending address */
-	keywest_writeb_wait(i2c, KW_ADDR_CONTROL, keywest_readb(i2c, KW_ADDR_CONTROL) | 2);
-	interrupt_state = keywest_poll_interrupt(i2c);
-	if (interrupt_state < 0)
-		return interrupt_state;
-
-	ack = keywest_readb(i2c, KW_ADDR_STATUS) & 0x0f;
-	if ((ack & 0x02) == 0) {
-		snd_printd("Ack Status on addr expected but got: 0x%02x on addr: 0x%02x\n", ack, i2c->addr);
-		return -EINVAL;
-	} 
-	return interrupt_state;
-}
+	new_client->addr = keywest_ctx->addr;
+	new_client->data = keywest_ctx;
+	new_client->adapter = adapter;
+	new_client->driver = &keywest_driver;
+	new_client->flags = 0;
 
-/* exported */
-int snd_pmac_keywest_write(pmac_keywest_t *i2c, unsigned char cmd, int len, unsigned char *data)
-{
-	int interrupt_state;
-	int error_state = 0;
-	int i;
+	strcpy(new_client->name, keywest_ctx->name);
 
-	snd_assert(len >= 1 && len <= 32, return -EINVAL);
+	new_client->id = keywest_ctx->id++; /* Automatically unique */
+	keywest_ctx->client = new_client;
 
-	if ((interrupt_state = keywest_start(i2c, cmd, 0)) < 0)
-		return -EINVAL;
+	if ((err = keywest_ctx->init_client(keywest_ctx)) < 0)
+		goto __err;
 
-	for(i = 0; i < len; i++) {
-		keywest_writeb_wait(i2c, KW_ADDR_DATA, data[i]);
+	/* Tell the i2c layer a new client has arrived */
+	if (i2c_attach_client(new_client)) {
+		err = -ENODEV;
+		goto __err;
+	}
 
-		/* Clear interrupt and go */
-		keywest_writeb_wait(i2c, KW_ADDR_ISR, interrupt_state);
+	return 0;
 
-		interrupt_state = keywest_poll_interrupt(i2c);
-		if (interrupt_state < 0) {
-			error_state = -EINVAL;
-			interrupt_state = 0;
-		}
-		if ((keywest_readb(i2c, KW_ADDR_STATUS) & 0x02) == 0) {
-			snd_printd("Ack Expected by not received(block)!\n");
-			error_state = -EINVAL;
-		}
-	}
+ __err:
+	kfree(new_client);
+	keywest_ctx->client = NULL;
+	return err;
+}
 
-	/* Send stop */
-	keywest_writeb_wait(i2c, KW_ADDR_CONTROL,
-			    keywest_readb(i2c, KW_ADDR_CONTROL) | 4);
-
-	keywest_writeb_wait(i2c, KW_ADDR_CONTROL, interrupt_state);
-		
-	interrupt_state = keywest_poll_interrupt(i2c);
-	if (interrupt_state < 0) {
-		error_state = -EINVAL;
-		interrupt_state = 0;
-	}
-	keywest_writeb_wait(i2c, KW_ADDR_ISR, interrupt_state);
+static int keywest_detach_client(struct i2c_client *client)
+{
+	if (! keywest_ctx)
+		return 0;
+	if (client == keywest_ctx->client)
+		keywest_ctx->client = NULL;
 
-	return error_state;
+	i2c_detach_client(client);
+	kfree(client);
+	return 0;
 }
 
 /* exported */
 void snd_pmac_keywest_cleanup(pmac_keywest_t *i2c)
 {
-	if (i2c->base) {
-		iounmap((void*)i2c->base);
-		i2c->base = 0;
+	if (keywest_ctx && keywest_ctx == i2c) {
+		i2c_del_driver(&keywest_driver);
+		keywest_ctx = NULL;
 	}
 }
 
 /* exported */
-int snd_pmac_keywest_find(pmac_t *chip, pmac_keywest_t *i2c, int addr,
-			  int (*init_client)(pmac_t *, pmac_keywest_t *))
+int __init snd_pmac_keywest_init(pmac_keywest_t *i2c)
 {
-	struct device_node *i2c_device;
-	void **temp;
-	void *base = NULL;
-	u32 steps = 0;
-
-	i2c_device = find_compatible_devices("i2c", "keywest");
-	
-	if (i2c_device == 0) {
-		printk(KERN_ERR "pmac: No Keywest i2c devices found.\n");
-		return -ENODEV;
-	}
-	
-	for (; i2c_device; i2c_device = i2c_device->next) {
-		snd_printd("Keywest device found: %s\n", i2c_device->full_name);
-		temp = (void **) get_property(i2c_device, "AAPL,address", NULL);
-		if (temp != NULL) {
-			base = *temp;
-		} else {
-			snd_printd("pmac: no 'address' prop!\n");
-			continue;
-		}
-
-		temp = (void **) get_property(i2c_device, "AAPL,address-step", NULL);
-		if (temp != NULL) {
-			steps = *(uint *)temp;
-		} else {
-			snd_printd("pmac: no 'address-step' prop!\n");
-			continue;
-		}
-		
-		i2c->base = (unsigned long)ioremap((unsigned long)base, steps * 8);
-		i2c->steps = steps;
-
-		/* Select standard sub mode 
-		 *  
-		 * ie for <Address><Ack><Command><Ack><data><Ack>... style transactions
-		 */
-		keywest_writeb_wait(i2c, KW_ADDR_MODE, 0x08);
-
-		/* Enable interrupts */
-		keywest_writeb_wait(i2c, KW_ADDR_IER, 1 + 2 + 4 + 8);
-
-		keywest_reset(i2c);
-
-		i2c->addr = addr;
-		if (init_client(chip, i2c) < 0) {
-			snd_pmac_keywest_cleanup(i2c);
-			continue;
-		}
+	int err;
+
+	if (keywest_ctx)
+		return -EBUSY;
 
-		return 0; /* ok */
+	if ((err = i2c_add_driver(&keywest_driver))) {
+		snd_printk(KERN_ERR "cannot register keywest i2c driver\n");
+		return err;
 	}
-	
-	return -ENODEV;
+	keywest_ctx = i2c;
+	return 0;
 }
diff -Nru a/sound/ppc/pmac.c b/sound/ppc/pmac.c
--- a/sound/ppc/pmac.c	Thu Jun 20 15:54:01 2002
+++ b/sound/ppc/pmac.c	Thu Jun 20 15:54:01 2002
@@ -23,6 +23,7 @@
 #define __NO_VERSION__
 #include <sound/driver.h>
 #include <asm/io.h>
+#include <asm/irq.h>
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <sound/core.h>
@@ -39,6 +40,11 @@
 #define pmu_resume()	/**/
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
+#define request_OF_resource(io,num,str)  1
+#define release_OF_resource(io,num) /**/
+#endif
+
 
 #define chip_t pmac_t
 
@@ -168,7 +174,7 @@
 {
 	/* set up frequency and format */
 	out_le32(&chip->awacs->control, chip->control_mask | (chip->rate_index << 8));
-	out_le32(&chip->awacs->byteswap, chip->format == SNDRV_PCM_FORMAT_S16_LE);
+	out_le32(&chip->awacs->byteswap, chip->format == SNDRV_PCM_FORMAT_S16_LE ? 1 : 0);
 	if (chip->set_format)
 		chip->set_format(chip);
 }
@@ -327,15 +333,17 @@
 static snd_pcm_uframes_t snd_pmac_pcm_pointer(pmac_t *chip, pmac_stream_t *rec,
 					      snd_pcm_substream_t *subs)
 {
-	int count;
+	int count = 0;
 
-#if 0 /* hmm.. how can we get the current dma pointer?? */
-	if (! rec->cmd.cmds[rec->cur_period].xfer_status) {
-		count = in_le16(&rec->cmd.cmds[rec->cur_period].res_count);
+#if 1 /* hmm.. how can we get the current dma pointer?? */
+	int stat;
+	volatile struct dbdma_cmd *cp = &rec->cmd.cmds[rec->cur_period];
+	stat = ld_le16(&cp->xfer_status);
+	if (stat & (ACTIVE|DEAD)) {
+		count = in_le16(&cp->res_count);
 		count = rec->period_size - count;
-	} else
+	}
 #endif
-		count = 0;
 	count += rec->cur_period * rec->period_size;
 	/*printk("pointer=%d\n", count);*/
 	return bytes_to_frames(subs->runtime, count);
@@ -547,8 +555,11 @@
 		}
 	}
 	runtime->hw.formats = chip->formats_ok;
-	if (chip->can_duplex)
+	if (chip->can_capture) {
+		if (! chip->can_duplex)
+			runtime->hw.info |= SNDRV_PCM_INFO_HALF_DUPLEX;
 		runtime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;
+	}
 	runtime->private_data = rec;
 	rec->substream = subs;
 
@@ -638,6 +649,13 @@
 	pointer:	snd_pmac_capture_pointer,
 };
 
+static void pmac_pcm_free(snd_pcm_t *pcm)
+{
+#if 0
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+#endif
+}
+
 int __init snd_pmac_pcm_new(pmac_t *chip)
 {
 	snd_pcm_t *pcm;
@@ -655,6 +673,7 @@
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_pmac_capture_ops);
 
 	pcm->private_data = chip;
+	pcm->private_free = pmac_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, chip->card->shortname);
 	chip->pcm = pcm;
@@ -668,6 +687,11 @@
 	chip->playback.cur_freqs = chip->freqs_ok;
 	chip->capture.cur_freqs = chip->freqs_ok;
 
+#if 0
+	/* preallocate 64k buffer */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, 64 * 1024, 64 * 1024, GFP_KERNEL);
+#endif
+
 	return 0;
 }
 
@@ -942,16 +966,16 @@
 	pmac_t *chip = snd_magic_cast(pmac_t, devid, return);
 	int ctrl = in_le32(&chip->awacs->control);
 
-	printk("pmac: control interrupt.. 0x%x\n", ctrl);
+	/*printk("pmac: control interrupt.. 0x%x\n", ctrl);*/
 	if (ctrl & MASK_PORTCHG) {
 		/* do something when headphone is plugged/unplugged? */
-		if (chip->port_change)
-			chip->port_change(chip);
+		if (chip->update_automute)
+			chip->update_automute(chip, 1);
 	}
 	if (ctrl & MASK_CNTLERR) {
 		int err = (in_le32(&chip->awacs->codec_stat) & MASK_ERRCODE) >> 16;
 		if (err && chip->model <= PMAC_SCREAMER)
-			snd_printk("error %x\n", err);
+			snd_printk(KERN_DEBUG "error %x\n", err);
 	}
 	/* Writing 1s to the CNTLERR and PORTCHG bits clears them... */
 	out_le32(&chip->awacs->control, ctrl);
@@ -959,7 +983,7 @@
 
 
 /*
- * feature
+ * a wrapper to feature call for compatibility
  */
 #if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
 static void snd_pmac_sound_feature(pmac_t *chip, int enable)
@@ -990,6 +1014,8 @@
 
 static int snd_pmac_free(pmac_t *chip)
 {
+	int i;
+
 	/* stop sounds */
 	if (chip->initialized) {
 		snd_pmac_dbdma_reset(chip);
@@ -1026,6 +1052,12 @@
 		iounmap((void*)chip->playback.dma);
 	if (chip->capture.dma)
 		iounmap((void*)chip->capture.dma);
+	if (chip->node) {
+		for (i = 0; i < 3; i++) {
+			if (chip->of_requested & (1 << i))
+				release_OF_resource(chip->node, i);
+		}
+	}
 	snd_magic_kfree(chip);
 	return 0;
 }
@@ -1042,6 +1074,33 @@
 
 
 /*
+ * check the machine support byteswap (little-endian)
+ */
+
+static void __init detect_byte_swap(pmac_t *chip)
+{
+	struct device_node *mio;
+
+	/* if seems that Keylargo can't byte-swap  */
+	for (mio = chip->node->parent; mio; mio = mio->parent) {
+		if (strcmp(mio->name, "mac-io") == 0) {
+			if (device_is_compatible(mio, "Keylargo"))
+				chip->can_byte_swap = 0;
+			break;
+		}
+	}
+
+	/* it seems the Pismo & iBook can't byte-swap in hardware. */
+	if (machine_is_compatible("PowerBook3,1") ||
+	    machine_is_compatible("PowerBook2,1"))
+		chip->can_byte_swap = 0 ;
+
+	if (machine_is_compatible("PowerBook2,1"))
+		chip->can_duplex = 0;
+}
+
+
+/*
  * detect a sound chip
  */
 static int __init snd_pmac_detect(pmac_t *chip)
@@ -1064,13 +1123,6 @@
 
 	chip->control_mask = MASK_IEPC | MASK_IEE | 0x11; /* default */
 
-	/* it seems the Pismo & iBook can't byte-swap in hardware. */
-	if (machine_is_compatible("PowerBook3,1") ||
-	    machine_is_compatible("PowerBook2,1"))
-		chip->can_byte_swap = 0 ;
-	if (machine_is_compatible("PowerBook2,1"))
-		chip->can_duplex = 0;
-
 	/* check machine type */
 	if (machine_is_compatible("AAPL,3400/2400")
 	    || machine_is_compatible("AAPL,3500"))
@@ -1106,7 +1158,7 @@
 	/* This should be verified on older screamers */
 	if (device_is_compatible(sound, "screamer")) {
 		chip->model = PMAC_SCREAMER;
-		chip->can_byte_swap = 0;
+		// chip->can_byte_swap = 0; /* FIXME: check this */
 	}
 	if (device_is_compatible(sound, "burgundy")) {
 		chip->model = PMAC_BURGUNDY;
@@ -1116,14 +1168,15 @@
 		chip->model = PMAC_DACA;
 		chip->can_capture = 0;  /* no capture */
 		chip->can_duplex = 0;
-		chip->can_byte_swap = 0; /* no le support */
+		// chip->can_byte_swap = 0; /* FIXME: check this */
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
 	}
-	if (device_is_compatible(sound, "tumbler")) {
+	if (device_is_compatible(sound, "tumbler") ||
+	    device_is_compatible(sound, "snapper")) {
 		chip->model = PMAC_TUMBLER;
 		chip->can_capture = 0;  /* no capture */
 		chip->can_duplex = 0;
-		chip->can_byte_swap = 0; /* no le support */
+		// chip->can_byte_swap = 0; /* FIXME: check this */
 		chip->num_freqs = 2;
 		chip->freq_table = tumbler_freqs;
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
@@ -1133,6 +1186,8 @@
 		chip->device_id = *prop;
 	chip->has_iic = (find_devices("perch") != NULL);
 
+	detect_byte_swap(chip);
+
 	/* look for a property saying what sample rates
 	   are available */
 	prop = (unsigned int *) get_property(sound, "sample-rates", &l);
@@ -1157,9 +1212,90 @@
 		/* assume only 44.1khz */
 		chip->freqs_ok = 1;
 	}
+
+	return 0;
+}
+
+/*
+ * exported - boolean info callbacks for ease of programming
+ */
+int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+#ifdef PMAC_SUPPORT_AUTOMUTE
+/*
+ * auto-mute
+ */
+static int pmac_auto_mute_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer.value[0] = chip->auto_mute;
+	return 0;
+}
+
+static int pmac_auto_mute_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	if (ucontrol->value.integer.value[0] != chip->auto_mute) {
+		chip->auto_mute = ucontrol->value.integer.value[0];
+		if (chip->update_automute)
+			chip->update_automute(chip, 1);
+		return 1;
+	}
 	return 0;
 }
 
+static int pmac_hp_detect_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	if (chip->detect_headphone)
+		ucontrol->value.integer.value[0] = chip->detect_headphone(chip);
+	else
+		ucontrol->value.integer.value[0] = 0;
+	return 0;
+}
+
+static snd_kcontrol_new_t auto_mute_controls[] __initdata = {
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "Auto Mute Switch",
+	  info: snd_pmac_boolean_mono_info,
+	  get: pmac_auto_mute_get,
+	  put: pmac_auto_mute_put,
+	},
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "Headphone Detection",
+	  access: SNDRV_CTL_ELEM_ACCESS_READ,
+	  info: snd_pmac_boolean_mono_info,
+	  get: pmac_hp_detect_get,
+	},
+};
+
+int __init snd_pmac_add_automute(pmac_t *chip)
+{
+	int err;
+	chip->auto_mute = 1;
+	err = snd_ctl_add(chip->card, snd_ctl_new1(&auto_mute_controls[0], chip));
+	if (err < 0)
+		return err;
+	chip->hp_detect_ctl = snd_ctl_new1(&auto_mute_controls[1], chip);
+	return snd_ctl_add(chip->card, chip->hp_detect_ctl);
+}
+#endif /* PMAC_SUPPORT_AUTOMUTE */
 
 /*
  * create and detect a pmac chip record
@@ -1168,7 +1304,7 @@
 {
 	pmac_t *chip;
 	struct device_node *np;
-	int err;
+	int i, err;
 	static snd_device_ops_t ops = {
 		dev_free:	snd_pmac_dev_free,
 	};
@@ -1203,26 +1339,38 @@
 		goto __error;
 	}
 
+	for (i = 0; i < 3; i++) {
+		static char *name[3] = { NULL, "- Tx DMA", "- Rx DMA" };
+		if (! request_OF_resource(np, i, name[i])) {
+			snd_printk(KERN_ERR "pmac: can't request resource %d!\n", i);
+			err = -ENODEV;
+			goto __error;
+		}
+		chip->of_requested |= (1 << i);
+	}
+
 	chip->awacs = (volatile struct awacs_regs *) ioremap(np->addrs[0].address, 0x1000);
 	chip->playback.dma = (volatile struct dbdma_regs *) ioremap(np->addrs[1].address, 0x100);
 	chip->capture.dma = (volatile struct dbdma_regs *) ioremap(np->addrs[2].address, 0x100);
-	if (request_irq(np->intrs[0].line, snd_pmac_ctrl_intr, 0,
-			"PMac", (void*)chip)) {
-		snd_printk("unable to grab IRQ %d\n", np->intrs[0].line);
-		err = -EBUSY;
-		goto __error;
+	if (chip->model <= PMAC_BURGUNDY) {
+		if (request_irq(np->intrs[0].line, snd_pmac_ctrl_intr, 0,
+				"PMac", (void*)chip)) {
+			snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[0].line);
+			err = -EBUSY;
+			goto __error;
+		}
+		chip->irq = np->intrs[0].line;
 	}
-	chip->irq = np->intrs[0].line;
 	if (request_irq(np->intrs[1].line, snd_pmac_tx_intr, 0,
 			"PMac Output", (void*)chip)) {
-		snd_printk("unable to grab IRQ %d\n", np->intrs[1].line);
+		snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[1].line);
 		err = -EBUSY;
 		goto __error;
 	}
 	chip->tx_irq = np->intrs[1].line;
 	if (request_irq(np->intrs[2].line, snd_pmac_rx_intr, 0,
 			"PMac Input", (void*)chip)) {
-		snd_printk("unable to grab IRQ %d\n", np->intrs[2].line);
+		snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[2].line);
 		err = -EBUSY;
 		goto __error;
 	}
@@ -1277,8 +1425,6 @@
 	card->set_power_state = snd_pmac_set_power_state;
 	card->power_state_private_data = chip;
 #endif
-
-	chip->initialized = 1;
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
 		goto __error;
diff -Nru a/sound/ppc/pmac.h b/sound/ppc/pmac.h
--- a/sound/ppc/pmac.h	Thu Jun 20 15:54:01 2002
+++ b/sound/ppc/pmac.h	Thu Jun 20 15:54:01 2002
@@ -45,14 +45,12 @@
 #include <asm/prom.h>
 #include <asm/machdep.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) || defined(CONFIG_ADB_CUDA)
-#define PMAC_AMP_AVAIL
-#endif
-
 /* maximum number of fragments */
 #define PMAC_MAX_FRAGS		32
 
 
+#define PMAC_SUPPORT_AUTOMUTE
+
 /*
  * typedefs
  */
@@ -138,14 +136,12 @@
 	unsigned int can_duplex : 1;
 	unsigned int can_capture : 1;
 
-#ifdef PMAC_AMP_AVAIL
-	unsigned int amp_only;
-	int amp_vol[2];
-#endif
-
+	unsigned int auto_mute : 1;
 	unsigned int initialized : 1;
 	unsigned int feature_is_set : 1;
 
+	unsigned int of_requested;
+
 	int num_freqs;
 	int *freq_table;
 	unsigned int freqs_ok;		/* bit flags */
@@ -157,6 +153,7 @@
 	spinlock_t reg_lock;
 	volatile struct awacs_regs *awacs;
 	int awacs_reg[8]; /* register cache */
+	unsigned int hp_stat_mask;
 
 	unsigned char *latch_base;
 	unsigned char *macio_base;
@@ -177,10 +174,14 @@
 	/* mixer stuffs */
 	void *mixer_data;
 	void (*mixer_free)(pmac_t *);
+	snd_kcontrol_t *master_sw_ctl;
+	snd_kcontrol_t *speaker_sw_ctl;
+	snd_kcontrol_t *hp_detect_ctl;
 
 	/* lowlevel callbacks */
 	void (*set_format)(pmac_t *chip);
-	void (*port_change)(pmac_t *chip);
+	void (*update_automute)(pmac_t *chip, int do_notify);
+	int (*detect_headphone)(pmac_t *chip);
 #ifdef CONFIG_PMAC_PBOOK
 	unsigned int sleep_registered : 1;
 	void (*suspend)(pmac_t *chip);
@@ -203,18 +204,22 @@
 
 /* i2c functions */
 typedef struct snd_pmac_keywest {
-	unsigned long base;
 	int addr;
-	int steps;
+	struct i2c_client *client;
+	int id;
+	int (*init_client)(struct snd_pmac_keywest *i2c);
+	char *name;
 } pmac_keywest_t;
 
-int snd_pmac_keywest_find(pmac_t *chip, pmac_keywest_t *i2c, int addr, int (*init_client)(pmac_t *, pmac_keywest_t *));
+int snd_pmac_keywest_init(pmac_keywest_t *i2c);
 void snd_pmac_keywest_cleanup(pmac_keywest_t *i2c);
-int snd_pmac_keywest_write(pmac_keywest_t *i2c, unsigned char cmd, int len, unsigned char *data);
-inline static int snd_pmac_keywest_write_byte(pmac_keywest_t *i2c, unsigned char cmd, unsigned char data)
-{
-	return snd_pmac_keywest_write(i2c, cmd, 1, &data);
-}
+#define snd_pmac_keywest_write(i2c,cmd,len,data) i2c_smbus_write_block_data((i2c)->client, cmd, len, data)
+#define snd_pmac_keywest_write_byte(i2c,cmd,data) i2c_smbus_write_byte_data((i2c)->client, cmd, data)
+
+/* misc */
+int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo);
+int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo);
 
+int snd_pmac_add_automute(pmac_t *chip);
 
 #endif /* __PMAC_H */
diff -Nru a/sound/ppc/powermac.c b/sound/ppc/powermac.c
--- a/sound/ppc/powermac.c	Thu Jun 20 15:54:01 2002
+++ b/sound/ppc/powermac.c	Thu Jun 20 15:54:01 2002
@@ -125,6 +125,8 @@
 
 	if ((err = snd_pmac_pcm_new(chip)) < 0)
 		goto __error;
+
+	chip->initialized = 1;
 	if (snd_enable_beep)
 		snd_pmac_attach_beep(chip);
 
diff -Nru a/sound/ppc/tumbler.c b/sound/ppc/tumbler.c
--- a/sound/ppc/tumbler.c	Thu Jun 20 15:54:00 2002
+++ b/sound/ppc/tumbler.c	Thu Jun 20 15:54:00 2002
@@ -23,10 +23,17 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/kmod.h>
 #include <sound/core.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#ifdef CONFIG_PPC_HAS_FEATURE_CALLS
+#include <asm/pmac_feature.h>
+#endif
 #include "pmac.h"
-
-// #define TUMBLER_TONE_CONTROL_SUPPORT
+#include "tumbler_volume.h"
 
 #define chip_t pmac_t
 
@@ -35,56 +42,126 @@
 
 /* registers */
 #define TAS_REG_MCS	0x01
+#define TAS_REG_DRC	0x02
 #define TAS_REG_VOL	0x04
-#define TAS_VOL_MAX ((1<<20) - 1)
-
 #define TAS_REG_TREBLE	0x05
-#define TAS_VOL_MAX_TREBLE	0x96	/* 1 = max, 0x96 = min */
 #define TAS_REG_BASS	0x06
-#define TAS_VOL_MAX_BASS	0x86	/* 1 = max, 0x86 = min */
+#define TAS_REG_INPUT1	0x07	/* pcm */
+#define TAS_REG_INPUT2	0x08	/* ??? */
+
+#define TAS_REG_PCM	TAS_REG_INPUT1
 
-#define TAS_MIXER_VOL_MAX	500
+#define TAS_MIXER_VOL_MAX	200
+
+enum {
+	VOL_IDX_PCM, VOL_IDX_BASS, VOL_IDX_TREBLE,
+	//VOL_IDX_ALTPCM,
+	VOL_IDX_LAST
+};
+
+typedef struct pmac_gpio {
+#ifdef CONFIG_PPC_HAS_FEATURE_CALLS
+	unsigned int addr;
+#else
+	void *addr;
+#endif
+	int active_state;
+} pmac_gpio_t;
 
 typedef struct pmac_tumber_t {
 	pmac_keywest_t i2c;
-	void *amp_mute;
-	void *headphone_mute;
-	void *headphone_status;
+	pmac_gpio_t audio_reset;
+	pmac_gpio_t amp_mute;
+	pmac_gpio_t hp_mute;
+	pmac_gpio_t hp_detect;
 	int headphone_irq;
-	int left_vol, right_vol;
-	int bass_vol, treble_vol;
+	unsigned int master_vol[2];
+	unsigned int master_switch[2];
+	unsigned int mono_vol[VOL_IDX_LAST];
+	int drc_range;
+	int drc_enable;
 } pmac_tumbler_t;
 
 
+#define number_of(ary) (sizeof(ary) / sizeof(ary[0]))
+
 /*
- * initialize / detect tumbler
  */
-static int tumbler_init_client(pmac_t *chip, pmac_keywest_t *i2c)
+
+static int tumbler_init_client(pmac_keywest_t *i2c)
 {
-	/* normal operation, SCLK=64fps, i2s output, i2s input, 16bit width */
-	return snd_pmac_keywest_write_byte(i2c, TAS_REG_MCS,
-					   (1<<6)+(2<<4)+(2<<2)+0);
+       /* normal operation, SCLK=64fps, i2s output, i2s input, 16bit width */
+       return snd_pmac_keywest_write_byte(i2c, TAS_REG_MCS,
+                                          (1<<6)+(2<<4)+(2<<2)+0);
 }
 
+
 /*
- * update volume
+ * gpio access
  */
-static int tumbler_set_volume(pmac_tumbler_t *mix)
+#ifdef CONFIG_PPC_HAS_FEATURE_CALLS
+#define do_gpio_write(gp, val) \
+	pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, (gp)->addr, val)
+#define do_gpio_read(gp) \
+	pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, (gp)->addr, 0)
+#define tumbler_gpio_free(gp) /* NOP */
+#else
+#define do_gpio_write(gp, val)	writeb(val, (gp)->addr)
+#define do_gpio_read(gp)	readb((gp)->addr)
+static inline void tumbler_gpio_free(pmac_gpio_t *gp)
+{
+	if (gp->addr) {
+		iounmap(gp->addr);
+		gp->addr = 0;
+	}
+}
+#endif /* CONFIG_PPC_HAS_FEATURE_CALLS */
+
+static void write_audio_gpio(pmac_gpio_t *gp, int active)
+{
+	if (! gp->addr)
+		return;
+	active = active ? gp->active_state : !gp->active_state;
+	do_gpio_write(gp, active ? 0x05 : 0x04);
+}
+
+static int read_audio_gpio(pmac_gpio_t *gp)
+{
+	int ret;
+	if (! gp->addr)
+		return 0;
+	ret = ((do_gpio_read(gp) & 0x02) !=0);
+	return ret == gp->active_state;
+}
+
+/*
+ * update master volume
+ */
+static int tumbler_set_master_volume(pmac_tumbler_t *mix)
 {
 	unsigned char block[6];
 	unsigned int left_vol, right_vol;
   
-	if (! mix->i2c.base)
+	if (! mix->i2c.client)
 		return -ENODEV;
   
-	left_vol = mix->left_vol << 6;
-	right_vol = mix->right_vol << 6;
+	if (! mix->master_switch[0])
+		left_vol = 0;
+	else {
+		left_vol = mix->master_vol[0];
+		if (left_vol >= number_of(master_volume_table))
+			left_vol = number_of(master_volume_table) - 1;
+		left_vol = master_volume_table[left_vol];
+	}
+	if (! mix->master_switch[1])
+		right_vol = 0;
+	else {
+		right_vol = mix->master_vol[1];
+		if (right_vol >= number_of(master_volume_table))
+			right_vol = number_of(master_volume_table) - 1;
+		right_vol = master_volume_table[right_vol];
+	}
 
-	if (left_vol > TAS_VOL_MAX)
-		left_vol = TAS_VOL_MAX;
-	if (right_vol > TAS_VOL_MAX)
-		right_vol = TAS_VOL_MAX;
-  
 	block[0] = (left_vol >> 16) & 0xff;
 	block[1] = (left_vol >> 8)  & 0xff;
 	block[2] = (left_vol >> 0)  & 0xff;
@@ -102,111 +179,121 @@
 
 
 /* output volume */
-static int tumbler_info_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int tumbler_info_master_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = TAS_MIXER_VOL_MAX;
+	uinfo->value.integer.max = number_of(master_volume_table) - 1;
 	return 0;
 }
 
-static int tumbler_get_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int tumbler_get_master_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	pmac_tumbler_t *mix;
-	if (! (mix = chip->mixer_data))
-		return -ENODEV;
-	ucontrol->value.integer.value[0] = mix->left_vol;
-	ucontrol->value.integer.value[1] = mix->right_vol;
+	pmac_tumbler_t *mix = chip->mixer_data;
+	snd_assert(mix, return -ENODEV);
+	ucontrol->value.integer.value[0] = mix->master_vol[0];
+	ucontrol->value.integer.value[1] = mix->master_vol[1];
 	return 0;
 }
 
-static int tumbler_put_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int tumbler_put_master_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	pmac_tumbler_t *mix;
+	pmac_tumbler_t *mix = chip->mixer_data;
 	int change;
 
-	if (! (mix = chip->mixer_data))
-		return -ENODEV;
-	change = mix->left_vol != ucontrol->value.integer.value[0] ||
-		mix->right_vol != ucontrol->value.integer.value[1];
+	snd_assert(mix, return -ENODEV);
+	change = mix->master_vol[0] != ucontrol->value.integer.value[0] ||
+		mix->master_vol[1] != ucontrol->value.integer.value[1];
 	if (change) {
-		mix->left_vol = ucontrol->value.integer.value[0];
-		mix->right_vol = ucontrol->value.integer.value[1];
-		tumbler_set_volume(mix);
+		mix->master_vol[0] = ucontrol->value.integer.value[0];
+		mix->master_vol[1] = ucontrol->value.integer.value[1];
+		tumbler_set_master_volume(mix);
 	}
 	return change;
 }
 
+/* output switch */
+static int tumbler_get_master_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	pmac_tumbler_t *mix = chip->mixer_data;
+	snd_assert(mix, return -ENODEV);
+	ucontrol->value.integer.value[0] = mix->master_switch[0];
+	ucontrol->value.integer.value[1] = mix->master_switch[1];
+	return 0;
+}
 
-#ifdef TUMBLER_TONE_CONTROL_SUPPORT
-static int tumbler_set_bass(pmac_tumbler_t *mix)
+static int tumbler_put_master_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
-	unsigned char data;
-	int val;
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	pmac_tumbler_t *mix = chip->mixer_data;
+	int change;
 
-	if (! mix->i2c.base)
-		return -ENODEV;
-  
-	val = TAS_VOL_MAX_BASS - mix->bass_vol + 1;
-	if (val < 1)
-		data = 1;
-	else if (val > TAS_VOL_MAX_BASS)
-		data = TAS_VOL_MAX_BASS;
-	else
-		data = val;
-	if (snd_pmac_keywest_write(&mix->i2c TAS_REG_BASS, 1, &data) < 0) {
-		snd_printk("failed to set bass volume\n");  
-		return -EINVAL; 
+	snd_assert(mix, return -ENODEV);
+	change = mix->master_switch[0] != ucontrol->value.integer.value[0] ||
+		mix->master_switch[1] != ucontrol->value.integer.value[1];
+	if (change) {
+		mix->master_switch[0] = !!ucontrol->value.integer.value[0];
+		mix->master_switch[1] = !!ucontrol->value.integer.value[1];
+		tumbler_set_master_volume(mix);
 	}
-	return 0;
+	return change;
 }
 
-static int tumbler_set_treble(pmac_tumbler_t *mix)
+
+/*
+ * dynamic range compression
+ */
+static int tumbler_set_drc(pmac_tumbler_t *mix)
 {
-	unsigned char data;
-	int val;
+	unsigned char val[2];
 
-	if (! mix->i2c.base)
+	if (! mix->i2c.client)
 		return -ENODEV;
   
-	val = TAS_VOL_MAX_TREBLE - mix->treble_vol + 1;
-	if (val < 1)
-		data = 1;
-	else if (val > TAS_VOL_MAX_BASS)
-		data = TAS_VOL_MAX_BASS;
-	else
-		data = val;
-	if (snd_pmac_keywest_write(&mix->i2c, TAS_REG_TREBLE, 1, &data) < 0) {
-		snd_printk("failed to set treble volume\n");  
+	if (mix->drc_enable) {
+		val[0] = 0xc1; /* enable, 3:1 compression */
+		if (mix->drc_range > 0x5f)
+			val[1] = 0xf0;
+		else if (mix->drc_range < 0)
+			val[1] = 0x91;
+		else
+			val[1] = mix->drc_range + 0x91;
+	} else {
+		val[0] = 0;
+		val[1] = 0;
+	}
+
+	if (snd_pmac_keywest_write(&mix->i2c, TAS_REG_DRC, 2, val) < 0) {
+		snd_printk("failed to set DRC\n");  
 		return -EINVAL; 
 	}
 	return 0;
 }
 
-/* bass volume */
-static int tumbler_info_bass(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int tumbler_info_drc_value(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = TAS_VOL_MAX_BASS - 1;
+	uinfo->value.integer.max = 0x5f;
 	return 0;
 }
 
-static int tumbler_get_bass(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int tumbler_get_drc_value(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
 	pmac_tumbler_t *mix;
 	if (! (mix = chip->mixer_data))
 		return -ENODEV;
-	ucontrol->value.integer.value[0] = mix->bass_vol;
+	ucontrol->value.integer.value[0] = mix->drc_range;
 	return 0;
 }
 
-static int tumbler_put_bass(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int tumbler_put_drc_value(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
 	pmac_tumbler_t *mix;
@@ -214,99 +301,291 @@
 
 	if (! (mix = chip->mixer_data))
 		return -ENODEV;
-	change = mix->bass_vol != ucontrol->value.integer.value[0];
+	change = mix->drc_range != ucontrol->value.integer.value[0];
 	if (change) {
-		mix->bass_vol = ucontrol->value.integer.value[0];
-		tumbler_set_bass(mix);
+		mix->drc_range = ucontrol->value.integer.value[0];
+		tumbler_set_drc(mix);
 	}
 	return change;
 }
 
-static int tumbler_info_treble(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int tumbler_get_drc_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	pmac_tumbler_t *mix;
+	if (! (mix = chip->mixer_data))
+		return -ENODEV;
+	ucontrol->value.integer.value[0] = mix->drc_enable;
+	return 0;
+}
+
+static int tumbler_put_drc_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	pmac_tumbler_t *mix;
+	int change;
+
+	if (! (mix = chip->mixer_data))
+		return -ENODEV;
+	change = mix->drc_enable != ucontrol->value.integer.value[0];
+	if (change) {
+		mix->drc_enable = !!ucontrol->value.integer.value[0];
+		tumbler_set_drc(mix);
+	}
+	return change;
+}
+
+
+/*
+ * mono volumes
+ */
+
+struct tumbler_mono_vol {
+	int index;
+	int reg;
+	int bytes;
+	unsigned int max;
+	unsigned int *table;
+};
+
+static int tumbler_set_mono_volume(pmac_tumbler_t *mix, struct tumbler_mono_vol *info)
+{
+	unsigned char block[4];
+	unsigned int vol;
+	int i;
+  
+	if (! mix->i2c.client)
+		return -ENODEV;
+  
+	vol = mix->mono_vol[info->index];
+	if (vol >= info->max)
+		vol = info->max - 1;
+	vol = info->table[vol];
+	for (i = 0; i < info->bytes; i++)
+		block[i] = (vol >> ((info->bytes - i - 1) * 8)) & 0xff;
+	if (snd_pmac_keywest_write(&mix->i2c, info->reg, info->bytes, block) < 0) {
+		snd_printk("failed to set mono volume %d\n", info->index);  
+		return -EINVAL; 
+	}
+	return 0;
+}
+
+static int tumbler_info_mono(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	struct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;
+
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = TAS_VOL_MAX_TREBLE - 1;
+	uinfo->value.integer.max = info->max;
 	return 0;
 }
 
-static int tumbler_get_treble(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int tumbler_get_mono(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
+	struct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
 	pmac_tumbler_t *mix;
 	if (! (mix = chip->mixer_data))
 		return -ENODEV;
-	ucontrol->value.integer.value[0] = mix->treble_vol;
+	ucontrol->value.integer.value[0] = mix->mono_vol[info->index];
 	return 0;
 }
 
-static int tumbler_put_treble(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int tumbler_put_mono(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
 {
+	struct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;
 	pmac_t *chip = snd_kcontrol_chip(kcontrol);
 	pmac_tumbler_t *mix;
 	int change;
 
 	if (! (mix = chip->mixer_data))
 		return -ENODEV;
-	change = mix->treble_vol != ucontrol->value.integer.value[0];
+	change = mix->mono_vol[info->index] != ucontrol->value.integer.value[0];
 	if (change) {
-		mix->treble_vol = ucontrol->value.integer.value[0];
-		tumbler_set_treble(mix);
+		mix->mono_vol[info->index] = ucontrol->value.integer.value[0];
+		tumbler_set_mono_volume(mix, info);
 	}
 	return change;
 }
 
+static struct tumbler_mono_vol tumbler_pcm_vol_info = {
+	index: VOL_IDX_PCM,
+	reg: TAS_REG_PCM,
+	bytes: 3,
+	max: number_of(mixer_volume_table),
+	table: mixer_volume_table,
+};
+
+#if 0 // for what?
+static struct tumbler_mono_vol tumbler_altpcm_vol_info = {
+	index: VOL_IDX_ALTPCM,
+	reg: TAS_REG_INPUT2,
+	bytes: 3,
+	max: number_of(mixer_volume_table),
+	table: mixer_volume_table,
+};
 #endif
 
+static struct tumbler_mono_vol tumbler_bass_vol_info = {
+	index: VOL_IDX_BASS,
+	reg: TAS_REG_BASS,
+	bytes: 1,
+	max: number_of(bass_volume_table),
+	table: bass_volume_table,
+};
+
+static struct tumbler_mono_vol tumbler_treble_vol_info = {
+	index: VOL_IDX_TREBLE,
+	reg: TAS_REG_TREBLE,
+	bytes: 1,
+	max: number_of(treble_volume_table),
+	table: treble_volume_table,
+};
 
-static snd_kcontrol_new_t tumbler_mixers[] = {
+#define DEFINE_MONO(xname,type) { \
+	iface: SNDRV_CTL_ELEM_IFACE_MIXER,\
+	name: xname, \
+	info: tumbler_info_mono, \
+	get: tumbler_get_mono, \
+	put: tumbler_put_mono, \
+	private_value: (unsigned long)(&tumbler_##type##_vol_info), \
+}
+
+/*
+ * mute switches
+ */
+
+enum { TUMBLER_MUTE_HP, TUMBLER_MUTE_AMP };
+
+static int tumbler_get_mute_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	pmac_tumbler_t *mix;
+	pmac_gpio_t *gp;
+	if (! (mix = chip->mixer_data))
+		return -ENODEV;
+	gp = (kcontrol->private_value == TUMBLER_MUTE_HP) ? &mix->hp_mute : &mix->amp_mute;
+	ucontrol->value.integer.value[0] = ! read_audio_gpio(gp);
+	return 0;
+}
+
+static int tumbler_put_mute_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	pmac_tumbler_t *mix;
+	pmac_gpio_t *gp;
+	int val;
+	if (! (mix = chip->mixer_data))
+		return -ENODEV;
+	gp = (kcontrol->private_value == TUMBLER_MUTE_HP) ? &mix->hp_mute : &mix->amp_mute;
+	val = ! read_audio_gpio(gp);
+	if (val != ucontrol->value.integer.value[0]) {
+		write_audio_gpio(gp, ! ucontrol->value.integer.value[0]);
+		return 1;
+	}
+	return 0;
+}
+
+
+/*
+ */
+static snd_kcontrol_new_t tumbler_mixers[] __initdata = {
 	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
 	  name: "Master Playback Volume",
-	  info: tumbler_info_volume,
-	  get: tumbler_get_volume,
-	  put: tumbler_put_volume
+	  info: tumbler_info_master_volume,
+	  get: tumbler_get_master_volume,
+	  put: tumbler_put_master_volume
 	},
-#ifdef TUMBLER_TONE_CONTROL_SUPPORT
 	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
-	  name: "Tone Control - Bass",
-	  info: tumbler_info_bass,
-	  get: tumbler_get_bass,
-	  put: tumbler_put_bass
+	  name: "Master Playback Switch",
+	  info: snd_pmac_boolean_stereo_info,
+	  get: tumbler_get_master_switch,
+	  put: tumbler_put_master_switch
 	},
+	DEFINE_MONO("Tone Control - Bass", bass),
+	DEFINE_MONO("Tone Control - Treble", treble),
+	DEFINE_MONO("PCM Playback Volume", pcm),
+	//  DEFINE_MONO("Mixer2 Playback Volume", altpcm),
 	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
-	  name: "Tone Control - Treble",
-	  info: tumbler_info_treble,
-	  get: tumbler_get_treble,
-	  put: tumbler_put_treble
+	  name: "DRC Switch",
+	  info: snd_pmac_boolean_mono_info,
+	  get: tumbler_get_drc_switch,
+	  put: tumbler_put_drc_switch
+	},
+	{ iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	  name: "DRC Range",
+	  info: tumbler_info_drc_value,
+	  get: tumbler_get_drc_value,
+	  put: tumbler_put_drc_value
 	},
-#endif
 };
 
-#define num_controls(ary) (sizeof(ary) / sizeof(snd_kcontrol_new_t))
+static snd_kcontrol_new_t tumbler_hp_sw __initdata = {
+	iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	name: "Headphone Playback Switch",
+	info: snd_pmac_boolean_mono_info,
+	get: tumbler_get_mute_switch,
+	put: tumbler_put_mute_switch,
+	private_value: TUMBLER_MUTE_HP,
+};
+static snd_kcontrol_new_t tumbler_speaker_sw __initdata = {
+	iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	name: "PC Speaker Playback Switch",
+	info: snd_pmac_boolean_mono_info,
+	get: tumbler_get_mute_switch,
+	put: tumbler_put_mute_switch,
+	private_value: TUMBLER_MUTE_AMP,
+};
 
-/* mute either amp or headphone according to the plug status */
-static void tumbler_update_headphone(pmac_t *chip)
+#ifdef PMAC_SUPPORT_AUTOMUTE
+/*
+ * auto-mute stuffs
+ */
+static int tumbler_detect_headphone(pmac_t *chip)
 {
 	pmac_tumbler_t *mix = chip->mixer_data;
+	return read_audio_gpio(&mix->hp_detect);
+}
 
-	if (! mix)
-		return;
+static void check_mute(pmac_t *chip, pmac_gpio_t *gp, int val, int do_notify, snd_kcontrol_t *sw)
+{
+	//pmac_tumbler_t *mix = chip->mixer_data;
+	if (val != read_audio_gpio(gp)) {
+		write_audio_gpio(gp, val);
+		if (do_notify)
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE, &sw->id);
+	}
+}
 
-	if (readb(mix->headphone_status) & 2) {
-		writeb(4 + 1, mix->amp_mute);
-		writeb(4 + 0, mix->headphone_mute);
-	} else {
-		writeb(4 + 0, mix->amp_mute);
-		writeb(4 + 1, mix->headphone_mute);
+static void tumbler_update_automute(pmac_t *chip, int do_notify)
+{
+	if (chip->auto_mute) {
+		pmac_tumbler_t *mix = chip->mixer_data;
+		snd_assert(mix, return);
+		if (tumbler_detect_headphone(chip)) {
+			/* mute speaker */
+			check_mute(chip, &mix->amp_mute, 1, do_notify, chip->speaker_sw_ctl);
+			check_mute(chip, &mix->hp_mute, 0, do_notify, chip->master_sw_ctl);
+		} else {
+			/* unmute speaker */
+			check_mute(chip, &mix->amp_mute, 0, do_notify, chip->speaker_sw_ctl);
+			check_mute(chip, &mix->hp_mute, 1, do_notify, chip->master_sw_ctl);
+		}
+		if (do_notify)
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->hp_detect_ctl->id);
 	}
 }
+#endif /* PMAC_SUPPORT_AUTOMUTE */
+
 
 /* interrupt - headphone plug changed */
 static void headphone_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	pmac_t *chip = snd_magic_cast(pmac_t, devid, return);
-	tumbler_update_headphone(chip);
+	if (chip->update_automute && chip->initialized)
+		chip->update_automute(chip, 1);
 }
 
 /* look for audio-gpio device */
@@ -325,45 +604,66 @@
 	return NULL;
 }
 
+/* look for audio-gpio device */
+static struct device_node *find_compatible_audio_device(const char *name)
+{
+	struct device_node *np;
+  
+	if (! (np = find_devices("gpio")))
+		return NULL;
+  
+	for (np = np->child; np; np = np->sibling) {
+		if (device_is_compatible(np, name))
+			return np;
+	}  
+	return NULL;
+}
+
 /* find an audio device and get its address */
-static unsigned long tumbler_find_device(const char *device)
+static unsigned long tumbler_find_device(const char *device, pmac_gpio_t *gp, int is_compatible)
 {
 	struct device_node *node;
-	void *base;
+	u32 *base;
 
-	node = find_audio_device(device);
+	if (is_compatible)
+		node = find_compatible_audio_device(device);
+	else
+		node = find_audio_device(device);
 	if (! node) {
-		snd_printd("cannot find device %s\n", device);
-		return 0;
+		snd_printdd("cannot find device %s\n", device);
+		return -ENODEV;
 	}
 
-	base = (void *)get_property(node, "AAPL,address", NULL);
+	base = (u32 *)get_property(node, "AAPL,address", NULL);
 	if (! base) {
 		snd_printd("cannot find address for device %s\n", device);
-		return 0;
+		return -ENODEV;
 	}
 
-	return *(unsigned long *)base;
+#ifdef CONFIG_PPC_HAS_FEATURE_CALLS
+	gp->addr = (*base) & 0x0000ffff;
+#else
+	gp->addr = (void*)ioremap((unsigned long)(*base), 1);
+#endif
+	base = (u32 *)get_property(node, "audio-gpio-active-state", NULL);
+	if (base)
+		gp->active_state = *base;
+	else
+		gp->active_state = 1;
+
+
+	return (node->n_intrs > 0) ? node->intrs[0].line : 0;
 }
 
 /* reset audio */
-static int tumbler_reset_audio(pmac_t *chip)
+static void tumbler_reset_audio(pmac_t *chip)
 {
-	unsigned long base;
-	void *map;
-
-	if (! (base = tumbler_find_device("audio-hw-reset")))
-		return -ENODEV;
+	pmac_tumbler_t *mix = chip->mixer_data;
 
-	map = ioremap(base, 1);
-	writeb(5, map);
+	write_audio_gpio(&mix->audio_reset, 1);
+	mdelay(100);
+	write_audio_gpio(&mix->audio_reset, 0);
 	mdelay(100);
-	writeb(4, map);
-	mdelay(1);
-	writeb(5, map);
-	mdelay(1);
-	iounmap(map);
-	return 0;
 }
 
 #ifdef CONFIG_PMAC_PBOOK
@@ -371,53 +671,49 @@
 static void tumbler_resume(pmac_t *chip)
 {
 	pmac_tumbler_t *mix = chip->mixer_data;
+	snd_assert(mix, return);
 	tumbler_reset_audio(chip);
-	snd_pmac_keywest_write_byte(&mix->i2c, TAS_REG_MCS,
-				    (1<<6)+(2<<4)+(2<<2)+0);
-	tumbler_set_volume(mix);
-	tumbler_update_headphone(chip); /* update mute */
+	if (mix->i2c.client)
+		tumbler_init_client(&mix->i2c);
+	tumbler_set_mono_volume(mix, &tumbler_pcm_vol_info);
+	tumbler_set_mono_volume(mix, &tumbler_bass_vol_info);
+	tumbler_set_mono_volume(mix, &tumbler_treble_vol_info);
+	// tumbler_set_mono_volume(mix, &tumbler_altpcm_vol_info);
+	tumbler_set_drc(mix);
+	tumbler_set_master_volume(mix);
+	if (chip->update_automute)
+		chip->update_automute(chip, 0);
 }
 #endif
 
 /* initialize tumbler */
 static int __init tumbler_init(pmac_t *chip)
 {
-	unsigned long base;
-	struct device_node *node;
-	int err;
+	int irq, err;
 	pmac_tumbler_t *mix = chip->mixer_data;
-
 	snd_assert(mix, return -EINVAL);
 
-	/* reset audio */
-	if (tumbler_reset_audio(chip) < 0)
-		return -ENODEV;
+	tumbler_find_device("audio-hw-reset", &mix->audio_reset, 0);
+	tumbler_find_device("amp-mute", &mix->amp_mute, 0);
+	tumbler_find_device("headphone-mute", &mix->hp_mute, 0);
+	irq = tumbler_find_device("headphone-detect", &mix->hp_detect, 0);
+	if (irq < 0)
+		irq = tumbler_find_device("keywest-gpio15", &mix->hp_detect, 1);
 
-	/* get amp-mute */
-	if (! (base = tumbler_find_device("amp-mute")))
-		return -ENODEV;
-	mix->amp_mute = ioremap(base, 1);
-	if (! (base = tumbler_find_device("headphone-mute")))
-		return -ENODEV;
-	mix->headphone_mute = ioremap(base, 1);
-	if (! (base = tumbler_find_device("headphone-detect")))
-		return -ENODEV;
-	mix->headphone_status = ioremap(base, 1);
+	tumbler_reset_audio(chip);
 
 	/* activate headphone status interrupts */
-	writeb(readb(mix->headphone_status) | (1<<7), mix->headphone_status);
-
-	if (! (node = find_audio_device("headphone-detect")))
-		return -ENODEV;
-	if (node->n_intrs == 0)
-		return -ENODEV;
-
-	if ((err = request_irq(node->intrs[0].line, headphone_intr, 0,
-			       "Tumbler Headphone Detection", chip)) < 0)
-		return err;
-	mix->headphone_irq = node->intrs[0].line;
+  	if (irq >= 0) {
+		unsigned char val;
+		if ((err = request_irq(irq, headphone_intr, 0,
+				       "Tumbler Headphone Detection", chip)) < 0)
+			return err;
+		/* activate headphone status interrupts */
+		val = do_gpio_read(&mix->hp_detect);
+		do_gpio_write(&mix->hp_detect, val | 0x80);
+	}
+	mix->headphone_irq = irq;
   
-	tumbler_update_headphone(chip);
 	return 0;
 }
 
@@ -429,12 +725,10 @@
 
 	if (mix->headphone_irq >= 0)
 		free_irq(mix->headphone_irq, chip);
-	if (mix->amp_mute)
-		iounmap(mix->amp_mute);
-	if (mix->headphone_mute)
-		iounmap(mix->headphone_mute);
-	if (mix->headphone_status)
-		iounmap(mix->headphone_status);
+	tumbler_gpio_free(&mix->audio_reset);
+	tumbler_gpio_free(&mix->amp_mute);
+	tumbler_gpio_free(&mix->hp_mute);
+	tumbler_gpio_free(&mix->hp_detect);
 	snd_pmac_keywest_cleanup(&mix->i2c);
 	kfree(mix);
 	chip->mixer_data = NULL;
@@ -445,6 +739,12 @@
 {
 	int i, err;
 	pmac_tumbler_t *mix;
+	u32 *paddr;
+	struct device_node *tas_node;
+
+#ifdef CONFIG_KMOD
+	request_module("i2c-keywest");
+#endif /* CONFIG_KMOD */	
 
 	mix = kmalloc(sizeof(*mix), GFP_KERNEL);
 	if (! mix)
@@ -458,7 +758,20 @@
 	if ((err = tumbler_init(chip)) < 0)
 		return err;
 
-	if ((err = snd_pmac_keywest_find(chip, &mix->i2c, TAS_I2C_ADDR, tumbler_init_client)) < 0)
+	/* set up TAS */
+	tas_node = find_devices("deq");
+	if (tas_node == NULL)
+		return -ENODEV;
+
+	paddr = (u32 *)get_property(tas_node, "i2c-address", NULL);
+	if (paddr)
+		mix->i2c.addr = (*paddr) >> 1;
+	else
+		mix->i2c.addr = TAS_I2C_ADDR;
+
+	mix->i2c.init_client = tumbler_init_client;
+	mix->i2c.name = "TAS3001c";
+	if ((err = snd_pmac_keywest_init(&mix->i2c)) < 0)
 		return err;
 
 	/*
@@ -466,13 +779,27 @@
 	 */
 	strcpy(chip->card->mixername, "PowerMac Tumbler");
 
-	for (i = 0; i < num_controls(tumbler_mixers); i++) {
+	for (i = 0; i < number_of(tumbler_mixers); i++) {
 		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&tumbler_mixers[i], chip))) < 0)
 			return err;
 	}
+	chip->master_sw_ctl = snd_ctl_new1(&tumbler_hp_sw, chip);
+	if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
+		return err;
+	chip->speaker_sw_ctl = snd_ctl_new1(&tumbler_speaker_sw, chip);
+	if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
+		return err;
 
 #ifdef CONFIG_PMAC_PBOOK
 	chip->resume = tumbler_resume;
+#endif
+
+#ifdef PMAC_SUPPORT_AUTOMUTE
+	if (mix->headphone_irq >=0 && (err = snd_pmac_add_automute(chip)) < 0)
+		return err;
+	chip->detect_headphone = tumbler_detect_headphone;
+	chip->update_automute = tumbler_update_automute;
+	tumbler_update_automute(chip, 0); /* update the status only */
 #endif
 
 	return 0;
diff -Nru a/sound/ppc/tumbler_volume.h b/sound/ppc/tumbler_volume.h
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/sound/ppc/tumbler_volume.h	Thu Jun 20 15:54:01 2002
@@ -0,0 +1,188 @@
+/* volume tables, taken from TAS3001c data manual */
+/* volume gain values */
+/* 0 = -70 dB, 175 = 18.0 dB in 0.5 dB step */
+static unsigned int master_volume_table[] = {
+	0x00000015, 0x00000016,	0x00000017,
+	0x00000019, 0x0000001a,	0x0000001c,
+	0x0000001d, 0x0000001f,	0x00000021,
+	0x00000023, 0x00000025,	0x00000027,
+	0x00000029, 0x0000002c,	0x0000002e,
+	0x00000031, 0x00000034,	0x00000037,
+	0x0000003a, 0x0000003e,	0x00000042,
+	0x00000045, 0x0000004a,	0x0000004e,
+	0x00000053, 0x00000057,	0x0000005d,
+	0x00000062, 0x00000068,	0x0000006e,
+	0x00000075, 0x0000007b,	0x00000083,
+	0x0000008b, 0x00000093,	0x0000009b,
+	0x000000a5, 0x000000ae,	0x000000b9,
+	0x000000c4, 0x000000cf,	0x000000dc,
+	0x000000e9, 0x000000f6,	0x00000105,
+	0x00000114, 0x00000125,	0x00000136,
+	0x00000148, 0x0000015c,	0x00000171,
+	0x00000186, 0x0000019e,	0x000001b6,
+	0x000001d0, 0x000001eb,	0x00000209,
+	0x00000227, 0x00000248,	0x0000026b,
+	0x0000028f, 0x000002b6,	0x000002df,
+	0x0000030b, 0x00000339,	0x0000036a,
+	0x0000039e, 0x000003d5,	0x0000040f,
+	0x0000044c, 0x0000048d,	0x000004d2,
+	0x0000051c, 0x00000569,	0x000005bb,
+	0x00000612, 0x0000066e,	0x000006d0,
+	0x00000737, 0x000007a5,	0x00000818,
+	0x00000893, 0x00000915,	0x0000099f,
+	0x00000a31, 0x00000acc,	0x00000b6f,
+	0x00000c1d, 0x00000cd5,	0x00000d97,
+	0x00000e65, 0x00000f40,	0x00001027,
+	0x0000111c, 0x00001220,	0x00001333,
+	0x00001456, 0x0000158a,	0x000016d1,
+	0x0000182b, 0x0000199a,	0x00001b1e,
+	0x00001cb9, 0x00001e6d,	0x0000203a,
+	0x00002223, 0x00002429,	0x0000264e,
+	0x00002893, 0x00002afa,	0x00002d86,
+	0x00003039, 0x00003314,	0x0000361b,
+	0x00003950, 0x00003cb5,	0x0000404e,
+	0x0000441d, 0x00004827,	0x00004c6d,
+	0x000050f4, 0x000055c0,	0x00005ad5,
+	0x00006037, 0x000065ea,	0x00006bf4,
+	0x0000725a, 0x00007920,	0x0000804e,
+	0x000087e8, 0x00008ff6,	0x0000987d,
+	0x0000a186, 0x0000ab19,	0x0000b53c,
+	0x0000bff9, 0x0000cb59,	0x0000d766,
+	0x0000e429, 0x0000f1ae,	0x00010000,
+	0x00010f2b, 0x00011f3d,	0x00013042,
+	0x00014249, 0x00015562,	0x0001699c,
+	0x00017f09, 0x000195bc,	0x0001adc6,
+	0x0001c73d, 0x0001e237,	0x0001feca,
+	0x00021d0e, 0x00023d1d,	0x00025f12,
+	0x0002830b, 0x0002a925,	0x0002d182,
+	0x0002fc42, 0x0003298b,	0x00035983,
+	0x00038c53, 0x0003c225,	0x0003fb28,
+	0x0004378b, 0x00047783,	0x0004bb44,
+	0x0005030a, 0x00054f10,	0x00059f98,
+	0x0005f4e5, 0x00064f40,	0x0006aef6,
+	0x00071457, 0x00077fbb,	0x0007f17b,
+};
+
+/* treble table */
+/* 0 = -18 dB, 72 = 18 dB in 0.5 dB step */
+static unsigned int treble_volume_table[] = {
+	0x96, 0x95, 0x94,
+	0x93, 0x92, 0x91,
+	0x90, 0x8f, 0x8e,
+	0x8d, 0x8c, 0x8b,
+	0x8a, 0x89, 0x88,
+	0x87, 0x86, 0x85,
+	0x84, 0x83, 0x82,
+	0x81, 0x80, 0x7f,
+	0x7e, 0x7d, 0x7c,
+	0x7b, 0x7a, 0x79,
+	0x78, 0x77, 0x76,
+	0x75, 0x74, 0x73,
+	0x72, 0x71, 0x70,
+	0x6e, 0x6d, 0x6c,
+	0x6b, 0x69, 0x68,
+	0x66, 0x65, 0x63,
+	0x62, 0x60, 0x5e,
+	0x5c, 0x5a, 0x57,
+	0x55, 0x52, 0x4f,
+	0x4c, 0x49, 0x45,
+	0x42, 0x3e, 0x3a,
+	0x36, 0x32, 0x2d,
+	0x28, 0x22, 0x1c,
+	0x16, 0x10, 0x09,
+	0x01,
+};
+
+/* bass table */
+/* 0 = -18 dB, 72 = 18 dB in 0.5 dB step */
+static unsigned int bass_volume_table[] = {
+	0x86, 0x82, 0x7f,
+	0x7d, 0x7a, 0x78,
+	0x76, 0x74, 0x72,
+	0x70, 0x6e, 0x6d,
+	0x6b, 0x69, 0x66,
+	0x64, 0x61, 0x5f,
+	0x5d, 0x5c, 0x5a,
+	0x59, 0x58, 0x56,
+	0x55, 0x54, 0x53,
+	0x51, 0x4f, 0x4d,
+	0x4b, 0x49, 0x46,
+	0x44, 0x42, 0x40,
+	0x3e, 0x3c, 0x3b,
+	0x39, 0x38, 0x36,
+	0x35, 0x33, 0x31,
+	0x30, 0x2e, 0x2c,
+	0x2b, 0x29, 0x28,
+	0x26, 0x25, 0x23,
+	0x21, 0x1f, 0x1c,
+	0x19, 0x18, 0x17,
+	0x16, 0x14, 0x13,
+	0x12, 0x10, 0x0f,
+	0x0d, 0x0b, 0x0a,
+	0x08, 0x06, 0x03,
+	0x01,
+};
+
+/* mixer (pcm) volume table */
+/* 0 = -70 dB, 175 = 18.0 dB in 0.5 dB step */
+static unsigned int mixer_volume_table[] = {
+	0x00014b, 0x00015f, 0x000174,
+	0x00018a, 0x0001a1, 0x0001ba,
+	0x0001d4, 0x0001f0, 0x00020d,
+	0x00022c, 0x00024d, 0x000270,
+	0x000295, 0x0002bc, 0x0002e6,
+	0x000312, 0x000340, 0x000372,
+	0x0003a6, 0x0003dd, 0x000418,
+	0x000456, 0x000498, 0x0004de,
+	0x000528, 0x000576, 0x0005c9,
+	0x000620, 0x00067d, 0x0006e0,
+	0x000748, 0x0007b7, 0x00082c,
+	0x0008a8, 0x00092b, 0x0009b6,
+	0x000a49, 0x000ae5, 0x000b8b,
+	0x000c3a, 0x000cf3, 0x000db8,
+	0x000e88, 0x000f64, 0x00104e,
+	0x001145, 0x00124b, 0x001361,
+	0x001487, 0x0015be, 0x001708,
+	0x001865, 0x0019d8, 0x001b60,
+	0x001cff, 0x001eb7, 0x002089,
+	0x002276, 0x002481, 0x0026ab,
+	0x0028f5, 0x002b63, 0x002df5,
+	0x0030ae, 0x003390, 0x00369e,
+	0x0039db, 0x003d49, 0x0040ea,
+	0x0044c3, 0x0048d6, 0x004d27,
+	0x0051b9, 0x005691, 0x005bb2,
+	0x006121, 0x0066e3, 0x006cfb,
+	0x007370, 0x007a48, 0x008186,
+	0x008933, 0x009154, 0x0099f1,
+	0x00a310, 0x00acba, 0x00b6f6,
+	0x00c1cd, 0x00cd49, 0x00d973,
+	0x00e655, 0x00f3fb, 0x010270,
+	0x0111c0, 0x0121f9, 0x013328,
+	0x01455b, 0x0158a2, 0x016d0e,
+	0x0182af, 0x019999, 0x01b1de,
+	0x01cb94, 0x01e6cf, 0x0203a7,
+	0x022235, 0x024293, 0x0264db,
+	0x02892c, 0x02afa3, 0x02d862,
+	0x03038a, 0x033142, 0x0361af,
+	0x0394fa, 0x03cb50, 0x0404de,
+	0x0441d5, 0x048268, 0x04c6d0,
+	0x050f44, 0x055c04, 0x05ad50,
+	0x06036e, 0x065ea5, 0x06bf44,
+	0x07259d, 0x079207, 0x0804dc,
+	0x087e80, 0x08ff59, 0x0987d5,
+	0x0a1866, 0x0ab189, 0x0b53be,
+	0x0bff91, 0x0cb591, 0x0d765a,
+	0x0e4290, 0x0f1adf, 0x100000,
+	0x10f2b4, 0x11f3c9, 0x13041a,
+	0x14248e, 0x15561a, 0x1699c0,
+	0x17f094, 0x195bb8, 0x1adc61,
+	0x1c73d5, 0x1e236d, 0x1fec98,
+	0x21d0d9, 0x23d1cd, 0x25f125,
+	0x2830af, 0x2a9254, 0x2d1818,
+	0x2fc420, 0x3298b0, 0x35982f,
+	0x38c528, 0x3c224c, 0x3fb278,
+	0x437880, 0x477828, 0x4bb446,
+	0x5030a1, 0x54f106, 0x59f980,
+	0x5f4e52, 0x64f403, 0x6aef5d,
+	0x714575, 0x77fbaa, 0x7f17af,
+};
diff -Nru a/sound/synth/emux/Makefile b/sound/synth/emux/Makefile
--- a/sound/synth/emux/Makefile	Thu Jun 20 15:54:01 2002
+++ b/sound/synth/emux/Makefile	Thu Jun 20 15:54:01 2002
@@ -6,7 +6,10 @@
 export-objs  := emux.o
 
 snd-emux-synth-objs := emux.o emux_synth.o emux_seq.o emux_nrpn.o \
-		       emux_effect.o emux_proc.o emux_oss.o soundfont.o
+		       emux_effect.o emux_proc.o soundfont.o
+ifeq ($(CONFIG_SND_SEQUENCER_OSS),y)
+  snd-emux-synth-objs += emux_oss.o
+endif
 
 # Toplevel Module Dependency
 ifeq ($(subst m,y,$(CONFIG_SND_SEQUENCER)),y)
diff -Nru a/sound/synth/emux/emux.c b/sound/synth/emux/emux.c
--- a/sound/synth/emux/emux.c	Thu Jun 20 15:54:01 2002
+++ b/sound/synth/emux/emux.c	Thu Jun 20 15:54:01 2002
@@ -47,7 +47,7 @@
 	init_MUTEX(&emu->register_mutex);
 
 	emu->client = -1;
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	emu->oss_synth = NULL;
 #endif
 	emu->max_voices = 0;
@@ -92,7 +92,7 @@
 	snd_emux_init_voices(emu);
 
 	snd_emux_init_seq(emu, card, index);
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	snd_emux_init_seq_oss(emu);
 #endif
 	snd_emux_init_virmidi(emu, card);
@@ -122,7 +122,7 @@
 	snd_emux_proc_free(emu);
 #endif
 	snd_emux_delete_virmidi(emu);
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 	snd_emux_detach_seq_oss(emu);
 #endif
 	snd_emux_detach_seq(emu);
@@ -148,6 +148,9 @@
 EXPORT_SYMBOL(snd_emux_terminate_all);
 EXPORT_SYMBOL(snd_emux_lock_voice);
 EXPORT_SYMBOL(snd_emux_unlock_voice);
+
+/* soundfont.c */
+EXPORT_SYMBOL(snd_sf_linear_to_log);
 
 
 /*
diff -Nru a/sound/synth/emux/emux_effect.c b/sound/synth/emux/emux_effect.c
--- a/sound/synth/emux/emux_effect.c	Thu Jun 20 15:54:00 2002
+++ b/sound/synth/emux/emux_effect.c	Thu Jun 20 15:54:00 2002
@@ -151,7 +151,7 @@
 	return addr;
 }
 
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 /* change effects - for OSS sequencer compatibility */
 void
 snd_emux_send_effect_oss(snd_emux_port_t *port, snd_midi_channel_t *chan, int type, int val)
diff -Nru a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
--- a/sound/synth/emux/emux_oss.c	Thu Jun 20 15:54:00 2002
+++ b/sound/synth/emux/emux_oss.c	Thu Jun 20 15:54:00 2002
@@ -25,7 +25,7 @@
 #define __NO_VERSION__
 #include <sound/driver.h>
 
-#ifdef CONFIG_SND_OSSEMUL
+#ifdef CONFIG_SND_SEQUENCER_OSS
 
 #include <asm/uaccess.h>
 #include <sound/core.h>
@@ -493,4 +493,4 @@
 	snd_emux_event_input(&ev, 0, port, atomic, hop);
 }
 
-#endif /* CONFIG_SND_OSSEMUL */
+#endif /* CONFIG_SND_SEQUENCER_OSS */
diff -Nru a/sound/synth/emux/emux_synth.c b/sound/synth/emux/emux_synth.c
--- a/sound/synth/emux/emux_synth.c	Thu Jun 20 15:54:01 2002
+++ b/sound/synth/emux/emux_synth.c	Thu Jun 20 15:54:01 2002
@@ -665,26 +665,26 @@
 	}
 	LIMITVALUE(pan, 0, 255);
 
-#if 1
-	/* using volume table */
-	if (vp->apan != (int)pan_volumes[pan]) {
-		vp->apan = pan_volumes[pan];
-		vp->aaux = pan_volumes[255 - pan];
-		return 1;
-	}
-	return 0;
-#else
-	/* assuming linear volume */
-	if (pan != vp->apan) {
-		vp->apan = pan;
-		if (pan == 0)
-			vp->aaux = 0xff;
-		else
-			vp->aaux = (-pan) & 0xff;
-		return 1;
-	} else
+	if (vp->emu->linear_panning) {
+		/* assuming linear volume */
+		if (pan != vp->apan) {
+			vp->apan = pan;
+			if (pan == 0)
+				vp->aaux = 0xff;
+			else
+				vp->aaux = (-pan) & 0xff;
+			return 1;
+		} else
+			return 0;
+	} else {
+		/* using volume table */
+		if (vp->apan != (int)pan_volumes[pan]) {
+			vp->apan = pan_volumes[pan];
+			vp->aaux = pan_volumes[255 - pan];
+			return 1;
+		}
 		return 0;
-#endif
+	}
 }
 
 
